{"ast":null,"code":"import _asyncToGenerator from \"/Users/frazerlinscott/Desktop/Software Frameworks/Assignments/Assignment1_SoftwareFrames_s2930588/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * @license Angular v16.2.6\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { getDebugNode, RendererFactory2 as RendererFactory2$1, InjectionToken as InjectionToken$1, ɵstringify, ɵReflectionCapabilities, Directive, Component, Pipe, NgModule, ɵgetInjectableDef, resolveForwardRef as resolveForwardRef$1, ɵNG_COMP_DEF, ɵRender3NgModuleRef, ApplicationInitStatus, LOCALE_ID as LOCALE_ID$1, ɵDEFAULT_LOCALE_ID, ɵsetLocaleId, ɵRender3ComponentFactory, ɵcompileComponent, ɵNG_DIR_DEF, ɵcompileDirective, ɵNG_PIPE_DEF, ɵcompilePipe, ɵNG_MOD_DEF, ɵtransitiveScopesFor, ɵpatchComponentDefWithScope, ɵNG_INJ_DEF, ɵcompileNgModuleDefs, provideZoneChangeDetection, Compiler, COMPILER_OPTIONS, Injector as Injector$1, ɵisEnvironmentProviders, ɵNgModuleFactory, ModuleWithComponentFactories, ɵconvertToBitFlags, InjectFlags as InjectFlags$1, ɵsetAllowDuplicateNgModuleIdsForTest, ɵresetCompiledComponents, ɵsetUnknownElementStrictMode as ɵsetUnknownElementStrictMode$1, ɵsetUnknownPropertyStrictMode as ɵsetUnknownPropertyStrictMode$1, ɵgetUnknownElementStrictMode as ɵgetUnknownElementStrictMode$1, ɵgetUnknownPropertyStrictMode as ɵgetUnknownPropertyStrictMode$1, EnvironmentInjector as EnvironmentInjector$1, NgZone as NgZone$1, ɵflushModuleScopingQueueAsMuchAsPossible } from '@angular/core';\nimport { ResourceLoader } from '@angular/compiler';\nimport { Subject, Subscription, Observable, merge as merge$1 } from 'rxjs';\nimport { share } from 'rxjs/operators';\n\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {@link inject} call.\n *\n * Example:\n *\n * ```\n * it('...', waitForAsync(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * });\n * ```\n *\n * @publicApi\n */\nfunction waitForAsync(fn) {\n  const _Zone = typeof Zone !== 'undefined' ? Zone : null;\n  if (!_Zone) {\n    return function () {\n      return Promise.reject('Zone is needed for the waitForAsync() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js');\n    };\n  }\n  const asyncTest = _Zone && _Zone[_Zone.__symbol__('asyncTest')];\n  if (typeof asyncTest === 'function') {\n    return asyncTest(fn);\n  }\n  return function () {\n    return Promise.reject('zone-testing.js is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/testing');\n  };\n}\n/**\n * @deprecated use `waitForAsync()`, (expected removal in v12)\n * @see {@link waitForAsync}\n * @publicApi\n * */\nfunction async(fn) {\n  return waitForAsync(fn);\n}\n\n/**\n * Fixture for debugging and testing a component.\n *\n * @publicApi\n */\nclass ComponentFixture {\n  constructor(componentRef, ngZone, _autoDetect) {\n    this.componentRef = componentRef;\n    this.ngZone = ngZone;\n    this._autoDetect = _autoDetect;\n    this._isStable = true;\n    this._isDestroyed = false;\n    this._resolve = null;\n    this._promise = null;\n    this._onUnstableSubscription = null;\n    this._onStableSubscription = null;\n    this._onMicrotaskEmptySubscription = null;\n    this._onErrorSubscription = null;\n    this.changeDetectorRef = componentRef.changeDetectorRef;\n    this.elementRef = componentRef.location;\n    this.debugElement = getDebugNode(this.elementRef.nativeElement);\n    this.componentInstance = componentRef.instance;\n    this.nativeElement = this.elementRef.nativeElement;\n    this.componentRef = componentRef;\n    this.ngZone = ngZone;\n    if (ngZone) {\n      // Create subscriptions outside the NgZone so that the callbacks run oustide\n      // of NgZone.\n      ngZone.runOutsideAngular(() => {\n        this._onUnstableSubscription = ngZone.onUnstable.subscribe({\n          next: () => {\n            this._isStable = false;\n          }\n        });\n        this._onMicrotaskEmptySubscription = ngZone.onMicrotaskEmpty.subscribe({\n          next: () => {\n            if (this._autoDetect) {\n              // Do a change detection run with checkNoChanges set to true to check\n              // there are no changes on the second run.\n              this.detectChanges(true);\n            }\n          }\n        });\n        this._onStableSubscription = ngZone.onStable.subscribe({\n          next: () => {\n            this._isStable = true;\n            // Check whether there is a pending whenStable() completer to resolve.\n            if (this._promise !== null) {\n              // If so check whether there are no pending macrotasks before resolving.\n              // Do this check in the next tick so that ngZone gets a chance to update the state of\n              // pending macrotasks.\n              queueMicrotask(() => {\n                if (!ngZone.hasPendingMacrotasks) {\n                  if (this._promise !== null) {\n                    this._resolve(true);\n                    this._resolve = null;\n                    this._promise = null;\n                  }\n                }\n              });\n            }\n          }\n        });\n        this._onErrorSubscription = ngZone.onError.subscribe({\n          next: error => {\n            throw error;\n          }\n        });\n      });\n    }\n  }\n  _tick(checkNoChanges) {\n    this.changeDetectorRef.detectChanges();\n    if (checkNoChanges) {\n      this.checkNoChanges();\n    }\n  }\n  /**\n   * Trigger a change detection cycle for the component.\n   */\n  detectChanges(checkNoChanges = true) {\n    if (this.ngZone != null) {\n      // Run the change detection inside the NgZone so that any async tasks as part of the change\n      // detection are captured by the zone and can be waited for in isStable.\n      this.ngZone.run(() => {\n        this._tick(checkNoChanges);\n      });\n    } else {\n      // Running without zone. Just do the change detection.\n      this._tick(checkNoChanges);\n    }\n  }\n  /**\n   * Do a change detection run to make sure there were no changes.\n   */\n  checkNoChanges() {\n    this.changeDetectorRef.checkNoChanges();\n  }\n  /**\n   * Set whether the fixture should autodetect changes.\n   *\n   * Also runs detectChanges once so that any existing change is detected.\n   */\n  autoDetectChanges(autoDetect = true) {\n    if (this.ngZone == null) {\n      throw new Error('Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set');\n    }\n    this._autoDetect = autoDetect;\n    this.detectChanges();\n  }\n  /**\n   * Return whether the fixture is currently stable or has async tasks that have not been completed\n   * yet.\n   */\n  isStable() {\n    return this._isStable && !this.ngZone.hasPendingMacrotasks;\n  }\n  /**\n   * Get a promise that resolves when the fixture is stable.\n   *\n   * This can be used to resume testing after events have triggered asynchronous activity or\n   * asynchronous change detection.\n   */\n  whenStable() {\n    if (this.isStable()) {\n      return Promise.resolve(false);\n    } else if (this._promise !== null) {\n      return this._promise;\n    } else {\n      this._promise = new Promise(res => {\n        this._resolve = res;\n      });\n      return this._promise;\n    }\n  }\n  _getRenderer() {\n    if (this._renderer === undefined) {\n      this._renderer = this.componentRef.injector.get(RendererFactory2$1, null);\n    }\n    return this._renderer;\n  }\n  /**\n   * Get a promise that resolves when the ui state is stable following animations.\n   */\n  whenRenderingDone() {\n    const renderer = this._getRenderer();\n    if (renderer && renderer.whenRenderingDone) {\n      return renderer.whenRenderingDone();\n    }\n    return this.whenStable();\n  }\n  /**\n   * Trigger component destruction.\n   */\n  destroy() {\n    if (!this._isDestroyed) {\n      this.componentRef.destroy();\n      if (this._onUnstableSubscription != null) {\n        this._onUnstableSubscription.unsubscribe();\n        this._onUnstableSubscription = null;\n      }\n      if (this._onStableSubscription != null) {\n        this._onStableSubscription.unsubscribe();\n        this._onStableSubscription = null;\n      }\n      if (this._onMicrotaskEmptySubscription != null) {\n        this._onMicrotaskEmptySubscription.unsubscribe();\n        this._onMicrotaskEmptySubscription = null;\n      }\n      if (this._onErrorSubscription != null) {\n        this._onErrorSubscription.unsubscribe();\n        this._onErrorSubscription = null;\n      }\n      this._isDestroyed = true;\n    }\n  }\n}\nconst _Zone = typeof Zone !== 'undefined' ? Zone : null;\nconst fakeAsyncTestModule = _Zone && _Zone[_Zone.__symbol__('fakeAsyncTest')];\nconst fakeAsyncTestModuleNotLoadedErrorMessage = `zone-testing.js is needed for the fakeAsync() test helper but could not be found.\n        Please make sure that your environment includes zone.js/testing`;\n/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * @publicApi\n */\nfunction resetFakeAsyncZone() {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.resetFakeAsyncZone();\n  }\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Wraps a function to be executed in the `fakeAsync` zone:\n * - Microtasks are manually executed by calling `flushMicrotasks()`.\n * - Timers are synchronous; `tick()` simulates the asynchronous passage of time.\n *\n * If there are any pending timers at the end of the function, an exception is thrown.\n *\n * Can be used to wrap `inject()` calls.\n *\n * @param fn The function that you want to wrap in the `fakeAsync` zone.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n *\n * @returns The function wrapped to be executed in the `fakeAsync` zone.\n * Any arguments passed when calling this returned function will be passed through to the `fn`\n * function in the parameters when it is called.\n *\n * @publicApi\n */\nfunction fakeAsync(fn) {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.fakeAsync(fn);\n  }\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the `fakeAsync` zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * @param millis The number of milliseconds to advance the virtual timer.\n * @param tickOptions The options to pass to the `tick()` function.\n *\n * @usageNotes\n *\n * The `tick()` option is a flag called `processNewMacroTasksSynchronously`,\n * which determines whether or not to invoke new macroTasks.\n *\n * If you provide a `tickOptions` object, but do not specify a\n * `processNewMacroTasksSynchronously` property (`tick(100, {})`),\n * then `processNewMacroTasksSynchronously` defaults to true.\n *\n * If you omit the `tickOptions` parameter (`tick(100))`), then\n * `tickOptions` defaults to `{processNewMacroTasksSynchronously: true}`.\n *\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * The following example includes a nested timeout (new macroTask), and\n * the `tickOptions` parameter is allowed to default. In this case,\n * `processNewMacroTasksSynchronously` defaults to true, and the nested\n * function is executed on each tick.\n *\n * ```\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick();\n *   expect(nestedTimeoutInvoked).toBe(true);\n * }));\n * ```\n *\n * In the following case, `processNewMacroTasksSynchronously` is explicitly\n * set to false, so the nested timeout function is not invoked.\n *\n * ```\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick(0, {processNewMacroTasksSynchronously: false});\n *   expect(nestedTimeoutInvoked).toBe(false);\n * }));\n * ```\n *\n *\n * @publicApi\n */\nfunction tick(millis = 0, tickOptions = {\n  processNewMacroTasksSynchronously: true\n}) {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.tick(millis, tickOptions);\n  }\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Flushes any pending microtasks and simulates the asynchronous passage of time for the timers in\n * the `fakeAsync` zone by\n * draining the macrotask queue until it is empty.\n *\n * @param maxTurns The maximum number of times the scheduler attempts to clear its queue before\n *     throwing an error.\n * @returns The simulated time elapsed, in milliseconds.\n *\n * @publicApi\n */\nfunction flush(maxTurns) {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.flush(maxTurns);\n  }\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Discard all remaining periodic tasks.\n *\n * @publicApi\n */\nfunction discardPeriodicTasks() {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.discardPeriodicTasks();\n  }\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Flush any pending microtasks.\n *\n * @publicApi\n */\nfunction flushMicrotasks() {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.flushMicrotasks();\n  }\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n\n/** Whether test modules should be torn down by default. */\nconst TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT = true;\n/** Whether unknown elements in templates should throw by default. */\nconst THROW_ON_UNKNOWN_ELEMENTS_DEFAULT = false;\n/** Whether unknown properties in templates should throw by default. */\nconst THROW_ON_UNKNOWN_PROPERTIES_DEFAULT = false;\n/**\n * An abstract class for inserting the root test component element in a platform independent way.\n *\n * @publicApi\n */\nclass TestComponentRenderer {\n  insertRootElement(rootElementId) {}\n  removeAllRootElements() {}\n}\n/**\n * @publicApi\n */\nconst ComponentFixtureAutoDetect = new InjectionToken$1('ComponentFixtureAutoDetect');\n/**\n * @publicApi\n */\nconst ComponentFixtureNoNgZone = new InjectionToken$1('ComponentFixtureNoNgZone');\n\n/**\n * Used to resolve resource URLs on `@Component` when used with JIT compilation.\n *\n * Example:\n * ```\n * @Component({\n *   selector: 'my-comp',\n *   templateUrl: 'my-comp.html', // This requires asynchronous resolution\n * })\n * class MyComponent{\n * }\n *\n * // Calling `renderComponent` will fail because `renderComponent` is a synchronous process\n * // and `MyComponent`'s `@Component.templateUrl` needs to be resolved asynchronously.\n *\n * // Calling `resolveComponentResources()` will resolve `@Component.templateUrl` into\n * // `@Component.template`, which allows `renderComponent` to proceed in a synchronous manner.\n *\n * // Use browser's `fetch()` function as the default resource resolution strategy.\n * resolveComponentResources(fetch).then(() => {\n *   // After resolution all URLs have been converted into `template` strings.\n *   renderComponent(MyComponent);\n * });\n *\n * ```\n *\n * NOTE: In AOT the resolution happens during compilation, and so there should be no need\n * to call this method outside JIT mode.\n *\n * @param resourceResolver a function which is responsible for returning a `Promise` to the\n * contents of the resolved URL. Browser's `fetch()` method is a good default implementation.\n */\nfunction resolveComponentResources(resourceResolver) {\n  // Store all promises which are fetching the resources.\n  const componentResolved = [];\n  // Cache so that we don't fetch the same resource more than once.\n  const urlMap = new Map();\n  function cachedResourceResolve(url) {\n    let promise = urlMap.get(url);\n    if (!promise) {\n      const resp = resourceResolver(url);\n      urlMap.set(url, promise = resp.then(unwrapResponse));\n    }\n    return promise;\n  }\n  componentResourceResolutionQueue.forEach((component, type) => {\n    const promises = [];\n    if (component.templateUrl) {\n      promises.push(cachedResourceResolve(component.templateUrl).then(template => {\n        component.template = template;\n      }));\n    }\n    const styleUrls = component.styleUrls;\n    const styles = component.styles || (component.styles = []);\n    const styleOffset = component.styles.length;\n    styleUrls && styleUrls.forEach((styleUrl, index) => {\n      styles.push(''); // pre-allocate array.\n      promises.push(cachedResourceResolve(styleUrl).then(style => {\n        styles[styleOffset + index] = style;\n        styleUrls.splice(styleUrls.indexOf(styleUrl), 1);\n        if (styleUrls.length == 0) {\n          component.styleUrls = undefined;\n        }\n      }));\n    });\n    const fullyResolved = Promise.all(promises).then(() => componentDefResolved(type));\n    componentResolved.push(fullyResolved);\n  });\n  clearResolutionOfComponentResourcesQueue();\n  return Promise.all(componentResolved).then(() => undefined);\n}\nlet componentResourceResolutionQueue = new Map();\n// Track when existing ɵcmp for a Type is waiting on resources.\nconst componentDefPendingResolution = new Set();\nfunction maybeQueueResolutionOfComponentResources(type, metadata) {\n  if (componentNeedsResolution(metadata)) {\n    componentResourceResolutionQueue.set(type, metadata);\n    componentDefPendingResolution.add(type);\n  }\n}\nfunction isComponentDefPendingResolution(type) {\n  return componentDefPendingResolution.has(type);\n}\nfunction componentNeedsResolution(component) {\n  return !!(component.templateUrl && !component.hasOwnProperty('template') || component.styleUrls && component.styleUrls.length);\n}\nfunction clearResolutionOfComponentResourcesQueue() {\n  const old = componentResourceResolutionQueue;\n  componentResourceResolutionQueue = new Map();\n  return old;\n}\nfunction restoreComponentResolutionQueue(queue) {\n  componentDefPendingResolution.clear();\n  queue.forEach((_, type) => componentDefPendingResolution.add(type));\n  componentResourceResolutionQueue = queue;\n}\nfunction isComponentResourceResolutionQueueEmpty() {\n  return componentResourceResolutionQueue.size === 0;\n}\nfunction unwrapResponse(response) {\n  return typeof response == 'string' ? response : response.text();\n}\nfunction componentDefResolved(type) {\n  componentDefPendingResolution.delete(type);\n}\nconst _global = globalThis;\nvar FactoryTarget;\n(function (FactoryTarget) {\n  FactoryTarget[FactoryTarget[\"Directive\"] = 0] = \"Directive\";\n  FactoryTarget[FactoryTarget[\"Component\"] = 1] = \"Component\";\n  FactoryTarget[FactoryTarget[\"Injectable\"] = 2] = \"Injectable\";\n  FactoryTarget[FactoryTarget[\"Pipe\"] = 3] = \"Pipe\";\n  FactoryTarget[FactoryTarget[\"NgModule\"] = 4] = \"NgModule\";\n})(FactoryTarget || (FactoryTarget = {}));\nvar R3TemplateDependencyKind;\n(function (R3TemplateDependencyKind) {\n  R3TemplateDependencyKind[R3TemplateDependencyKind[\"Directive\"] = 0] = \"Directive\";\n  R3TemplateDependencyKind[R3TemplateDependencyKind[\"Pipe\"] = 1] = \"Pipe\";\n  R3TemplateDependencyKind[R3TemplateDependencyKind[\"NgModule\"] = 2] = \"NgModule\";\n})(R3TemplateDependencyKind || (R3TemplateDependencyKind = {}));\nvar ViewEncapsulation$1;\n(function (ViewEncapsulation) {\n  ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\";\n  // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.\n  ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\n  ViewEncapsulation[ViewEncapsulation[\"ShadowDom\"] = 3] = \"ShadowDom\";\n})(ViewEncapsulation$1 || (ViewEncapsulation$1 = {}));\nfunction getCompilerFacade(request) {\n  const globalNg = _global['ng'];\n  if (globalNg && globalNg.ɵcompilerFacade) {\n    return globalNg.ɵcompilerFacade;\n  }\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    // Log the type as an error so that a developer can easily navigate to the type from the\n    // console.\n    console.error(`JIT compilation failed for ${request.kind}`, request.type);\n    let message = `The ${request.kind} '${request.type.name}' needs to be compiled using the JIT compiler, but '@angular/compiler' is not available.\\n\\n`;\n    if (request.usage === 1 /* JitCompilerUsage.PartialDeclaration */) {\n      message += `The ${request.kind} is part of a library that has been partially compiled.\\n`;\n      message += `However, the Angular Linker has not processed the library such that JIT compilation is used as fallback.\\n`;\n      message += '\\n';\n      message += `Ideally, the library is processed using the Angular Linker to become fully AOT compiled.\\n`;\n    } else {\n      message += `JIT compilation is discouraged for production use-cases! Consider using AOT mode instead.\\n`;\n    }\n    message += `Alternatively, the JIT compiler should be loaded by bootstrapping using '@angular/platform-browser-dynamic' or '@angular/platform-server',\\n`;\n    message += `or manually provide the compiler with 'import \"@angular/compiler\";' before bootstrapping.`;\n    throw new Error(message);\n  } else {\n    throw new Error('JIT compiler unavailable');\n  }\n}\nfunction getClosureSafeProperty(objWithPropertyToExtract) {\n  for (let key in objWithPropertyToExtract) {\n    if (objWithPropertyToExtract[key] === getClosureSafeProperty) {\n      return key;\n    }\n  }\n  throw Error('Could not find renamed property on target object.');\n}\n/**\n * Sets properties on a target object from a source object, but only if\n * the property doesn't already exist on the target object.\n * @param target The target to set properties on\n * @param source The source of the property keys and values to set\n */\nfunction fillProperties(target, source) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\nfunction stringify(token) {\n  if (typeof token === 'string') {\n    return token;\n  }\n  if (Array.isArray(token)) {\n    return '[' + token.map(stringify).join(', ') + ']';\n  }\n  if (token == null) {\n    return '' + token;\n  }\n  if (token.overriddenName) {\n    return `${token.overriddenName}`;\n  }\n  if (token.name) {\n    return `${token.name}`;\n  }\n  const res = token.toString();\n  if (res == null) {\n    return '' + res;\n  }\n  const newLineIndex = res.indexOf('\\n');\n  return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n}\n/**\n * Concatenates two strings with separator, allocating new strings only when necessary.\n *\n * @param before before string.\n * @param separator separator string.\n * @param after after string.\n * @returns concatenated string.\n */\nfunction concatStringsWithSpace(before, after) {\n  return before == null || before === '' ? after === null ? '' : after : after == null || after === '' ? before : before + ' ' + after;\n}\nconst __forward_ref__ = getClosureSafeProperty({\n  __forward_ref__: getClosureSafeProperty\n});\n/**\n * Allows to refer to references which are not yet defined.\n *\n * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of\n * DI is declared, but not yet defined. It is also used when the `token` which we use when creating\n * a query is not yet defined.\n *\n * `forwardRef` is also used to break circularities in standalone components imports.\n *\n * @usageNotes\n * ### Circular dependency example\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}\n *\n * ### Circular standalone reference import example\n * ```ts\n * @Component({\n *   standalone: true,\n *   imports: [ChildComponent],\n *   selector: 'app-parent',\n *   template: `<app-child [hideParent]=\"hideParent\"></app-child>`,\n * })\n * export class ParentComponent {\n *   @Input() hideParent: boolean;\n * }\n *\n *\n * @Component({\n *   standalone: true,\n *   imports: [CommonModule, forwardRef(() => ParentComponent)],\n *   selector: 'app-child',\n *   template: `<app-parent *ngIf=\"!hideParent\"></app-parent>`,\n * })\n * export class ChildComponent {\n *   @Input() hideParent: boolean;\n * }\n * ```\n *\n * @publicApi\n */\nfunction forwardRef(forwardRefFn) {\n  forwardRefFn.__forward_ref__ = forwardRef;\n  forwardRefFn.toString = function () {\n    return stringify(this());\n  };\n  return forwardRefFn;\n}\n/**\n * Lazily retrieves the reference value from a forwardRef.\n *\n * Acts as the identity function when given a non-forward-ref value.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}\n *\n * @see {@link forwardRef}\n * @publicApi\n */\nfunction resolveForwardRef(type) {\n  return isForwardRef(type) ? type() : type;\n}\n/** Checks whether a function is wrapped by a `forwardRef`. */\nfunction isForwardRef(fn) {\n  return typeof fn === 'function' && fn.hasOwnProperty(__forward_ref__) && fn.__forward_ref__ === forwardRef;\n}\n\n/**\n * Construct an injectable definition which defines how a token will be constructed by the DI\n * system, and in which injectors (if any) it will be available.\n *\n * This should be assigned to a static `ɵprov` field on a type, which will then be an\n * `InjectableType`.\n *\n * Options:\n * * `providedIn` determines which injectors will include the injectable, by either associating it\n *   with an `@NgModule` or other `InjectorType`, or by specifying that this injectable should be\n *   provided in the `'root'` injector, which will be the application-level injector in most apps.\n * * `factory` gives the zero argument function which will create an instance of the injectable.\n *   The factory can call [`inject`](api/core/inject) to access the `Injector` and request injection\n * of dependencies.\n *\n * @codeGenApi\n * @publicApi This instruction has been emitted by ViewEngine for some time and is deployed to npm.\n */\nfunction ɵɵdefineInjectable(opts) {\n  return {\n    token: opts.token,\n    providedIn: opts.providedIn || null,\n    factory: opts.factory,\n    value: undefined\n  };\n}\n/**\n * @deprecated in v8, delete after v10. This API should be used only by generated code, and that\n * code should now use ɵɵdefineInjectable instead.\n * @publicApi\n */\nconst defineInjectable = ɵɵdefineInjectable;\n/**\n * Construct an `InjectorDef` which configures an injector.\n *\n * This should be assigned to a static injector def (`ɵinj`) field on a type, which will then be an\n * `InjectorType`.\n *\n * Options:\n *\n * * `providers`: an optional array of providers to add to the injector. Each provider must\n *   either have a factory or point to a type which has a `ɵprov` static property (the\n *   type must be an `InjectableType`).\n * * `imports`: an optional array of imports of other `InjectorType`s or `InjectorTypeWithModule`s\n *   whose providers will also be added to the injector. Locally provided types will override\n *   providers from imports.\n *\n * @codeGenApi\n */\nfunction ɵɵdefineInjector(options) {\n  return {\n    providers: options.providers || [],\n    imports: options.imports || []\n  };\n}\n/**\n * Read the injectable def (`ɵprov`) for `type` in a way which is immune to accidentally reading\n * inherited value.\n *\n * @param type A type which may have its own (non-inherited) `ɵprov`.\n */\nfunction getInjectableDef(type) {\n  return getOwnDefinition(type, NG_PROV_DEF) || getOwnDefinition(type, NG_INJECTABLE_DEF);\n}\nfunction isInjectable(type) {\n  return getInjectableDef(type) !== null;\n}\n/**\n * Return definition only if it is defined directly on `type` and is not inherited from a base\n * class of `type`.\n */\nfunction getOwnDefinition(type, field) {\n  return type.hasOwnProperty(field) ? type[field] : null;\n}\n/**\n * Read the injectable def (`ɵprov`) for `type` or read the `ɵprov` from one of its ancestors.\n *\n * @param type A type which may have `ɵprov`, via inheritance.\n *\n * @deprecated Will be removed in a future version of Angular, where an error will occur in the\n *     scenario if we find the `ɵprov` on an ancestor only.\n */\nfunction getInheritedInjectableDef(type) {\n  const def = type && (type[NG_PROV_DEF] || type[NG_INJECTABLE_DEF]);\n  if (def) {\n    ngDevMode && console.warn(`DEPRECATED: DI is instantiating a token \"${type.name}\" that inherits its @Injectable decorator but does not provide one itself.\\n` + `This will become an error in a future version of Angular. Please add @Injectable() to the \"${type.name}\" class.`);\n    return def;\n  } else {\n    return null;\n  }\n}\n/**\n * Read the injector def type in a way which is immune to accidentally reading inherited value.\n *\n * @param type type which may have an injector def (`ɵinj`)\n */\nfunction getInjectorDef(type) {\n  return type && (type.hasOwnProperty(NG_INJ_DEF) || type.hasOwnProperty(NG_INJECTOR_DEF)) ? type[NG_INJ_DEF] : null;\n}\nconst NG_PROV_DEF = getClosureSafeProperty({\n  ɵprov: getClosureSafeProperty\n});\nconst NG_INJ_DEF = getClosureSafeProperty({\n  ɵinj: getClosureSafeProperty\n});\n// We need to keep these around so we can read off old defs if new defs are unavailable\nconst NG_INJECTABLE_DEF = getClosureSafeProperty({\n  ngInjectableDef: getClosureSafeProperty\n});\nconst NG_INJECTOR_DEF = getClosureSafeProperty({\n  ngInjectorDef: getClosureSafeProperty\n});\n\n/**\n * Base URL for the error details page.\n *\n * Keep this constant in sync across:\n *  - packages/compiler-cli/src/ngtsc/diagnostics/src/error_details_base_url.ts\n *  - packages/core/src/error_details_base_url.ts\n */\nconst ERROR_DETAILS_PAGE_BASE_URL = 'https://angular.io/errors';\n/**\n * URL for the XSS security documentation.\n */\nconst XSS_SECURITY_URL = 'https://g.co/ng/security#xss';\n\n/**\n * Class that represents a runtime error.\n * Formats and outputs the error message in a consistent way.\n *\n * Example:\n * ```\n *  throw new RuntimeError(\n *    RuntimeErrorCode.INJECTOR_ALREADY_DESTROYED,\n *    ngDevMode && 'Injector has already been destroyed.');\n * ```\n *\n * Note: the `message` argument contains a descriptive error message as a string in development\n * mode (when the `ngDevMode` is defined). In production mode (after tree-shaking pass), the\n * `message` argument becomes `false`, thus we account for it in the typings and the runtime\n * logic.\n */\nclass RuntimeError extends Error {\n  constructor(code, message) {\n    super(formatRuntimeError(code, message));\n    this.code = code;\n  }\n}\n/**\n * Called to format a runtime error.\n * See additional info on the `message` argument type in the `RuntimeError` class description.\n */\nfunction formatRuntimeError(code, message) {\n  // Error code might be a negative number, which is a special marker that instructs the logic to\n  // generate a link to the error details page on angular.io.\n  // We also prepend `0` to non-compile-time errors.\n  const fullCode = `NG0${Math.abs(code)}`;\n  let errorMessage = `${fullCode}${message ? ': ' + message : ''}`;\n  if (ngDevMode && code < 0) {\n    const addPeriodSeparator = !errorMessage.match(/[.,;!?\\n]$/);\n    const separator = addPeriodSeparator ? '.' : '';\n    errorMessage = `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;\n  }\n  return errorMessage;\n}\n\n/**\n * @description\n *\n * Represents a type that a Component or other object is instances of.\n *\n * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is represented by\n * the `MyCustomComponent` constructor function.\n *\n * @publicApi\n */\nconst Type = Function;\nfunction isType(v) {\n  return typeof v === 'function';\n}\n\n// The functions in this file verify that the assumptions we are making\nfunction assertNumber(actual, msg) {\n  if (!(typeof actual === 'number')) {\n    throwError(msg, typeof actual, 'number', '===');\n  }\n}\nfunction assertNumberInRange(actual, minInclusive, maxInclusive) {\n  assertNumber(actual, 'Expected a number');\n  assertLessThanOrEqual(actual, maxInclusive, 'Expected number to be less than or equal to');\n  assertGreaterThanOrEqual(actual, minInclusive, 'Expected number to be greater than or equal to');\n}\nfunction assertString(actual, msg) {\n  if (!(typeof actual === 'string')) {\n    throwError(msg, actual === null ? 'null' : typeof actual, 'string', '===');\n  }\n}\nfunction assertFunction(actual, msg) {\n  if (!(typeof actual === 'function')) {\n    throwError(msg, actual === null ? 'null' : typeof actual, 'function', '===');\n  }\n}\nfunction assertEqual(actual, expected, msg) {\n  if (!(actual == expected)) {\n    throwError(msg, actual, expected, '==');\n  }\n}\nfunction assertNotEqual(actual, expected, msg) {\n  if (!(actual != expected)) {\n    throwError(msg, actual, expected, '!=');\n  }\n}\nfunction assertSame(actual, expected, msg) {\n  if (!(actual === expected)) {\n    throwError(msg, actual, expected, '===');\n  }\n}\nfunction assertNotSame(actual, expected, msg) {\n  if (!(actual !== expected)) {\n    throwError(msg, actual, expected, '!==');\n  }\n}\nfunction assertLessThan(actual, expected, msg) {\n  if (!(actual < expected)) {\n    throwError(msg, actual, expected, '<');\n  }\n}\nfunction assertLessThanOrEqual(actual, expected, msg) {\n  if (!(actual <= expected)) {\n    throwError(msg, actual, expected, '<=');\n  }\n}\nfunction assertGreaterThan(actual, expected, msg) {\n  if (!(actual > expected)) {\n    throwError(msg, actual, expected, '>');\n  }\n}\nfunction assertGreaterThanOrEqual(actual, expected, msg) {\n  if (!(actual >= expected)) {\n    throwError(msg, actual, expected, '>=');\n  }\n}\nfunction assertNotDefined(actual, msg) {\n  if (actual != null) {\n    throwError(msg, actual, null, '==');\n  }\n}\nfunction assertDefined(actual, msg) {\n  if (actual == null) {\n    throwError(msg, actual, null, '!=');\n  }\n}\nfunction throwError(msg, actual, expected, comparison) {\n  throw new Error(`ASSERTION ERROR: ${msg}` + (comparison == null ? '' : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`));\n}\nfunction assertDomNode(node) {\n  if (!(node instanceof Node)) {\n    throwError(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`);\n  }\n}\nfunction assertIndexInRange(arr, index) {\n  assertDefined(arr, 'Array must be defined.');\n  const maxLen = arr.length;\n  if (index < 0 || index >= maxLen) {\n    throwError(`Index expected to be less than ${maxLen} but got ${index}`);\n  }\n}\nfunction assertOneOf(value, ...validValues) {\n  if (validValues.indexOf(value) !== -1) return true;\n  throwError(`Expected value to be one of ${JSON.stringify(validValues)} but was ${JSON.stringify(value)}.`);\n}\n\n/**\n * Determines if the contents of two arrays is identical\n *\n * @param a first array\n * @param b second array\n * @param identityAccessor Optional function for extracting stable object identity from a value in\n *     the array.\n */\nfunction arrayEquals(a, b, identityAccessor) {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    let valueA = a[i];\n    let valueB = b[i];\n    if (identityAccessor) {\n      valueA = identityAccessor(valueA);\n      valueB = identityAccessor(valueB);\n    }\n    if (valueB !== valueA) {\n      return false;\n    }\n  }\n  return true;\n}\n/**\n * Flattens an array.\n */\nfunction flatten$1(list) {\n  return list.flat(Number.POSITIVE_INFINITY);\n}\nfunction deepForEach(input, fn) {\n  input.forEach(value => Array.isArray(value) ? deepForEach(value, fn) : fn(value));\n}\nfunction addToArray(arr, index, value) {\n  // perf: array.push is faster than array.splice!\n  if (index >= arr.length) {\n    arr.push(value);\n  } else {\n    arr.splice(index, 0, value);\n  }\n}\nfunction removeFromArray(arr, index) {\n  // perf: array.pop is faster than array.splice!\n  if (index >= arr.length - 1) {\n    return arr.pop();\n  } else {\n    return arr.splice(index, 1)[0];\n  }\n}\nfunction newArray(size, value) {\n  const list = [];\n  for (let i = 0; i < size; i++) {\n    list.push(value);\n  }\n  return list;\n}\n/**\n * Remove item from array (Same as `Array.splice()` but faster.)\n *\n * `Array.splice()` is not as fast because it has to allocate an array for the elements which were\n * removed. This causes memory pressure and slows down code when most of the time we don't\n * care about the deleted items array.\n *\n * https://jsperf.com/fast-array-splice (About 20x faster)\n *\n * @param array Array to splice\n * @param index Index of element in array to remove.\n * @param count Number of items to remove.\n */\nfunction arraySplice(array, index, count) {\n  const length = array.length - count;\n  while (index < length) {\n    array[index] = array[index + count];\n    index++;\n  }\n  while (count--) {\n    array.pop(); // shrink the array\n  }\n}\n/**\n * Same as `Array.splice(index, 0, value)` but faster.\n *\n * `Array.splice()` is not fast because it has to allocate an array for the elements which were\n * removed. This causes memory pressure and slows down code when most of the time we don't\n * care about the deleted items array.\n *\n * @param array Array to splice.\n * @param index Index in array where the `value` should be added.\n * @param value Value to add to array.\n */\nfunction arrayInsert(array, index, value) {\n  ngDevMode && assertLessThanOrEqual(index, array.length, 'Can\\'t insert past array end.');\n  let end = array.length;\n  while (end > index) {\n    const previousEnd = end - 1;\n    array[end] = array[previousEnd];\n    end = previousEnd;\n  }\n  array[index] = value;\n}\n/**\n * Same as `Array.splice2(index, 0, value1, value2)` but faster.\n *\n * `Array.splice()` is not fast because it has to allocate an array for the elements which were\n * removed. This causes memory pressure and slows down code when most of the time we don't\n * care about the deleted items array.\n *\n * @param array Array to splice.\n * @param index Index in array where the `value` should be added.\n * @param value1 Value to add to array.\n * @param value2 Value to add to array.\n */\nfunction arrayInsert2(array, index, value1, value2) {\n  ngDevMode && assertLessThanOrEqual(index, array.length, 'Can\\'t insert past array end.');\n  let end = array.length;\n  if (end == index) {\n    // inserting at the end.\n    array.push(value1, value2);\n  } else if (end === 1) {\n    // corner case when we have less items in array than we have items to insert.\n    array.push(value2, array[0]);\n    array[0] = value1;\n  } else {\n    end--;\n    array.push(array[end - 1], array[end]);\n    while (end > index) {\n      const previousEnd = end - 2;\n      array[end] = array[previousEnd];\n      end--;\n    }\n    array[index] = value1;\n    array[index + 1] = value2;\n  }\n}\n/**\n * Get an index of an `value` in a sorted `array`.\n *\n * NOTE:\n * - This uses binary search algorithm for fast removals.\n *\n * @param array A sorted array to binary search.\n * @param value The value to look for.\n * @returns index of the value.\n *   - positive index if value found.\n *   - negative index if value not found. (`~index` to get the value where it should have been\n *     located)\n */\nfunction arrayIndexOfSorted(array, value) {\n  return _arrayIndexOfSorted(array, value, 0);\n}\n/**\n * Set a `value` for a `key`.\n *\n * @param keyValueArray to modify.\n * @param key The key to locate or create.\n * @param value The value to set for a `key`.\n * @returns index (always even) of where the value vas set.\n */\nfunction keyValueArraySet(keyValueArray, key, value) {\n  let index = keyValueArrayIndexOf(keyValueArray, key);\n  if (index >= 0) {\n    // if we found it set it.\n    keyValueArray[index | 1] = value;\n  } else {\n    index = ~index;\n    arrayInsert2(keyValueArray, index, key, value);\n  }\n  return index;\n}\n/**\n * Retrieve a `value` for a `key` (on `undefined` if not found.)\n *\n * @param keyValueArray to search.\n * @param key The key to locate.\n * @return The `value` stored at the `key` location or `undefined if not found.\n */\nfunction keyValueArrayGet(keyValueArray, key) {\n  const index = keyValueArrayIndexOf(keyValueArray, key);\n  if (index >= 0) {\n    // if we found it retrieve it.\n    return keyValueArray[index | 1];\n  }\n  return undefined;\n}\n/**\n * Retrieve a `key` index value in the array or `-1` if not found.\n *\n * @param keyValueArray to search.\n * @param key The key to locate.\n * @returns index of where the key is (or should have been.)\n *   - positive (even) index if key found.\n *   - negative index if key not found. (`~index` (even) to get the index where it should have\n *     been inserted.)\n */\nfunction keyValueArrayIndexOf(keyValueArray, key) {\n  return _arrayIndexOfSorted(keyValueArray, key, 1);\n}\n/**\n * Delete a `key` (and `value`) from the `KeyValueArray`.\n *\n * @param keyValueArray to modify.\n * @param key The key to locate or delete (if exist).\n * @returns index of where the key was (or should have been.)\n *   - positive (even) index if key found and deleted.\n *   - negative index if key not found. (`~index` (even) to get the index where it should have\n *     been.)\n */\nfunction keyValueArrayDelete(keyValueArray, key) {\n  const index = keyValueArrayIndexOf(keyValueArray, key);\n  if (index >= 0) {\n    // if we found it remove it.\n    arraySplice(keyValueArray, index, 2);\n  }\n  return index;\n}\n/**\n * INTERNAL: Get an index of an `value` in a sorted `array` by grouping search by `shift`.\n *\n * NOTE:\n * - This uses binary search algorithm for fast removals.\n *\n * @param array A sorted array to binary search.\n * @param value The value to look for.\n * @param shift grouping shift.\n *   - `0` means look at every location\n *   - `1` means only look at every other (even) location (the odd locations are to be ignored as\n *         they are values.)\n * @returns index of the value.\n *   - positive index if value found.\n *   - negative index if value not found. (`~index` to get the value where it should have been\n * inserted)\n */\nfunction _arrayIndexOfSorted(array, value, shift) {\n  ngDevMode && assertEqual(Array.isArray(array), true, 'Expecting an array');\n  let start = 0;\n  let end = array.length >> shift;\n  while (end !== start) {\n    const middle = start + (end - start >> 1); // find the middle.\n    const current = array[middle << shift];\n    if (value === current) {\n      return middle << shift;\n    } else if (current > value) {\n      end = middle;\n    } else {\n      start = middle + 1; // We already searched middle so make it non-inclusive by adding 1\n    }\n  }\n\n  return ~(end << shift);\n}\n\n/**\n * Convince closure compiler that the wrapped function has no side-effects.\n *\n * Closure compiler always assumes that `toString` has no side-effects. We use this quirk to\n * allow us to execute a function but have closure compiler mark the call as no-side-effects.\n * It is important that the return value for the `noSideEffects` function be assigned\n * to something which is retained otherwise the call to `noSideEffects` will be removed by closure\n * compiler.\n */\nfunction noSideEffects(fn) {\n  return {\n    toString: fn\n  }.toString();\n}\nconst ANNOTATIONS = '__annotations__';\nconst PARAMETERS = '__parameters__';\nconst PROP_METADATA = '__prop__metadata__';\n/**\n * @suppress {globalThis}\n */\nfunction makeDecorator(name, props, parentClass, additionalProcessing, typeFn) {\n  return noSideEffects(() => {\n    const metaCtor = makeMetadataCtor(props);\n    function DecoratorFactory(...args) {\n      if (this instanceof DecoratorFactory) {\n        metaCtor.call(this, ...args);\n        return this;\n      }\n      const annotationInstance = new DecoratorFactory(...args);\n      return function TypeDecorator(cls) {\n        if (typeFn) typeFn(cls, ...args);\n        // Use of Object.defineProperty is important since it creates non-enumerable property which\n        // prevents the property is copied during subclassing.\n        const annotations = cls.hasOwnProperty(ANNOTATIONS) ? cls[ANNOTATIONS] : Object.defineProperty(cls, ANNOTATIONS, {\n          value: []\n        })[ANNOTATIONS];\n        annotations.push(annotationInstance);\n        if (additionalProcessing) additionalProcessing(cls);\n        return cls;\n      };\n    }\n    if (parentClass) {\n      DecoratorFactory.prototype = Object.create(parentClass.prototype);\n    }\n    DecoratorFactory.prototype.ngMetadataName = name;\n    DecoratorFactory.annotationCls = DecoratorFactory;\n    return DecoratorFactory;\n  });\n}\nfunction makeMetadataCtor(props) {\n  return function ctor(...args) {\n    if (props) {\n      const values = props(...args);\n      for (const propName in values) {\n        this[propName] = values[propName];\n      }\n    }\n  };\n}\nfunction makeParamDecorator(name, props, parentClass) {\n  return noSideEffects(() => {\n    const metaCtor = makeMetadataCtor(props);\n    function ParamDecoratorFactory(...args) {\n      if (this instanceof ParamDecoratorFactory) {\n        metaCtor.apply(this, args);\n        return this;\n      }\n      const annotationInstance = new ParamDecoratorFactory(...args);\n      ParamDecorator.annotation = annotationInstance;\n      return ParamDecorator;\n      function ParamDecorator(cls, unusedKey, index) {\n        // Use of Object.defineProperty is important since it creates non-enumerable property which\n        // prevents the property is copied during subclassing.\n        const parameters = cls.hasOwnProperty(PARAMETERS) ? cls[PARAMETERS] : Object.defineProperty(cls, PARAMETERS, {\n          value: []\n        })[PARAMETERS];\n        // there might be gaps if some in between parameters do not have annotations.\n        // we pad with nulls.\n        while (parameters.length <= index) {\n          parameters.push(null);\n        }\n        (parameters[index] = parameters[index] || []).push(annotationInstance);\n        return cls;\n      }\n    }\n    if (parentClass) {\n      ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);\n    }\n    ParamDecoratorFactory.prototype.ngMetadataName = name;\n    ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;\n    return ParamDecoratorFactory;\n  });\n}\nfunction makePropDecorator(name, props, parentClass, additionalProcessing) {\n  return noSideEffects(() => {\n    const metaCtor = makeMetadataCtor(props);\n    function PropDecoratorFactory(...args) {\n      if (this instanceof PropDecoratorFactory) {\n        metaCtor.apply(this, args);\n        return this;\n      }\n      const decoratorInstance = new PropDecoratorFactory(...args);\n      function PropDecorator(target, name) {\n        // target is undefined with standard decorators. This case is not supported and will throw\n        // if this decorator is used in JIT mode with standard decorators.\n        if (target === undefined) {\n          throw new Error('Standard Angular field decorators are not supported in JIT mode.');\n        }\n        const constructor = target.constructor;\n        // Use of Object.defineProperty is important because it creates a non-enumerable property\n        // which prevents the property from being copied during subclassing.\n        const meta = constructor.hasOwnProperty(PROP_METADATA) ? constructor[PROP_METADATA] : Object.defineProperty(constructor, PROP_METADATA, {\n          value: {}\n        })[PROP_METADATA];\n        meta[name] = meta.hasOwnProperty(name) && meta[name] || [];\n        meta[name].unshift(decoratorInstance);\n        if (additionalProcessing) additionalProcessing(target, name, ...args);\n      }\n      return PropDecorator;\n    }\n    if (parentClass) {\n      PropDecoratorFactory.prototype = Object.create(parentClass.prototype);\n    }\n    PropDecoratorFactory.prototype.ngMetadataName = name;\n    PropDecoratorFactory.annotationCls = PropDecoratorFactory;\n    return PropDecoratorFactory;\n  });\n}\n\n/*\n * #########################\n * Attention: These Regular expressions have to hold even if the code is minified!\n * ##########################\n */\n/**\n * Regular expression that detects pass-through constructors for ES5 output. This Regex\n * intends to capture the common delegation pattern emitted by TypeScript and Babel. Also\n * it intends to capture the pattern where existing constructors have been downleveled from\n * ES2015 to ES5 using TypeScript w/ downlevel iteration. e.g.\n *\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, arguments) || this;\n * ```\n *\n * downleveled to ES5 with `downlevelIteration` for TypeScript < 4.2:\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, __spread(arguments)) || this;\n * ```\n *\n * or downleveled to ES5 with `downlevelIteration` for TypeScript >= 4.2:\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;\n * ```\n *\n * More details can be found in: https://github.com/angular/angular/issues/38453.\n */\nconst ES5_DELEGATE_CTOR = /^function\\s+\\S+\\(\\)\\s*{[\\s\\S]+\\.apply\\(this,\\s*(arguments|(?:[^()]+\\(\\[\\],)?[^()]+\\(arguments\\).*)\\)/;\n/** Regular expression that detects ES2015 classes which extend from other classes. */\nconst ES2015_INHERITED_CLASS = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{/;\n/**\n * Regular expression that detects ES2015 classes which extend from other classes and\n * have an explicit constructor defined.\n */\nconst ES2015_INHERITED_CLASS_WITH_CTOR = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{[\\s\\S]*constructor\\s*\\(/;\n/**\n * Regular expression that detects ES2015 classes which extend from other classes\n * and inherit a constructor.\n */\nconst ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{[\\s\\S]*constructor\\s*\\(\\)\\s*{[^}]*super\\(\\.\\.\\.arguments\\)/;\n/**\n * Determine whether a stringified type is a class which delegates its constructor\n * to its parent.\n *\n * This is not trivial since compiled code can actually contain a constructor function\n * even if the original source code did not. For instance, when the child class contains\n * an initialized instance property.\n */\nfunction isDelegateCtor(typeStr) {\n  return ES5_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS.test(typeStr) && !ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr);\n}\nclass ReflectionCapabilities {\n  constructor(reflect) {\n    this._reflect = reflect || _global['Reflect'];\n  }\n  factory(t) {\n    return (...args) => new t(...args);\n  }\n  /** @internal */\n  _zipTypesAndAnnotations(paramTypes, paramAnnotations) {\n    let result;\n    if (typeof paramTypes === 'undefined') {\n      result = newArray(paramAnnotations.length);\n    } else {\n      result = newArray(paramTypes.length);\n    }\n    for (let i = 0; i < result.length; i++) {\n      // TS outputs Object for parameters without types, while Traceur omits\n      // the annotations. For now we preserve the Traceur behavior to aid\n      // migration, but this can be revisited.\n      if (typeof paramTypes === 'undefined') {\n        result[i] = [];\n      } else if (paramTypes[i] && paramTypes[i] != Object) {\n        result[i] = [paramTypes[i]];\n      } else {\n        result[i] = [];\n      }\n      if (paramAnnotations && paramAnnotations[i] != null) {\n        result[i] = result[i].concat(paramAnnotations[i]);\n      }\n    }\n    return result;\n  }\n  _ownParameters(type, parentCtor) {\n    const typeStr = type.toString();\n    // If we have no decorators, we only have function.length as metadata.\n    // In that case, to detect whether a child class declared an own constructor or not,\n    // we need to look inside of that constructor to check whether it is\n    // just calling the parent.\n    // This also helps to work around for https://github.com/Microsoft/TypeScript/issues/12439\n    // that sets 'design:paramtypes' to []\n    // if a class inherits from another class but has no ctor declared itself.\n    if (isDelegateCtor(typeStr)) {\n      return null;\n    }\n    // Prefer the direct API.\n    if (type.parameters && type.parameters !== parentCtor.parameters) {\n      return type.parameters;\n    }\n    // API of tsickle for lowering decorators to properties on the class.\n    const tsickleCtorParams = type.ctorParameters;\n    if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {\n      // Newer tsickle uses a function closure\n      // Retain the non-function case for compatibility with older tsickle\n      const ctorParameters = typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;\n      const paramTypes = ctorParameters.map(ctorParam => ctorParam && ctorParam.type);\n      const paramAnnotations = ctorParameters.map(ctorParam => ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));\n      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n    }\n    // API for metadata created by invoking the decorators.\n    const paramAnnotations = type.hasOwnProperty(PARAMETERS) && type[PARAMETERS];\n    const paramTypes = this._reflect && this._reflect.getOwnMetadata && this._reflect.getOwnMetadata('design:paramtypes', type);\n    if (paramTypes || paramAnnotations) {\n      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n    }\n    // If a class has no decorators, at least create metadata\n    // based on function.length.\n    // Note: We know that this is a real constructor as we checked\n    // the content of the constructor above.\n    return newArray(type.length);\n  }\n  parameters(type) {\n    // Note: only report metadata if we have at least one class decorator\n    // to stay in sync with the static reflector.\n    if (!isType(type)) {\n      return [];\n    }\n    const parentCtor = getParentCtor(type);\n    let parameters = this._ownParameters(type, parentCtor);\n    if (!parameters && parentCtor !== Object) {\n      parameters = this.parameters(parentCtor);\n    }\n    return parameters || [];\n  }\n  _ownAnnotations(typeOrFunc, parentCtor) {\n    // Prefer the direct API.\n    if (typeOrFunc.annotations && typeOrFunc.annotations !== parentCtor.annotations) {\n      let annotations = typeOrFunc.annotations;\n      if (typeof annotations === 'function' && annotations.annotations) {\n        annotations = annotations.annotations;\n      }\n      return annotations;\n    }\n    // API of tsickle for lowering decorators to properties on the class.\n    if (typeOrFunc.decorators && typeOrFunc.decorators !== parentCtor.decorators) {\n      return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);\n    }\n    // API for metadata created by invoking the decorators.\n    if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {\n      return typeOrFunc[ANNOTATIONS];\n    }\n    return null;\n  }\n  annotations(typeOrFunc) {\n    if (!isType(typeOrFunc)) {\n      return [];\n    }\n    const parentCtor = getParentCtor(typeOrFunc);\n    const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];\n    const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];\n    return parentAnnotations.concat(ownAnnotations);\n  }\n  _ownPropMetadata(typeOrFunc, parentCtor) {\n    // Prefer the direct API.\n    if (typeOrFunc.propMetadata && typeOrFunc.propMetadata !== parentCtor.propMetadata) {\n      let propMetadata = typeOrFunc.propMetadata;\n      if (typeof propMetadata === 'function' && propMetadata.propMetadata) {\n        propMetadata = propMetadata.propMetadata;\n      }\n      return propMetadata;\n    }\n    // API of tsickle for lowering decorators to properties on the class.\n    if (typeOrFunc.propDecorators && typeOrFunc.propDecorators !== parentCtor.propDecorators) {\n      const propDecorators = typeOrFunc.propDecorators;\n      const propMetadata = {};\n      Object.keys(propDecorators).forEach(prop => {\n        propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);\n      });\n      return propMetadata;\n    }\n    // API for metadata created by invoking the decorators.\n    if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {\n      return typeOrFunc[PROP_METADATA];\n    }\n    return null;\n  }\n  propMetadata(typeOrFunc) {\n    if (!isType(typeOrFunc)) {\n      return {};\n    }\n    const parentCtor = getParentCtor(typeOrFunc);\n    const propMetadata = {};\n    if (parentCtor !== Object) {\n      const parentPropMetadata = this.propMetadata(parentCtor);\n      Object.keys(parentPropMetadata).forEach(propName => {\n        propMetadata[propName] = parentPropMetadata[propName];\n      });\n    }\n    const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);\n    if (ownPropMetadata) {\n      Object.keys(ownPropMetadata).forEach(propName => {\n        const decorators = [];\n        if (propMetadata.hasOwnProperty(propName)) {\n          decorators.push(...propMetadata[propName]);\n        }\n        decorators.push(...ownPropMetadata[propName]);\n        propMetadata[propName] = decorators;\n      });\n    }\n    return propMetadata;\n  }\n  ownPropMetadata(typeOrFunc) {\n    if (!isType(typeOrFunc)) {\n      return {};\n    }\n    return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};\n  }\n  hasLifecycleHook(type, lcProperty) {\n    return type instanceof Type && lcProperty in type.prototype;\n  }\n}\nfunction convertTsickleDecoratorIntoMetadata(decoratorInvocations) {\n  if (!decoratorInvocations) {\n    return [];\n  }\n  return decoratorInvocations.map(decoratorInvocation => {\n    const decoratorType = decoratorInvocation.type;\n    const annotationCls = decoratorType.annotationCls;\n    const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];\n    return new annotationCls(...annotationArgs);\n  });\n}\nfunction getParentCtor(ctor) {\n  const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;\n  const parentCtor = parentProto ? parentProto.constructor : null;\n  // Note: We always use `Object` as the null value\n  // to simplify checking later on.\n  return parentCtor || Object;\n}\nfunction ngDevModeResetPerfCounters() {\n  const locationString = typeof location !== 'undefined' ? location.toString() : '';\n  const newCounters = {\n    namedConstructors: locationString.indexOf('ngDevMode=namedConstructors') != -1,\n    firstCreatePass: 0,\n    tNode: 0,\n    tView: 0,\n    rendererCreateTextNode: 0,\n    rendererSetText: 0,\n    rendererCreateElement: 0,\n    rendererAddEventListener: 0,\n    rendererSetAttribute: 0,\n    rendererRemoveAttribute: 0,\n    rendererSetProperty: 0,\n    rendererSetClassName: 0,\n    rendererAddClass: 0,\n    rendererRemoveClass: 0,\n    rendererSetStyle: 0,\n    rendererRemoveStyle: 0,\n    rendererDestroy: 0,\n    rendererDestroyNode: 0,\n    rendererMoveNode: 0,\n    rendererRemoveNode: 0,\n    rendererAppendChild: 0,\n    rendererInsertBefore: 0,\n    rendererCreateComment: 0,\n    hydratedNodes: 0,\n    hydratedComponents: 0,\n    dehydratedViewsRemoved: 0,\n    dehydratedViewsCleanupRuns: 0,\n    componentsSkippedHydration: 0\n  };\n  // Make sure to refer to ngDevMode as ['ngDevMode'] for closure.\n  const allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;\n  _global['ngDevMode'] = allowNgDevModeTrue && newCounters;\n  return newCounters;\n}\n/**\n * This function checks to see if the `ngDevMode` has been set. If yes,\n * then we honor it, otherwise we default to dev mode with additional checks.\n *\n * The idea is that unless we are doing production build where we explicitly\n * set `ngDevMode == false` we should be helping the developer by providing\n * as much early warning and errors as possible.\n *\n * `ɵɵdefineComponent` is guaranteed to have been called before any component template functions\n * (and thus Ivy instructions), so a single initialization there is sufficient to ensure ngDevMode\n * is defined for the entire instruction set.\n *\n * When checking `ngDevMode` on toplevel, always init it before referencing it\n * (e.g. `((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode())`), otherwise you can\n *  get a `ReferenceError` like in https://github.com/angular/angular/issues/31595.\n *\n * Details on possible values for `ngDevMode` can be found on its docstring.\n *\n * NOTE:\n * - changes to the `ngDevMode` name must be synced with `compiler-cli/src/tooling.ts`.\n */\nfunction initNgDevMode() {\n  // The below checks are to ensure that calling `initNgDevMode` multiple times does not\n  // reset the counters.\n  // If the `ngDevMode` is not an object, then it means we have not created the perf counters\n  // yet.\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (typeof ngDevMode !== 'object') {\n      ngDevModeResetPerfCounters();\n    }\n    return typeof ngDevMode !== 'undefined' && !!ngDevMode;\n  }\n  return false;\n}\nlet _injectorProfilerContext;\nfunction getInjectorProfilerContext() {\n  !ngDevMode && throwError('getInjectorProfilerContext should never be called in production mode');\n  return _injectorProfilerContext;\n}\nfunction setInjectorProfilerContext(context) {\n  !ngDevMode && throwError('setInjectorProfilerContext should never be called in production mode');\n  const previous = _injectorProfilerContext;\n  _injectorProfilerContext = context;\n  return previous;\n}\nlet injectorProfilerCallback = null;\n/**\n * Sets the callback function which will be invoked during certain DI events within the\n * runtime (for example: injecting services, creating injectable instances, configuring providers)\n *\n * Warning: this function is *INTERNAL* and should not be relied upon in application's code.\n * The contract of the function might be changed in any release and/or the function can be removed\n * completely.\n *\n * @param profiler function provided by the caller or null value to disable profiling.\n */\nconst setInjectorProfiler = injectorProfiler => {\n  !ngDevMode && throwError('setInjectorProfiler should never be called in production mode');\n  injectorProfilerCallback = injectorProfiler;\n};\n/**\n * Injector profiler function which emits on DI events executed by the runtime.\n *\n * @param event InjectorProfilerEvent corresponding to the DI event being emitted\n */\nfunction injectorProfiler(event) {\n  !ngDevMode && throwError('Injector profiler should never be called in production mode');\n  if (injectorProfilerCallback != null /* both `null` and `undefined` */) {\n    injectorProfilerCallback(event);\n  }\n}\n/**\n * Emits an InjectorProfilerEventType.ProviderConfigured to the injector profiler. The data in the\n * emitted event includes the raw provider, as well as the token that provider is providing.\n *\n * @param provider A provider object\n */\nfunction emitProviderConfiguredEvent(provider, isViewProvider = false) {\n  !ngDevMode && throwError('Injector profiler should never be called in production mode');\n  injectorProfiler({\n    type: 2 /* InjectorProfilerEventType.ProviderConfigured */,\n    context: getInjectorProfilerContext(),\n    providerRecord: {\n      token: typeof provider === 'function' ? provider : resolveForwardRef(provider.provide),\n      provider,\n      isViewProvider\n    }\n  });\n}\n/**\n * Emits an event to the injector profiler with the instance that was created. Note that\n * the injector associated with this emission can be accessed by using getDebugInjectContext()\n *\n * @param instance an object created by an injector\n */\nfunction emitInstanceCreatedByInjectorEvent(instance) {\n  !ngDevMode && throwError('Injector profiler should never be called in production mode');\n  injectorProfiler({\n    type: 1 /* InjectorProfilerEventType.InstanceCreatedByInjector */,\n    context: getInjectorProfilerContext(),\n    instance: {\n      value: instance\n    }\n  });\n}\n/**\n * @param token DI token associated with injected service\n * @param value the instance of the injected service (i.e the result of `inject(token)`)\n * @param flags the flags that the token was injected with\n */\nfunction emitInjectEvent(token, value, flags) {\n  !ngDevMode && throwError('Injector profiler should never be called in production mode');\n  injectorProfiler({\n    type: 0 /* InjectorProfilerEventType.Inject */,\n    context: getInjectorProfilerContext(),\n    service: {\n      token,\n      value,\n      flags\n    }\n  });\n}\nfunction runInInjectorProfilerContext(injector, token, callback) {\n  !ngDevMode && throwError('runInInjectorProfilerContext should never be called in production mode');\n  const prevInjectContext = setInjectorProfilerContext({\n    injector,\n    token\n  });\n  try {\n    callback();\n  } finally {\n    setInjectorProfilerContext(prevInjectContext);\n  }\n}\nfunction isEnvironmentProviders(value) {\n  return value && !!value.ɵproviders;\n}\n\n/**\n * Used for stringify render output in Ivy.\n * Important! This function is very performance-sensitive and we should\n * be extra careful not to introduce megamorphic reads in it.\n * Check `core/test/render3/perf/render_stringify` for benchmarks and alternate implementations.\n */\nfunction renderStringify(value) {\n  if (typeof value === 'string') return value;\n  if (value == null) return '';\n  // Use `String` so that it invokes the `toString` method of the value. Note that this\n  // appears to be faster than calling `value.toString` (see `render_stringify` benchmark).\n  return String(value);\n}\n/**\n * Used to stringify a value so that it can be displayed in an error message.\n * Important! This function contains a megamorphic read and should only be\n * used for error messages.\n */\nfunction stringifyForError(value) {\n  if (typeof value === 'function') return value.name || value.toString();\n  if (typeof value === 'object' && value != null && typeof value.type === 'function') {\n    return value.type.name || value.type.toString();\n  }\n  return renderStringify(value);\n}\n\n/** Called when directives inject each other (creating a circular dependency) */\nfunction throwCyclicDependencyError(token, path) {\n  const depPath = path ? `. Dependency path: ${path.join(' > ')} > ${token}` : '';\n  throw new RuntimeError(-200 /* RuntimeErrorCode.CYCLIC_DI_DEPENDENCY */, `Circular dependency in DI detected for ${token}${depPath}`);\n}\nfunction throwMixedMultiProviderError() {\n  throw new Error(`Cannot mix multi providers and regular providers`);\n}\nfunction throwInvalidProviderError(ngModuleType, providers, provider) {\n  if (ngModuleType && providers) {\n    const providerDetail = providers.map(v => v == provider ? '?' + provider + '?' : '...');\n    throw new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}' - only instances of Provider and Type are allowed, got: [${providerDetail.join(', ')}]`);\n  } else if (isEnvironmentProviders(provider)) {\n    if (provider.ɵfromNgModule) {\n      throw new RuntimeError(207 /* RuntimeErrorCode.PROVIDER_IN_WRONG_CONTEXT */, `Invalid providers from 'importProvidersFrom' present in a non-environment injector. 'importProvidersFrom' can't be used for component providers.`);\n    } else {\n      throw new RuntimeError(207 /* RuntimeErrorCode.PROVIDER_IN_WRONG_CONTEXT */, `Invalid providers present in a non-environment injector. 'EnvironmentProviders' can't be used for component providers.`);\n    }\n  } else {\n    throw new Error('Invalid provider');\n  }\n}\n/** Throws an error when a token is not found in DI. */\nfunction throwProviderNotFoundError(token, injectorName) {\n  const injectorDetails = injectorName ? ` in ${injectorName}` : '';\n  throw new RuntimeError(-201 /* RuntimeErrorCode.PROVIDER_NOT_FOUND */, ngDevMode && `No provider for ${stringifyForError(token)} found${injectorDetails}`);\n}\n\n/**\n * Injection flags for DI.\n *\n * @publicApi\n * @deprecated use an options object for [`inject`](api/core/inject) instead.\n */\nvar InjectFlags;\n(function (InjectFlags) {\n  // TODO(alxhub): make this 'const' (and remove `InternalInjectFlags` enum) when ngc no longer\n  // writes exports of it into ngfactory files.\n  /** Check self and check parent injector if needed */\n  InjectFlags[InjectFlags[\"Default\"] = 0] = \"Default\";\n  /**\n   * Specifies that an injector should retrieve a dependency from any injector until reaching the\n   * host element of the current component. (Only used with Element Injector)\n   */\n  InjectFlags[InjectFlags[\"Host\"] = 1] = \"Host\";\n  /** Don't ascend to ancestors of the node requesting injection. */\n  InjectFlags[InjectFlags[\"Self\"] = 2] = \"Self\";\n  /** Skip the node that is requesting injection. */\n  InjectFlags[InjectFlags[\"SkipSelf\"] = 4] = \"SkipSelf\";\n  /** Inject `defaultValue` instead if token not found. */\n  InjectFlags[InjectFlags[\"Optional\"] = 8] = \"Optional\";\n})(InjectFlags || (InjectFlags = {}));\n\n/**\n * Current implementation of inject.\n *\n * By default, it is `injectInjectorOnly`, which makes it `Injector`-only aware. It can be changed\n * to `directiveInject`, which brings in the `NodeInjector` system of ivy. It is designed this\n * way for two reasons:\n *  1. `Injector` should not depend on ivy logic.\n *  2. To maintain tree shake-ability we don't want to bring in unnecessary code.\n */\nlet _injectImplementation;\nfunction getInjectImplementation() {\n  return _injectImplementation;\n}\n/**\n * Sets the current inject implementation.\n */\nfunction setInjectImplementation(impl) {\n  const previous = _injectImplementation;\n  _injectImplementation = impl;\n  return previous;\n}\n/**\n * Injects `root` tokens in limp mode.\n *\n * If no injector exists, we can still inject tree-shakable providers which have `providedIn` set to\n * `\"root\"`. This is known as the limp mode injection. In such case the value is stored in the\n * injectable definition.\n */\nfunction injectRootLimpMode(token, notFoundValue, flags) {\n  const injectableDef = getInjectableDef(token);\n  if (injectableDef && injectableDef.providedIn == 'root') {\n    return injectableDef.value === undefined ? injectableDef.value = injectableDef.factory() : injectableDef.value;\n  }\n  if (flags & InjectFlags.Optional) return null;\n  if (notFoundValue !== undefined) return notFoundValue;\n  throwProviderNotFoundError(stringify(token), 'Injector');\n}\n/**\n * Assert that `_injectImplementation` is not `fn`.\n *\n * This is useful, to prevent infinite recursion.\n *\n * @param fn Function which it should not equal to\n */\nfunction assertInjectImplementationNotEqual(fn) {\n  ngDevMode && assertNotEqual(_injectImplementation, fn, 'Calling ɵɵinject would cause infinite recursion');\n}\nconst _THROW_IF_NOT_FOUND = {};\nconst THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n/*\n * Name of a property (that we patch onto DI decorator), which is used as an annotation of which\n * InjectFlag this decorator represents. This allows to avoid direct references to the DI decorators\n * in the code, thus making them tree-shakable.\n */\nconst DI_DECORATOR_FLAG = '__NG_DI_FLAG__';\nconst NG_TEMP_TOKEN_PATH = 'ngTempTokenPath';\nconst NG_TOKEN_PATH = 'ngTokenPath';\nconst NEW_LINE = /\\n/gm;\nconst NO_NEW_LINE = 'ɵ';\nconst SOURCE = '__source';\n/**\n * Current injector value used by `inject`.\n * - `undefined`: it is an error to call `inject`\n * - `null`: `inject` can be called but there is no injector (limp-mode).\n * - Injector instance: Use the injector for resolution.\n */\nlet _currentInjector = undefined;\nfunction getCurrentInjector() {\n  return _currentInjector;\n}\nfunction setCurrentInjector(injector) {\n  const former = _currentInjector;\n  _currentInjector = injector;\n  return former;\n}\nfunction injectInjectorOnly(token, flags = InjectFlags.Default) {\n  if (_currentInjector === undefined) {\n    throw new RuntimeError(-203 /* RuntimeErrorCode.MISSING_INJECTION_CONTEXT */, ngDevMode && `inject() must be called from an injection context such as a constructor, a factory function, a field initializer, or a function used with \\`runInInjectionContext\\`.`);\n  } else if (_currentInjector === null) {\n    return injectRootLimpMode(token, undefined, flags);\n  } else {\n    const value = _currentInjector.get(token, flags & InjectFlags.Optional ? null : undefined, flags);\n    ngDevMode && emitInjectEvent(token, value, flags);\n    return value;\n  }\n}\nfunction ɵɵinject(token, flags = InjectFlags.Default) {\n  return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef(token), flags);\n}\n/**\n * Throws an error indicating that a factory function could not be generated by the compiler for a\n * particular class.\n *\n * The name of the class is not mentioned here, but will be in the generated factory function name\n * and thus in the stack trace.\n *\n * @codeGenApi\n */\nfunction ɵɵinvalidFactoryDep(index) {\n  throw new RuntimeError(202 /* RuntimeErrorCode.INVALID_FACTORY_DEPENDENCY */, ngDevMode && `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.\nThis can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.\n\nPlease check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.`);\n}\n/**\n * Injects a token from the currently active injector.\n * `inject` is only supported in an [injection context](/guide/dependency-injection-context). It can\n * be used during:\n * - Construction (via the `constructor`) of a class being instantiated by the DI system, such\n * as an `@Injectable` or `@Component`.\n * - In the initializer for fields of such classes.\n * - In the factory function specified for `useFactory` of a `Provider` or an `@Injectable`.\n * - In the `factory` function specified for an `InjectionToken`.\n * - In a stackframe of a function call in a DI context\n *\n * @param token A token that represents a dependency that should be injected.\n * @param flags Optional flags that control how injection is executed.\n * The flags correspond to injection strategies that can be specified with\n * parameter decorators `@Host`, `@Self`, `@SkipSelf`, and `@Optional`.\n * @returns the injected value if operation is successful, `null` otherwise.\n * @throws if called outside of a supported context.\n *\n * @usageNotes\n * In practice the `inject()` calls are allowed in a constructor, a constructor parameter and a\n * field initializer:\n *\n * ```typescript\n * @Injectable({providedIn: 'root'})\n * export class Car {\n *   radio: Radio|undefined;\n *   // OK: field initializer\n *   spareTyre = inject(Tyre);\n *\n *   constructor() {\n *     // OK: constructor body\n *     this.radio = inject(Radio);\n *   }\n * }\n * ```\n *\n * It is also legal to call `inject` from a provider's factory:\n *\n * ```typescript\n * providers: [\n *   {provide: Car, useFactory: () => {\n *     // OK: a class factory\n *     const engine = inject(Engine);\n *     return new Car(engine);\n *   }}\n * ]\n * ```\n *\n * Calls to the `inject()` function outside of the class creation context will result in error. Most\n * notably, calls to `inject()` are disallowed after a class instance was created, in methods\n * (including lifecycle hooks):\n *\n * ```typescript\n * @Component({ ... })\n * export class CarComponent {\n *   ngOnInit() {\n *     // ERROR: too late, the component instance was already created\n *     const engine = inject(Engine);\n *     engine.start();\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nfunction inject$1(token, flags = InjectFlags.Default) {\n  return ɵɵinject(token, convertToBitFlags(flags));\n}\n// Converts object-based DI flags (`InjectOptions`) to bit flags (`InjectFlags`).\nfunction convertToBitFlags(flags) {\n  if (typeof flags === 'undefined' || typeof flags === 'number') {\n    return flags;\n  }\n  // While TypeScript doesn't accept it without a cast, bitwise OR with false-y values in\n  // JavaScript is a no-op. We can use that for a very codesize-efficient conversion from\n  // `InjectOptions` to `InjectFlags`.\n  return 0 /* InternalInjectFlags.Default */ | (\n  // comment to force a line break in the formatter\n  flags.optional && 8 /* InternalInjectFlags.Optional */) | (flags.host && 1 /* InternalInjectFlags.Host */) | (flags.self && 2 /* InternalInjectFlags.Self */) | (flags.skipSelf && 4 /* InternalInjectFlags.SkipSelf */);\n}\n\nfunction injectArgs(types) {\n  const args = [];\n  for (let i = 0; i < types.length; i++) {\n    const arg = resolveForwardRef(types[i]);\n    if (Array.isArray(arg)) {\n      if (arg.length === 0) {\n        throw new RuntimeError(900 /* RuntimeErrorCode.INVALID_DIFFER_INPUT */, ngDevMode && 'Arguments array must have arguments.');\n      }\n      let type = undefined;\n      let flags = InjectFlags.Default;\n      for (let j = 0; j < arg.length; j++) {\n        const meta = arg[j];\n        const flag = getInjectFlag(meta);\n        if (typeof flag === 'number') {\n          // Special case when we handle @Inject decorator.\n          if (flag === -1 /* DecoratorFlags.Inject */) {\n            type = meta.token;\n          } else {\n            flags |= flag;\n          }\n        } else {\n          type = meta;\n        }\n      }\n      args.push(ɵɵinject(type, flags));\n    } else {\n      args.push(ɵɵinject(arg));\n    }\n  }\n  return args;\n}\n/**\n * Attaches a given InjectFlag to a given decorator using monkey-patching.\n * Since DI decorators can be used in providers `deps` array (when provider is configured using\n * `useFactory`) without initialization (e.g. `Host`) and as an instance (e.g. `new Host()`), we\n * attach the flag to make it available both as a static property and as a field on decorator\n * instance.\n *\n * @param decorator Provided DI decorator.\n * @param flag InjectFlag that should be applied.\n */\nfunction attachInjectFlag(decorator, flag) {\n  decorator[DI_DECORATOR_FLAG] = flag;\n  decorator.prototype[DI_DECORATOR_FLAG] = flag;\n  return decorator;\n}\n/**\n * Reads monkey-patched property that contains InjectFlag attached to a decorator.\n *\n * @param token Token that may contain monkey-patched DI flags property.\n */\nfunction getInjectFlag(token) {\n  return token[DI_DECORATOR_FLAG];\n}\nfunction catchInjectorError(e, token, injectorErrorName, source) {\n  const tokenPath = e[NG_TEMP_TOKEN_PATH];\n  if (token[SOURCE]) {\n    tokenPath.unshift(token[SOURCE]);\n  }\n  e.message = formatError('\\n' + e.message, tokenPath, injectorErrorName, source);\n  e[NG_TOKEN_PATH] = tokenPath;\n  e[NG_TEMP_TOKEN_PATH] = null;\n  throw e;\n}\nfunction formatError(text, obj, injectorErrorName, source = null) {\n  text = text && text.charAt(0) === '\\n' && text.charAt(1) == NO_NEW_LINE ? text.slice(2) : text;\n  let context = stringify(obj);\n  if (Array.isArray(obj)) {\n    context = obj.map(stringify).join(' -> ');\n  } else if (typeof obj === 'object') {\n    let parts = [];\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        let value = obj[key];\n        parts.push(key + ':' + (typeof value === 'string' ? JSON.stringify(value) : stringify(value)));\n      }\n    }\n    context = `{${parts.join(', ')}}`;\n  }\n  return `${injectorErrorName}${source ? '(' + source + ')' : ''}[${context}]: ${text.replace(NEW_LINE, '\\n  ')}`;\n}\n\n/**\n * Inject decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Inject = attachInjectFlag(\n// Disable tslint because `DecoratorFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nmakeParamDecorator('Inject', token => ({\n  token\n})), -1 /* DecoratorFlags.Inject */);\n/**\n * Optional decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Optional =\n// Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nattachInjectFlag(makeParamDecorator('Optional'), 8 /* InternalInjectFlags.Optional */);\n/**\n * Self decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Self =\n// Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nattachInjectFlag(makeParamDecorator('Self'), 2 /* InternalInjectFlags.Self */);\n/**\n * `SkipSelf` decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst SkipSelf =\n// Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nattachInjectFlag(makeParamDecorator('SkipSelf'), 4 /* InternalInjectFlags.SkipSelf */);\n/**\n * Host decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Host =\n// Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nattachInjectFlag(makeParamDecorator('Host'), 1 /* InternalInjectFlags.Host */);\n\n/**\n * The strategy that the default change detector uses to detect changes.\n * When set, takes effect the next time change detection is triggered.\n *\n * @see {@link ChangeDetectorRef#usage-notes Change detection usage}\n *\n * @publicApi\n */\nvar ChangeDetectionStrategy;\n(function (ChangeDetectionStrategy) {\n  /**\n   * Use the `CheckOnce` strategy, meaning that automatic change detection is deactivated\n   * until reactivated by setting the strategy to `Default` (`CheckAlways`).\n   * Change detection can still be explicitly invoked.\n   * This strategy applies to all child directives and cannot be overridden.\n   */\n  ChangeDetectionStrategy[ChangeDetectionStrategy[\"OnPush\"] = 0] = \"OnPush\";\n  /**\n   * Use the default `CheckAlways` strategy, in which change detection is automatic until\n   * explicitly deactivated.\n   */\n  ChangeDetectionStrategy[ChangeDetectionStrategy[\"Default\"] = 1] = \"Default\";\n})(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));\n\n/**\n * Defines the CSS styles encapsulation policies for the {@link Component} decorator's\n * `encapsulation` option.\n *\n * See {@link Component#encapsulation encapsulation}.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/ts/metadata/encapsulation.ts region='longform'}\n *\n * @publicApi\n */\nvar ViewEncapsulation;\n(function (ViewEncapsulation) {\n  // TODO: consider making `ViewEncapsulation` a `const enum` instead. See\n  // https://github.com/angular/angular/issues/44119 for additional information.\n  /**\n   * Emulates a native Shadow DOM encapsulation behavior by adding a specific attribute to the\n   * component's host element and applying the same attribute to all the CSS selectors provided\n   * via {@link Component#styles styles} or {@link Component#styleUrls styleUrls}.\n   *\n   * This is the default option.\n   */\n  ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\";\n  // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.\n  /**\n   * Doesn't provide any sort of CSS style encapsulation, meaning that all the styles provided\n   * via {@link Component#styles styles} or {@link Component#styleUrls styleUrls} are applicable\n   * to any HTML element of the application regardless of their host Component.\n   */\n  ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\n  /**\n   * Uses the browser's native Shadow DOM API to encapsulate CSS styles, meaning that it creates\n   * a ShadowRoot for the component's host element which is then used to encapsulate\n   * all the Component's styling.\n   */\n  ViewEncapsulation[ViewEncapsulation[\"ShadowDom\"] = 3] = \"ShadowDom\";\n})(ViewEncapsulation || (ViewEncapsulation = {}));\n\n/**\n * This file contains reuseable \"empty\" symbols that can be used as default return values\n * in different parts of the rendering code. Because the same symbols are returned, this\n * allows for identity checks against these values to be consistently used by the framework\n * code.\n */\nconst EMPTY_OBJ = {};\nconst EMPTY_ARRAY = [];\n// freezing the values prevents any code from accidentally inserting new values in\nif ((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode()) {\n  // These property accesses can be ignored because ngDevMode will be set to false\n  // when optimizing code and the whole if statement will be dropped.\n  // tslint:disable-next-line:no-toplevel-property-access\n  Object.freeze(EMPTY_OBJ);\n  // tslint:disable-next-line:no-toplevel-property-access\n  Object.freeze(EMPTY_ARRAY);\n}\nconst NG_COMP_DEF = getClosureSafeProperty({\n  ɵcmp: getClosureSafeProperty\n});\nconst NG_DIR_DEF = getClosureSafeProperty({\n  ɵdir: getClosureSafeProperty\n});\nconst NG_PIPE_DEF = getClosureSafeProperty({\n  ɵpipe: getClosureSafeProperty\n});\nconst NG_MOD_DEF = getClosureSafeProperty({\n  ɵmod: getClosureSafeProperty\n});\nconst NG_FACTORY_DEF = getClosureSafeProperty({\n  ɵfac: getClosureSafeProperty\n});\n/**\n * If a directive is diPublic, bloomAdd sets a property on the type with this constant as\n * the key and the directive's unique ID as the value. This allows us to map directives to their\n * bloom filter bit for DI.\n */\n// TODO(misko): This is wrong. The NG_ELEMENT_ID should never be minified.\nconst NG_ELEMENT_ID = getClosureSafeProperty({\n  __NG_ELEMENT_ID__: getClosureSafeProperty\n});\n/**\n * The `NG_ENV_ID` field on a DI token indicates special processing in the `EnvironmentInjector`:\n * getting such tokens from the `EnvironmentInjector` will bypass the standard DI resolution\n * strategy and instead will return implementation produced by the `NG_ENV_ID` factory function.\n *\n * This particular retrieval of DI tokens is mostly done to eliminate circular dependencies and\n * improve tree-shaking.\n */\nconst NG_ENV_ID = getClosureSafeProperty({\n  __NG_ENV_ID__: getClosureSafeProperty\n});\n\n/**\n * Returns an index of `classToSearch` in `className` taking token boundaries into account.\n *\n * `classIndexOf('AB A', 'A', 0)` will be 3 (not 0 since `AB!==A`)\n *\n * @param className A string containing classes (whitespace separated)\n * @param classToSearch A class name to locate\n * @param startingIndex Starting location of search\n * @returns an index of the located class (or -1 if not found)\n */\nfunction classIndexOf(className, classToSearch, startingIndex) {\n  ngDevMode && assertNotEqual(classToSearch, '', 'can not look for \"\" string.');\n  let end = className.length;\n  while (true) {\n    const foundIndex = className.indexOf(classToSearch, startingIndex);\n    if (foundIndex === -1) return foundIndex;\n    if (foundIndex === 0 || className.charCodeAt(foundIndex - 1) <= 32 /* CharCode.SPACE */) {\n      // Ensure that it has leading whitespace\n      const length = classToSearch.length;\n      if (foundIndex + length === end || className.charCodeAt(foundIndex + length) <= 32 /* CharCode.SPACE */) {\n        // Ensure that it has trailing whitespace\n        return foundIndex;\n      }\n    }\n    // False positive, keep searching from where we left off.\n    startingIndex = foundIndex + 1;\n  }\n}\n\n/**\n * Assigns all attribute values to the provided element via the inferred renderer.\n *\n * This function accepts two forms of attribute entries:\n *\n * default: (key, value):\n *  attrs = [key1, value1, key2, value2]\n *\n * namespaced: (NAMESPACE_MARKER, uri, name, value)\n *  attrs = [NAMESPACE_MARKER, uri, name, value, NAMESPACE_MARKER, uri, name, value]\n *\n * The `attrs` array can contain a mix of both the default and namespaced entries.\n * The \"default\" values are set without a marker, but if the function comes across\n * a marker value then it will attempt to set a namespaced value. If the marker is\n * not of a namespaced value then the function will quit and return the index value\n * where it stopped during the iteration of the attrs array.\n *\n * See [AttributeMarker] to understand what the namespace marker value is.\n *\n * Note that this instruction does not support assigning style and class values to\n * an element. See `elementStart` and `elementHostAttrs` to learn how styling values\n * are applied to an element.\n * @param renderer The renderer to be used\n * @param native The element that the attributes will be assigned to\n * @param attrs The attribute array of values that will be assigned to the element\n * @returns the index value that was last accessed in the attributes array\n */\nfunction setUpAttributes(renderer, native, attrs) {\n  let i = 0;\n  while (i < attrs.length) {\n    const value = attrs[i];\n    if (typeof value === 'number') {\n      // only namespaces are supported. Other value types (such as style/class\n      // entries) are not supported in this function.\n      if (value !== 0 /* AttributeMarker.NamespaceURI */) {\n        break;\n      }\n      // we just landed on the marker value ... therefore\n      // we should skip to the next entry\n      i++;\n      const namespaceURI = attrs[i++];\n      const attrName = attrs[i++];\n      const attrVal = attrs[i++];\n      ngDevMode && ngDevMode.rendererSetAttribute++;\n      renderer.setAttribute(native, attrName, attrVal, namespaceURI);\n    } else {\n      // attrName is string;\n      const attrName = value;\n      const attrVal = attrs[++i];\n      // Standard attributes\n      ngDevMode && ngDevMode.rendererSetAttribute++;\n      if (isAnimationProp(attrName)) {\n        renderer.setProperty(native, attrName, attrVal);\n      } else {\n        renderer.setAttribute(native, attrName, attrVal);\n      }\n      i++;\n    }\n  }\n  // another piece of code may iterate over the same attributes array. Therefore\n  // it may be helpful to return the exact spot where the attributes array exited\n  // whether by running into an unsupported marker or if all the static values were\n  // iterated over.\n  return i;\n}\n/**\n * Test whether the given value is a marker that indicates that the following\n * attribute values in a `TAttributes` array are only the names of attributes,\n * and not name-value pairs.\n * @param marker The attribute marker to test.\n * @returns true if the marker is a \"name-only\" marker (e.g. `Bindings`, `Template` or `I18n`).\n */\nfunction isNameOnlyAttributeMarker(marker) {\n  return marker === 3 /* AttributeMarker.Bindings */ || marker === 4 /* AttributeMarker.Template */ || marker === 6 /* AttributeMarker.I18n */;\n}\n\nfunction isAnimationProp(name) {\n  // Perf note: accessing charCodeAt to check for the first character of a string is faster as\n  // compared to accessing a character at index 0 (ex. name[0]). The main reason for this is that\n  // charCodeAt doesn't allocate memory to return a substring.\n  return name.charCodeAt(0) === 64 /* CharCode.AT_SIGN */;\n}\n/**\n * Merges `src` `TAttributes` into `dst` `TAttributes` removing any duplicates in the process.\n *\n * This merge function keeps the order of attrs same.\n *\n * @param dst Location of where the merged `TAttributes` should end up.\n * @param src `TAttributes` which should be appended to `dst`\n */\nfunction mergeHostAttrs(dst, src) {\n  if (src === null || src.length === 0) {\n    // do nothing\n  } else if (dst === null || dst.length === 0) {\n    // We have source, but dst is empty, just make a copy.\n    dst = src.slice();\n  } else {\n    let srcMarker = -1 /* AttributeMarker.ImplicitAttributes */;\n    for (let i = 0; i < src.length; i++) {\n      const item = src[i];\n      if (typeof item === 'number') {\n        srcMarker = item;\n      } else {\n        if (srcMarker === 0 /* AttributeMarker.NamespaceURI */) {\n          // Case where we need to consume `key1`, `key2`, `value` items.\n        } else if (srcMarker === -1 /* AttributeMarker.ImplicitAttributes */ || srcMarker === 2 /* AttributeMarker.Styles */) {\n          // Case where we have to consume `key1` and `value` only.\n          mergeHostAttribute(dst, srcMarker, item, null, src[++i]);\n        } else {\n          // Case where we have to consume `key1` only.\n          mergeHostAttribute(dst, srcMarker, item, null, null);\n        }\n      }\n    }\n  }\n  return dst;\n}\n/**\n * Append `key`/`value` to existing `TAttributes` taking region marker and duplicates into account.\n *\n * @param dst `TAttributes` to append to.\n * @param marker Region where the `key`/`value` should be added.\n * @param key1 Key to add to `TAttributes`\n * @param key2 Key to add to `TAttributes` (in case of `AttributeMarker.NamespaceURI`)\n * @param value Value to add or to overwrite to `TAttributes` Only used if `marker` is not Class.\n */\nfunction mergeHostAttribute(dst, marker, key1, key2, value) {\n  let i = 0;\n  // Assume that new markers will be inserted at the end.\n  let markerInsertPosition = dst.length;\n  // scan until correct type.\n  if (marker === -1 /* AttributeMarker.ImplicitAttributes */) {\n    markerInsertPosition = -1;\n  } else {\n    while (i < dst.length) {\n      const dstValue = dst[i++];\n      if (typeof dstValue === 'number') {\n        if (dstValue === marker) {\n          markerInsertPosition = -1;\n          break;\n        } else if (dstValue > marker) {\n          // We need to save this as we want the markers to be inserted in specific order.\n          markerInsertPosition = i - 1;\n          break;\n        }\n      }\n    }\n  }\n  // search until you find place of insertion\n  while (i < dst.length) {\n    const item = dst[i];\n    if (typeof item === 'number') {\n      // since `i` started as the index after the marker, we did not find it if we are at the next\n      // marker\n      break;\n    } else if (item === key1) {\n      // We already have same token\n      if (key2 === null) {\n        if (value !== null) {\n          dst[i + 1] = value;\n        }\n        return;\n      } else if (key2 === dst[i + 1]) {\n        dst[i + 2] = value;\n        return;\n      }\n    }\n    // Increment counter.\n    i++;\n    if (key2 !== null) i++;\n    if (value !== null) i++;\n  }\n  // insert at location.\n  if (markerInsertPosition !== -1) {\n    dst.splice(markerInsertPosition, 0, marker);\n    i = markerInsertPosition + 1;\n  }\n  dst.splice(i++, 0, key1);\n  if (key2 !== null) {\n    dst.splice(i++, 0, key2);\n  }\n  if (value !== null) {\n    dst.splice(i++, 0, value);\n  }\n}\nconst NG_TEMPLATE_SELECTOR = 'ng-template';\n/**\n * Search the `TAttributes` to see if it contains `cssClassToMatch` (case insensitive)\n *\n * @param attrs `TAttributes` to search through.\n * @param cssClassToMatch class to match (lowercase)\n * @param isProjectionMode Whether or not class matching should look into the attribute `class` in\n *    addition to the `AttributeMarker.Classes`.\n */\nfunction isCssClassMatching(attrs, cssClassToMatch, isProjectionMode) {\n  // TODO(misko): The fact that this function needs to know about `isProjectionMode` seems suspect.\n  // It is strange to me that sometimes the class information comes in form of `class` attribute\n  // and sometimes in form of `AttributeMarker.Classes`. Some investigation is needed to determine\n  // if that is the right behavior.\n  ngDevMode && assertEqual(cssClassToMatch, cssClassToMatch.toLowerCase(), 'Class name expected to be lowercase.');\n  let i = 0;\n  // Indicates whether we are processing value from the implicit\n  // attribute section (i.e. before the first marker in the array).\n  let isImplicitAttrsSection = true;\n  while (i < attrs.length) {\n    let item = attrs[i++];\n    if (typeof item === 'string' && isImplicitAttrsSection) {\n      const value = attrs[i++];\n      if (isProjectionMode && item === 'class') {\n        // We found a `class` attribute in the implicit attribute section,\n        // check if it matches the value of the `cssClassToMatch` argument.\n        if (classIndexOf(value.toLowerCase(), cssClassToMatch, 0) !== -1) {\n          return true;\n        }\n      }\n    } else if (item === 1 /* AttributeMarker.Classes */) {\n      // We found the classes section. Start searching for the class.\n      while (i < attrs.length && typeof (item = attrs[i++]) == 'string') {\n        // while we have strings\n        if (item.toLowerCase() === cssClassToMatch) return true;\n      }\n      return false;\n    } else if (typeof item === 'number') {\n      // We've came across a first marker, which indicates\n      // that the implicit attribute section is over.\n      isImplicitAttrsSection = false;\n    }\n  }\n  return false;\n}\n/**\n * Checks whether the `tNode` represents an inline template (e.g. `*ngFor`).\n *\n * @param tNode current TNode\n */\nfunction isInlineTemplate(tNode) {\n  return tNode.type === 4 /* TNodeType.Container */ && tNode.value !== NG_TEMPLATE_SELECTOR;\n}\n/**\n * Function that checks whether a given tNode matches tag-based selector and has a valid type.\n *\n * Matching can be performed in 2 modes: projection mode (when we project nodes) and regular\n * directive matching mode:\n * - in the \"directive matching\" mode we do _not_ take TContainer's tagName into account if it is\n * different from NG_TEMPLATE_SELECTOR (value different from NG_TEMPLATE_SELECTOR indicates that a\n * tag name was extracted from * syntax so we would match the same directive twice);\n * - in the \"projection\" mode, we use a tag name potentially extracted from the * syntax processing\n * (applicable to TNodeType.Container only).\n */\nfunction hasTagAndTypeMatch(tNode, currentSelector, isProjectionMode) {\n  const tagNameToCompare = tNode.type === 4 /* TNodeType.Container */ && !isProjectionMode ? NG_TEMPLATE_SELECTOR : tNode.value;\n  return currentSelector === tagNameToCompare;\n}\n/**\n * A utility function to match an Ivy node static data against a simple CSS selector\n *\n * @param node static data of the node to match\n * @param selector The selector to try matching against the node.\n * @param isProjectionMode if `true` we are matching for content projection, otherwise we are doing\n * directive matching.\n * @returns true if node matches the selector.\n */\nfunction isNodeMatchingSelector(tNode, selector, isProjectionMode) {\n  ngDevMode && assertDefined(selector[0], 'Selector should have a tag name');\n  let mode = 4 /* SelectorFlags.ELEMENT */;\n  const nodeAttrs = tNode.attrs || [];\n  // Find the index of first attribute that has no value, only a name.\n  const nameOnlyMarkerIdx = getNameOnlyMarkerIndex(nodeAttrs);\n  // When processing \":not\" selectors, we skip to the next \":not\" if the\n  // current one doesn't match\n  let skipToNextSelector = false;\n  for (let i = 0; i < selector.length; i++) {\n    const current = selector[i];\n    if (typeof current === 'number') {\n      // If we finish processing a :not selector and it hasn't failed, return false\n      if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) {\n        return false;\n      }\n      // If we are skipping to the next :not() and this mode flag is positive,\n      // it's a part of the current :not() selector, and we should keep skipping\n      if (skipToNextSelector && isPositive(current)) continue;\n      skipToNextSelector = false;\n      mode = current | mode & 1 /* SelectorFlags.NOT */;\n      continue;\n    }\n    if (skipToNextSelector) continue;\n    if (mode & 4 /* SelectorFlags.ELEMENT */) {\n      mode = 2 /* SelectorFlags.ATTRIBUTE */ | mode & 1 /* SelectorFlags.NOT */;\n      if (current !== '' && !hasTagAndTypeMatch(tNode, current, isProjectionMode) || current === '' && selector.length === 1) {\n        if (isPositive(mode)) return false;\n        skipToNextSelector = true;\n      }\n    } else {\n      const selectorAttrValue = mode & 8 /* SelectorFlags.CLASS */ ? current : selector[++i];\n      // special case for matching against classes when a tNode has been instantiated with\n      // class and style values as separate attribute values (e.g. ['title', CLASS, 'foo'])\n      if (mode & 8 /* SelectorFlags.CLASS */ && tNode.attrs !== null) {\n        if (!isCssClassMatching(tNode.attrs, selectorAttrValue, isProjectionMode)) {\n          if (isPositive(mode)) return false;\n          skipToNextSelector = true;\n        }\n        continue;\n      }\n      const attrName = mode & 8 /* SelectorFlags.CLASS */ ? 'class' : current;\n      const attrIndexInNode = findAttrIndexInNode(attrName, nodeAttrs, isInlineTemplate(tNode), isProjectionMode);\n      if (attrIndexInNode === -1) {\n        if (isPositive(mode)) return false;\n        skipToNextSelector = true;\n        continue;\n      }\n      if (selectorAttrValue !== '') {\n        let nodeAttrValue;\n        if (attrIndexInNode > nameOnlyMarkerIdx) {\n          nodeAttrValue = '';\n        } else {\n          ngDevMode && assertNotEqual(nodeAttrs[attrIndexInNode], 0 /* AttributeMarker.NamespaceURI */, 'We do not match directives on namespaced attributes');\n          // we lowercase the attribute value to be able to match\n          // selectors without case-sensitivity\n          // (selectors are already in lowercase when generated)\n          nodeAttrValue = nodeAttrs[attrIndexInNode + 1].toLowerCase();\n        }\n        const compareAgainstClassName = mode & 8 /* SelectorFlags.CLASS */ ? nodeAttrValue : null;\n        if (compareAgainstClassName && classIndexOf(compareAgainstClassName, selectorAttrValue, 0) !== -1 || mode & 2 /* SelectorFlags.ATTRIBUTE */ && selectorAttrValue !== nodeAttrValue) {\n          if (isPositive(mode)) return false;\n          skipToNextSelector = true;\n        }\n      }\n    }\n  }\n  return isPositive(mode) || skipToNextSelector;\n}\nfunction isPositive(mode) {\n  return (mode & 1 /* SelectorFlags.NOT */) === 0;\n}\n/**\n * Examines the attribute's definition array for a node to find the index of the\n * attribute that matches the given `name`.\n *\n * NOTE: This will not match namespaced attributes.\n *\n * Attribute matching depends upon `isInlineTemplate` and `isProjectionMode`.\n * The following table summarizes which types of attributes we attempt to match:\n *\n * ===========================================================================================================\n * Modes                   | Normal Attributes | Bindings Attributes | Template Attributes | I18n\n * Attributes\n * ===========================================================================================================\n * Inline + Projection     | YES               | YES                 | NO                  | YES\n * -----------------------------------------------------------------------------------------------------------\n * Inline + Directive      | NO                | NO                  | YES                 | NO\n * -----------------------------------------------------------------------------------------------------------\n * Non-inline + Projection | YES               | YES                 | NO                  | YES\n * -----------------------------------------------------------------------------------------------------------\n * Non-inline + Directive  | YES               | YES                 | NO                  | YES\n * ===========================================================================================================\n *\n * @param name the name of the attribute to find\n * @param attrs the attribute array to examine\n * @param isInlineTemplate true if the node being matched is an inline template (e.g. `*ngFor`)\n * rather than a manually expanded template node (e.g `<ng-template>`).\n * @param isProjectionMode true if we are matching against content projection otherwise we are\n * matching against directives.\n */\nfunction findAttrIndexInNode(name, attrs, isInlineTemplate, isProjectionMode) {\n  if (attrs === null) return -1;\n  let i = 0;\n  if (isProjectionMode || !isInlineTemplate) {\n    let bindingsMode = false;\n    while (i < attrs.length) {\n      const maybeAttrName = attrs[i];\n      if (maybeAttrName === name) {\n        return i;\n      } else if (maybeAttrName === 3 /* AttributeMarker.Bindings */ || maybeAttrName === 6 /* AttributeMarker.I18n */) {\n        bindingsMode = true;\n      } else if (maybeAttrName === 1 /* AttributeMarker.Classes */ || maybeAttrName === 2 /* AttributeMarker.Styles */) {\n        let value = attrs[++i];\n        // We should skip classes here because we have a separate mechanism for\n        // matching classes in projection mode.\n        while (typeof value === 'string') {\n          value = attrs[++i];\n        }\n        continue;\n      } else if (maybeAttrName === 4 /* AttributeMarker.Template */) {\n        // We do not care about Template attributes in this scenario.\n        break;\n      } else if (maybeAttrName === 0 /* AttributeMarker.NamespaceURI */) {\n        // Skip the whole namespaced attribute and value. This is by design.\n        i += 4;\n        continue;\n      }\n      // In binding mode there are only names, rather than name-value pairs.\n      i += bindingsMode ? 1 : 2;\n    }\n    // We did not match the attribute\n    return -1;\n  } else {\n    return matchTemplateAttribute(attrs, name);\n  }\n}\nfunction isNodeMatchingSelectorList(tNode, selector, isProjectionMode = false) {\n  for (let i = 0; i < selector.length; i++) {\n    if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction getProjectAsAttrValue(tNode) {\n  const nodeAttrs = tNode.attrs;\n  if (nodeAttrs != null) {\n    const ngProjectAsAttrIdx = nodeAttrs.indexOf(5 /* AttributeMarker.ProjectAs */);\n    // only check for ngProjectAs in attribute names, don't accidentally match attribute's value\n    // (attribute names are stored at even indexes)\n    if ((ngProjectAsAttrIdx & 1) === 0) {\n      return nodeAttrs[ngProjectAsAttrIdx + 1];\n    }\n  }\n  return null;\n}\nfunction getNameOnlyMarkerIndex(nodeAttrs) {\n  for (let i = 0; i < nodeAttrs.length; i++) {\n    const nodeAttr = nodeAttrs[i];\n    if (isNameOnlyAttributeMarker(nodeAttr)) {\n      return i;\n    }\n  }\n  return nodeAttrs.length;\n}\nfunction matchTemplateAttribute(attrs, name) {\n  let i = attrs.indexOf(4 /* AttributeMarker.Template */);\n  if (i > -1) {\n    i++;\n    while (i < attrs.length) {\n      const attr = attrs[i];\n      // Return in case we checked all template attrs and are switching to the next section in the\n      // attrs array (that starts with a number that represents an attribute marker).\n      if (typeof attr === 'number') return -1;\n      if (attr === name) return i;\n      i++;\n    }\n  }\n  return -1;\n}\n/**\n * Checks whether a selector is inside a CssSelectorList\n * @param selector Selector to be checked.\n * @param list List in which to look for the selector.\n */\nfunction isSelectorInSelectorList(selector, list) {\n  selectorListLoop: for (let i = 0; i < list.length; i++) {\n    const currentSelectorInList = list[i];\n    if (selector.length !== currentSelectorInList.length) {\n      continue;\n    }\n    for (let j = 0; j < selector.length; j++) {\n      if (selector[j] !== currentSelectorInList[j]) {\n        continue selectorListLoop;\n      }\n    }\n    return true;\n  }\n  return false;\n}\nfunction maybeWrapInNotSelector(isNegativeMode, chunk) {\n  return isNegativeMode ? ':not(' + chunk.trim() + ')' : chunk;\n}\nfunction stringifyCSSSelector(selector) {\n  let result = selector[0];\n  let i = 1;\n  let mode = 2 /* SelectorFlags.ATTRIBUTE */;\n  let currentChunk = '';\n  let isNegativeMode = false;\n  while (i < selector.length) {\n    let valueOrMarker = selector[i];\n    if (typeof valueOrMarker === 'string') {\n      if (mode & 2 /* SelectorFlags.ATTRIBUTE */) {\n        const attrValue = selector[++i];\n        currentChunk += '[' + valueOrMarker + (attrValue.length > 0 ? '=\"' + attrValue + '\"' : '') + ']';\n      } else if (mode & 8 /* SelectorFlags.CLASS */) {\n        currentChunk += '.' + valueOrMarker;\n      } else if (mode & 4 /* SelectorFlags.ELEMENT */) {\n        currentChunk += ' ' + valueOrMarker;\n      }\n    } else {\n      //\n      // Append current chunk to the final result in case we come across SelectorFlag, which\n      // indicates that the previous section of a selector is over. We need to accumulate content\n      // between flags to make sure we wrap the chunk later in :not() selector if needed, e.g.\n      // ```\n      //  ['', Flags.CLASS, '.classA', Flags.CLASS | Flags.NOT, '.classB', '.classC']\n      // ```\n      // should be transformed to `.classA :not(.classB .classC)`.\n      //\n      // Note: for negative selector part, we accumulate content between flags until we find the\n      // next negative flag. This is needed to support a case where `:not()` rule contains more than\n      // one chunk, e.g. the following selector:\n      // ```\n      //  ['', Flags.ELEMENT | Flags.NOT, 'p', Flags.CLASS, 'foo', Flags.CLASS | Flags.NOT, 'bar']\n      // ```\n      // should be stringified to `:not(p.foo) :not(.bar)`\n      //\n      if (currentChunk !== '' && !isPositive(valueOrMarker)) {\n        result += maybeWrapInNotSelector(isNegativeMode, currentChunk);\n        currentChunk = '';\n      }\n      mode = valueOrMarker;\n      // According to CssSelector spec, once we come across `SelectorFlags.NOT` flag, the negative\n      // mode is maintained for remaining chunks of a selector.\n      isNegativeMode = isNegativeMode || !isPositive(mode);\n    }\n    i++;\n  }\n  if (currentChunk !== '') {\n    result += maybeWrapInNotSelector(isNegativeMode, currentChunk);\n  }\n  return result;\n}\n/**\n * Generates string representation of CSS selector in parsed form.\n *\n * ComponentDef and DirectiveDef are generated with the selector in parsed form to avoid doing\n * additional parsing at runtime (for example, for directive matching). However in some cases (for\n * example, while bootstrapping a component), a string version of the selector is required to query\n * for the host element on the page. This function takes the parsed form of a selector and returns\n * its string representation.\n *\n * @param selectorList selector in parsed form\n * @returns string representation of a given selector\n */\nfunction stringifyCSSSelectorList(selectorList) {\n  return selectorList.map(stringifyCSSSelector).join(',');\n}\n/**\n * Extracts attributes and classes information from a given CSS selector.\n *\n * This function is used while creating a component dynamically. In this case, the host element\n * (that is created dynamically) should contain attributes and classes specified in component's CSS\n * selector.\n *\n * @param selector CSS selector in parsed form (in a form of array)\n * @returns object with `attrs` and `classes` fields that contain extracted information\n */\nfunction extractAttrsAndClassesFromSelector(selector) {\n  const attrs = [];\n  const classes = [];\n  let i = 1;\n  let mode = 2 /* SelectorFlags.ATTRIBUTE */;\n  while (i < selector.length) {\n    let valueOrMarker = selector[i];\n    if (typeof valueOrMarker === 'string') {\n      if (mode === 2 /* SelectorFlags.ATTRIBUTE */) {\n        if (valueOrMarker !== '') {\n          attrs.push(valueOrMarker, selector[++i]);\n        }\n      } else if (mode === 8 /* SelectorFlags.CLASS */) {\n        classes.push(valueOrMarker);\n      }\n    } else {\n      // According to CssSelector spec, once we come across `SelectorFlags.NOT` flag, the negative\n      // mode is maintained for remaining chunks of a selector. Since attributes and classes are\n      // extracted only for \"positive\" part of the selector, we can stop here.\n      if (!isPositive(mode)) break;\n      mode = valueOrMarker;\n    }\n    i++;\n  }\n  return {\n    attrs,\n    classes\n  };\n}\n\n/**\n * Create a component definition object.\n *\n *\n * # Example\n * ```\n * class MyComponent {\n *   // Generated by Angular Template Compiler\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\n *   static ɵcmp = defineComponent({\n *     ...\n *   });\n * }\n * ```\n * @codeGenApi\n */\nfunction ɵɵdefineComponent(componentDefinition) {\n  return noSideEffects(() => {\n    // Initialize ngDevMode. This must be the first statement in ɵɵdefineComponent.\n    // See the `initNgDevMode` docstring for more information.\n    (typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode();\n    const baseDef = getNgDirectiveDef(componentDefinition);\n    const def = {\n      ...baseDef,\n      decls: componentDefinition.decls,\n      vars: componentDefinition.vars,\n      template: componentDefinition.template,\n      consts: componentDefinition.consts || null,\n      ngContentSelectors: componentDefinition.ngContentSelectors,\n      onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,\n      directiveDefs: null,\n      pipeDefs: null,\n      dependencies: baseDef.standalone && componentDefinition.dependencies || null,\n      getStandaloneInjector: null,\n      signals: componentDefinition.signals ?? false,\n      data: componentDefinition.data || {},\n      encapsulation: componentDefinition.encapsulation || ViewEncapsulation.Emulated,\n      styles: componentDefinition.styles || EMPTY_ARRAY,\n      _: null,\n      schemas: componentDefinition.schemas || null,\n      tView: null,\n      id: ''\n    };\n    initFeatures(def);\n    const dependencies = componentDefinition.dependencies;\n    def.directiveDefs = extractDefListOrFactory(dependencies, /* pipeDef */false);\n    def.pipeDefs = extractDefListOrFactory(dependencies, /* pipeDef */true);\n    def.id = getComponentId(def);\n    return def;\n  });\n}\n/**\n * Generated next to NgModules to monkey-patch directive and pipe references onto a component's\n * definition, when generating a direct reference in the component file would otherwise create an\n * import cycle.\n *\n * See [this explanation](https://hackmd.io/Odw80D0pR6yfsOjg_7XCJg?view) for more details.\n *\n * @codeGenApi\n */\nfunction ɵɵsetComponentScope(type, directives, pipes) {\n  const def = type.ɵcmp;\n  def.directiveDefs = extractDefListOrFactory(directives, /* pipeDef */false);\n  def.pipeDefs = extractDefListOrFactory(pipes, /* pipeDef */true);\n}\nfunction extractDirectiveDef(type) {\n  return getComponentDef$1(type) || getDirectiveDef(type);\n}\nfunction nonNull(value) {\n  return value !== null;\n}\n/**\n * @codeGenApi\n */\nfunction ɵɵdefineNgModule(def) {\n  return noSideEffects(() => {\n    const res = {\n      type: def.type,\n      bootstrap: def.bootstrap || EMPTY_ARRAY,\n      declarations: def.declarations || EMPTY_ARRAY,\n      imports: def.imports || EMPTY_ARRAY,\n      exports: def.exports || EMPTY_ARRAY,\n      transitiveCompileScopes: null,\n      schemas: def.schemas || null,\n      id: def.id || null\n    };\n    return res;\n  });\n}\n/**\n * Adds the module metadata that is necessary to compute the module's transitive scope to an\n * existing module definition.\n *\n * Scope metadata of modules is not used in production builds, so calls to this function can be\n * marked pure to tree-shake it from the bundle, allowing for all referenced declarations\n * to become eligible for tree-shaking as well.\n *\n * @codeGenApi\n */\nfunction ɵɵsetNgModuleScope(type, scope) {\n  return noSideEffects(() => {\n    const ngModuleDef = getNgModuleDef(type, true);\n    ngModuleDef.declarations = scope.declarations || EMPTY_ARRAY;\n    ngModuleDef.imports = scope.imports || EMPTY_ARRAY;\n    ngModuleDef.exports = scope.exports || EMPTY_ARRAY;\n  });\n}\n/**\n * Inverts an inputs or outputs lookup such that the keys, which were the\n * minified keys, are part of the values, and the values are parsed so that\n * the publicName of the property is the new key\n *\n * e.g. for\n *\n * ```\n * class Comp {\n *   @Input()\n *   propName1: string;\n *\n *   @Input('publicName2')\n *   declaredPropName2: number;\n * }\n * ```\n *\n * will be serialized as\n *\n * ```\n * {\n *   propName1: 'propName1',\n *   declaredPropName2: ['publicName2', 'declaredPropName2'],\n * }\n * ```\n *\n * which is than translated by the minifier as:\n *\n * ```\n * {\n *   minifiedPropName1: 'propName1',\n *   minifiedPropName2: ['publicName2', 'declaredPropName2'],\n * }\n * ```\n *\n * becomes: (public name => minifiedName)\n *\n * ```\n * {\n *  'propName1': 'minifiedPropName1',\n *  'publicName2': 'minifiedPropName2',\n * }\n * ```\n *\n * Optionally the function can take `secondary` which will result in: (public name => declared name)\n *\n * ```\n * {\n *  'propName1': 'propName1',\n *  'publicName2': 'declaredPropName2',\n * }\n * ```\n *\n\n */\nfunction invertObject(obj, secondary) {\n  if (obj == null) return EMPTY_OBJ;\n  const newLookup = {};\n  for (const minifiedKey in obj) {\n    if (obj.hasOwnProperty(minifiedKey)) {\n      let publicName = obj[minifiedKey];\n      let declaredName = publicName;\n      if (Array.isArray(publicName)) {\n        declaredName = publicName[1];\n        publicName = publicName[0];\n      }\n      newLookup[publicName] = minifiedKey;\n      if (secondary) {\n        secondary[publicName] = declaredName;\n      }\n    }\n  }\n  return newLookup;\n}\n/**\n * Create a directive definition object.\n *\n * # Example\n * ```ts\n * class MyDirective {\n *   // Generated by Angular Template Compiler\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\n *   static ɵdir = ɵɵdefineDirective({\n *     ...\n *   });\n * }\n * ```\n *\n * @codeGenApi\n */\nfunction ɵɵdefineDirective(directiveDefinition) {\n  return noSideEffects(() => {\n    const def = getNgDirectiveDef(directiveDefinition);\n    initFeatures(def);\n    return def;\n  });\n}\n/**\n * Create a pipe definition object.\n *\n * # Example\n * ```\n * class MyPipe implements PipeTransform {\n *   // Generated by Angular Template Compiler\n *   static ɵpipe = definePipe({\n *     ...\n *   });\n * }\n * ```\n * @param pipeDef Pipe definition generated by the compiler\n *\n * @codeGenApi\n */\nfunction ɵɵdefinePipe(pipeDef) {\n  return {\n    type: pipeDef.type,\n    name: pipeDef.name,\n    factory: null,\n    pure: pipeDef.pure !== false,\n    standalone: pipeDef.standalone === true,\n    onDestroy: pipeDef.type.prototype.ngOnDestroy || null\n  };\n}\n/**\n * The following getter methods retrieve the definition from the type. Currently the retrieval\n * honors inheritance, but in the future we may change the rule to require that definitions are\n * explicit. This would require some sort of migration strategy.\n */\nfunction getComponentDef$1(type) {\n  return type[NG_COMP_DEF] || null;\n}\nfunction getDirectiveDef(type) {\n  return type[NG_DIR_DEF] || null;\n}\nfunction getPipeDef$1(type) {\n  return type[NG_PIPE_DEF] || null;\n}\n/**\n * Checks whether a given Component, Directive or Pipe is marked as standalone.\n * This will return false if passed anything other than a Component, Directive, or Pipe class\n * See [this guide](/guide/standalone-components) for additional information:\n *\n * @param type A reference to a Component, Directive or Pipe.\n * @publicApi\n */\nfunction isStandalone(type) {\n  const def = getComponentDef$1(type) || getDirectiveDef(type) || getPipeDef$1(type);\n  return def !== null ? def.standalone : false;\n}\nfunction getNgModuleDef(type, throwNotFound) {\n  const ngModuleDef = type[NG_MOD_DEF] || null;\n  if (!ngModuleDef && throwNotFound === true) {\n    throw new Error(`Type ${stringify(type)} does not have 'ɵmod' property.`);\n  }\n  return ngModuleDef;\n}\nfunction getNgDirectiveDef(directiveDefinition) {\n  const declaredInputs = {};\n  return {\n    type: directiveDefinition.type,\n    providersResolver: null,\n    factory: null,\n    hostBindings: directiveDefinition.hostBindings || null,\n    hostVars: directiveDefinition.hostVars || 0,\n    hostAttrs: directiveDefinition.hostAttrs || null,\n    contentQueries: directiveDefinition.contentQueries || null,\n    declaredInputs,\n    inputTransforms: null,\n    inputConfig: directiveDefinition.inputs || EMPTY_OBJ,\n    exportAs: directiveDefinition.exportAs || null,\n    standalone: directiveDefinition.standalone === true,\n    signals: directiveDefinition.signals === true,\n    selectors: directiveDefinition.selectors || EMPTY_ARRAY,\n    viewQuery: directiveDefinition.viewQuery || null,\n    features: directiveDefinition.features || null,\n    setInput: null,\n    findHostDirectiveDefs: null,\n    hostDirectives: null,\n    inputs: invertObject(directiveDefinition.inputs, declaredInputs),\n    outputs: invertObject(directiveDefinition.outputs)\n  };\n}\nfunction initFeatures(definition) {\n  definition.features?.forEach(fn => fn(definition));\n}\nfunction extractDefListOrFactory(dependencies, pipeDef) {\n  if (!dependencies) {\n    return null;\n  }\n  const defExtractor = pipeDef ? getPipeDef$1 : extractDirectiveDef;\n  return () => (typeof dependencies === 'function' ? dependencies() : dependencies).map(dep => defExtractor(dep)).filter(nonNull);\n}\n/**\n * A map that contains the generated component IDs and type.\n */\nconst GENERATED_COMP_IDS = new Map();\n/**\n * A method can returns a component ID from the component definition using a variant of DJB2 hash\n * algorithm.\n */\nfunction getComponentId(componentDef) {\n  let hash = 0;\n  // We cannot rely solely on the component selector as the same selector can be used in different\n  // modules.\n  //\n  // `componentDef.style` is not used, due to it causing inconsistencies. Ex: when server\n  // component styles has no sourcemaps and browsers do.\n  //\n  // Example:\n  // https://github.com/angular/components/blob/d9f82c8f95309e77a6d82fd574c65871e91354c2/src/material/core/option/option.ts#L248\n  // https://github.com/angular/components/blob/285f46dc2b4c5b127d356cb7c4714b221f03ce50/src/material/legacy-core/option/option.ts#L32\n  const hashSelectors = [componentDef.selectors, componentDef.ngContentSelectors, componentDef.hostVars, componentDef.hostAttrs, componentDef.consts, componentDef.vars, componentDef.decls, componentDef.encapsulation, componentDef.standalone, componentDef.signals, componentDef.exportAs, JSON.stringify(componentDef.inputs), JSON.stringify(componentDef.outputs),\n  // We cannot use 'componentDef.type.name' as the name of the symbol will change and will not\n  // match in the server and browser bundles.\n  Object.getOwnPropertyNames(componentDef.type.prototype), !!componentDef.contentQueries, !!componentDef.viewQuery].join('|');\n  for (const char of hashSelectors) {\n    hash = Math.imul(31, hash) + char.charCodeAt(0) << 0;\n  }\n  // Force positive number hash.\n  // 2147483647 = equivalent of Integer.MAX_VALUE.\n  hash += 2147483647 + 1;\n  const compId = 'c' + hash;\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (GENERATED_COMP_IDS.has(compId)) {\n      const previousCompDefType = GENERATED_COMP_IDS.get(compId);\n      if (previousCompDefType !== componentDef.type) {\n        console.warn(formatRuntimeError(-912 /* RuntimeErrorCode.COMPONENT_ID_COLLISION */, `Component ID generation collision detected. Components '${previousCompDefType.name}' and '${componentDef.type.name}' with selector '${stringifyCSSSelectorList(componentDef.selectors)}' generated the same component ID. To fix this, you can change the selector of one of those components or add an extra host attribute to force a different ID.`));\n      }\n    } else {\n      GENERATED_COMP_IDS.set(compId, componentDef.type);\n    }\n  }\n  return compId;\n}\n\n// Below are constants for LView indices to help us look up LView members\n// without having to remember the specific indices.\n// Uglify will inline these when minifying so there shouldn't be a cost.\nconst HOST = 0;\nconst TVIEW = 1;\nconst FLAGS = 2;\nconst PARENT = 3;\nconst NEXT = 4;\nconst DESCENDANT_VIEWS_TO_REFRESH = 5;\nconst T_HOST = 6;\nconst CLEANUP = 7;\nconst CONTEXT = 8;\nconst INJECTOR$1 = 9;\nconst ENVIRONMENT = 10;\nconst RENDERER = 11;\nconst CHILD_HEAD = 12;\nconst CHILD_TAIL = 13;\n// FIXME(misko): Investigate if the three declarations aren't all same thing.\nconst DECLARATION_VIEW = 14;\nconst DECLARATION_COMPONENT_VIEW = 15;\nconst DECLARATION_LCONTAINER = 16;\nconst PREORDER_HOOK_FLAGS = 17;\nconst QUERIES = 18;\nconst ID = 19;\nconst EMBEDDED_VIEW_INJECTOR = 20;\nconst ON_DESTROY_HOOKS = 21;\nconst HYDRATION = 22;\nconst REACTIVE_TEMPLATE_CONSUMER = 23;\nconst REACTIVE_HOST_BINDING_CONSUMER = 24;\n/**\n * Size of LView's header. Necessary to adjust for it when setting slots.\n *\n * IMPORTANT: `HEADER_OFFSET` should only be referred to the in the `ɵɵ*` instructions to translate\n * instruction index into `LView` index. All other indexes should be in the `LView` index space and\n * there should be no need to refer to `HEADER_OFFSET` anywhere else.\n */\nconst HEADER_OFFSET = 25;\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd$4 = 1;\n\n/**\n * Special location which allows easy identification of type. If we have an array which was\n * retrieved from the `LView` and that array has `true` at `TYPE` location, we know it is\n * `LContainer`.\n */\nconst TYPE = 1;\n/**\n * Below are constants for LContainer indices to help us look up LContainer members\n * without having to remember the specific indices.\n * Uglify will inline these when minifying so there shouldn't be a cost.\n */\n/**\n * Flag to signify that this `LContainer` may have transplanted views which need to be change\n * detected. (see: `LView[DECLARATION_COMPONENT_VIEW])`.\n *\n * This flag, once set, is never unset for the `LContainer`. This means that when unset we can skip\n * a lot of work in `refreshEmbeddedViews`. But when set we still need to verify\n * that the `MOVED_VIEWS` are transplanted and on-push.\n */\nconst HAS_TRANSPLANTED_VIEWS = 2;\n// PARENT, NEXT, DESCENDANT_VIEWS_TO_REFRESH are indices 3, 4, and 5\n// As we already have these constants in LView, we don't need to re-create them.\n// T_HOST is index 6\n// We already have this constants in LView, we don't need to re-create it.\nconst NATIVE = 7;\nconst VIEW_REFS = 8;\nconst MOVED_VIEWS = 9;\nconst DEHYDRATED_VIEWS = 10;\n/**\n * Size of LContainer's header. Represents the index after which all views in the\n * container will be inserted. We need to keep a record of current views so we know\n * which views are already in the DOM (and don't need to be re-added) and so we can\n * remove views from the DOM when they are no longer required.\n */\nconst CONTAINER_HEADER_OFFSET = 11;\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd$3 = 1;\n\n/**\n * True if `value` is `LView`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nfunction isLView(value) {\n  return Array.isArray(value) && typeof value[TYPE] === 'object';\n}\n/**\n * True if `value` is `LContainer`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nfunction isLContainer(value) {\n  return Array.isArray(value) && value[TYPE] === true;\n}\nfunction isContentQueryHost(tNode) {\n  return (tNode.flags & 4 /* TNodeFlags.hasContentQuery */) !== 0;\n}\nfunction isComponentHost(tNode) {\n  return tNode.componentOffset > -1;\n}\nfunction isDirectiveHost(tNode) {\n  return (tNode.flags & 1 /* TNodeFlags.isDirectiveHost */) === 1 /* TNodeFlags.isDirectiveHost */;\n}\n\nfunction isComponentDef(def) {\n  return !!def.template;\n}\nfunction isRootView(target) {\n  return (target[FLAGS] & 512 /* LViewFlags.IsRoot */) !== 0;\n}\nfunction isProjectionTNode(tNode) {\n  return (tNode.type & 16 /* TNodeType.Projection */) === 16 /* TNodeType.Projection */;\n}\n\nfunction hasI18n(lView) {\n  return (lView[FLAGS] & 32 /* LViewFlags.HasI18n */) === 32 /* LViewFlags.HasI18n */;\n}\n\n// [Assert functions do not constraint type when they are guarded by a truthy\n// expression.](https://github.com/microsoft/TypeScript/issues/37295)\nfunction assertTNodeForLView(tNode, lView) {\n  assertTNodeForTView(tNode, lView[TVIEW]);\n}\nfunction assertTNodeForTView(tNode, tView) {\n  assertTNode(tNode);\n  const tData = tView.data;\n  for (let i = HEADER_OFFSET; i < tData.length; i++) {\n    if (tData[i] === tNode) {\n      return;\n    }\n  }\n  throwError('This TNode does not belong to this TView.');\n}\nfunction assertTNode(tNode) {\n  assertDefined(tNode, 'TNode must be defined');\n  if (!(tNode && typeof tNode === 'object' && tNode.hasOwnProperty('directiveStylingLast'))) {\n    throwError('Not of type TNode, got: ' + tNode);\n  }\n}\nfunction assertTIcu(tIcu) {\n  assertDefined(tIcu, 'Expected TIcu to be defined');\n  if (!(typeof tIcu.currentCaseLViewIndex === 'number')) {\n    throwError('Object is not of TIcu type.');\n  }\n}\nfunction assertComponentType(actual, msg = 'Type passed in is not ComponentType, it does not have \\'ɵcmp\\' property.') {\n  if (!getComponentDef$1(actual)) {\n    throwError(msg);\n  }\n}\nfunction assertNgModuleType(actual, msg = 'Type passed in is not NgModuleType, it does not have \\'ɵmod\\' property.') {\n  if (!getNgModuleDef(actual)) {\n    throwError(msg);\n  }\n}\nfunction assertCurrentTNodeIsParent(isParent) {\n  assertEqual(isParent, true, 'currentTNode should be a parent');\n}\nfunction assertHasParent(tNode) {\n  assertDefined(tNode, 'currentTNode should exist!');\n  assertDefined(tNode.parent, 'currentTNode should have a parent');\n}\nfunction assertLContainer(value) {\n  assertDefined(value, 'LContainer must be defined');\n  assertEqual(isLContainer(value), true, 'Expecting LContainer');\n}\nfunction assertLViewOrUndefined(value) {\n  value && assertEqual(isLView(value), true, 'Expecting LView or undefined or null');\n}\nfunction assertLView(value) {\n  assertDefined(value, 'LView must be defined');\n  assertEqual(isLView(value), true, 'Expecting LView');\n}\nfunction assertFirstCreatePass(tView, errMessage) {\n  assertEqual(tView.firstCreatePass, true, errMessage || 'Should only be called in first create pass.');\n}\nfunction assertFirstUpdatePass(tView, errMessage) {\n  assertEqual(tView.firstUpdatePass, true, errMessage || 'Should only be called in first update pass.');\n}\n/**\n * This is a basic sanity check that an object is probably a directive def. DirectiveDef is\n * an interface, so we can't do a direct instanceof check.\n */\nfunction assertDirectiveDef(obj) {\n  if (obj.type === undefined || obj.selectors == undefined || obj.inputs === undefined) {\n    throwError(`Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);\n  }\n}\nfunction assertIndexInDeclRange(lView, index) {\n  const tView = lView[1];\n  assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);\n}\nfunction assertIndexInExpandoRange(lView, index) {\n  const tView = lView[1];\n  assertBetween(tView.expandoStartIndex, lView.length, index);\n}\nfunction assertBetween(lower, upper, index) {\n  if (!(lower <= index && index < upper)) {\n    throwError(`Index out of range (expecting ${lower} <= ${index} < ${upper})`);\n  }\n}\nfunction assertProjectionSlots(lView, errMessage) {\n  assertDefined(lView[DECLARATION_COMPONENT_VIEW], 'Component views should exist.');\n  assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection, errMessage || 'Components with projection nodes (<ng-content>) must have projection slots defined.');\n}\nfunction assertParentView(lView, errMessage) {\n  assertDefined(lView, errMessage || 'Component views should always have a parent view (component\\'s host view)');\n}\n/**\n * This is a basic sanity check that the `injectorIndex` seems to point to what looks like a\n * NodeInjector data structure.\n *\n * @param lView `LView` which should be checked.\n * @param injectorIndex index into the `LView` where the `NodeInjector` is expected.\n */\nfunction assertNodeInjector(lView, injectorIndex) {\n  assertIndexInExpandoRange(lView, injectorIndex);\n  assertIndexInExpandoRange(lView, injectorIndex + 8 /* NodeInjectorOffset.PARENT */);\n  assertNumber(lView[injectorIndex + 0], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 1], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 2], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 3], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 4], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 5], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 6], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 7], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 8 /* NodeInjectorOffset.PARENT */], 'injectorIndex should point to parent injector');\n}\nfunction getFactoryDef(type, throwNotFound) {\n  const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);\n  if (!hasFactoryDef && throwNotFound === true && ngDevMode) {\n    throw new Error(`Type ${stringify(type)} does not have 'ɵfac' property.`);\n  }\n  return hasFactoryDef ? type[NG_FACTORY_DEF] : null;\n}\n\n/**\n * Symbol used to tell `Signal`s apart from other functions.\n *\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\n */\nconst SIGNAL = /* @__PURE__ */Symbol('SIGNAL');\n/**\n * Checks if the given `value` is a reactive `Signal`.\n *\n * @developerPreview\n */\nfunction isSignal(value) {\n  return typeof value === 'function' && value[SIGNAL] !== undefined;\n}\n/**\n * The default equality function used for `signal` and `computed`, which treats objects and arrays\n * as never equal, and all other primitive values using identity semantics.\n *\n * This allows signals to hold non-primitive values (arrays, objects, other collections) and still\n * propagate change notification upon explicit mutation without identity change.\n *\n * @developerPreview\n */\nfunction defaultEquals(a, b) {\n  // `Object.is` compares two values using identity semantics which is desired behavior for\n  // primitive values. If `Object.is` determines two values to be equal we need to make sure that\n  // those don't represent objects (we want to make sure that 2 objects are always considered\n  // \"unequal\"). The null check is needed for the special case of JavaScript reporting null values\n  // as objects (`typeof null === 'object'`).\n  return (a === null || typeof a !== 'object') && Object.is(a, b);\n}\n\n// Required as the signals library is in a separate package, so we need to explicitly ensure the\n/**\n * The currently active consumer `ReactiveNode`, if running code in a reactive context.\n *\n * Change this via `setActiveConsumer`.\n */\nlet activeConsumer = null;\nlet inNotificationPhase = false;\nfunction setActiveConsumer(consumer) {\n  const prev = activeConsumer;\n  activeConsumer = consumer;\n  return prev;\n}\nconst REACTIVE_NODE = {\n  version: 0,\n  dirty: false,\n  producerNode: undefined,\n  producerLastReadVersion: undefined,\n  producerIndexOfThis: undefined,\n  nextProducerIndex: 0,\n  liveConsumerNode: undefined,\n  liveConsumerIndexOfThis: undefined,\n  consumerAllowSignalWrites: false,\n  consumerIsAlwaysLive: false,\n  producerMustRecompute: () => false,\n  producerRecomputeValue: () => {},\n  consumerMarkedDirty: () => {}\n};\n/**\n * Called by implementations when a producer's signal is read.\n */\nfunction producerAccessed(node) {\n  if (inNotificationPhase) {\n    throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? `Assertion error: signal read during notification phase` : '');\n  }\n  if (activeConsumer === null) {\n    // Accessed outside of a reactive context, so nothing to record.\n    return;\n  }\n  // This producer is the `idx`th dependency of `activeConsumer`.\n  const idx = activeConsumer.nextProducerIndex++;\n  assertConsumerNode(activeConsumer);\n  if (idx < activeConsumer.producerNode.length && activeConsumer.producerNode[idx] !== node) {\n    // There's been a change in producers since the last execution of `activeConsumer`.\n    // `activeConsumer.producerNode[idx]` holds a stale dependency which will be be removed and\n    // replaced with `this`.\n    //\n    // If `activeConsumer` isn't live, then this is a no-op, since we can replace the producer in\n    // `activeConsumer.producerNode` directly. However, if `activeConsumer` is live, then we need\n    // to remove it from the stale producer's `liveConsumer`s.\n    if (consumerIsLive(activeConsumer)) {\n      const staleProducer = activeConsumer.producerNode[idx];\n      producerRemoveLiveConsumerAtIndex(staleProducer, activeConsumer.producerIndexOfThis[idx]);\n      // At this point, the only record of `staleProducer` is the reference at\n      // `activeConsumer.producerNode[idx]` which will be overwritten below.\n    }\n  }\n\n  if (activeConsumer.producerNode[idx] !== node) {\n    // We're a new dependency of the consumer (at `idx`).\n    activeConsumer.producerNode[idx] = node;\n    // If the active consumer is live, then add it as a live consumer. If not, then use 0 as a\n    // placeholder value.\n    activeConsumer.producerIndexOfThis[idx] = consumerIsLive(activeConsumer) ? producerAddLiveConsumer(node, activeConsumer, idx) : 0;\n  }\n  activeConsumer.producerLastReadVersion[idx] = node.version;\n}\n/**\n * Ensure this producer's `version` is up-to-date.\n */\nfunction producerUpdateValueVersion(node) {\n  if (consumerIsLive(node) && !node.dirty) {\n    // A live consumer will be marked dirty by producers, so a clean state means that its version\n    // is guaranteed to be up-to-date.\n    return;\n  }\n  if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\n    // None of our producers report a change since the last time they were read, so no\n    // recomputation of our value is necessary, and we can consider ourselves clean.\n    node.dirty = false;\n    return;\n  }\n  node.producerRecomputeValue(node);\n  // After recomputing the value, we're no longer dirty.\n  node.dirty = false;\n}\n/**\n * Propagate a dirty notification to live consumers of this producer.\n */\nfunction producerNotifyConsumers(node) {\n  if (node.liveConsumerNode === undefined) {\n    return;\n  }\n  // Prevent signal reads when we're updating the graph\n  const prev = inNotificationPhase;\n  inNotificationPhase = true;\n  try {\n    for (const consumer of node.liveConsumerNode) {\n      if (!consumer.dirty) {\n        consumerMarkDirty(consumer);\n      }\n    }\n  } finally {\n    inNotificationPhase = prev;\n  }\n}\n/**\n * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\n * based on the current consumer context.\n */\nfunction producerUpdatesAllowed() {\n  return activeConsumer?.consumerAllowSignalWrites !== false;\n}\nfunction consumerMarkDirty(node) {\n  node.dirty = true;\n  producerNotifyConsumers(node);\n  node.consumerMarkedDirty?.(node);\n}\n/**\n * Prepare this consumer to run a computation in its reactive context.\n *\n * Must be called by subclasses which represent reactive computations, before those computations\n * begin.\n */\nfunction consumerBeforeComputation(node) {\n  node && (node.nextProducerIndex = 0);\n  return setActiveConsumer(node);\n}\n/**\n * Finalize this consumer's state after a reactive computation has run.\n *\n * Must be called by subclasses which represent reactive computations, after those computations\n * have finished.\n */\nfunction consumerAfterComputation(node, prevConsumer) {\n  setActiveConsumer(prevConsumer);\n  if (!node || node.producerNode === undefined || node.producerIndexOfThis === undefined || node.producerLastReadVersion === undefined) {\n    return;\n  }\n  if (consumerIsLive(node)) {\n    // For live consumers, we need to remove the producer -> consumer edge for any stale producers\n    // which weren't dependencies after the recomputation.\n    for (let i = node.nextProducerIndex; i < node.producerNode.length; i++) {\n      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n    }\n  }\n  // Truncate the producer tracking arrays.\n  // Perf note: this is essentially truncating the length to `node.nextProducerIndex`, but\n  // benchmarking has shown that individual pop operations are faster.\n  while (node.producerNode.length > node.nextProducerIndex) {\n    node.producerNode.pop();\n    node.producerLastReadVersion.pop();\n    node.producerIndexOfThis.pop();\n  }\n}\n/**\n * Determine whether this consumer has any dependencies which have changed since the last time\n * they were read.\n */\nfunction consumerPollProducersForChange(node) {\n  assertConsumerNode(node);\n  // Poll producers for change.\n  for (let i = 0; i < node.producerNode.length; i++) {\n    const producer = node.producerNode[i];\n    const seenVersion = node.producerLastReadVersion[i];\n    // First check the versions. A mismatch means that the producer's value is known to have\n    // changed since the last time we read it.\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n    // The producer's version is the same as the last time we read it, but it might itself be\n    // stale. Force the producer to recompute its version (calculating a new value if necessary).\n    producerUpdateValueVersion(producer);\n    // Now when we do this check, `producer.version` is guaranteed to be up to date, so if the\n    // versions still match then it has not changed since the last time we read it.\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n  }\n  return false;\n}\n/**\n * Disconnect this consumer from the graph.\n */\nfunction consumerDestroy(node) {\n  assertConsumerNode(node);\n  if (consumerIsLive(node)) {\n    // Drop all connections from the graph to this node.\n    for (let i = 0; i < node.producerNode.length; i++) {\n      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n    }\n  }\n  // Truncate all the arrays to drop all connection from this node to the graph.\n  node.producerNode.length = node.producerLastReadVersion.length = node.producerIndexOfThis.length = 0;\n  if (node.liveConsumerNode) {\n    node.liveConsumerNode.length = node.liveConsumerIndexOfThis.length = 0;\n  }\n}\n/**\n * Add `consumer` as a live consumer of this node.\n *\n * Note that this operation is potentially transitive. If this node becomes live, then it becomes\n * a live consumer of all of its current producers.\n */\nfunction producerAddLiveConsumer(node, consumer, indexOfThis) {\n  assertProducerNode(node);\n  assertConsumerNode(node);\n  if (node.liveConsumerNode.length === 0) {\n    // When going from 0 to 1 live consumers, we become a live consumer to our producers.\n    for (let i = 0; i < node.producerNode.length; i++) {\n      node.producerIndexOfThis[i] = producerAddLiveConsumer(node.producerNode[i], node, i);\n    }\n  }\n  node.liveConsumerIndexOfThis.push(indexOfThis);\n  return node.liveConsumerNode.push(consumer) - 1;\n}\n/**\n * Remove the live consumer at `idx`.\n */\nfunction producerRemoveLiveConsumerAtIndex(node, idx) {\n  assertProducerNode(node);\n  assertConsumerNode(node);\n  if (typeof ngDevMode !== 'undefined' && ngDevMode && idx >= node.liveConsumerNode.length) {\n    throw new Error(`Assertion error: active consumer index ${idx} is out of bounds of ${node.liveConsumerNode.length} consumers)`);\n  }\n  if (node.liveConsumerNode.length === 1) {\n    // When removing the last live consumer, we will no longer be live. We need to remove\n    // ourselves from our producers' tracking (which may cause consumer-producers to lose\n    // liveness as well).\n    for (let i = 0; i < node.producerNode.length; i++) {\n      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n    }\n  }\n  // Move the last value of `liveConsumers` into `idx`. Note that if there's only a single\n  // live consumer, this is a no-op.\n  const lastIdx = node.liveConsumerNode.length - 1;\n  node.liveConsumerNode[idx] = node.liveConsumerNode[lastIdx];\n  node.liveConsumerIndexOfThis[idx] = node.liveConsumerIndexOfThis[lastIdx];\n  // Truncate the array.\n  node.liveConsumerNode.length--;\n  node.liveConsumerIndexOfThis.length--;\n  // If the index is still valid, then we need to fix the index pointer from the producer to this\n  // consumer, and update it from `lastIdx` to `idx` (accounting for the move above).\n  if (idx < node.liveConsumerNode.length) {\n    const idxProducer = node.liveConsumerIndexOfThis[idx];\n    const consumer = node.liveConsumerNode[idx];\n    assertConsumerNode(consumer);\n    consumer.producerIndexOfThis[idxProducer] = idx;\n  }\n}\nfunction consumerIsLive(node) {\n  return node.consumerIsAlwaysLive || (node?.liveConsumerNode?.length ?? 0) > 0;\n}\nfunction assertConsumerNode(node) {\n  node.producerNode ??= [];\n  node.producerIndexOfThis ??= [];\n  node.producerLastReadVersion ??= [];\n}\nfunction assertProducerNode(node) {\n  node.liveConsumerNode ??= [];\n  node.liveConsumerIndexOfThis ??= [];\n}\n\n/**\n * Create a computed `Signal` which derives a reactive value from an expression.\n *\n * @developerPreview\n */\nfunction computed(computation, options) {\n  const node = Object.create(COMPUTED_NODE);\n  node.computation = computation;\n  options?.equal && (node.equal = options.equal);\n  const computed = () => {\n    // Check if the value needs updating before returning it.\n    producerUpdateValueVersion(node);\n    // Record that someone looked at this signal.\n    producerAccessed(node);\n    if (node.value === ERRORED) {\n      throw node.error;\n    }\n    return node.value;\n  };\n  computed[SIGNAL] = node;\n  return computed;\n}\n/**\n * A dedicated symbol used before a computed value has been calculated for the first time.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst UNSET = /* @__PURE__ */Symbol('UNSET');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * is in progress. Used to detect cycles in computation chains.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst COMPUTING = /* @__PURE__ */Symbol('COMPUTING');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * failed. The thrown error is cached until the computation gets dirty again.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst ERRORED = /* @__PURE__ */Symbol('ERRORED');\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst COMPUTED_NODE = /* @__PURE__ */(() => {\n  return {\n    ...REACTIVE_NODE,\n    value: UNSET,\n    dirty: true,\n    error: null,\n    equal: defaultEquals,\n    producerMustRecompute(node) {\n      // Force a recomputation if there's no current value, or if the current value is in the\n      // process of being calculated (which should throw an error).\n      return node.value === UNSET || node.value === COMPUTING;\n    },\n    producerRecomputeValue(node) {\n      if (node.value === COMPUTING) {\n        // Our computation somehow led to a cyclic read of itself.\n        throw new Error('Detected cycle in computations.');\n      }\n      const oldValue = node.value;\n      node.value = COMPUTING;\n      const prevConsumer = consumerBeforeComputation(node);\n      let newValue;\n      try {\n        newValue = node.computation();\n      } catch (err) {\n        newValue = ERRORED;\n        node.error = err;\n      } finally {\n        consumerAfterComputation(node, prevConsumer);\n      }\n      if (oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED && node.equal(oldValue, newValue)) {\n        // No change to `valueVersion` - old and new values are\n        // semantically equivalent.\n        node.value = oldValue;\n        return;\n      }\n      node.value = newValue;\n      node.version++;\n    }\n  };\n})();\nfunction defaultThrowError() {\n  throw new Error();\n}\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\nfunction throwInvalidWriteToSignalError() {\n  throwInvalidWriteToSignalErrorFn();\n}\nfunction setThrowInvalidWriteToSignalError(fn) {\n  throwInvalidWriteToSignalErrorFn = fn;\n}\n\n/**\n * If set, called after `WritableSignal`s are updated.\n *\n * This hook can be used to achieve various effects, such as running effects synchronously as part\n * of setting a signal.\n */\nlet postSignalSetFn = null;\n/**\n * Create a `Signal` that can be set or updated directly.\n *\n * @developerPreview\n */\nfunction signal(initialValue, options) {\n  const node = Object.create(SIGNAL_NODE);\n  node.value = initialValue;\n  options?.equal && (node.equal = options.equal);\n  function signalFn() {\n    producerAccessed(node);\n    return node.value;\n  }\n  signalFn.set = signalSetFn;\n  signalFn.update = signalUpdateFn;\n  signalFn.mutate = signalMutateFn;\n  signalFn.asReadonly = signalAsReadonlyFn;\n  signalFn[SIGNAL] = node;\n  return signalFn;\n}\nfunction setPostSignalSetFn(fn) {\n  const prev = postSignalSetFn;\n  postSignalSetFn = fn;\n  return prev;\n}\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst SIGNAL_NODE = /* @__PURE__ */(() => {\n  return {\n    ...REACTIVE_NODE,\n    equal: defaultEquals,\n    readonlyFn: undefined\n  };\n})();\nfunction signalValueChanged(node) {\n  node.version++;\n  producerNotifyConsumers(node);\n  postSignalSetFn?.();\n}\nfunction signalSetFn(newValue) {\n  const node = this[SIGNAL];\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError();\n  }\n  if (!node.equal(node.value, newValue)) {\n    node.value = newValue;\n    signalValueChanged(node);\n  }\n}\nfunction signalUpdateFn(updater) {\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError();\n  }\n  signalSetFn.call(this, updater(this[SIGNAL].value));\n}\nfunction signalMutateFn(mutator) {\n  const node = this[SIGNAL];\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError();\n  }\n  // Mutate bypasses equality checks as it's by definition changing the value.\n  mutator(node.value);\n  signalValueChanged(node);\n}\nfunction signalAsReadonlyFn() {\n  const node = this[SIGNAL];\n  if (node.readonlyFn === undefined) {\n    const readonlyFn = () => this();\n    readonlyFn[SIGNAL] = node;\n    node.readonlyFn = readonlyFn;\n  }\n  return node.readonlyFn;\n}\n\n/**\n * Execute an arbitrary function in a non-reactive (non-tracking) context. The executed function\n * can, optionally, return a value.\n *\n * @developerPreview\n */\nfunction untracked(nonReactiveReadsFn) {\n  const prevConsumer = setActiveConsumer(null);\n  // We are not trying to catch any particular errors here, just making sure that the consumers\n  // stack is restored in case of errors.\n  try {\n    return nonReactiveReadsFn();\n  } finally {\n    setActiveConsumer(prevConsumer);\n  }\n}\nfunction watch(fn, schedule, allowSignalWrites) {\n  const node = Object.create(WATCH_NODE);\n  if (allowSignalWrites) {\n    node.consumerAllowSignalWrites = true;\n  }\n  node.fn = fn;\n  node.schedule = schedule;\n  const registerOnCleanup = cleanupFn => {\n    node.cleanupFn = cleanupFn;\n  };\n  const run = () => {\n    node.dirty = false;\n    if (node.hasRun && !consumerPollProducersForChange(node)) {\n      return;\n    }\n    node.hasRun = true;\n    const prevConsumer = consumerBeforeComputation(node);\n    try {\n      node.cleanupFn();\n      node.cleanupFn = NOOP_CLEANUP_FN;\n      node.fn(registerOnCleanup);\n    } finally {\n      consumerAfterComputation(node, prevConsumer);\n    }\n  };\n  node.ref = {\n    notify: () => consumerMarkDirty(node),\n    run,\n    cleanup: () => node.cleanupFn()\n  };\n  return node.ref;\n}\nconst NOOP_CLEANUP_FN = () => {};\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst WATCH_NODE = /* @__PURE__ */(() => {\n  return {\n    ...REACTIVE_NODE,\n    consumerIsAlwaysLive: true,\n    consumerAllowSignalWrites: false,\n    consumerMarkedDirty: node => {\n      node.schedule(node.ref);\n    },\n    hasRun: false,\n    cleanupFn: NOOP_CLEANUP_FN\n  };\n})();\nfunction setAlternateWeakRefImpl(impl) {\n  // TODO: remove this function\n}\n\n/**\n * Represents a basic change from a previous to a new value for a single\n * property on a directive instance. Passed as a value in a\n * {@link SimpleChanges} object to the `ngOnChanges` hook.\n *\n * @see {@link OnChanges}\n *\n * @publicApi\n */\nclass SimpleChange {\n  constructor(previousValue, currentValue, firstChange) {\n    this.previousValue = previousValue;\n    this.currentValue = currentValue;\n    this.firstChange = firstChange;\n  }\n  /**\n   * Check whether the new value is the first value assigned.\n   */\n  isFirstChange() {\n    return this.firstChange;\n  }\n}\n\n/**\n * The NgOnChangesFeature decorates a component with support for the ngOnChanges\n * lifecycle hook, so it should be included in any component that implements\n * that hook.\n *\n * If the component or directive uses inheritance, the NgOnChangesFeature MUST\n * be included as a feature AFTER {@link InheritDefinitionFeature}, otherwise\n * inherited properties will not be propagated to the ngOnChanges lifecycle\n * hook.\n *\n * Example usage:\n *\n * ```\n * static ɵcmp = defineComponent({\n *   ...\n *   inputs: {name: 'publicName'},\n *   features: [NgOnChangesFeature]\n * });\n * ```\n *\n * @codeGenApi\n */\nfunction ɵɵNgOnChangesFeature() {\n  return NgOnChangesFeatureImpl;\n}\nfunction NgOnChangesFeatureImpl(definition) {\n  if (definition.type.prototype.ngOnChanges) {\n    definition.setInput = ngOnChangesSetInput;\n  }\n  return rememberChangeHistoryAndInvokeOnChangesHook;\n}\n// This option ensures that the ngOnChanges lifecycle hook will be inherited\n// from superclasses (in InheritDefinitionFeature).\n/** @nocollapse */\n// tslint:disable-next-line:no-toplevel-property-access\nɵɵNgOnChangesFeature.ngInherit = true;\n/**\n * This is a synthetic lifecycle hook which gets inserted into `TView.preOrderHooks` to simulate\n * `ngOnChanges`.\n *\n * The hook reads the `NgSimpleChangesStore` data from the component instance and if changes are\n * found it invokes `ngOnChanges` on the component instance.\n *\n * @param this Component instance. Because this function gets inserted into `TView.preOrderHooks`,\n *     it is guaranteed to be called with component instance.\n */\nfunction rememberChangeHistoryAndInvokeOnChangesHook() {\n  const simpleChangesStore = getSimpleChangesStore(this);\n  const current = simpleChangesStore?.current;\n  if (current) {\n    const previous = simpleChangesStore.previous;\n    if (previous === EMPTY_OBJ) {\n      simpleChangesStore.previous = current;\n    } else {\n      // New changes are copied to the previous store, so that we don't lose history for inputs\n      // which were not changed this time\n      for (let key in current) {\n        previous[key] = current[key];\n      }\n    }\n    simpleChangesStore.current = null;\n    this.ngOnChanges(current);\n  }\n}\nfunction ngOnChangesSetInput(instance, value, publicName, privateName) {\n  const declaredName = this.declaredInputs[publicName];\n  ngDevMode && assertString(declaredName, 'Name of input in ngOnChanges has to be a string');\n  const simpleChangesStore = getSimpleChangesStore(instance) || setSimpleChangesStore(instance, {\n    previous: EMPTY_OBJ,\n    current: null\n  });\n  const current = simpleChangesStore.current || (simpleChangesStore.current = {});\n  const previous = simpleChangesStore.previous;\n  const previousChange = previous[declaredName];\n  current[declaredName] = new SimpleChange(previousChange && previousChange.currentValue, value, previous === EMPTY_OBJ);\n  instance[privateName] = value;\n}\nconst SIMPLE_CHANGES_STORE = '__ngSimpleChanges__';\nfunction getSimpleChangesStore(instance) {\n  return instance[SIMPLE_CHANGES_STORE] || null;\n}\nfunction setSimpleChangesStore(instance, store) {\n  return instance[SIMPLE_CHANGES_STORE] = store;\n}\nlet profilerCallback = null;\n/**\n * Sets the callback function which will be invoked before and after performing certain actions at\n * runtime (for example, before and after running change detection).\n *\n * Warning: this function is *INTERNAL* and should not be relied upon in application's code.\n * The contract of the function might be changed in any release and/or the function can be removed\n * completely.\n *\n * @param profiler function provided by the caller or null value to disable profiling.\n */\nconst setProfiler = profiler => {\n  profilerCallback = profiler;\n};\n/**\n * Profiler function which wraps user code executed by the runtime.\n *\n * @param event ProfilerEvent corresponding to the execution context\n * @param instance component instance\n * @param hookOrListener lifecycle hook function or output listener. The value depends on the\n *  execution context\n * @returns\n */\nconst profiler = function (event, instance, hookOrListener) {\n  if (profilerCallback != null /* both `null` and `undefined` */) {\n    profilerCallback(event, instance, hookOrListener);\n  }\n};\nconst SVG_NAMESPACE = 'svg';\nconst MATH_ML_NAMESPACE = 'math';\n\n/**\n * For efficiency reasons we often put several different data types (`RNode`, `LView`, `LContainer`)\n * in same location in `LView`. This is because we don't want to pre-allocate space for it\n * because the storage is sparse. This file contains utilities for dealing with such data types.\n *\n * How do we know what is stored at a given location in `LView`.\n * - `Array.isArray(value) === false` => `RNode` (The normal storage value)\n * - `Array.isArray(value) === true` => then the `value[0]` represents the wrapped value.\n *   - `typeof value[TYPE] === 'object'` => `LView`\n *      - This happens when we have a component at a given location\n *   - `typeof value[TYPE] === true` => `LContainer`\n *      - This happens when we have `LContainer` binding at a given location.\n *\n *\n * NOTE: it is assumed that `Array.isArray` and `typeof` operations are very efficient.\n */\n/**\n * Returns `RNode`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nfunction unwrapRNode(value) {\n  while (Array.isArray(value)) {\n    value = value[HOST];\n  }\n  return value;\n}\n/**\n * Returns `LView` or `null` if not found.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nfunction unwrapLView(value) {\n  while (Array.isArray(value)) {\n    // This check is same as `isLView()` but we don't call at as we don't want to call\n    // `Array.isArray()` twice and give JITer more work for inlining.\n    if (typeof value[TYPE] === 'object') return value;\n    value = value[HOST];\n  }\n  return null;\n}\n/**\n * Retrieves an element value from the provided `viewData`, by unwrapping\n * from any containers, component views, or style contexts.\n */\nfunction getNativeByIndex(index, lView) {\n  ngDevMode && assertIndexInRange(lView, index);\n  ngDevMode && assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Expected to be past HEADER_OFFSET');\n  return unwrapRNode(lView[index]);\n}\n/**\n * Retrieve an `RNode` for a given `TNode` and `LView`.\n *\n * This function guarantees in dev mode to retrieve a non-null `RNode`.\n *\n * @param tNode\n * @param lView\n */\nfunction getNativeByTNode(tNode, lView) {\n  ngDevMode && assertTNodeForLView(tNode, lView);\n  ngDevMode && assertIndexInRange(lView, tNode.index);\n  const node = unwrapRNode(lView[tNode.index]);\n  return node;\n}\n/**\n * Retrieve an `RNode` or `null` for a given `TNode` and `LView`.\n *\n * Some `TNode`s don't have associated `RNode`s. For example `Projection`\n *\n * @param tNode\n * @param lView\n */\nfunction getNativeByTNodeOrNull(tNode, lView) {\n  const index = tNode === null ? -1 : tNode.index;\n  if (index !== -1) {\n    ngDevMode && assertTNodeForLView(tNode, lView);\n    const node = unwrapRNode(lView[index]);\n    return node;\n  }\n  return null;\n}\n// fixme(misko): The return Type should be `TNode|null`\nfunction getTNode(tView, index) {\n  ngDevMode && assertGreaterThan(index, -1, 'wrong index for TNode');\n  ngDevMode && assertLessThan(index, tView.data.length, 'wrong index for TNode');\n  const tNode = tView.data[index];\n  ngDevMode && tNode !== null && assertTNode(tNode);\n  return tNode;\n}\n/** Retrieves a value from any `LView` or `TData`. */\nfunction load(view, index) {\n  ngDevMode && assertIndexInRange(view, index);\n  return view[index];\n}\nfunction getComponentLViewByIndex(nodeIndex, hostView) {\n  // Could be an LView or an LContainer. If LContainer, unwrap to find LView.\n  ngDevMode && assertIndexInRange(hostView, nodeIndex);\n  const slotValue = hostView[nodeIndex];\n  const lView = isLView(slotValue) ? slotValue : slotValue[HOST];\n  return lView;\n}\n/** Checks whether a given view is in creation mode */\nfunction isCreationMode(view) {\n  return (view[FLAGS] & 4 /* LViewFlags.CreationMode */) === 4 /* LViewFlags.CreationMode */;\n}\n/**\n * Returns a boolean for whether the view is attached to the change detection tree.\n *\n * Note: This determines whether a view should be checked, not whether it's inserted\n * into a container. For that, you'll want `viewAttachedToContainer` below.\n */\nfunction viewAttachedToChangeDetector(view) {\n  return (view[FLAGS] & 128 /* LViewFlags.Attached */) === 128 /* LViewFlags.Attached */;\n}\n/** Returns a boolean for whether the view is attached to a container. */\nfunction viewAttachedToContainer(view) {\n  return isLContainer(view[PARENT]);\n}\nfunction getConstant(consts, index) {\n  if (index === null || index === undefined) return null;\n  ngDevMode && assertIndexInRange(consts, index);\n  return consts[index];\n}\n/**\n * Resets the pre-order hook flags of the view.\n * @param lView the LView on which the flags are reset\n */\nfunction resetPreOrderHookFlags(lView) {\n  lView[PREORDER_HOOK_FLAGS] = 0;\n}\n/**\n * Adds the `RefreshView` flag from the lView and updates DESCENDANT_VIEWS_TO_REFRESH counters of\n * parents.\n */\nfunction markViewForRefresh(lView) {\n  if ((lView[FLAGS] & 1024 /* LViewFlags.RefreshView */) === 0) {\n    lView[FLAGS] |= 1024 /* LViewFlags.RefreshView */;\n    updateViewsToRefresh(lView, 1);\n  }\n}\n/**\n * Removes the `RefreshView` flag from the lView and updates DESCENDANT_VIEWS_TO_REFRESH counters of\n * parents.\n */\nfunction clearViewRefreshFlag(lView) {\n  if (lView[FLAGS] & 1024 /* LViewFlags.RefreshView */) {\n    lView[FLAGS] &= ~1024 /* LViewFlags.RefreshView */;\n    updateViewsToRefresh(lView, -1);\n  }\n}\n/**\n * Updates the `DESCENDANT_VIEWS_TO_REFRESH` counter on the parents of the `LView` as well as the\n * parents above that whose\n *  1. counter goes from 0 to 1, indicating that there is a new child that has a view to refresh\n *  or\n *  2. counter goes from 1 to 0, indicating there are no more descendant views to refresh\n */\nfunction updateViewsToRefresh(lView, amount) {\n  let parent = lView[PARENT];\n  if (parent === null) {\n    return;\n  }\n  parent[DESCENDANT_VIEWS_TO_REFRESH] += amount;\n  let viewOrContainer = parent;\n  parent = parent[PARENT];\n  while (parent !== null && (amount === 1 && viewOrContainer[DESCENDANT_VIEWS_TO_REFRESH] === 1 || amount === -1 && viewOrContainer[DESCENDANT_VIEWS_TO_REFRESH] === 0)) {\n    parent[DESCENDANT_VIEWS_TO_REFRESH] += amount;\n    viewOrContainer = parent;\n    parent = parent[PARENT];\n  }\n}\n/**\n * Stores a LView-specific destroy callback.\n */\nfunction storeLViewOnDestroy(lView, onDestroyCallback) {\n  if ((lView[FLAGS] & 256 /* LViewFlags.Destroyed */) === 256 /* LViewFlags.Destroyed */) {\n    throw new RuntimeError(911 /* RuntimeErrorCode.VIEW_ALREADY_DESTROYED */, ngDevMode && 'View has already been destroyed.');\n  }\n  if (lView[ON_DESTROY_HOOKS] === null) {\n    lView[ON_DESTROY_HOOKS] = [];\n  }\n  lView[ON_DESTROY_HOOKS].push(onDestroyCallback);\n}\n/**\n * Removes previously registered LView-specific destroy callback.\n */\nfunction removeLViewOnDestroy(lView, onDestroyCallback) {\n  if (lView[ON_DESTROY_HOOKS] === null) return;\n  const destroyCBIdx = lView[ON_DESTROY_HOOKS].indexOf(onDestroyCallback);\n  if (destroyCBIdx !== -1) {\n    lView[ON_DESTROY_HOOKS].splice(destroyCBIdx, 1);\n  }\n}\nconst instructionState = {\n  lFrame: createLFrame(null),\n  bindingsEnabled: true,\n  skipHydrationRootTNode: null\n};\n/**\n * In this mode, any changes in bindings will throw an ExpressionChangedAfterChecked error.\n *\n * Necessary to support ChangeDetectorRef.checkNoChanges().\n *\n * The `checkNoChanges` function is invoked only in ngDevMode=true and verifies that no unintended\n * changes exist in the change detector or its children.\n */\nlet _isInCheckNoChangesMode = false;\n/**\n * Returns true if the instruction state stack is empty.\n *\n * Intended to be called from tests only (tree shaken otherwise).\n */\nfunction specOnlyIsInstructionStateEmpty() {\n  return instructionState.lFrame.parent === null;\n}\nfunction getElementDepthCount() {\n  return instructionState.lFrame.elementDepthCount;\n}\nfunction increaseElementDepthCount() {\n  instructionState.lFrame.elementDepthCount++;\n}\nfunction decreaseElementDepthCount() {\n  instructionState.lFrame.elementDepthCount--;\n}\nfunction getBindingsEnabled() {\n  return instructionState.bindingsEnabled;\n}\n/**\n * Returns true if currently inside a skip hydration block.\n * @returns boolean\n */\nfunction isInSkipHydrationBlock$1() {\n  return instructionState.skipHydrationRootTNode !== null;\n}\n/**\n * Returns true if this is the root TNode of the skip hydration block.\n * @param tNode the current TNode\n * @returns boolean\n */\nfunction isSkipHydrationRootTNode(tNode) {\n  return instructionState.skipHydrationRootTNode === tNode;\n}\n/**\n * Enables directive matching on elements.\n *\n *  * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- ɵɵdisableBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- ɵɵenableBindings() -->\n * </div>\n * ```\n *\n * @codeGenApi\n */\nfunction ɵɵenableBindings() {\n  instructionState.bindingsEnabled = true;\n}\n/**\n * Sets a flag to specify that the TNode is in a skip hydration block.\n * @param tNode the current TNode\n */\nfunction enterSkipHydrationBlock(tNode) {\n  instructionState.skipHydrationRootTNode = tNode;\n}\n/**\n * Disables directive matching on element.\n *\n *  * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- ɵɵdisableBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- ɵɵenableBindings() -->\n * </div>\n * ```\n *\n * @codeGenApi\n */\nfunction ɵɵdisableBindings() {\n  instructionState.bindingsEnabled = false;\n}\n/**\n * Clears the root skip hydration node when leaving a skip hydration block.\n */\nfunction leaveSkipHydrationBlock() {\n  instructionState.skipHydrationRootTNode = null;\n}\n/**\n * Return the current `LView`.\n */\nfunction getLView() {\n  return instructionState.lFrame.lView;\n}\n/**\n * Return the current `TView`.\n */\nfunction getTView() {\n  return instructionState.lFrame.tView;\n}\n/**\n * Restores `contextViewData` to the given OpaqueViewState instance.\n *\n * Used in conjunction with the getCurrentView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n *\n * @param viewToRestore The OpaqueViewState instance to restore.\n * @returns Context of the restored OpaqueViewState instance.\n *\n * @codeGenApi\n */\nfunction ɵɵrestoreView(viewToRestore) {\n  instructionState.lFrame.contextLView = viewToRestore;\n  return viewToRestore[CONTEXT];\n}\n/**\n * Clears the view set in `ɵɵrestoreView` from memory. Returns the passed in\n * value so that it can be used as a return value of an instruction.\n *\n * @codeGenApi\n */\nfunction ɵɵresetView(value) {\n  instructionState.lFrame.contextLView = null;\n  return value;\n}\nfunction getCurrentTNode() {\n  let currentTNode = getCurrentTNodePlaceholderOk();\n  while (currentTNode !== null && currentTNode.type === 64 /* TNodeType.Placeholder */) {\n    currentTNode = currentTNode.parent;\n  }\n  return currentTNode;\n}\nfunction getCurrentTNodePlaceholderOk() {\n  return instructionState.lFrame.currentTNode;\n}\nfunction getCurrentParentTNode() {\n  const lFrame = instructionState.lFrame;\n  const currentTNode = lFrame.currentTNode;\n  return lFrame.isParent ? currentTNode : currentTNode.parent;\n}\nfunction setCurrentTNode(tNode, isParent) {\n  ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);\n  const lFrame = instructionState.lFrame;\n  lFrame.currentTNode = tNode;\n  lFrame.isParent = isParent;\n}\nfunction isCurrentTNodeParent() {\n  return instructionState.lFrame.isParent;\n}\nfunction setCurrentTNodeAsNotParent() {\n  instructionState.lFrame.isParent = false;\n}\nfunction getContextLView() {\n  const contextLView = instructionState.lFrame.contextLView;\n  ngDevMode && assertDefined(contextLView, 'contextLView must be defined.');\n  return contextLView;\n}\nfunction isInCheckNoChangesMode() {\n  !ngDevMode && throwError('Must never be called in production mode');\n  return _isInCheckNoChangesMode;\n}\nfunction setIsInCheckNoChangesMode(mode) {\n  !ngDevMode && throwError('Must never be called in production mode');\n  _isInCheckNoChangesMode = mode;\n}\n// top level variables should not be exported for performance reasons (PERF_NOTES.md)\nfunction getBindingRoot() {\n  const lFrame = instructionState.lFrame;\n  let index = lFrame.bindingRootIndex;\n  if (index === -1) {\n    index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;\n  }\n  return index;\n}\nfunction getBindingIndex() {\n  return instructionState.lFrame.bindingIndex;\n}\nfunction setBindingIndex(value) {\n  return instructionState.lFrame.bindingIndex = value;\n}\nfunction nextBindingIndex() {\n  return instructionState.lFrame.bindingIndex++;\n}\nfunction incrementBindingIndex(count) {\n  const lFrame = instructionState.lFrame;\n  const index = lFrame.bindingIndex;\n  lFrame.bindingIndex = lFrame.bindingIndex + count;\n  return index;\n}\nfunction isInI18nBlock() {\n  return instructionState.lFrame.inI18n;\n}\nfunction setInI18nBlock(isInI18nBlock) {\n  instructionState.lFrame.inI18n = isInI18nBlock;\n}\n/**\n * Set a new binding root index so that host template functions can execute.\n *\n * Bindings inside the host template are 0 index. But because we don't know ahead of time\n * how many host bindings we have we can't pre-compute them. For this reason they are all\n * 0 index and we just shift the root so that they match next available location in the LView.\n *\n * @param bindingRootIndex Root index for `hostBindings`\n * @param currentDirectiveIndex `TData[currentDirectiveIndex]` will point to the current directive\n *        whose `hostBindings` are being processed.\n */\nfunction setBindingRootForHostBindings(bindingRootIndex, currentDirectiveIndex) {\n  const lFrame = instructionState.lFrame;\n  lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;\n  setCurrentDirectiveIndex(currentDirectiveIndex);\n}\n/**\n * When host binding is executing this points to the directive index.\n * `TView.data[getCurrentDirectiveIndex()]` is `DirectiveDef`\n * `LView[getCurrentDirectiveIndex()]` is directive instance.\n */\nfunction getCurrentDirectiveIndex() {\n  return instructionState.lFrame.currentDirectiveIndex;\n}\n/**\n * Sets an index of a directive whose `hostBindings` are being processed.\n *\n * @param currentDirectiveIndex `TData` index where current directive instance can be found.\n */\nfunction setCurrentDirectiveIndex(currentDirectiveIndex) {\n  instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;\n}\n/**\n * Retrieve the current `DirectiveDef` which is active when `hostBindings` instruction is being\n * executed.\n *\n * @param tData Current `TData` where the `DirectiveDef` will be looked up at.\n */\nfunction getCurrentDirectiveDef(tData) {\n  const currentDirectiveIndex = instructionState.lFrame.currentDirectiveIndex;\n  return currentDirectiveIndex === -1 ? null : tData[currentDirectiveIndex];\n}\nfunction getCurrentQueryIndex() {\n  return instructionState.lFrame.currentQueryIndex;\n}\nfunction setCurrentQueryIndex(value) {\n  instructionState.lFrame.currentQueryIndex = value;\n}\n/**\n * Returns a `TNode` of the location where the current `LView` is declared at.\n *\n * @param lView an `LView` that we want to find parent `TNode` for.\n */\nfunction getDeclarationTNode(lView) {\n  const tView = lView[TVIEW];\n  // Return the declaration parent for embedded views\n  if (tView.type === 2 /* TViewType.Embedded */) {\n    ngDevMode && assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');\n    return tView.declTNode;\n  }\n  // Components don't have `TView.declTNode` because each instance of component could be\n  // inserted in different location, hence `TView.declTNode` is meaningless.\n  // Falling back to `T_HOST` in case we cross component boundary.\n  if (tView.type === 1 /* TViewType.Component */) {\n    return lView[T_HOST];\n  }\n  // Remaining TNode type is `TViewType.Root` which doesn't have a parent TNode.\n  return null;\n}\n/**\n * This is a light weight version of the `enterView` which is needed by the DI system.\n *\n * @param lView `LView` location of the DI context.\n * @param tNode `TNode` for DI context\n * @param flags DI context flags. if `SkipSelf` flag is set than we walk up the declaration\n *     tree from `tNode`  until we find parent declared `TElementNode`.\n * @returns `true` if we have successfully entered DI associated with `tNode` (or with declared\n *     `TNode` if `flags` has  `SkipSelf`). Failing to enter DI implies that no associated\n *     `NodeInjector` can be found and we should instead use `ModuleInjector`.\n *     - If `true` than this call must be fallowed by `leaveDI`\n *     - If `false` than this call failed and we should NOT call `leaveDI`\n */\nfunction enterDI(lView, tNode, flags) {\n  ngDevMode && assertLViewOrUndefined(lView);\n  if (flags & InjectFlags.SkipSelf) {\n    ngDevMode && assertTNodeForTView(tNode, lView[TVIEW]);\n    let parentTNode = tNode;\n    let parentLView = lView;\n    while (true) {\n      ngDevMode && assertDefined(parentTNode, 'Parent TNode should be defined');\n      parentTNode = parentTNode.parent;\n      if (parentTNode === null && !(flags & InjectFlags.Host)) {\n        parentTNode = getDeclarationTNode(parentLView);\n        if (parentTNode === null) break;\n        // In this case, a parent exists and is definitely an element. So it will definitely\n        // have an existing lView as the declaration view, which is why we can assume it's defined.\n        ngDevMode && assertDefined(parentLView, 'Parent LView should be defined');\n        parentLView = parentLView[DECLARATION_VIEW];\n        // In Ivy there are Comment nodes that correspond to ngIf and NgFor embedded directives\n        // We want to skip those and look only at Elements and ElementContainers to ensure\n        // we're looking at true parent nodes, and not content or other types.\n        if (parentTNode.type & (2 /* TNodeType.Element */ | 8 /* TNodeType.ElementContainer */)) {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n    if (parentTNode === null) {\n      // If we failed to find a parent TNode this means that we should use module injector.\n      return false;\n    } else {\n      tNode = parentTNode;\n      lView = parentLView;\n    }\n  }\n  ngDevMode && assertTNodeForLView(tNode, lView);\n  const lFrame = instructionState.lFrame = allocLFrame();\n  lFrame.currentTNode = tNode;\n  lFrame.lView = lView;\n  return true;\n}\n/**\n * Swap the current lView with a new lView.\n *\n * For performance reasons we store the lView in the top level of the module.\n * This way we minimize the number of properties to read. Whenever a new view\n * is entered we have to store the lView for later, and when the view is\n * exited the state has to be restored\n *\n * @param newView New lView to become active\n * @returns the previously active lView;\n */\nfunction enterView(newView) {\n  ngDevMode && assertNotEqual(newView[0], newView[1], '????');\n  ngDevMode && assertLViewOrUndefined(newView);\n  const newLFrame = allocLFrame();\n  if (ngDevMode) {\n    assertEqual(newLFrame.isParent, true, 'Expected clean LFrame');\n    assertEqual(newLFrame.lView, null, 'Expected clean LFrame');\n    assertEqual(newLFrame.tView, null, 'Expected clean LFrame');\n    assertEqual(newLFrame.selectedIndex, -1, 'Expected clean LFrame');\n    assertEqual(newLFrame.elementDepthCount, 0, 'Expected clean LFrame');\n    assertEqual(newLFrame.currentDirectiveIndex, -1, 'Expected clean LFrame');\n    assertEqual(newLFrame.currentNamespace, null, 'Expected clean LFrame');\n    assertEqual(newLFrame.bindingRootIndex, -1, 'Expected clean LFrame');\n    assertEqual(newLFrame.currentQueryIndex, 0, 'Expected clean LFrame');\n  }\n  const tView = newView[TVIEW];\n  instructionState.lFrame = newLFrame;\n  ngDevMode && tView.firstChild && assertTNodeForTView(tView.firstChild, tView);\n  newLFrame.currentTNode = tView.firstChild;\n  newLFrame.lView = newView;\n  newLFrame.tView = tView;\n  newLFrame.contextLView = newView;\n  newLFrame.bindingIndex = tView.bindingStartIndex;\n  newLFrame.inI18n = false;\n}\n/**\n * Allocates next free LFrame. This function tries to reuse the `LFrame`s to lower memory pressure.\n */\nfunction allocLFrame() {\n  const currentLFrame = instructionState.lFrame;\n  const childLFrame = currentLFrame === null ? null : currentLFrame.child;\n  const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;\n  return newLFrame;\n}\nfunction createLFrame(parent) {\n  const lFrame = {\n    currentTNode: null,\n    isParent: true,\n    lView: null,\n    tView: null,\n    selectedIndex: -1,\n    contextLView: null,\n    elementDepthCount: 0,\n    currentNamespace: null,\n    currentDirectiveIndex: -1,\n    bindingRootIndex: -1,\n    bindingIndex: -1,\n    currentQueryIndex: 0,\n    parent: parent,\n    child: null,\n    inI18n: false\n  };\n  parent !== null && (parent.child = lFrame); // link the new LFrame for reuse.\n  return lFrame;\n}\n/**\n * A lightweight version of leave which is used with DI.\n *\n * This function only resets `currentTNode` and `LView` as those are the only properties\n * used with DI (`enterDI()`).\n *\n * NOTE: This function is reexported as `leaveDI`. However `leaveDI` has return type of `void` where\n * as `leaveViewLight` has `LFrame`. This is so that `leaveViewLight` can be used in `leaveView`.\n */\nfunction leaveViewLight() {\n  const oldLFrame = instructionState.lFrame;\n  instructionState.lFrame = oldLFrame.parent;\n  oldLFrame.currentTNode = null;\n  oldLFrame.lView = null;\n  return oldLFrame;\n}\n/**\n * This is a lightweight version of the `leaveView` which is needed by the DI system.\n *\n * NOTE: this function is an alias so that we can change the type of the function to have `void`\n * return type.\n */\nconst leaveDI = leaveViewLight;\n/**\n * Leave the current `LView`\n *\n * This pops the `LFrame` with the associated `LView` from the stack.\n *\n * IMPORTANT: We must zero out the `LFrame` values here otherwise they will be retained. This is\n * because for performance reasons we don't release `LFrame` but rather keep it for next use.\n */\nfunction leaveView() {\n  const oldLFrame = leaveViewLight();\n  oldLFrame.isParent = true;\n  oldLFrame.tView = null;\n  oldLFrame.selectedIndex = -1;\n  oldLFrame.contextLView = null;\n  oldLFrame.elementDepthCount = 0;\n  oldLFrame.currentDirectiveIndex = -1;\n  oldLFrame.currentNamespace = null;\n  oldLFrame.bindingRootIndex = -1;\n  oldLFrame.bindingIndex = -1;\n  oldLFrame.currentQueryIndex = 0;\n}\nfunction nextContextImpl(level) {\n  const contextLView = instructionState.lFrame.contextLView = walkUpViews(level, instructionState.lFrame.contextLView);\n  return contextLView[CONTEXT];\n}\nfunction walkUpViews(nestingLevel, currentView) {\n  while (nestingLevel > 0) {\n    ngDevMode && assertDefined(currentView[DECLARATION_VIEW], 'Declaration view should be defined if nesting level is greater than 0.');\n    currentView = currentView[DECLARATION_VIEW];\n    nestingLevel--;\n  }\n  return currentView;\n}\n/**\n * Gets the currently selected element index.\n *\n * Used with {@link property} instruction (and more in the future) to identify the index in the\n * current `LView` to act on.\n */\nfunction getSelectedIndex() {\n  return instructionState.lFrame.selectedIndex;\n}\n/**\n * Sets the most recent index passed to {@link select}\n *\n * Used with {@link property} instruction (and more in the future) to identify the index in the\n * current `LView` to act on.\n *\n * (Note that if an \"exit function\" was set earlier (via `setElementExitFn()`) then that will be\n * run if and when the provided `index` value is different from the current selected index value.)\n */\nfunction setSelectedIndex(index) {\n  ngDevMode && index !== -1 && assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Index must be past HEADER_OFFSET (or -1).');\n  ngDevMode && assertLessThan(index, instructionState.lFrame.lView.length, 'Can\\'t set index passed end of LView');\n  instructionState.lFrame.selectedIndex = index;\n}\n/**\n * Gets the `tNode` that represents currently selected element.\n */\nfunction getSelectedTNode() {\n  const lFrame = instructionState.lFrame;\n  return getTNode(lFrame.tView, lFrame.selectedIndex);\n}\n/**\n * Sets the namespace used to create elements to `'http://www.w3.org/2000/svg'` in global state.\n *\n * @codeGenApi\n */\nfunction ɵɵnamespaceSVG() {\n  instructionState.lFrame.currentNamespace = SVG_NAMESPACE;\n}\n/**\n * Sets the namespace used to create elements to `'http://www.w3.org/1998/MathML/'` in global state.\n *\n * @codeGenApi\n */\nfunction ɵɵnamespaceMathML() {\n  instructionState.lFrame.currentNamespace = MATH_ML_NAMESPACE;\n}\n/**\n * Sets the namespace used to create elements to `null`, which forces element creation to use\n * `createElement` rather than `createElementNS`.\n *\n * @codeGenApi\n */\nfunction ɵɵnamespaceHTML() {\n  namespaceHTMLInternal();\n}\n/**\n * Sets the namespace used to create elements to `null`, which forces element creation to use\n * `createElement` rather than `createElementNS`.\n */\nfunction namespaceHTMLInternal() {\n  instructionState.lFrame.currentNamespace = null;\n}\nfunction getNamespace$1() {\n  return instructionState.lFrame.currentNamespace;\n}\nlet _wasLastNodeCreated = true;\n/**\n * Retrieves a global flag that indicates whether the most recent DOM node\n * was created or hydrated.\n */\nfunction wasLastNodeCreated() {\n  return _wasLastNodeCreated;\n}\n/**\n * Sets a global flag to indicate whether the most recent DOM node\n * was created or hydrated.\n */\nfunction lastNodeWasCreated(flag) {\n  _wasLastNodeCreated = flag;\n}\n\n/**\n * Adds all directive lifecycle hooks from the given `DirectiveDef` to the given `TView`.\n *\n * Must be run *only* on the first template pass.\n *\n * Sets up the pre-order hooks on the provided `tView`,\n * see {@link HookData} for details about the data structure.\n *\n * @param directiveIndex The index of the directive in LView\n * @param directiveDef The definition containing the hooks to setup in tView\n * @param tView The current TView\n */\nfunction registerPreOrderHooks(directiveIndex, directiveDef, tView) {\n  ngDevMode && assertFirstCreatePass(tView);\n  const {\n    ngOnChanges,\n    ngOnInit,\n    ngDoCheck\n  } = directiveDef.type.prototype;\n  if (ngOnChanges) {\n    const wrappedOnChanges = NgOnChangesFeatureImpl(directiveDef);\n    (tView.preOrderHooks ??= []).push(directiveIndex, wrappedOnChanges);\n    (tView.preOrderCheckHooks ??= []).push(directiveIndex, wrappedOnChanges);\n  }\n  if (ngOnInit) {\n    (tView.preOrderHooks ??= []).push(0 - directiveIndex, ngOnInit);\n  }\n  if (ngDoCheck) {\n    (tView.preOrderHooks ??= []).push(directiveIndex, ngDoCheck);\n    (tView.preOrderCheckHooks ??= []).push(directiveIndex, ngDoCheck);\n  }\n}\n/**\n *\n * Loops through the directives on the provided `tNode` and queues hooks to be\n * run that are not initialization hooks.\n *\n * Should be executed during `elementEnd()` and similar to\n * preserve hook execution order. Content, view, and destroy hooks for projected\n * components and directives must be called *before* their hosts.\n *\n * Sets up the content, view, and destroy hooks on the provided `tView`,\n * see {@link HookData} for details about the data structure.\n *\n * NOTE: This does not set up `onChanges`, `onInit` or `doCheck`, those are set up\n * separately at `elementStart`.\n *\n * @param tView The current TView\n * @param tNode The TNode whose directives are to be searched for hooks to queue\n */\nfunction registerPostOrderHooks(tView, tNode) {\n  ngDevMode && assertFirstCreatePass(tView);\n  // It's necessary to loop through the directives at elementEnd() (rather than processing in\n  // directiveCreate) so we can preserve the current hook order. Content, view, and destroy\n  // hooks for projected components and directives must be called *before* their hosts.\n  for (let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {\n    const directiveDef = tView.data[i];\n    ngDevMode && assertDefined(directiveDef, 'Expecting DirectiveDef');\n    const lifecycleHooks = directiveDef.type.prototype;\n    const {\n      ngAfterContentInit,\n      ngAfterContentChecked,\n      ngAfterViewInit,\n      ngAfterViewChecked,\n      ngOnDestroy\n    } = lifecycleHooks;\n    if (ngAfterContentInit) {\n      (tView.contentHooks ??= []).push(-i, ngAfterContentInit);\n    }\n    if (ngAfterContentChecked) {\n      (tView.contentHooks ??= []).push(i, ngAfterContentChecked);\n      (tView.contentCheckHooks ??= []).push(i, ngAfterContentChecked);\n    }\n    if (ngAfterViewInit) {\n      (tView.viewHooks ??= []).push(-i, ngAfterViewInit);\n    }\n    if (ngAfterViewChecked) {\n      (tView.viewHooks ??= []).push(i, ngAfterViewChecked);\n      (tView.viewCheckHooks ??= []).push(i, ngAfterViewChecked);\n    }\n    if (ngOnDestroy != null) {\n      (tView.destroyHooks ??= []).push(i, ngOnDestroy);\n    }\n  }\n}\n/**\n * Executing hooks requires complex logic as we need to deal with 2 constraints.\n *\n * 1. Init hooks (ngOnInit, ngAfterContentInit, ngAfterViewInit) must all be executed once and only\n * once, across many change detection cycles. This must be true even if some hooks throw, or if\n * some recursively trigger a change detection cycle.\n * To solve that, it is required to track the state of the execution of these init hooks.\n * This is done by storing and maintaining flags in the view: the {@link InitPhaseState},\n * and the index within that phase. They can be seen as a cursor in the following structure:\n * [[onInit1, onInit2], [afterContentInit1], [afterViewInit1, afterViewInit2, afterViewInit3]]\n * They are stored as flags in LView[FLAGS].\n *\n * 2. Pre-order hooks can be executed in batches, because of the select instruction.\n * To be able to pause and resume their execution, we also need some state about the hook's array\n * that is being processed:\n * - the index of the next hook to be executed\n * - the number of init hooks already found in the processed part of the  array\n * They are stored as flags in LView[PREORDER_HOOK_FLAGS].\n */\n/**\n * Executes pre-order check hooks ( OnChanges, DoChanges) given a view where all the init hooks were\n * executed once. This is a light version of executeInitAndCheckPreOrderHooks where we can skip read\n * / write of the init-hooks related flags.\n * @param lView The LView where hooks are defined\n * @param hooks Hooks to be run\n * @param nodeIndex 3 cases depending on the value:\n * - undefined: all hooks from the array should be executed (post-order case)\n * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\n * flushing the remaining hooks)\n * - number: execute hooks only from the saved index until that node index exclusive (pre-order\n * case, when executing select(number))\n */\nfunction executeCheckHooks(lView, hooks, nodeIndex) {\n  callHooks(lView, hooks, 3 /* InitPhaseState.InitPhaseCompleted */, nodeIndex);\n}\n/**\n * Executes post-order init and check hooks (one of AfterContentInit, AfterContentChecked,\n * AfterViewInit, AfterViewChecked) given a view where there are pending init hooks to be executed.\n * @param lView The LView where hooks are defined\n * @param hooks Hooks to be run\n * @param initPhase A phase for which hooks should be run\n * @param nodeIndex 3 cases depending on the value:\n * - undefined: all hooks from the array should be executed (post-order case)\n * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\n * flushing the remaining hooks)\n * - number: execute hooks only from the saved index until that node index exclusive (pre-order\n * case, when executing select(number))\n */\nfunction executeInitAndCheckHooks(lView, hooks, initPhase, nodeIndex) {\n  ngDevMode && assertNotEqual(initPhase, 3 /* InitPhaseState.InitPhaseCompleted */, 'Init pre-order hooks should not be called more than once');\n  if ((lView[FLAGS] & 3 /* LViewFlags.InitPhaseStateMask */) === initPhase) {\n    callHooks(lView, hooks, initPhase, nodeIndex);\n  }\n}\nfunction incrementInitPhaseFlags(lView, initPhase) {\n  ngDevMode && assertNotEqual(initPhase, 3 /* InitPhaseState.InitPhaseCompleted */, 'Init hooks phase should not be incremented after all init hooks have been run.');\n  let flags = lView[FLAGS];\n  if ((flags & 3 /* LViewFlags.InitPhaseStateMask */) === initPhase) {\n    flags &= 8191 /* LViewFlags.IndexWithinInitPhaseReset */;\n    flags += 1 /* LViewFlags.InitPhaseStateIncrementer */;\n    lView[FLAGS] = flags;\n  }\n}\n/**\n * Calls lifecycle hooks with their contexts, skipping init hooks if it's not\n * the first LView pass\n *\n * @param currentView The current view\n * @param arr The array in which the hooks are found\n * @param initPhaseState the current state of the init phase\n * @param currentNodeIndex 3 cases depending on the value:\n * - undefined: all hooks from the array should be executed (post-order case)\n * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\n * flushing the remaining hooks)\n * - number: execute hooks only from the saved index until that node index exclusive (pre-order\n * case, when executing select(number))\n */\nfunction callHooks(currentView, arr, initPhase, currentNodeIndex) {\n  ngDevMode && assertEqual(isInCheckNoChangesMode(), false, 'Hooks should never be run when in check no changes mode.');\n  const startIndex = currentNodeIndex !== undefined ? currentView[PREORDER_HOOK_FLAGS] & 65535 /* PreOrderHookFlags.IndexOfTheNextPreOrderHookMaskMask */ : 0;\n  const nodeIndexLimit = currentNodeIndex != null ? currentNodeIndex : -1;\n  const max = arr.length - 1; // Stop the loop at length - 1, because we look for the hook at i + 1\n  let lastNodeIndexFound = 0;\n  for (let i = startIndex; i < max; i++) {\n    const hook = arr[i + 1];\n    if (typeof hook === 'number') {\n      lastNodeIndexFound = arr[i];\n      if (currentNodeIndex != null && lastNodeIndexFound >= currentNodeIndex) {\n        break;\n      }\n    } else {\n      const isInitHook = arr[i] < 0;\n      if (isInitHook) {\n        currentView[PREORDER_HOOK_FLAGS] += 65536 /* PreOrderHookFlags.NumberOfInitHooksCalledIncrementer */;\n      }\n\n      if (lastNodeIndexFound < nodeIndexLimit || nodeIndexLimit == -1) {\n        callHook(currentView, initPhase, arr, i);\n        currentView[PREORDER_HOOK_FLAGS] = (currentView[PREORDER_HOOK_FLAGS] & 4294901760 /* PreOrderHookFlags.NumberOfInitHooksCalledMask */) + i + 2;\n      }\n      i++;\n    }\n  }\n}\n/**\n * Executes a single lifecycle hook, making sure that:\n * - it is called in the non-reactive context;\n * - profiling data are registered.\n */\nfunction callHookInternal(directive, hook) {\n  profiler(4 /* ProfilerEvent.LifecycleHookStart */, directive, hook);\n  const prevConsumer = setActiveConsumer(null);\n  try {\n    hook.call(directive);\n  } finally {\n    setActiveConsumer(prevConsumer);\n    profiler(5 /* ProfilerEvent.LifecycleHookEnd */, directive, hook);\n  }\n}\n/**\n * Execute one hook against the current `LView`.\n *\n * @param currentView The current view\n * @param initPhaseState the current state of the init phase\n * @param arr The array in which the hooks are found\n * @param i The current index within the hook data array\n */\nfunction callHook(currentView, initPhase, arr, i) {\n  const isInitHook = arr[i] < 0;\n  const hook = arr[i + 1];\n  const directiveIndex = isInitHook ? -arr[i] : arr[i];\n  const directive = currentView[directiveIndex];\n  if (isInitHook) {\n    const indexWithintInitPhase = currentView[FLAGS] >> 13 /* LViewFlags.IndexWithinInitPhaseShift */;\n    // The init phase state must be always checked here as it may have been recursively updated.\n    if (indexWithintInitPhase < currentView[PREORDER_HOOK_FLAGS] >> 16 /* PreOrderHookFlags.NumberOfInitHooksCalledShift */ && (currentView[FLAGS] & 3 /* LViewFlags.InitPhaseStateMask */) === initPhase) {\n      currentView[FLAGS] += 8192 /* LViewFlags.IndexWithinInitPhaseIncrementer */;\n      callHookInternal(directive, hook);\n    }\n  } else {\n    callHookInternal(directive, hook);\n  }\n}\nconst NO_PARENT_INJECTOR = -1;\n/**\n * Each injector is saved in 9 contiguous slots in `LView` and 9 contiguous slots in\n * `TView.data`. This allows us to store information about the current node's tokens (which\n * can be shared in `TView`) as well as the tokens of its ancestor nodes (which cannot be\n * shared, so they live in `LView`).\n *\n * Each of these slots (aside from the last slot) contains a bloom filter. This bloom filter\n * determines whether a directive is available on the associated node or not. This prevents us\n * from searching the directives array at this level unless it's probable the directive is in it.\n *\n * See: https://en.wikipedia.org/wiki/Bloom_filter for more about bloom filters.\n *\n * Because all injectors have been flattened into `LView` and `TViewData`, they cannot typed\n * using interfaces as they were previously. The start index of each `LInjector` and `TInjector`\n * will differ based on where it is flattened into the main array, so it's not possible to know\n * the indices ahead of time and save their types here. The interfaces are still included here\n * for documentation purposes.\n *\n * export interface LInjector extends Array<any> {\n *\n *    // Cumulative bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)\n *    [0]: number;\n *\n *    // Cumulative bloom for directive IDs 32-63\n *    [1]: number;\n *\n *    // Cumulative bloom for directive IDs 64-95\n *    [2]: number;\n *\n *    // Cumulative bloom for directive IDs 96-127\n *    [3]: number;\n *\n *    // Cumulative bloom for directive IDs 128-159\n *    [4]: number;\n *\n *    // Cumulative bloom for directive IDs 160 - 191\n *    [5]: number;\n *\n *    // Cumulative bloom for directive IDs 192 - 223\n *    [6]: number;\n *\n *    // Cumulative bloom for directive IDs 224 - 255\n *    [7]: number;\n *\n *    // We need to store a reference to the injector's parent so DI can keep looking up\n *    // the injector tree until it finds the dependency it's looking for.\n *    [PARENT_INJECTOR]: number;\n * }\n *\n * export interface TInjector extends Array<any> {\n *\n *    // Shared node bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)\n *    [0]: number;\n *\n *    // Shared node bloom for directive IDs 32-63\n *    [1]: number;\n *\n *    // Shared node bloom for directive IDs 64-95\n *    [2]: number;\n *\n *    // Shared node bloom for directive IDs 96-127\n *    [3]: number;\n *\n *    // Shared node bloom for directive IDs 128-159\n *    [4]: number;\n *\n *    // Shared node bloom for directive IDs 160 - 191\n *    [5]: number;\n *\n *    // Shared node bloom for directive IDs 192 - 223\n *    [6]: number;\n *\n *    // Shared node bloom for directive IDs 224 - 255\n *    [7]: number;\n *\n *    // Necessary to find directive indices for a particular node.\n *    [TNODE]: TElementNode|TElementContainerNode|TContainerNode;\n *  }\n */\n/**\n * Factory for creating instances of injectors in the NodeInjector.\n *\n * This factory is complicated by the fact that it can resolve `multi` factories as well.\n *\n * NOTE: Some of the fields are optional which means that this class has two hidden classes.\n * - One without `multi` support (most common)\n * - One with `multi` values, (rare).\n *\n * Since VMs can cache up to 4 inline hidden classes this is OK.\n *\n * - Single factory: Only `resolving` and `factory` is defined.\n * - `providers` factory: `componentProviders` is a number and `index = -1`.\n * - `viewProviders` factory: `componentProviders` is a number and `index` points to `providers`.\n */\nclass NodeInjectorFactory {\n  constructor(\n  /**\n   * Factory to invoke in order to create a new instance.\n   */\n  factory,\n  /**\n   * Set to `true` if the token is declared in `viewProviders` (or if it is component).\n   */\n  isViewProvider, injectImplementation) {\n    this.factory = factory;\n    /**\n     * Marker set to true during factory invocation to see if we get into recursive loop.\n     * Recursive loop causes an error to be displayed.\n     */\n    this.resolving = false;\n    ngDevMode && assertDefined(factory, 'Factory not specified');\n    ngDevMode && assertEqual(typeof factory, 'function', 'Expected factory function.');\n    this.canSeeViewProviders = isViewProvider;\n    this.injectImpl = injectImplementation;\n  }\n}\nfunction isFactory(obj) {\n  return obj instanceof NodeInjectorFactory;\n}\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd$2 = 1;\n\n/**\n * Converts `TNodeType` into human readable text.\n * Make sure this matches with `TNodeType`\n */\nfunction toTNodeTypeAsString(tNodeType) {\n  let text = '';\n  tNodeType & 1 /* TNodeType.Text */ && (text += '|Text');\n  tNodeType & 2 /* TNodeType.Element */ && (text += '|Element');\n  tNodeType & 4 /* TNodeType.Container */ && (text += '|Container');\n  tNodeType & 8 /* TNodeType.ElementContainer */ && (text += '|ElementContainer');\n  tNodeType & 16 /* TNodeType.Projection */ && (text += '|Projection');\n  tNodeType & 32 /* TNodeType.Icu */ && (text += '|IcuContainer');\n  tNodeType & 64 /* TNodeType.Placeholder */ && (text += '|Placeholder');\n  return text.length > 0 ? text.substring(1) : text;\n}\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd$1 = 1;\n/**\n * Returns `true` if the `TNode` has a directive which has `@Input()` for `class` binding.\n *\n * ```\n * <div my-dir [class]=\"exp\"></div>\n * ```\n * and\n * ```\n * @Directive({\n * })\n * class MyDirective {\n *   @Input()\n *   class: string;\n * }\n * ```\n *\n * In the above case it is necessary to write the reconciled styling information into the\n * directive's input.\n *\n * @param tNode\n */\nfunction hasClassInput(tNode) {\n  return (tNode.flags & 8 /* TNodeFlags.hasClassInput */) !== 0;\n}\n/**\n * Returns `true` if the `TNode` has a directive which has `@Input()` for `style` binding.\n *\n * ```\n * <div my-dir [style]=\"exp\"></div>\n * ```\n * and\n * ```\n * @Directive({\n * })\n * class MyDirective {\n *   @Input()\n *   class: string;\n * }\n * ```\n *\n * In the above case it is necessary to write the reconciled styling information into the\n * directive's input.\n *\n * @param tNode\n */\nfunction hasStyleInput(tNode) {\n  return (tNode.flags & 16 /* TNodeFlags.hasStyleInput */) !== 0;\n}\nfunction assertTNodeType(tNode, expectedTypes, message) {\n  assertDefined(tNode, 'should be called with a TNode');\n  if ((tNode.type & expectedTypes) === 0) {\n    throwError(message || `Expected [${toTNodeTypeAsString(expectedTypes)}] but got ${toTNodeTypeAsString(tNode.type)}.`);\n  }\n}\nfunction assertPureTNodeType(type) {\n  if (!(type === 2 /* TNodeType.Element */ ||\n  //\n  type === 1 /* TNodeType.Text */ ||\n  //\n  type === 4 /* TNodeType.Container */ ||\n  //\n  type === 8 /* TNodeType.ElementContainer */ ||\n  //\n  type === 32 /* TNodeType.Icu */ ||\n  //\n  type === 16 /* TNodeType.Projection */ ||\n  //\n  type === 64 /* TNodeType.Placeholder */)) {\n    throwError(`Expected TNodeType to have only a single type selected, but got ${toTNodeTypeAsString(type)}.`);\n  }\n}\n\n/// Parent Injector Utils ///////////////////////////////////////////////////////////////\nfunction hasParentInjector(parentLocation) {\n  return parentLocation !== NO_PARENT_INJECTOR;\n}\nfunction getParentInjectorIndex(parentLocation) {\n  ngDevMode && assertNumber(parentLocation, 'Number expected');\n  ngDevMode && assertNotEqual(parentLocation, -1, 'Not a valid state.');\n  const parentInjectorIndex = parentLocation & 32767 /* RelativeInjectorLocationFlags.InjectorIndexMask */;\n  ngDevMode && assertGreaterThan(parentInjectorIndex, HEADER_OFFSET, 'Parent injector must be pointing past HEADER_OFFSET.');\n  return parentLocation & 32767 /* RelativeInjectorLocationFlags.InjectorIndexMask */;\n}\n\nfunction getParentInjectorViewOffset(parentLocation) {\n  return parentLocation >> 16 /* RelativeInjectorLocationFlags.ViewOffsetShift */;\n}\n/**\n * Unwraps a parent injector location number to find the view offset from the current injector,\n * then walks up the declaration view tree until the view is found that contains the parent\n * injector.\n *\n * @param location The location of the parent injector, which contains the view offset\n * @param startView The LView instance from which to start walking up the view tree\n * @returns The LView instance that contains the parent injector\n */\nfunction getParentInjectorView(location, startView) {\n  let viewOffset = getParentInjectorViewOffset(location);\n  let parentView = startView;\n  // For most cases, the parent injector can be found on the host node (e.g. for component\n  // or container), but we must keep the loop here to support the rarer case of deeply nested\n  // <ng-template> tags or inline views, where the parent injector might live many views\n  // above the child injector.\n  while (viewOffset > 0) {\n    parentView = parentView[DECLARATION_VIEW];\n    viewOffset--;\n  }\n  return parentView;\n}\n\n/**\n * Defines if the call to `inject` should include `viewProviders` in its resolution.\n *\n * This is set to true when we try to instantiate a component. This value is reset in\n * `getNodeInjectable` to a value which matches the declaration location of the token about to be\n * instantiated. This is done so that if we are injecting a token which was declared outside of\n * `viewProviders` we don't accidentally pull `viewProviders` in.\n *\n * Example:\n *\n * ```\n * @Injectable()\n * class MyService {\n *   constructor(public value: String) {}\n * }\n *\n * @Component({\n *   providers: [\n *     MyService,\n *     {provide: String, value: 'providers' }\n *   ]\n *   viewProviders: [\n *     {provide: String, value: 'viewProviders'}\n *   ]\n * })\n * class MyComponent {\n *   constructor(myService: MyService, value: String) {\n *     // We expect that Component can see into `viewProviders`.\n *     expect(value).toEqual('viewProviders');\n *     // `MyService` was not declared in `viewProviders` hence it can't see it.\n *     expect(myService.value).toEqual('providers');\n *   }\n * }\n *\n * ```\n */\nlet includeViewProviders = true;\nfunction setIncludeViewProviders(v) {\n  const oldValue = includeViewProviders;\n  includeViewProviders = v;\n  return oldValue;\n}\n/**\n * The number of slots in each bloom filter (used by DI). The larger this number, the fewer\n * directives that will share slots, and thus, the fewer false positives when checking for\n * the existence of a directive.\n */\nconst BLOOM_SIZE = 256;\nconst BLOOM_MASK = BLOOM_SIZE - 1;\n/**\n * The number of bits that is represented by a single bloom bucket. JS bit operations are 32 bits,\n * so each bucket represents 32 distinct tokens which accounts for log2(32) = 5 bits of a bloom hash\n * number.\n */\nconst BLOOM_BUCKET_BITS = 5;\n/** Counter used to generate unique IDs for directives. */\nlet nextNgElementId = 0;\n/** Value used when something wasn't found by an injector. */\nconst NOT_FOUND = {};\n/**\n * Registers this directive as present in its node's injector by flipping the directive's\n * corresponding bit in the injector's bloom filter.\n *\n * @param injectorIndex The index of the node injector where this token should be registered\n * @param tView The TView for the injector's bloom filters\n * @param type The directive token to register\n */\nfunction bloomAdd(injectorIndex, tView, type) {\n  ngDevMode && assertEqual(tView.firstCreatePass, true, 'expected firstCreatePass to be true');\n  let id;\n  if (typeof type === 'string') {\n    id = type.charCodeAt(0) || 0;\n  } else if (type.hasOwnProperty(NG_ELEMENT_ID)) {\n    id = type[NG_ELEMENT_ID];\n  }\n  // Set a unique ID on the directive type, so if something tries to inject the directive,\n  // we can easily retrieve the ID and hash it into the bloom bit that should be checked.\n  if (id == null) {\n    id = type[NG_ELEMENT_ID] = nextNgElementId++;\n  }\n  // We only have BLOOM_SIZE (256) slots in our bloom filter (8 buckets * 32 bits each),\n  // so all unique IDs must be modulo-ed into a number from 0 - 255 to fit into the filter.\n  const bloomHash = id & BLOOM_MASK;\n  // Create a mask that targets the specific bit associated with the directive.\n  // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n  // to bit positions 0 - 31 in a 32 bit integer.\n  const mask = 1 << bloomHash;\n  // Each bloom bucket in `tData` represents `BLOOM_BUCKET_BITS` number of bits of `bloomHash`.\n  // Any bits in `bloomHash` beyond `BLOOM_BUCKET_BITS` indicate the bucket offset that the mask\n  // should be written to.\n  tView.data[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)] |= mask;\n}\n/**\n * Creates (or gets an existing) injector for a given element or container.\n *\n * @param tNode for which an injector should be retrieved / created.\n * @param lView View where the node is stored\n * @returns Node injector\n */\nfunction getOrCreateNodeInjectorForNode(tNode, lView) {\n  const existingInjectorIndex = getInjectorIndex(tNode, lView);\n  if (existingInjectorIndex !== -1) {\n    return existingInjectorIndex;\n  }\n  const tView = lView[TVIEW];\n  if (tView.firstCreatePass) {\n    tNode.injectorIndex = lView.length;\n    insertBloom(tView.data, tNode); // foundation for node bloom\n    insertBloom(lView, null); // foundation for cumulative bloom\n    insertBloom(tView.blueprint, null);\n  }\n  const parentLoc = getParentInjectorLocation(tNode, lView);\n  const injectorIndex = tNode.injectorIndex;\n  // If a parent injector can't be found, its location is set to -1.\n  // In that case, we don't need to set up a cumulative bloom\n  if (hasParentInjector(parentLoc)) {\n    const parentIndex = getParentInjectorIndex(parentLoc);\n    const parentLView = getParentInjectorView(parentLoc, lView);\n    const parentData = parentLView[TVIEW].data;\n    // Creates a cumulative bloom filter that merges the parent's bloom filter\n    // and its own cumulative bloom (which contains tokens for all ancestors)\n    for (let i = 0; i < 8 /* NodeInjectorOffset.BLOOM_SIZE */; i++) {\n      lView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];\n    }\n  }\n  lView[injectorIndex + 8 /* NodeInjectorOffset.PARENT */] = parentLoc;\n  return injectorIndex;\n}\nfunction insertBloom(arr, footer) {\n  arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);\n}\nfunction getInjectorIndex(tNode, lView) {\n  if (tNode.injectorIndex === -1 ||\n  // If the injector index is the same as its parent's injector index, then the index has been\n  // copied down from the parent node. No injector has been created yet on this node.\n  tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex ||\n  // After the first template pass, the injector index might exist but the parent values\n  // might not have been calculated yet for this instance\n  lView[tNode.injectorIndex + 8 /* NodeInjectorOffset.PARENT */] === null) {\n    return -1;\n  } else {\n    ngDevMode && assertIndexInRange(lView, tNode.injectorIndex);\n    return tNode.injectorIndex;\n  }\n}\n/**\n * Finds the index of the parent injector, with a view offset if applicable. Used to set the\n * parent injector initially.\n *\n * @returns Returns a number that is the combination of the number of LViews that we have to go up\n * to find the LView containing the parent inject AND the index of the injector within that LView.\n */\nfunction getParentInjectorLocation(tNode, lView) {\n  if (tNode.parent && tNode.parent.injectorIndex !== -1) {\n    // If we have a parent `TNode` and there is an injector associated with it we are done, because\n    // the parent injector is within the current `LView`.\n    return tNode.parent.injectorIndex; // ViewOffset is 0\n  }\n  // When parent injector location is computed it may be outside of the current view. (ie it could\n  // be pointing to a declared parent location). This variable stores number of declaration parents\n  // we need to walk up in order to find the parent injector location.\n  let declarationViewOffset = 0;\n  let parentTNode = null;\n  let lViewCursor = lView;\n  // The parent injector is not in the current `LView`. We will have to walk the declared parent\n  // `LView` hierarchy and look for it. If we walk of the top, that means that there is no parent\n  // `NodeInjector`.\n  while (lViewCursor !== null) {\n    parentTNode = getTNodeFromLView(lViewCursor);\n    if (parentTNode === null) {\n      // If we have no parent, than we are done.\n      return NO_PARENT_INJECTOR;\n    }\n    ngDevMode && parentTNode && assertTNodeForLView(parentTNode, lViewCursor[DECLARATION_VIEW]);\n    // Every iteration of the loop requires that we go to the declared parent.\n    declarationViewOffset++;\n    lViewCursor = lViewCursor[DECLARATION_VIEW];\n    if (parentTNode.injectorIndex !== -1) {\n      // We found a NodeInjector which points to something.\n      return parentTNode.injectorIndex | declarationViewOffset << 16 /* RelativeInjectorLocationFlags.ViewOffsetShift */;\n    }\n  }\n\n  return NO_PARENT_INJECTOR;\n}\n/**\n * Makes a type or an injection token public to the DI system by adding it to an\n * injector's bloom filter.\n *\n * @param di The node injector in which a directive will be added\n * @param token The type or the injection token to be made public\n */\nfunction diPublicInInjector(injectorIndex, tView, token) {\n  bloomAdd(injectorIndex, tView, token);\n}\n/**\n * Inject static attribute value into directive constructor.\n *\n * This method is used with `factory` functions which are generated as part of\n * `defineDirective` or `defineComponent`. The method retrieves the static value\n * of an attribute. (Dynamic attributes are not supported since they are not resolved\n *  at the time of injection and can change over time.)\n *\n * # Example\n * Given:\n * ```\n * @Component(...)\n * class MyComponent {\n *   constructor(@Attribute('title') title: string) { ... }\n * }\n * ```\n * When instantiated with\n * ```\n * <my-component title=\"Hello\"></my-component>\n * ```\n *\n * Then factory method generated is:\n * ```\n * MyComponent.ɵcmp = defineComponent({\n *   factory: () => new MyComponent(injectAttribute('title'))\n *   ...\n * })\n * ```\n *\n * @publicApi\n */\nfunction injectAttributeImpl(tNode, attrNameToInject) {\n  ngDevMode && assertTNodeType(tNode, 12 /* TNodeType.AnyContainer */ | 3 /* TNodeType.AnyRNode */);\n  ngDevMode && assertDefined(tNode, 'expecting tNode');\n  if (attrNameToInject === 'class') {\n    return tNode.classes;\n  }\n  if (attrNameToInject === 'style') {\n    return tNode.styles;\n  }\n  const attrs = tNode.attrs;\n  if (attrs) {\n    const attrsLength = attrs.length;\n    let i = 0;\n    while (i < attrsLength) {\n      const value = attrs[i];\n      // If we hit a `Bindings` or `Template` marker then we are done.\n      if (isNameOnlyAttributeMarker(value)) break;\n      // Skip namespaced attributes\n      if (value === 0 /* AttributeMarker.NamespaceURI */) {\n        // we skip the next two values\n        // as namespaced attributes looks like\n        // [..., AttributeMarker.NamespaceURI, 'http://someuri.com/test', 'test:exist',\n        // 'existValue', ...]\n        i = i + 2;\n      } else if (typeof value === 'number') {\n        // Skip to the first value of the marked attribute.\n        i++;\n        while (i < attrsLength && typeof attrs[i] === 'string') {\n          i++;\n        }\n      } else if (value === attrNameToInject) {\n        return attrs[i + 1];\n      } else {\n        i = i + 2;\n      }\n    }\n  }\n  return null;\n}\nfunction notFoundValueOrThrow(notFoundValue, token, flags) {\n  if (flags & InjectFlags.Optional || notFoundValue !== undefined) {\n    return notFoundValue;\n  } else {\n    throwProviderNotFoundError(token, 'NodeInjector');\n  }\n}\n/**\n * Returns the value associated to the given token from the ModuleInjector or throws exception\n *\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\n * @returns the value from the injector or throws an exception\n */\nfunction lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue) {\n  if (flags & InjectFlags.Optional && notFoundValue === undefined) {\n    // This must be set or the NullInjector will throw for optional deps\n    notFoundValue = null;\n  }\n  if ((flags & (InjectFlags.Self | InjectFlags.Host)) === 0) {\n    const moduleInjector = lView[INJECTOR$1];\n    // switch to `injectInjectorOnly` implementation for module injector, since module injector\n    // should not have access to Component/Directive DI scope (that may happen through\n    // `directiveInject` implementation)\n    const previousInjectImplementation = setInjectImplementation(undefined);\n    try {\n      if (moduleInjector) {\n        return moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional);\n      } else {\n        return injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);\n      }\n    } finally {\n      setInjectImplementation(previousInjectImplementation);\n    }\n  }\n  return notFoundValueOrThrow(notFoundValue, token, flags);\n}\n/**\n * Returns the value associated to the given token from the NodeInjectors => ModuleInjector.\n *\n * Look for the injector providing the token by walking up the node injector tree and then\n * the module injector tree.\n *\n * This function patches `token` with `__NG_ELEMENT_ID__` which contains the id for the bloom\n * filter. `-1` is reserved for injecting `Injector` (implemented by `NodeInjector`)\n *\n * @param tNode The Node where the search for the injector should start\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\n * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided\n */\nfunction getOrCreateInjectable(tNode, lView, token, flags = InjectFlags.Default, notFoundValue) {\n  if (tNode !== null) {\n    // If the view or any of its ancestors have an embedded\n    // view injector, we have to look it up there first.\n    if (lView[FLAGS] & 2048 /* LViewFlags.HasEmbeddedViewInjector */ &&\n    // The token must be present on the current node injector when the `Self`\n    // flag is set, so the lookup on embedded view injector(s) can be skipped.\n    !(flags & InjectFlags.Self)) {\n      const embeddedInjectorValue = lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, NOT_FOUND);\n      if (embeddedInjectorValue !== NOT_FOUND) {\n        return embeddedInjectorValue;\n      }\n    }\n    // Otherwise try the node injector.\n    const value = lookupTokenUsingNodeInjector(tNode, lView, token, flags, NOT_FOUND);\n    if (value !== NOT_FOUND) {\n      return value;\n    }\n  }\n  // Finally, fall back to the module injector.\n  return lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);\n}\n/**\n * Returns the value associated to the given token from the node injector.\n *\n * @param tNode The Node where the search for the injector should start\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\n * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided\n */\nfunction lookupTokenUsingNodeInjector(tNode, lView, token, flags, notFoundValue) {\n  const bloomHash = bloomHashBitOrFactory(token);\n  // If the ID stored here is a function, this is a special object like ElementRef or TemplateRef\n  // so just call the factory function to create it.\n  if (typeof bloomHash === 'function') {\n    if (!enterDI(lView, tNode, flags)) {\n      // Failed to enter DI, try module injector instead. If a token is injected with the @Host\n      // flag, the module injector is not searched for that token in Ivy.\n      return flags & InjectFlags.Host ? notFoundValueOrThrow(notFoundValue, token, flags) : lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);\n    }\n    try {\n      let value;\n      if (ngDevMode) {\n        runInInjectorProfilerContext(new NodeInjector(getCurrentTNode(), getLView()), token, () => {\n          value = bloomHash(flags);\n          if (value != null) {\n            emitInstanceCreatedByInjectorEvent(value);\n          }\n        });\n      } else {\n        value = bloomHash(flags);\n      }\n      if (value == null && !(flags & InjectFlags.Optional)) {\n        throwProviderNotFoundError(token);\n      } else {\n        return value;\n      }\n    } finally {\n      leaveDI();\n    }\n  } else if (typeof bloomHash === 'number') {\n    // A reference to the previous injector TView that was found while climbing the element\n    // injector tree. This is used to know if viewProviders can be accessed on the current\n    // injector.\n    let previousTView = null;\n    let injectorIndex = getInjectorIndex(tNode, lView);\n    let parentLocation = NO_PARENT_INJECTOR;\n    let hostTElementNode = flags & InjectFlags.Host ? lView[DECLARATION_COMPONENT_VIEW][T_HOST] : null;\n    // If we should skip this injector, or if there is no injector on this node, start by\n    // searching the parent injector.\n    if (injectorIndex === -1 || flags & InjectFlags.SkipSelf) {\n      parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) : lView[injectorIndex + 8 /* NodeInjectorOffset.PARENT */];\n      if (parentLocation === NO_PARENT_INJECTOR || !shouldSearchParent(flags, false)) {\n        injectorIndex = -1;\n      } else {\n        previousTView = lView[TVIEW];\n        injectorIndex = getParentInjectorIndex(parentLocation);\n        lView = getParentInjectorView(parentLocation, lView);\n      }\n    }\n    // Traverse up the injector tree until we find a potential match or until we know there\n    // *isn't* a match.\n    while (injectorIndex !== -1) {\n      ngDevMode && assertNodeInjector(lView, injectorIndex);\n      // Check the current injector. If it matches, see if it contains token.\n      const tView = lView[TVIEW];\n      ngDevMode && assertTNodeForLView(tView.data[injectorIndex + 8 /* NodeInjectorOffset.TNODE */], lView);\n      if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {\n        // At this point, we have an injector which *may* contain the token, so we step through\n        // the providers and directives associated with the injector's corresponding node to get\n        // the instance.\n        const instance = searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode);\n        if (instance !== NOT_FOUND) {\n          return instance;\n        }\n      }\n      parentLocation = lView[injectorIndex + 8 /* NodeInjectorOffset.PARENT */];\n      if (parentLocation !== NO_PARENT_INJECTOR && shouldSearchParent(flags, lView[TVIEW].data[injectorIndex + 8 /* NodeInjectorOffset.TNODE */] === hostTElementNode) && bloomHasToken(bloomHash, injectorIndex, lView)) {\n        // The def wasn't found anywhere on this node, so it was a false positive.\n        // Traverse up the tree and continue searching.\n        previousTView = tView;\n        injectorIndex = getParentInjectorIndex(parentLocation);\n        lView = getParentInjectorView(parentLocation, lView);\n      } else {\n        // If we should not search parent OR If the ancestor bloom filter value does not have the\n        // bit corresponding to the directive we can give up on traversing up to find the specific\n        // injector.\n        injectorIndex = -1;\n      }\n    }\n  }\n  return notFoundValue;\n}\nfunction searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode) {\n  const currentTView = lView[TVIEW];\n  const tNode = currentTView.data[injectorIndex + 8 /* NodeInjectorOffset.TNODE */];\n  // First, we need to determine if view providers can be accessed by the starting element.\n  // There are two possibilities\n  const canAccessViewProviders = previousTView == null ?\n  // 1) This is the first invocation `previousTView == null` which means that we are at the\n  // `TNode` of where injector is starting to look. In such a case the only time we are allowed\n  // to look into the ViewProviders is if:\n  // - we are on a component\n  // - AND the injector set `includeViewProviders` to true (implying that the token can see\n  // ViewProviders because it is the Component or a Service which itself was declared in\n  // ViewProviders)\n  isComponentHost(tNode) && includeViewProviders :\n  // 2) `previousTView != null` which means that we are now walking across the parent nodes.\n  // In such a case we are only allowed to look into the ViewProviders if:\n  // - We just crossed from child View to Parent View `previousTView != currentTView`\n  // - AND the parent TNode is an Element.\n  // This means that we just came from the Component's View and therefore are allowed to see\n  // into the ViewProviders.\n  previousTView != currentTView && (tNode.type & 3 /* TNodeType.AnyRNode */) !== 0;\n  // This special case happens when there is a @host on the inject and when we are searching\n  // on the host element node.\n  const isHostSpecialCase = flags & InjectFlags.Host && hostTElementNode === tNode;\n  const injectableIdx = locateDirectiveOrProvider(tNode, currentTView, token, canAccessViewProviders, isHostSpecialCase);\n  if (injectableIdx !== null) {\n    return getNodeInjectable(lView, currentTView, injectableIdx, tNode);\n  } else {\n    return NOT_FOUND;\n  }\n}\n/**\n * Searches for the given token among the node's directives and providers.\n *\n * @param tNode TNode on which directives are present.\n * @param tView The tView we are currently processing\n * @param token Provider token or type of a directive to look for.\n * @param canAccessViewProviders Whether view providers should be considered.\n * @param isHostSpecialCase Whether the host special case applies.\n * @returns Index of a found directive or provider, or null when none found.\n */\nfunction locateDirectiveOrProvider(tNode, tView, token, canAccessViewProviders, isHostSpecialCase) {\n  const nodeProviderIndexes = tNode.providerIndexes;\n  const tInjectables = tView.data;\n  const injectablesStart = nodeProviderIndexes & 1048575 /* TNodeProviderIndexes.ProvidersStartIndexMask */;\n  const directivesStart = tNode.directiveStart;\n  const directiveEnd = tNode.directiveEnd;\n  const cptViewProvidersCount = nodeProviderIndexes >> 20 /* TNodeProviderIndexes.CptViewProvidersCountShift */;\n  const startingIndex = canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount;\n  // When the host special case applies, only the viewProviders and the component are visible\n  const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;\n  for (let i = startingIndex; i < endIndex; i++) {\n    const providerTokenOrDef = tInjectables[i];\n    if (i < directivesStart && token === providerTokenOrDef || i >= directivesStart && providerTokenOrDef.type === token) {\n      return i;\n    }\n  }\n  if (isHostSpecialCase) {\n    const dirDef = tInjectables[directivesStart];\n    if (dirDef && isComponentDef(dirDef) && dirDef.type === token) {\n      return directivesStart;\n    }\n  }\n  return null;\n}\n/**\n * Retrieve or instantiate the injectable from the `LView` at particular `index`.\n *\n * This function checks to see if the value has already been instantiated and if so returns the\n * cached `injectable`. Otherwise if it detects that the value is still a factory it\n * instantiates the `injectable` and caches the value.\n */\nfunction getNodeInjectable(lView, tView, index, tNode) {\n  let value = lView[index];\n  const tData = tView.data;\n  if (isFactory(value)) {\n    const factory = value;\n    if (factory.resolving) {\n      throwCyclicDependencyError(stringifyForError(tData[index]));\n    }\n    const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);\n    factory.resolving = true;\n    let prevInjectContext;\n    if (ngDevMode) {\n      // tData indexes mirror the concrete instances in its corresponding LView.\n      // lView[index] here is either the injectable instace itself or a factory,\n      // therefore tData[index] is the constructor of that injectable or a\n      // definition object that contains the constructor in a `.type` field.\n      const token = tData[index].type || tData[index];\n      const injector = new NodeInjector(tNode, lView);\n      prevInjectContext = setInjectorProfilerContext({\n        injector,\n        token\n      });\n    }\n    const previousInjectImplementation = factory.injectImpl ? setInjectImplementation(factory.injectImpl) : null;\n    const success = enterDI(lView, tNode, InjectFlags.Default);\n    ngDevMode && assertEqual(success, true, 'Because flags do not contain \\`SkipSelf\\' we expect this to always succeed.');\n    try {\n      value = lView[index] = factory.factory(undefined, tData, lView, tNode);\n      ngDevMode && emitInstanceCreatedByInjectorEvent(value);\n      // This code path is hit for both directives and providers.\n      // For perf reasons, we want to avoid searching for hooks on providers.\n      // It does no harm to try (the hooks just won't exist), but the extra\n      // checks are unnecessary and this is a hot path. So we check to see\n      // if the index of the dependency is in the directive range for this\n      // tNode. If it's not, we know it's a provider and skip hook registration.\n      if (tView.firstCreatePass && index >= tNode.directiveStart) {\n        ngDevMode && assertDirectiveDef(tData[index]);\n        registerPreOrderHooks(index, tData[index], tView);\n      }\n    } finally {\n      ngDevMode && setInjectorProfilerContext(prevInjectContext);\n      previousInjectImplementation !== null && setInjectImplementation(previousInjectImplementation);\n      setIncludeViewProviders(previousIncludeViewProviders);\n      factory.resolving = false;\n      leaveDI();\n    }\n  }\n  return value;\n}\n/**\n * Returns the bit in an injector's bloom filter that should be used to determine whether or not\n * the directive might be provided by the injector.\n *\n * When a directive is public, it is added to the bloom filter and given a unique ID that can be\n * retrieved on the Type. When the directive isn't public or the token is not a directive `null`\n * is returned as the node injector can not possibly provide that token.\n *\n * @param token the injection token\n * @returns the matching bit to check in the bloom filter or `null` if the token is not known.\n *   When the returned value is negative then it represents special values such as `Injector`.\n */\nfunction bloomHashBitOrFactory(token) {\n  ngDevMode && assertDefined(token, 'token must be defined');\n  if (typeof token === 'string') {\n    return token.charCodeAt(0) || 0;\n  }\n  const tokenId =\n  // First check with `hasOwnProperty` so we don't get an inherited ID.\n  token.hasOwnProperty(NG_ELEMENT_ID) ? token[NG_ELEMENT_ID] : undefined;\n  // Negative token IDs are used for special objects such as `Injector`\n  if (typeof tokenId === 'number') {\n    if (tokenId >= 0) {\n      return tokenId & BLOOM_MASK;\n    } else {\n      ngDevMode && assertEqual(tokenId, -1 /* InjectorMarkers.Injector */, 'Expecting to get Special Injector Id');\n      return createNodeInjector;\n    }\n  } else {\n    return tokenId;\n  }\n}\nfunction bloomHasToken(bloomHash, injectorIndex, injectorView) {\n  // Create a mask that targets the specific bit associated with the directive we're looking for.\n  // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n  // to bit positions 0 - 31 in a 32 bit integer.\n  const mask = 1 << bloomHash;\n  // Each bloom bucket in `injectorView` represents `BLOOM_BUCKET_BITS` number of bits of\n  // `bloomHash`. Any bits in `bloomHash` beyond `BLOOM_BUCKET_BITS` indicate the bucket offset\n  // that should be used.\n  const value = injectorView[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)];\n  // If the bloom filter value has the bit corresponding to the directive's bloomBit flipped on,\n  // this injector is a potential match.\n  return !!(value & mask);\n}\n/** Returns true if flags prevent parent injector from being searched for tokens */\nfunction shouldSearchParent(flags, isFirstHostTNode) {\n  return !(flags & InjectFlags.Self) && !(flags & InjectFlags.Host && isFirstHostTNode);\n}\nfunction getNodeInjectorLView(nodeInjector) {\n  return nodeInjector._lView;\n}\nfunction getNodeInjectorTNode(nodeInjector) {\n  return nodeInjector._tNode;\n}\nclass NodeInjector {\n  constructor(_tNode, _lView) {\n    this._tNode = _tNode;\n    this._lView = _lView;\n  }\n  get(token, notFoundValue, flags) {\n    return getOrCreateInjectable(this._tNode, this._lView, token, convertToBitFlags(flags), notFoundValue);\n  }\n}\n/** Creates a `NodeInjector` for the current node. */\nfunction createNodeInjector() {\n  return new NodeInjector(getCurrentTNode(), getLView());\n}\n/**\n * @codeGenApi\n */\nfunction ɵɵgetInheritedFactory(type) {\n  return noSideEffects(() => {\n    const ownConstructor = type.prototype.constructor;\n    const ownFactory = ownConstructor[NG_FACTORY_DEF] || getFactoryOf(ownConstructor);\n    const objectPrototype = Object.prototype;\n    let parent = Object.getPrototypeOf(type.prototype).constructor;\n    // Go up the prototype until we hit `Object`.\n    while (parent && parent !== objectPrototype) {\n      const factory = parent[NG_FACTORY_DEF] || getFactoryOf(parent);\n      // If we hit something that has a factory and the factory isn't the same as the type,\n      // we've found the inherited factory. Note the check that the factory isn't the type's\n      // own factory is redundant in most cases, but if the user has custom decorators on the\n      // class, this lookup will start one level down in the prototype chain, causing us to\n      // find the own factory first and potentially triggering an infinite loop downstream.\n      if (factory && factory !== ownFactory) {\n        return factory;\n      }\n      parent = Object.getPrototypeOf(parent);\n    }\n    // There is no factory defined. Either this was improper usage of inheritance\n    // (no Angular decorator on the superclass) or there is no constructor at all\n    // in the inheritance chain. Since the two cases cannot be distinguished, the\n    // latter has to be assumed.\n    return t => new t();\n  });\n}\nfunction getFactoryOf(type) {\n  if (isForwardRef(type)) {\n    return () => {\n      const factory = getFactoryOf(resolveForwardRef(type));\n      return factory && factory();\n    };\n  }\n  return getFactoryDef(type);\n}\n/**\n * Returns a value from the closest embedded or node injector.\n *\n * @param tNode The Node where the search for the injector should start\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\n * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided\n */\nfunction lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, notFoundValue) {\n  let currentTNode = tNode;\n  let currentLView = lView;\n  // When an LView with an embedded view injector is inserted, it'll likely be interlaced with\n  // nodes who may have injectors (e.g. node injector -> embedded view injector -> node injector).\n  // Since the bloom filters for the node injectors have already been constructed and we don't\n  // have a way of extracting the records from an injector, the only way to maintain the correct\n  // hierarchy when resolving the value is to walk it node-by-node while attempting to resolve\n  // the token at each level.\n  while (currentTNode !== null && currentLView !== null && currentLView[FLAGS] & 2048 /* LViewFlags.HasEmbeddedViewInjector */ && !(currentLView[FLAGS] & 512 /* LViewFlags.IsRoot */)) {\n    ngDevMode && assertTNodeForLView(currentTNode, currentLView);\n    // Note that this lookup on the node injector is using the `Self` flag, because\n    // we don't want the node injector to look at any parent injectors since we\n    // may hit the embedded view injector first.\n    const nodeInjectorValue = lookupTokenUsingNodeInjector(currentTNode, currentLView, token, flags | InjectFlags.Self, NOT_FOUND);\n    if (nodeInjectorValue !== NOT_FOUND) {\n      return nodeInjectorValue;\n    }\n    // Has an explicit type due to a TS bug: https://github.com/microsoft/TypeScript/issues/33191\n    let parentTNode = currentTNode.parent;\n    // `TNode.parent` includes the parent within the current view only. If it doesn't exist,\n    // it means that we've hit the view boundary and we need to go up to the next view.\n    if (!parentTNode) {\n      // Before we go to the next LView, check if the token exists on the current embedded injector.\n      const embeddedViewInjector = currentLView[EMBEDDED_VIEW_INJECTOR];\n      if (embeddedViewInjector) {\n        const embeddedViewInjectorValue = embeddedViewInjector.get(token, NOT_FOUND, flags);\n        if (embeddedViewInjectorValue !== NOT_FOUND) {\n          return embeddedViewInjectorValue;\n        }\n      }\n      // Otherwise keep going up the tree.\n      parentTNode = getTNodeFromLView(currentLView);\n      currentLView = currentLView[DECLARATION_VIEW];\n    }\n    currentTNode = parentTNode;\n  }\n  return notFoundValue;\n}\n/** Gets the TNode associated with an LView inside of the declaration view. */\nfunction getTNodeFromLView(lView) {\n  const tView = lView[TVIEW];\n  const tViewType = tView.type;\n  // The parent pointer differs based on `TView.type`.\n  if (tViewType === 2 /* TViewType.Embedded */) {\n    ngDevMode && assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');\n    return tView.declTNode;\n  } else if (tViewType === 1 /* TViewType.Component */) {\n    // Components don't have `TView.declTNode` because each instance of component could be\n    // inserted in different location, hence `TView.declTNode` is meaningless.\n    return lView[T_HOST];\n  }\n  return null;\n}\n\n/**\n * Facade for the attribute injection from DI.\n *\n * @codeGenApi\n */\nfunction ɵɵinjectAttribute(attrNameToInject) {\n  return injectAttributeImpl(getCurrentTNode(), attrNameToInject);\n}\n\n/**\n * Attribute decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Attribute = makeParamDecorator('Attribute', attributeName => ({\n  attributeName,\n  __NG_ELEMENT_ID__: () => ɵɵinjectAttribute(attributeName)\n}));\nlet _reflect = null;\nfunction getReflect() {\n  return _reflect = _reflect || new ReflectionCapabilities();\n}\nfunction reflectDependencies(type) {\n  return convertDependencies(getReflect().parameters(type));\n}\nfunction convertDependencies(deps) {\n  return deps.map(dep => reflectDependency(dep));\n}\nfunction reflectDependency(dep) {\n  const meta = {\n    token: null,\n    attribute: null,\n    host: false,\n    optional: false,\n    self: false,\n    skipSelf: false\n  };\n  if (Array.isArray(dep) && dep.length > 0) {\n    for (let j = 0; j < dep.length; j++) {\n      const param = dep[j];\n      if (param === undefined) {\n        // param may be undefined if type of dep is not set by ngtsc\n        continue;\n      }\n      const proto = Object.getPrototypeOf(param);\n      if (param instanceof Optional || proto.ngMetadataName === 'Optional') {\n        meta.optional = true;\n      } else if (param instanceof SkipSelf || proto.ngMetadataName === 'SkipSelf') {\n        meta.skipSelf = true;\n      } else if (param instanceof Self || proto.ngMetadataName === 'Self') {\n        meta.self = true;\n      } else if (param instanceof Host || proto.ngMetadataName === 'Host') {\n        meta.host = true;\n      } else if (param instanceof Inject) {\n        meta.token = param.token;\n      } else if (param instanceof Attribute) {\n        if (param.attributeName === undefined) {\n          throw new RuntimeError(204 /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */, ngDevMode && `Attribute name must be defined.`);\n        }\n        meta.attribute = param.attributeName;\n      } else {\n        meta.token = param;\n      }\n    }\n  } else if (dep === undefined || Array.isArray(dep) && dep.length === 0) {\n    meta.token = null;\n  } else {\n    meta.token = dep;\n  }\n  return meta;\n}\n\n/**\n * Map of module-id to the corresponding NgModule.\n */\nconst modules = new Map();\n/**\n * Whether to check for duplicate NgModule registrations.\n *\n * This can be disabled for testing.\n */\nlet checkForDuplicateNgModules = true;\nfunction assertSameOrNotExisting(id, type, incoming) {\n  if (type && type !== incoming && checkForDuplicateNgModules) {\n    throw new Error(`Duplicate module registered for ${id} - ${stringify(type)} vs ${stringify(type.name)}`);\n  }\n}\n/**\n * Adds the given NgModule type to Angular's NgModule registry.\n *\n * This is generated as a side-effect of NgModule compilation. Note that the `id` is passed in\n * explicitly and not read from the NgModule definition. This is for two reasons: it avoids a\n * megamorphic read, and in JIT there's a chicken-and-egg problem where the NgModule may not be\n * fully resolved when it's registered.\n *\n * @codeGenApi\n */\nfunction registerNgModuleType(ngModuleType, id) {\n  const existing = modules.get(id) || null;\n  assertSameOrNotExisting(id, existing, ngModuleType);\n  modules.set(id, ngModuleType);\n}\nfunction clearModulesForTest() {\n  modules.clear();\n}\nfunction getRegisteredNgModuleType(id) {\n  return modules.get(id);\n}\n/**\n * Control whether the NgModule registration system enforces that each NgModule type registered has\n * a unique id.\n *\n * This is useful for testing as the NgModule registry cannot be properly reset between tests with\n * Angular's current API.\n */\nfunction setAllowDuplicateNgModuleIdsForTest(allowDuplicates) {\n  checkForDuplicateNgModules = !allowDuplicates;\n}\n\n/**\n * Creates a token that can be used in a DI Provider.\n *\n * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a\n * runtime representation) such as when injecting an interface, callable type, array or\n * parameterized type.\n *\n * `InjectionToken` is parameterized on `T` which is the type of object which will be returned by\n * the `Injector`. This provides an additional level of type safety.\n *\n * <div class=\"alert is-helpful\">\n *\n * **Important Note**: Ensure that you use the same instance of the `InjectionToken` in both the\n * provider and the injection call. Creating a new instance of `InjectionToken` in different places,\n * even with the same description, will be treated as different tokens by Angular's DI system,\n * leading to a `NullInjectorError`.\n *\n * </div>\n *\n * <code-example format=\"typescript\" language=\"typescript\" path=\"injection-token/src/main.ts\"\n * region=\"InjectionToken\"></code-example>\n *\n * When creating an `InjectionToken`, you can optionally specify a factory function which returns\n * (possibly by creating) a default value of the parameterized type `T`. This sets up the\n * `InjectionToken` using this factory as a provider as if it was defined explicitly in the\n * application's root injector. If the factory function, which takes zero arguments, needs to inject\n * dependencies, it can do so using the [`inject`](api/core/inject) function.\n * As you can see in the Tree-shakable InjectionToken example below.\n *\n * Additionally, if a `factory` is specified you can also specify the `providedIn` option, which\n * overrides the above behavior and marks the token as belonging to a particular `@NgModule` (note:\n * this option is now deprecated). As mentioned above, `'root'` is the default value for\n * `providedIn`.\n *\n * The `providedIn: NgModule` and `providedIn: 'any'` options are deprecated.\n *\n * @usageNotes\n * ### Basic Examples\n *\n * ### Plain InjectionToken\n *\n * {@example core/di/ts/injector_spec.ts region='InjectionToken'}\n *\n * ### Tree-shakable InjectionToken\n *\n * {@example core/di/ts/injector_spec.ts region='ShakableInjectionToken'}\n *\n * @publicApi\n */\nclass InjectionToken {\n  /**\n   * @param _desc   Description for the token,\n   *                used only for debugging purposes,\n   *                it should but does not need to be unique\n   * @param options Options for the token's usage, as described above\n   */\n  constructor(_desc, options) {\n    this._desc = _desc;\n    /** @internal */\n    this.ngMetadataName = 'InjectionToken';\n    this.ɵprov = undefined;\n    if (typeof options == 'number') {\n      (typeof ngDevMode === 'undefined' || ngDevMode) && assertLessThan(options, 0, 'Only negative numbers are supported here');\n      // This is a special hack to assign __NG_ELEMENT_ID__ to this instance.\n      // See `InjectorMarkers`\n      this.__NG_ELEMENT_ID__ = options;\n    } else if (options !== undefined) {\n      this.ɵprov = ɵɵdefineInjectable({\n        token: this,\n        providedIn: options.providedIn || 'root',\n        factory: options.factory\n      });\n    }\n  }\n  /**\n   * @internal\n   */\n  get multi() {\n    return this;\n  }\n  toString() {\n    return `InjectionToken ${this._desc}`;\n  }\n}\n\n/**\n * Most of the use of `document` in Angular is from within the DI system so it is possible to simply\n * inject the `DOCUMENT` token and are done.\n *\n * Ivy is special because it does not rely upon the DI and must get hold of the document some other\n * way.\n *\n * The solution is to define `getDocument()` and `setDocument()` top-level functions for ivy.\n * Wherever ivy needs the global document, it calls `getDocument()` instead.\n *\n * When running ivy outside of a browser environment, it is necessary to call `setDocument()` to\n * tell ivy what the global `document` is.\n *\n * Angular does this for us in each of the standard platforms (`Browser` and `Server`)\n * by calling `setDocument()` when providing the `DOCUMENT` token.\n */\nlet DOCUMENT = undefined;\n/**\n * Tell ivy what the `document` is for this platform.\n *\n * It is only necessary to call this if the current platform is not a browser.\n *\n * @param document The object representing the global `document` in this environment.\n */\nfunction setDocument(document) {\n  DOCUMENT = document;\n}\n/**\n * Access the object that represents the `document` for this platform.\n *\n * Ivy calls this whenever it needs to access the `document` object.\n * For example to create the renderer or to do sanitization.\n */\nfunction getDocument() {\n  if (DOCUMENT !== undefined) {\n    return DOCUMENT;\n  } else if (typeof document !== 'undefined') {\n    return document;\n  }\n  throw new RuntimeError(210 /* RuntimeErrorCode.MISSING_DOCUMENT */, (typeof ngDevMode === 'undefined' || ngDevMode) && `The document object is not available in this context. Make sure the DOCUMENT injection token is provided.`);\n  // No \"document\" can be found. This should only happen if we are running ivy outside Angular and\n  // the current platform is not a browser. Since this is not a supported scenario at the moment\n  // this should not happen in Angular apps.\n  // Once we support running ivy outside of Angular we will need to publish `setDocument()` as a\n  // public API.\n}\n\n/**\n * A [DI token](guide/glossary#di-token \"DI token definition\") representing a string ID, used\n * primarily for prefixing application attributes and CSS styles when\n * {@link ViewEncapsulation#Emulated} is being used.\n *\n * The token is needed in cases when multiple applications are bootstrapped on a page\n * (for example, using `bootstrapApplication` calls). In this case, ensure that those applications\n * have different `APP_ID` value setup. For example:\n *\n * ```\n * bootstrapApplication(ComponentA, {\n *   providers: [\n *     { provide: APP_ID, useValue: 'app-a' },\n *     // ... other providers ...\n *   ]\n * });\n *\n * bootstrapApplication(ComponentB, {\n *   providers: [\n *     { provide: APP_ID, useValue: 'app-b' },\n *     // ... other providers ...\n *   ]\n * });\n * ```\n *\n * By default, when there is only one application bootstrapped, you don't need to provide the\n * `APP_ID` token (the `ng` will be used as an app ID).\n *\n * @publicApi\n */\nconst APP_ID = new InjectionToken('AppId', {\n  providedIn: 'root',\n  factory: () => DEFAULT_APP_ID\n});\n/** Default value of the `APP_ID` token. */\nconst DEFAULT_APP_ID = 'ng';\n/**\n * A function that is executed when a platform is initialized.\n * @publicApi\n */\nconst PLATFORM_INITIALIZER = new InjectionToken('Platform Initializer');\n/**\n * A token that indicates an opaque platform ID.\n * @publicApi\n */\nconst PLATFORM_ID = new InjectionToken('Platform ID', {\n  providedIn: 'platform',\n  factory: () => 'unknown' // set a default platform name, when none set explicitly\n});\n/**\n * A [DI token](guide/glossary#di-token \"DI token definition\") that indicates the root directory of\n * the application\n * @publicApi\n * @deprecated\n */\nconst PACKAGE_ROOT_URL = new InjectionToken('Application Packages Root URL');\n// We keep this token here, rather than the animations package, so that modules that only care\n// about which animations module is loaded (e.g. the CDK) can retrieve it without having to\n// include extra dependencies. See #44970 for more context.\n/**\n * A [DI token](guide/glossary#di-token \"DI token definition\") that indicates which animations\n * module has been loaded.\n * @publicApi\n */\nconst ANIMATION_MODULE_TYPE = new InjectionToken('AnimationModuleType');\n// TODO(crisbeto): link to CSP guide here.\n/**\n * Token used to configure the [Content Security Policy](https://web.dev/strict-csp/) nonce that\n * Angular will apply when inserting inline styles. If not provided, Angular will look up its value\n * from the `ngCspNonce` attribute of the application root node.\n *\n * @publicApi\n */\nconst CSP_NONCE = new InjectionToken('CSP nonce', {\n  providedIn: 'root',\n  factory: () => {\n    // Ideally we wouldn't have to use `querySelector` here since we know that the nonce will be on\n    // the root node, but because the token value is used in renderers, it has to be available\n    // *very* early in the bootstrapping process. This should be a fairly shallow search, because\n    // the app won't have been added to the DOM yet. Some approaches that were considered:\n    // 1. Find the root node through `ApplicationRef.components[i].location` - normally this would\n    // be enough for our purposes, but the token is injected very early so the `components` array\n    // isn't populated yet.\n    // 2. Find the root `LView` through the current `LView` - renderers are a prerequisite to\n    // creating the `LView`. This means that no `LView` will have been entered when this factory is\n    // invoked for the root component.\n    // 3. Have the token factory return `() => string` which is invoked when a nonce is requested -\n    // the slightly later execution does allow us to get an `LView` reference, but the fact that\n    // it is a function means that it could be executed at *any* time (including immediately) which\n    // may lead to weird bugs.\n    // 4. Have the `ComponentFactory` read the attribute and provide it to the injector under the\n    // hood - has the same problem as #1 and #2 in that the renderer is used to query for the root\n    // node and the nonce value needs to be available when the renderer is created.\n    return getDocument().body?.querySelector('[ngCspNonce]')?.getAttribute('ngCspNonce') || null;\n  }\n});\n/**\n * Internal token to collect all SSR-related features enabled for this application.\n *\n * Note: the token is in `core` to let other packages register features (the `core`\n * package is imported in other packages).\n */\nconst ENABLED_SSR_FEATURES = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'ENABLED_SSR_FEATURES' : '', {\n  providedIn: 'root',\n  factory: () => new Set()\n});\n\n/**\n * A multi-provider token for initialization functions that will run upon construction of an\n * environment injector.\n *\n * @publicApi\n */\nconst ENVIRONMENT_INITIALIZER = new InjectionToken('ENVIRONMENT_INITIALIZER');\n\n/**\n * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.\n *\n * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a\n * project.\n *\n * @publicApi\n */\nconst INJECTOR = new InjectionToken('INJECTOR',\n// Disable tslint because this is const enum which gets inlined not top level prop access.\n// tslint:disable-next-line: no-toplevel-property-access\n-1 /* InjectorMarkers.Injector */);\n\nconst INJECTOR_DEF_TYPES = new InjectionToken('INJECTOR_DEF_TYPES');\nclass NullInjector {\n  get(token, notFoundValue = THROW_IF_NOT_FOUND) {\n    if (notFoundValue === THROW_IF_NOT_FOUND) {\n      const error = new Error(`NullInjectorError: No provider for ${stringify(token)}!`);\n      error.name = 'NullInjectorError';\n      throw error;\n    }\n    return notFoundValue;\n  }\n}\n\n/**\n * Wrap an array of `Provider`s into `EnvironmentProviders`, preventing them from being accidentally\n * referenced in `@Component` in a component injector.\n */\nfunction makeEnvironmentProviders(providers) {\n  return {\n    ɵproviders: providers\n  };\n}\n/**\n * Collects providers from all NgModules and standalone components, including transitively imported\n * ones.\n *\n * Providers extracted via `importProvidersFrom` are only usable in an application injector or\n * another environment injector (such as a route injector). They should not be used in component\n * providers.\n *\n * More information about standalone components can be found in [this\n * guide](guide/standalone-components).\n *\n * @usageNotes\n * The results of the `importProvidersFrom` call can be used in the `bootstrapApplication` call:\n *\n * ```typescript\n * await bootstrapApplication(RootComponent, {\n *   providers: [\n *     importProvidersFrom(NgModuleOne, NgModuleTwo)\n *   ]\n * });\n * ```\n *\n * You can also use the `importProvidersFrom` results in the `providers` field of a route, when a\n * standalone component is used:\n *\n * ```typescript\n * export const ROUTES: Route[] = [\n *   {\n *     path: 'foo',\n *     providers: [\n *       importProvidersFrom(NgModuleOne, NgModuleTwo)\n *     ],\n *     component: YourStandaloneComponent\n *   }\n * ];\n * ```\n *\n * @returns Collected providers from the specified list of types.\n * @publicApi\n */\nfunction importProvidersFrom(...sources) {\n  return {\n    ɵproviders: internalImportProvidersFrom(true, sources),\n    ɵfromNgModule: true\n  };\n}\nfunction internalImportProvidersFrom(checkForStandaloneCmp, ...sources) {\n  const providersOut = [];\n  const dedup = new Set(); // already seen types\n  let injectorTypesWithProviders;\n  const collectProviders = provider => {\n    providersOut.push(provider);\n  };\n  deepForEach(sources, source => {\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && checkForStandaloneCmp) {\n      const cmpDef = getComponentDef$1(source);\n      if (cmpDef?.standalone) {\n        throw new RuntimeError(800 /* RuntimeErrorCode.IMPORT_PROVIDERS_FROM_STANDALONE */, `Importing providers supports NgModule or ModuleWithProviders but got a standalone component \"${stringifyForError(source)}\"`);\n      }\n    }\n    // Narrow `source` to access the internal type analogue for `ModuleWithProviders`.\n    const internalSource = source;\n    if (walkProviderTree(internalSource, collectProviders, [], dedup)) {\n      injectorTypesWithProviders ||= [];\n      injectorTypesWithProviders.push(internalSource);\n    }\n  });\n  // Collect all providers from `ModuleWithProviders` types.\n  if (injectorTypesWithProviders !== undefined) {\n    processInjectorTypesWithProviders(injectorTypesWithProviders, collectProviders);\n  }\n  return providersOut;\n}\n/**\n * Collects all providers from the list of `ModuleWithProviders` and appends them to the provided\n * array.\n */\nfunction processInjectorTypesWithProviders(typesWithProviders, visitor) {\n  for (let i = 0; i < typesWithProviders.length; i++) {\n    const {\n      ngModule,\n      providers\n    } = typesWithProviders[i];\n    deepForEachProvider(providers, provider => {\n      ngDevMode && validateProvider(provider, providers || EMPTY_ARRAY, ngModule);\n      visitor(provider, ngModule);\n    });\n  }\n}\n/**\n * The logic visits an `InjectorType`, an `InjectorTypeWithProviders`, or a standalone\n * `ComponentType`, and all of its transitive providers and collects providers.\n *\n * If an `InjectorTypeWithProviders` that declares providers besides the type is specified,\n * the function will return \"true\" to indicate that the providers of the type definition need\n * to be processed. This allows us to process providers of injector types after all imports of\n * an injector definition are processed. (following View Engine semantics: see FW-1349)\n */\nfunction walkProviderTree(container, visitor, parents, dedup) {\n  container = resolveForwardRef(container);\n  if (!container) return false;\n  // The actual type which had the definition. Usually `container`, but may be an unwrapped type\n  // from `InjectorTypeWithProviders`.\n  let defType = null;\n  let injDef = getInjectorDef(container);\n  const cmpDef = !injDef && getComponentDef$1(container);\n  if (!injDef && !cmpDef) {\n    // `container` is not an injector type or a component type. It might be:\n    //  * An `InjectorTypeWithProviders` that wraps an injector type.\n    //  * A standalone directive or pipe that got pulled in from a standalone component's\n    //    dependencies.\n    // Try to unwrap it as an `InjectorTypeWithProviders` first.\n    const ngModule = container.ngModule;\n    injDef = getInjectorDef(ngModule);\n    if (injDef) {\n      defType = ngModule;\n    } else {\n      // Not a component or injector type, so ignore it.\n      return false;\n    }\n  } else if (cmpDef && !cmpDef.standalone) {\n    return false;\n  } else {\n    defType = container;\n  }\n  // Check for circular dependencies.\n  if (ngDevMode && parents.indexOf(defType) !== -1) {\n    const defName = stringify(defType);\n    const path = parents.map(stringify);\n    throwCyclicDependencyError(defName, path);\n  }\n  // Check for multiple imports of the same module\n  const isDuplicate = dedup.has(defType);\n  if (cmpDef) {\n    if (isDuplicate) {\n      // This component definition has already been processed.\n      return false;\n    }\n    dedup.add(defType);\n    if (cmpDef.dependencies) {\n      const deps = typeof cmpDef.dependencies === 'function' ? cmpDef.dependencies() : cmpDef.dependencies;\n      for (const dep of deps) {\n        walkProviderTree(dep, visitor, parents, dedup);\n      }\n    }\n  } else if (injDef) {\n    // First, include providers from any imports.\n    if (injDef.imports != null && !isDuplicate) {\n      // Before processing defType's imports, add it to the set of parents. This way, if it ends\n      // up deeply importing itself, this can be detected.\n      ngDevMode && parents.push(defType);\n      // Add it to the set of dedups. This way we can detect multiple imports of the same module\n      dedup.add(defType);\n      let importTypesWithProviders;\n      try {\n        deepForEach(injDef.imports, imported => {\n          if (walkProviderTree(imported, visitor, parents, dedup)) {\n            importTypesWithProviders ||= [];\n            // If the processed import is an injector type with providers, we store it in the\n            // list of import types with providers, so that we can process those afterwards.\n            importTypesWithProviders.push(imported);\n          }\n        });\n      } finally {\n        // Remove it from the parents set when finished.\n        ngDevMode && parents.pop();\n      }\n      // Imports which are declared with providers (TypeWithProviders) need to be processed\n      // after all imported modules are processed. This is similar to how View Engine\n      // processes/merges module imports in the metadata resolver. See: FW-1349.\n      if (importTypesWithProviders !== undefined) {\n        processInjectorTypesWithProviders(importTypesWithProviders, visitor);\n      }\n    }\n    if (!isDuplicate) {\n      // Track the InjectorType and add a provider for it.\n      // It's important that this is done after the def's imports.\n      const factory = getFactoryDef(defType) || (() => new defType());\n      // Append extra providers to make more info available for consumers (to retrieve an injector\n      // type), as well as internally (to calculate an injection scope correctly and eagerly\n      // instantiate a `defType` when an injector is created).\n      // Provider to create `defType` using its factory.\n      visitor({\n        provide: defType,\n        useFactory: factory,\n        deps: EMPTY_ARRAY\n      }, defType);\n      // Make this `defType` available to an internal logic that calculates injector scope.\n      visitor({\n        provide: INJECTOR_DEF_TYPES,\n        useValue: defType,\n        multi: true\n      }, defType);\n      // Provider to eagerly instantiate `defType` via `INJECTOR_INITIALIZER`.\n      visitor({\n        provide: ENVIRONMENT_INITIALIZER,\n        useValue: () => ɵɵinject(defType),\n        multi: true\n      }, defType);\n    }\n    // Next, include providers listed on the definition itself.\n    const defProviders = injDef.providers;\n    if (defProviders != null && !isDuplicate) {\n      const injectorType = container;\n      deepForEachProvider(defProviders, provider => {\n        ngDevMode && validateProvider(provider, defProviders, injectorType);\n        visitor(provider, injectorType);\n      });\n    }\n  } else {\n    // Should not happen, but just in case.\n    return false;\n  }\n  return defType !== container && container.providers !== undefined;\n}\nfunction validateProvider(provider, providers, containerType) {\n  if (isTypeProvider(provider) || isValueProvider(provider) || isFactoryProvider(provider) || isExistingProvider(provider)) {\n    return;\n  }\n  // Here we expect the provider to be a `useClass` provider (by elimination).\n  const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));\n  if (!classRef) {\n    throwInvalidProviderError(containerType, providers, provider);\n  }\n}\nfunction deepForEachProvider(providers, fn) {\n  for (let provider of providers) {\n    if (isEnvironmentProviders(provider)) {\n      provider = provider.ɵproviders;\n    }\n    if (Array.isArray(provider)) {\n      deepForEachProvider(provider, fn);\n    } else {\n      fn(provider);\n    }\n  }\n}\nconst USE_VALUE$1 = getClosureSafeProperty({\n  provide: String,\n  useValue: getClosureSafeProperty\n});\nfunction isValueProvider(value) {\n  return value !== null && typeof value == 'object' && USE_VALUE$1 in value;\n}\nfunction isExistingProvider(value) {\n  return !!(value && value.useExisting);\n}\nfunction isFactoryProvider(value) {\n  return !!(value && value.useFactory);\n}\nfunction isTypeProvider(value) {\n  return typeof value === 'function';\n}\nfunction isClassProvider(value) {\n  return !!value.useClass;\n}\n\n/**\n * An internal token whose presence in an injector indicates that the injector should treat itself\n * as a root scoped injector when processing requests for unknown tokens which may indicate\n * they are provided in the root scope.\n */\nconst INJECTOR_SCOPE = new InjectionToken('Set Injector scope.');\n\n/**\n * Marker which indicates that a value has not yet been created from the factory function.\n */\nconst NOT_YET = {};\n/**\n * Marker which indicates that the factory function for a token is in the process of being called.\n *\n * If the injector is asked to inject a token with its value set to CIRCULAR, that indicates\n * injection of a dependency has recursively attempted to inject the original token, and there is\n * a circular dependency among the providers.\n */\nconst CIRCULAR = {};\n/**\n * A lazily initialized NullInjector.\n */\nlet NULL_INJECTOR = undefined;\nfunction getNullInjector() {\n  if (NULL_INJECTOR === undefined) {\n    NULL_INJECTOR = new NullInjector();\n  }\n  return NULL_INJECTOR;\n}\n/**\n * An `Injector` that's part of the environment injector hierarchy, which exists outside of the\n * component tree.\n */\nclass EnvironmentInjector {}\nclass R3Injector extends EnvironmentInjector {\n  /**\n   * Flag indicating that this injector was previously destroyed.\n   */\n  get destroyed() {\n    return this._destroyed;\n  }\n  constructor(providers, parent, source, scopes) {\n    super();\n    this.parent = parent;\n    this.source = source;\n    this.scopes = scopes;\n    /**\n     * Map of tokens to records which contain the instances of those tokens.\n     * - `null` value implies that we don't have the record. Used by tree-shakable injectors\n     * to prevent further searches.\n     */\n    this.records = new Map();\n    /**\n     * Set of values instantiated by this injector which contain `ngOnDestroy` lifecycle hooks.\n     */\n    this._ngOnDestroyHooks = new Set();\n    this._onDestroyHooks = [];\n    this._destroyed = false;\n    // Start off by creating Records for every provider.\n    forEachSingleProvider(providers, provider => this.processProvider(provider));\n    // Make sure the INJECTOR token provides this injector.\n    this.records.set(INJECTOR, makeRecord(undefined, this));\n    // And `EnvironmentInjector` if the current injector is supposed to be env-scoped.\n    if (scopes.has('environment')) {\n      this.records.set(EnvironmentInjector, makeRecord(undefined, this));\n    }\n    // Detect whether this injector has the APP_ROOT_SCOPE token and thus should provide\n    // any injectable scoped to APP_ROOT_SCOPE.\n    const record = this.records.get(INJECTOR_SCOPE);\n    if (record != null && typeof record.value === 'string') {\n      this.scopes.add(record.value);\n    }\n    this.injectorDefTypes = new Set(this.get(INJECTOR_DEF_TYPES.multi, EMPTY_ARRAY, InjectFlags.Self));\n  }\n  /**\n   * Destroy the injector and release references to every instance or provider associated with it.\n   *\n   * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a\n   * hook was found.\n   */\n  destroy() {\n    this.assertNotDestroyed();\n    // Set destroyed = true first, in case lifecycle hooks re-enter destroy().\n    this._destroyed = true;\n    try {\n      // Call all the lifecycle hooks.\n      for (const service of this._ngOnDestroyHooks) {\n        service.ngOnDestroy();\n      }\n      const onDestroyHooks = this._onDestroyHooks;\n      // Reset the _onDestroyHooks array before iterating over it to prevent hooks that unregister\n      // themselves from mutating the array during iteration.\n      this._onDestroyHooks = [];\n      for (const hook of onDestroyHooks) {\n        hook();\n      }\n    } finally {\n      // Release all references.\n      this.records.clear();\n      this._ngOnDestroyHooks.clear();\n      this.injectorDefTypes.clear();\n    }\n  }\n  onDestroy(callback) {\n    this.assertNotDestroyed();\n    this._onDestroyHooks.push(callback);\n    return () => this.removeOnDestroy(callback);\n  }\n  runInContext(fn) {\n    this.assertNotDestroyed();\n    const previousInjector = setCurrentInjector(this);\n    const previousInjectImplementation = setInjectImplementation(undefined);\n    let prevInjectContext;\n    if (ngDevMode) {\n      prevInjectContext = setInjectorProfilerContext({\n        injector: this,\n        token: null\n      });\n    }\n    try {\n      return fn();\n    } finally {\n      setCurrentInjector(previousInjector);\n      setInjectImplementation(previousInjectImplementation);\n      ngDevMode && setInjectorProfilerContext(prevInjectContext);\n    }\n  }\n  get(token, notFoundValue = THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n    this.assertNotDestroyed();\n    if (token.hasOwnProperty(NG_ENV_ID)) {\n      return token[NG_ENV_ID](this);\n    }\n    flags = convertToBitFlags(flags);\n    // Set the injection context.\n    let prevInjectContext;\n    if (ngDevMode) {\n      prevInjectContext = setInjectorProfilerContext({\n        injector: this,\n        token: token\n      });\n    }\n    const previousInjector = setCurrentInjector(this);\n    const previousInjectImplementation = setInjectImplementation(undefined);\n    try {\n      // Check for the SkipSelf flag.\n      if (!(flags & InjectFlags.SkipSelf)) {\n        // SkipSelf isn't set, check if the record belongs to this injector.\n        let record = this.records.get(token);\n        if (record === undefined) {\n          // No record, but maybe the token is scoped to this injector. Look for an injectable\n          // def with a scope matching this injector.\n          const def = couldBeInjectableType(token) && getInjectableDef(token);\n          if (def && this.injectableDefInScope(def)) {\n            // Found an injectable def and it's scoped to this injector. Pretend as if it was here\n            // all along.\n            record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);\n          } else {\n            record = null;\n          }\n          this.records.set(token, record);\n        }\n        // If a record was found, get the instance for it and return it.\n        if (record != null /* NOT null || undefined */) {\n          return this.hydrate(token, record);\n        }\n      }\n      // Select the next injector based on the Self flag - if self is set, the next injector is\n      // the NullInjector, otherwise it's the parent.\n      const nextInjector = !(flags & InjectFlags.Self) ? this.parent : getNullInjector();\n      // Set the notFoundValue based on the Optional flag - if optional is set and notFoundValue\n      // is undefined, the value is null, otherwise it's the notFoundValue.\n      notFoundValue = flags & InjectFlags.Optional && notFoundValue === THROW_IF_NOT_FOUND ? null : notFoundValue;\n      return nextInjector.get(token, notFoundValue);\n    } catch (e) {\n      if (e.name === 'NullInjectorError') {\n        const path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];\n        path.unshift(stringify(token));\n        if (previousInjector) {\n          // We still have a parent injector, keep throwing\n          throw e;\n        } else {\n          // Format & throw the final error message when we don't have any previous injector\n          return catchInjectorError(e, token, 'R3InjectorError', this.source);\n        }\n      } else {\n        throw e;\n      }\n    } finally {\n      // Lastly, restore the previous injection context.\n      setInjectImplementation(previousInjectImplementation);\n      setCurrentInjector(previousInjector);\n      ngDevMode && setInjectorProfilerContext(prevInjectContext);\n    }\n  }\n  /** @internal */\n  resolveInjectorInitializers() {\n    const previousInjector = setCurrentInjector(this);\n    const previousInjectImplementation = setInjectImplementation(undefined);\n    let prevInjectContext;\n    if (ngDevMode) {\n      prevInjectContext = setInjectorProfilerContext({\n        injector: this,\n        token: null\n      });\n    }\n    try {\n      const initializers = this.get(ENVIRONMENT_INITIALIZER.multi, EMPTY_ARRAY, InjectFlags.Self);\n      if (ngDevMode && !Array.isArray(initializers)) {\n        throw new RuntimeError(-209 /* RuntimeErrorCode.INVALID_MULTI_PROVIDER */, 'Unexpected type of the `ENVIRONMENT_INITIALIZER` token value ' + `(expected an array, but got ${typeof initializers}). ` + 'Please check that the `ENVIRONMENT_INITIALIZER` token is configured as a ' + '`multi: true` provider.');\n      }\n      for (const initializer of initializers) {\n        initializer();\n      }\n    } finally {\n      setCurrentInjector(previousInjector);\n      setInjectImplementation(previousInjectImplementation);\n      ngDevMode && setInjectorProfilerContext(prevInjectContext);\n    }\n  }\n  toString() {\n    const tokens = [];\n    const records = this.records;\n    for (const token of records.keys()) {\n      tokens.push(stringify(token));\n    }\n    return `R3Injector[${tokens.join(', ')}]`;\n  }\n  assertNotDestroyed() {\n    if (this._destroyed) {\n      throw new RuntimeError(205 /* RuntimeErrorCode.INJECTOR_ALREADY_DESTROYED */, ngDevMode && 'Injector has already been destroyed.');\n    }\n  }\n  /**\n   * Process a `SingleProvider` and add it.\n   */\n  processProvider(provider) {\n    // Determine the token from the provider. Either it's its own token, or has a {provide: ...}\n    // property.\n    provider = resolveForwardRef(provider);\n    let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider && provider.provide);\n    // Construct a `Record` for the provider.\n    const record = providerToRecord(provider);\n    if (ngDevMode) {\n      runInInjectorProfilerContext(this, token, () => {\n        // Emit InjectorProfilerEventType.Create if provider is a value provider because\n        // these are the only providers that do not go through the value hydration logic\n        // where this event would normally be emitted from.\n        if (isValueProvider(provider)) {\n          emitInstanceCreatedByInjectorEvent(provider.useValue);\n        }\n        emitProviderConfiguredEvent(provider);\n      });\n    }\n    if (!isTypeProvider(provider) && provider.multi === true) {\n      // If the provider indicates that it's a multi-provider, process it specially.\n      // First check whether it's been defined already.\n      let multiRecord = this.records.get(token);\n      if (multiRecord) {\n        // It has. Throw a nice error if\n        if (ngDevMode && multiRecord.multi === undefined) {\n          throwMixedMultiProviderError();\n        }\n      } else {\n        multiRecord = makeRecord(undefined, NOT_YET, true);\n        multiRecord.factory = () => injectArgs(multiRecord.multi);\n        this.records.set(token, multiRecord);\n      }\n      token = provider;\n      multiRecord.multi.push(provider);\n    } else {\n      const existing = this.records.get(token);\n      if (ngDevMode && existing && existing.multi !== undefined) {\n        throwMixedMultiProviderError();\n      }\n    }\n    this.records.set(token, record);\n  }\n  hydrate(token, record) {\n    if (ngDevMode && record.value === CIRCULAR) {\n      throwCyclicDependencyError(stringify(token));\n    } else if (record.value === NOT_YET) {\n      record.value = CIRCULAR;\n      if (ngDevMode) {\n        runInInjectorProfilerContext(this, token, () => {\n          record.value = record.factory();\n          emitInstanceCreatedByInjectorEvent(record.value);\n        });\n      } else {\n        record.value = record.factory();\n      }\n    }\n    if (typeof record.value === 'object' && record.value && hasOnDestroy(record.value)) {\n      this._ngOnDestroyHooks.add(record.value);\n    }\n    return record.value;\n  }\n  injectableDefInScope(def) {\n    if (!def.providedIn) {\n      return false;\n    }\n    const providedIn = resolveForwardRef(def.providedIn);\n    if (typeof providedIn === 'string') {\n      return providedIn === 'any' || this.scopes.has(providedIn);\n    } else {\n      return this.injectorDefTypes.has(providedIn);\n    }\n  }\n  removeOnDestroy(callback) {\n    const destroyCBIdx = this._onDestroyHooks.indexOf(callback);\n    if (destroyCBIdx !== -1) {\n      this._onDestroyHooks.splice(destroyCBIdx, 1);\n    }\n  }\n}\nfunction injectableDefOrInjectorDefFactory(token) {\n  // Most tokens will have an injectable def directly on them, which specifies a factory directly.\n  const injectableDef = getInjectableDef(token);\n  const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);\n  if (factory !== null) {\n    return factory;\n  }\n  // InjectionTokens should have an injectable def (ɵprov) and thus should be handled above.\n  // If it's missing that, it's an error.\n  if (token instanceof InjectionToken) {\n    throw new RuntimeError(204 /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */, ngDevMode && `Token ${stringify(token)} is missing a ɵprov definition.`);\n  }\n  // Undecorated types can sometimes be created if they have no constructor arguments.\n  if (token instanceof Function) {\n    return getUndecoratedInjectableFactory(token);\n  }\n  // There was no way to resolve a factory for this token.\n  throw new RuntimeError(204 /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */, ngDevMode && 'unreachable');\n}\nfunction getUndecoratedInjectableFactory(token) {\n  // If the token has parameters then it has dependencies that we cannot resolve implicitly.\n  const paramLength = token.length;\n  if (paramLength > 0) {\n    const args = newArray(paramLength, '?');\n    throw new RuntimeError(204 /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */, ngDevMode && `Can't resolve all parameters for ${stringify(token)}: (${args.join(', ')}).`);\n  }\n  // The constructor function appears to have no parameters.\n  // This might be because it inherits from a super-class. In which case, use an injectable\n  // def from an ancestor if there is one.\n  // Otherwise this really is a simple class with no dependencies, so return a factory that\n  // just instantiates the zero-arg constructor.\n  const inheritedInjectableDef = getInheritedInjectableDef(token);\n  if (inheritedInjectableDef !== null) {\n    return () => inheritedInjectableDef.factory(token);\n  } else {\n    return () => new token();\n  }\n}\nfunction providerToRecord(provider) {\n  if (isValueProvider(provider)) {\n    return makeRecord(undefined, provider.useValue);\n  } else {\n    const factory = providerToFactory(provider);\n    return makeRecord(factory, NOT_YET);\n  }\n}\n/**\n * Converts a `SingleProvider` into a factory function.\n *\n * @param provider provider to convert to factory\n */\nfunction providerToFactory(provider, ngModuleType, providers) {\n  let factory = undefined;\n  if (ngDevMode && isEnvironmentProviders(provider)) {\n    throwInvalidProviderError(undefined, providers, provider);\n  }\n  if (isTypeProvider(provider)) {\n    const unwrappedProvider = resolveForwardRef(provider);\n    return getFactoryDef(unwrappedProvider) || injectableDefOrInjectorDefFactory(unwrappedProvider);\n  } else {\n    if (isValueProvider(provider)) {\n      factory = () => resolveForwardRef(provider.useValue);\n    } else if (isFactoryProvider(provider)) {\n      factory = () => provider.useFactory(...injectArgs(provider.deps || []));\n    } else if (isExistingProvider(provider)) {\n      factory = () => ɵɵinject(resolveForwardRef(provider.useExisting));\n    } else {\n      const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));\n      if (ngDevMode && !classRef) {\n        throwInvalidProviderError(ngModuleType, providers, provider);\n      }\n      if (hasDeps(provider)) {\n        factory = () => new classRef(...injectArgs(provider.deps));\n      } else {\n        return getFactoryDef(classRef) || injectableDefOrInjectorDefFactory(classRef);\n      }\n    }\n  }\n  return factory;\n}\nfunction makeRecord(factory, value, multi = false) {\n  return {\n    factory: factory,\n    value: value,\n    multi: multi ? [] : undefined\n  };\n}\nfunction hasDeps(value) {\n  return !!value.deps;\n}\nfunction hasOnDestroy(value) {\n  return value !== null && typeof value === 'object' && typeof value.ngOnDestroy === 'function';\n}\nfunction couldBeInjectableType(value) {\n  return typeof value === 'function' || typeof value === 'object' && value instanceof InjectionToken;\n}\nfunction forEachSingleProvider(providers, fn) {\n  for (const provider of providers) {\n    if (Array.isArray(provider)) {\n      forEachSingleProvider(provider, fn);\n    } else if (provider && isEnvironmentProviders(provider)) {\n      forEachSingleProvider(provider.ɵproviders, fn);\n    } else {\n      fn(provider);\n    }\n  }\n}\n\n/**\n * Runs the given function in the [context](guide/dependency-injection-context) of the given\n * `Injector`.\n *\n * Within the function's stack frame, [`inject`](api/core/inject) can be used to inject dependencies\n * from the given `Injector`. Note that `inject` is only usable synchronously, and cannot be used in\n * any asynchronous callbacks or after any `await` points.\n *\n * @param injector the injector which will satisfy calls to [`inject`](api/core/inject) while `fn`\n *     is executing\n * @param fn the closure to be run in the context of `injector`\n * @returns the return value of the function, if any\n * @publicApi\n */\nfunction runInInjectionContext(injector, fn) {\n  if (injector instanceof R3Injector) {\n    injector.assertNotDestroyed();\n  }\n  let prevInjectorProfilerContext;\n  if (ngDevMode) {\n    prevInjectorProfilerContext = setInjectorProfilerContext({\n      injector,\n      token: null\n    });\n  }\n  const prevInjector = setCurrentInjector(injector);\n  const previousInjectImplementation = setInjectImplementation(undefined);\n  try {\n    return fn();\n  } finally {\n    setCurrentInjector(prevInjector);\n    ngDevMode && setInjectorProfilerContext(prevInjectorProfilerContext);\n    setInjectImplementation(previousInjectImplementation);\n  }\n}\n/**\n * Asserts that the current stack frame is within an [injection\n * context](guide/dependency-injection-context) and has access to `inject`.\n *\n * @param debugFn a reference to the function making the assertion (used for the error message).\n *\n * @publicApi\n */\nfunction assertInInjectionContext(debugFn) {\n  // Taking a `Function` instead of a string name here prevents the unminified name of the function\n  // from being retained in the bundle regardless of minification.\n  if (!getInjectImplementation() && !getCurrentInjector()) {\n    throw new RuntimeError(-203 /* RuntimeErrorCode.MISSING_INJECTION_CONTEXT */, ngDevMode && debugFn.name + '() can only be used within an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext`');\n  }\n}\n\n/**\n * A mapping of the @angular/core API surface used in generated expressions to the actual symbols.\n *\n * This should be kept up to date with the public exports of @angular/core.\n */\nconst angularCoreDiEnv = {\n  'ɵɵdefineInjectable': ɵɵdefineInjectable,\n  'ɵɵdefineInjector': ɵɵdefineInjector,\n  'ɵɵinject': ɵɵinject,\n  'ɵɵinvalidFactoryDep': ɵɵinvalidFactoryDep,\n  'resolveForwardRef': resolveForwardRef\n};\n\n/**\n * Compile an Angular injectable according to its `Injectable` metadata, and patch the resulting\n * injectable def (`ɵprov`) onto the injectable type.\n */\nfunction compileInjectable(type, meta) {\n  let ngInjectableDef = null;\n  let ngFactoryDef = null;\n  // if NG_PROV_DEF is already defined on this class then don't overwrite it\n  if (!type.hasOwnProperty(NG_PROV_DEF)) {\n    Object.defineProperty(type, NG_PROV_DEF, {\n      get: () => {\n        if (ngInjectableDef === null) {\n          const compiler = getCompilerFacade({\n            usage: 0 /* JitCompilerUsage.Decorator */,\n            kind: 'injectable',\n            type\n          });\n          ngInjectableDef = compiler.compileInjectable(angularCoreDiEnv, `ng:///${type.name}/ɵprov.js`, getInjectableMetadata(type, meta));\n        }\n        return ngInjectableDef;\n      }\n    });\n  }\n  // if NG_FACTORY_DEF is already defined on this class then don't overwrite it\n  if (!type.hasOwnProperty(NG_FACTORY_DEF)) {\n    Object.defineProperty(type, NG_FACTORY_DEF, {\n      get: () => {\n        if (ngFactoryDef === null) {\n          const compiler = getCompilerFacade({\n            usage: 0 /* JitCompilerUsage.Decorator */,\n            kind: 'injectable',\n            type\n          });\n          ngFactoryDef = compiler.compileFactory(angularCoreDiEnv, `ng:///${type.name}/ɵfac.js`, {\n            name: type.name,\n            type,\n            typeArgumentCount: 0,\n            deps: reflectDependencies(type),\n            target: compiler.FactoryTarget.Injectable\n          });\n        }\n        return ngFactoryDef;\n      },\n      // Leave this configurable so that the factories from directives or pipes can take precedence.\n      configurable: true\n    });\n  }\n}\nconst USE_VALUE = getClosureSafeProperty({\n  provide: String,\n  useValue: getClosureSafeProperty\n});\nfunction isUseClassProvider(meta) {\n  return meta.useClass !== undefined;\n}\nfunction isUseValueProvider(meta) {\n  return USE_VALUE in meta;\n}\nfunction isUseFactoryProvider(meta) {\n  return meta.useFactory !== undefined;\n}\nfunction isUseExistingProvider(meta) {\n  return meta.useExisting !== undefined;\n}\nfunction getInjectableMetadata(type, srcMeta) {\n  // Allow the compilation of a class with a `@Injectable()` decorator without parameters\n  const meta = srcMeta || {\n    providedIn: null\n  };\n  const compilerMeta = {\n    name: type.name,\n    type: type,\n    typeArgumentCount: 0,\n    providedIn: meta.providedIn\n  };\n  if ((isUseClassProvider(meta) || isUseFactoryProvider(meta)) && meta.deps !== undefined) {\n    compilerMeta.deps = convertDependencies(meta.deps);\n  }\n  // Check to see if the user explicitly provided a `useXxxx` property.\n  if (isUseClassProvider(meta)) {\n    compilerMeta.useClass = meta.useClass;\n  } else if (isUseValueProvider(meta)) {\n    compilerMeta.useValue = meta.useValue;\n  } else if (isUseFactoryProvider(meta)) {\n    compilerMeta.useFactory = meta.useFactory;\n  } else if (isUseExistingProvider(meta)) {\n    compilerMeta.useExisting = meta.useExisting;\n  }\n  return compilerMeta;\n}\n\n/**\n * Injectable decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Injectable = makeDecorator('Injectable', undefined, undefined, undefined, (type, meta) => compileInjectable(type, meta));\n\n/**\n * Create a new `Injector` which is configured using a `defType` of `InjectorType<any>`s.\n */\nfunction createInjector(defType, parent = null, additionalProviders = null, name) {\n  const injector = createInjectorWithoutInjectorInstances(defType, parent, additionalProviders, name);\n  injector.resolveInjectorInitializers();\n  return injector;\n}\n/**\n * Creates a new injector without eagerly resolving its injector types. Can be used in places\n * where resolving the injector types immediately can lead to an infinite loop. The injector types\n * should be resolved at a later point by calling `_resolveInjectorDefTypes`.\n */\nfunction createInjectorWithoutInjectorInstances(defType, parent = null, additionalProviders = null, name, scopes = new Set()) {\n  const providers = [additionalProviders || EMPTY_ARRAY, importProvidersFrom(defType)];\n  name = name || (typeof defType === 'object' ? undefined : stringify(defType));\n  return new R3Injector(providers, parent || getNullInjector(), name || null, scopes);\n}\n\n/**\n * Concrete injectors implement this interface. Injectors are configured\n * with [providers](guide/glossary#provider) that associate\n * dependencies of various types with [injection tokens](guide/glossary#di-token).\n *\n * @see [\"DI Providers\"](guide/dependency-injection-providers).\n * @see {@link StaticProvider}\n *\n * @usageNotes\n *\n *  The following example creates a service injector instance.\n *\n * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}\n *\n * ### Usage example\n *\n * {@example core/di/ts/injector_spec.ts region='Injector'}\n *\n * `Injector` returns itself when given `Injector` as a token:\n *\n * {@example core/di/ts/injector_spec.ts region='injectInjector'}\n *\n * @publicApi\n */\nclass Injector {\n  static #_ = this.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;\n  static #_2 = this.NULL = /* @__PURE__ */new NullInjector();\n  static create(options, parent) {\n    if (Array.isArray(options)) {\n      return createInjector({\n        name: ''\n      }, parent, options, '');\n    } else {\n      const name = options.name ?? '';\n      return createInjector({\n        name\n      }, options.parent, options.providers, name);\n    }\n  }\n  /** @nocollapse */\n  static #_3 = this.ɵprov = ɵɵdefineInjectable({\n    token: Injector,\n    providedIn: 'any',\n    factory: () => ɵɵinject(INJECTOR)\n  });\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static #_4 = this.__NG_ELEMENT_ID__ = -1 /* InjectorMarkers.Injector */;\n}\n\n/**\n * @module\n * @description\n * The `di` module provides dependency injection container services.\n */\n\n/**\n * This file should not be necessary because node resolution should just default to `./di/index`!\n *\n * However it does not seem to work and it breaks:\n *  - //packages/animations/browser/test:test_web_chromium-local\n *  - //packages/compiler-cli/test:extract_i18n\n *  - //packages/compiler-cli/test:ngc\n *  - //packages/compiler-cli/test:perform_watch\n *  - //packages/compiler-cli/test/diagnostics:check_types\n *  - //packages/compiler-cli/test/transformers:test\n *  - //packages/compiler/test:test\n *  - //tools/public_api_guard:core_api\n *\n * Remove this file once the above is solved or wait until `ngc` is deleted and then it should be\n * safe to delete this file.\n */\n\n/**\n *\n * @codeGenApi\n */\nfunction ɵɵresolveWindow(element) {\n  return element.ownerDocument.defaultView;\n}\n/**\n *\n * @codeGenApi\n */\nfunction ɵɵresolveDocument(element) {\n  return element.ownerDocument;\n}\n/**\n *\n * @codeGenApi\n */\nfunction ɵɵresolveBody(element) {\n  return element.ownerDocument.body;\n}\n/**\n * The special delimiter we use to separate property names, prefixes, and suffixes\n * in property binding metadata. See storeBindingMetadata().\n *\n * We intentionally use the Unicode \"REPLACEMENT CHARACTER\" (U+FFFD) as a delimiter\n * because it is a very uncommon character that is unlikely to be part of a user's\n * property names or interpolation strings. If it is in fact used in a property\n * binding, DebugElement.properties will not return the correct value for that\n * binding. However, there should be no runtime effect for real applications.\n *\n * This character is typically rendered as a question mark inside of a diamond.\n * See https://en.wikipedia.org/wiki/Specials_(Unicode_block)\n *\n */\nconst INTERPOLATION_DELIMITER = `�`;\n/**\n * Unwrap a value which might be behind a closure (for forward declaration reasons).\n */\nfunction maybeUnwrapFn$1(value) {\n  if (value instanceof Function) {\n    return value();\n  } else {\n    return value;\n  }\n}\n/**\n * Detects whether the code is invoked in a browser.\n * Later on, this check should be replaced with a tree-shakable\n * flag (e.g. `!isServer`).\n */\nfunction isPlatformBrowser(injector) {\n  return (injector ?? inject$1(Injector)).get(PLATFORM_ID) === 'browser';\n}\n\n/**\n * Defines a schema that allows an NgModule to contain the following:\n * - Non-Angular elements named with dash case (`-`).\n * - Element properties named with dash case (`-`).\n * Dash case is the naming convention for custom elements.\n *\n * @publicApi\n */\nconst CUSTOM_ELEMENTS_SCHEMA = {\n  name: 'custom-elements'\n};\n/**\n * Defines a schema that allows any property on any element.\n *\n * This schema allows you to ignore the errors related to any unknown elements or properties in a\n * template. The usage of this schema is generally discouraged because it prevents useful validation\n * and may hide real errors in your template. Consider using the `CUSTOM_ELEMENTS_SCHEMA` instead.\n *\n * @publicApi\n */\nconst NO_ERRORS_SCHEMA = {\n  name: 'no-errors-schema'\n};\nlet shouldThrowErrorOnUnknownElement = false;\n/**\n * Sets a strict mode for JIT-compiled components to throw an error on unknown elements,\n * instead of just logging the error.\n * (for AOT-compiled ones this check happens at build time).\n */\nfunction ɵsetUnknownElementStrictMode(shouldThrow) {\n  shouldThrowErrorOnUnknownElement = shouldThrow;\n}\n/**\n * Gets the current value of the strict mode.\n */\nfunction ɵgetUnknownElementStrictMode() {\n  return shouldThrowErrorOnUnknownElement;\n}\nlet shouldThrowErrorOnUnknownProperty = false;\n/**\n * Sets a strict mode for JIT-compiled components to throw an error on unknown properties,\n * instead of just logging the error.\n * (for AOT-compiled ones this check happens at build time).\n */\nfunction ɵsetUnknownPropertyStrictMode(shouldThrow) {\n  shouldThrowErrorOnUnknownProperty = shouldThrow;\n}\n/**\n * Gets the current value of the strict mode.\n */\nfunction ɵgetUnknownPropertyStrictMode() {\n  return shouldThrowErrorOnUnknownProperty;\n}\n/**\n * Validates that the element is known at runtime and produces\n * an error if it's not the case.\n * This check is relevant for JIT-compiled components (for AOT-compiled\n * ones this check happens at build time).\n *\n * The element is considered known if either:\n * - it's a known HTML element\n * - it's a known custom element\n * - the element matches any directive\n * - the element is allowed by one of the schemas\n *\n * @param element Element to validate\n * @param lView An `LView` that represents a current component that is being rendered\n * @param tagName Name of the tag to check\n * @param schemas Array of schemas\n * @param hasDirectives Boolean indicating that the element matches any directive\n */\nfunction validateElementIsKnown(element, lView, tagName, schemas, hasDirectives) {\n  // If `schemas` is set to `null`, that's an indication that this Component was compiled in AOT\n  // mode where this check happens at compile time. In JIT mode, `schemas` is always present and\n  // defined as an array (as an empty array in case `schemas` field is not defined) and we should\n  // execute the check below.\n  if (schemas === null) return;\n  // If the element matches any directive, it's considered as valid.\n  if (!hasDirectives && tagName !== null) {\n    // The element is unknown if it's an instance of HTMLUnknownElement, or it isn't registered\n    // as a custom element. Note that unknown elements with a dash in their name won't be instances\n    // of HTMLUnknownElement in browsers that support web components.\n    const isUnknown =\n    // Note that we can't check for `typeof HTMLUnknownElement === 'function'` because\n    // Domino doesn't expose HTMLUnknownElement globally.\n    typeof HTMLUnknownElement !== 'undefined' && HTMLUnknownElement && element instanceof HTMLUnknownElement || typeof customElements !== 'undefined' && tagName.indexOf('-') > -1 && !customElements.get(tagName);\n    if (isUnknown && !matchingSchemas(schemas, tagName)) {\n      const isHostStandalone = isHostComponentStandalone(lView);\n      const templateLocation = getTemplateLocationDetails(lView);\n      const schemas = `'${isHostStandalone ? '@Component' : '@NgModule'}.schemas'`;\n      let message = `'${tagName}' is not a known element${templateLocation}:\\n`;\n      message += `1. If '${tagName}' is an Angular component, then verify that it is ${isHostStandalone ? 'included in the \\'@Component.imports\\' of this component' : 'a part of an @NgModule where this component is declared'}.\\n`;\n      if (tagName && tagName.indexOf('-') > -1) {\n        message += `2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas} of this component to suppress this message.`;\n      } else {\n        message += `2. To allow any element add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;\n      }\n      if (shouldThrowErrorOnUnknownElement) {\n        throw new RuntimeError(304 /* RuntimeErrorCode.UNKNOWN_ELEMENT */, message);\n      } else {\n        console.error(formatRuntimeError(304 /* RuntimeErrorCode.UNKNOWN_ELEMENT */, message));\n      }\n    }\n  }\n}\n/**\n * Validates that the property of the element is known at runtime and returns\n * false if it's not the case.\n * This check is relevant for JIT-compiled components (for AOT-compiled\n * ones this check happens at build time).\n *\n * The property is considered known if either:\n * - it's a known property of the element\n * - the element is allowed by one of the schemas\n * - the property is used for animations\n *\n * @param element Element to validate\n * @param propName Name of the property to check\n * @param tagName Name of the tag hosting the property\n * @param schemas Array of schemas\n */\nfunction isPropertyValid(element, propName, tagName, schemas) {\n  // If `schemas` is set to `null`, that's an indication that this Component was compiled in AOT\n  // mode where this check happens at compile time. In JIT mode, `schemas` is always present and\n  // defined as an array (as an empty array in case `schemas` field is not defined) and we should\n  // execute the check below.\n  if (schemas === null) return true;\n  // The property is considered valid if the element matches the schema, it exists on the element,\n  // or it is synthetic.\n  if (matchingSchemas(schemas, tagName) || propName in element || isAnimationProp(propName)) {\n    return true;\n  }\n  // Note: `typeof Node` returns 'function' in most browsers, but is undefined with domino.\n  return typeof Node === 'undefined' || Node === null || !(element instanceof Node);\n}\n/**\n * Logs or throws an error that a property is not supported on an element.\n *\n * @param propName Name of the invalid property\n * @param tagName Name of the tag hosting the property\n * @param nodeType Type of the node hosting the property\n * @param lView An `LView` that represents a current component\n */\nfunction handleUnknownPropertyError(propName, tagName, nodeType, lView) {\n  // Special-case a situation when a structural directive is applied to\n  // an `<ng-template>` element, for example: `<ng-template *ngIf=\"true\">`.\n  // In this case the compiler generates the `ɵɵtemplate` instruction with\n  // the `null` as the tagName. The directive matching logic at runtime relies\n  // on this effect (see `isInlineTemplate`), thus using the 'ng-template' as\n  // a default value of the `tNode.value` is not feasible at this moment.\n  if (!tagName && nodeType === 4 /* TNodeType.Container */) {\n    tagName = 'ng-template';\n  }\n  const isHostStandalone = isHostComponentStandalone(lView);\n  const templateLocation = getTemplateLocationDetails(lView);\n  let message = `Can't bind to '${propName}' since it isn't a known property of '${tagName}'${templateLocation}.`;\n  const schemas = `'${isHostStandalone ? '@Component' : '@NgModule'}.schemas'`;\n  const importLocation = isHostStandalone ? 'included in the \\'@Component.imports\\' of this component' : 'a part of an @NgModule where this component is declared';\n  if (KNOWN_CONTROL_FLOW_DIRECTIVES.has(propName)) {\n    // Most likely this is a control flow directive (such as `*ngIf`) used in\n    // a template, but the directive or the `CommonModule` is not imported.\n    const correspondingImport = KNOWN_CONTROL_FLOW_DIRECTIVES.get(propName);\n    message += `\\nIf the '${propName}' is an Angular control flow directive, ` + `please make sure that either the '${correspondingImport}' directive or the 'CommonModule' is ${importLocation}.`;\n  } else {\n    // May be an Angular component, which is not imported/declared?\n    message += `\\n1. If '${tagName}' is an Angular component and it has the ` + `'${propName}' input, then verify that it is ${importLocation}.`;\n    // May be a Web Component?\n    if (tagName && tagName.indexOf('-') > -1) {\n      message += `\\n2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' ` + `to the ${schemas} of this component to suppress this message.`;\n      message += `\\n3. To allow any property add 'NO_ERRORS_SCHEMA' to ` + `the ${schemas} of this component.`;\n    } else {\n      // If it's expected, the error can be suppressed by the `NO_ERRORS_SCHEMA` schema.\n      message += `\\n2. To allow any property add 'NO_ERRORS_SCHEMA' to ` + `the ${schemas} of this component.`;\n    }\n  }\n  reportUnknownPropertyError(message);\n}\nfunction reportUnknownPropertyError(message) {\n  if (shouldThrowErrorOnUnknownProperty) {\n    throw new RuntimeError(303 /* RuntimeErrorCode.UNKNOWN_BINDING */, message);\n  } else {\n    console.error(formatRuntimeError(303 /* RuntimeErrorCode.UNKNOWN_BINDING */, message));\n  }\n}\n/**\n * WARNING: this is a **dev-mode only** function (thus should always be guarded by the `ngDevMode`)\n * and must **not** be used in production bundles. The function makes megamorphic reads, which might\n * be too slow for production mode and also it relies on the constructor function being available.\n *\n * Gets a reference to the host component def (where a current component is declared).\n *\n * @param lView An `LView` that represents a current component that is being rendered.\n */\nfunction getDeclarationComponentDef(lView) {\n  !ngDevMode && throwError('Must never be called in production mode');\n  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];\n  const context = declarationLView[CONTEXT];\n  // Unable to obtain a context.\n  if (!context) return null;\n  return context.constructor ? getComponentDef$1(context.constructor) : null;\n}\n/**\n * WARNING: this is a **dev-mode only** function (thus should always be guarded by the `ngDevMode`)\n * and must **not** be used in production bundles. The function makes megamorphic reads, which might\n * be too slow for production mode.\n *\n * Checks if the current component is declared inside of a standalone component template.\n *\n * @param lView An `LView` that represents a current component that is being rendered.\n */\nfunction isHostComponentStandalone(lView) {\n  !ngDevMode && throwError('Must never be called in production mode');\n  const componentDef = getDeclarationComponentDef(lView);\n  // Treat host component as non-standalone if we can't obtain the def.\n  return !!componentDef?.standalone;\n}\n/**\n * WARNING: this is a **dev-mode only** function (thus should always be guarded by the `ngDevMode`)\n * and must **not** be used in production bundles. The function makes megamorphic reads, which might\n * be too slow for production mode.\n *\n * Constructs a string describing the location of the host component template. The function is used\n * in dev mode to produce error messages.\n *\n * @param lView An `LView` that represents a current component that is being rendered.\n */\nfunction getTemplateLocationDetails(lView) {\n  !ngDevMode && throwError('Must never be called in production mode');\n  const hostComponentDef = getDeclarationComponentDef(lView);\n  const componentClassName = hostComponentDef?.type?.name;\n  return componentClassName ? ` (used in the '${componentClassName}' component template)` : '';\n}\n/**\n * The set of known control flow directives and their corresponding imports.\n * We use this set to produce a more precises error message with a note\n * that the `CommonModule` should also be included.\n */\nconst KNOWN_CONTROL_FLOW_DIRECTIVES = new Map([['ngIf', 'NgIf'], ['ngFor', 'NgFor'], ['ngSwitchCase', 'NgSwitchCase'], ['ngSwitchDefault', 'NgSwitchDefault']]);\n/**\n * Returns true if the tag name is allowed by specified schemas.\n * @param schemas Array of schemas\n * @param tagName Name of the tag\n */\nfunction matchingSchemas(schemas, tagName) {\n  if (schemas !== null) {\n    for (let i = 0; i < schemas.length; i++) {\n      const schema = schemas[i];\n      if (schema === NO_ERRORS_SCHEMA || schema === CUSTOM_ELEMENTS_SCHEMA && tagName && tagName.indexOf('-') > -1) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * The name of an attribute that can be added to the hydration boundary node\n * (component host node) to disable hydration for the content within that boundary.\n */\nconst SKIP_HYDRATION_ATTR_NAME = 'ngSkipHydration';\n/**\n * Helper function to check if a given TNode has the 'ngSkipHydration' attribute.\n */\nfunction hasSkipHydrationAttrOnTNode(tNode) {\n  const SKIP_HYDRATION_ATTR_NAME_LOWER_CASE = SKIP_HYDRATION_ATTR_NAME.toLowerCase();\n  const attrs = tNode.mergedAttrs;\n  if (attrs === null) return false;\n  // only ever look at the attribute name and skip the values\n  for (let i = 0; i < attrs.length; i += 2) {\n    const value = attrs[i];\n    // This is a marker, which means that the static attributes section is over,\n    // so we can exit early.\n    if (typeof value === 'number') return false;\n    if (typeof value === 'string' && value.toLowerCase() === SKIP_HYDRATION_ATTR_NAME_LOWER_CASE) {\n      return true;\n    }\n  }\n  return false;\n}\n/**\n * Helper function to check if a given RElement has the 'ngSkipHydration' attribute.\n */\nfunction hasSkipHydrationAttrOnRElement(rNode) {\n  return rNode.hasAttribute(SKIP_HYDRATION_ATTR_NAME);\n}\n/**\n * Checks whether a TNode has a flag to indicate that it's a part of\n * a skip hydration block.\n */\nfunction hasInSkipHydrationBlockFlag(tNode) {\n  return (tNode.flags & 128 /* TNodeFlags.inSkipHydrationBlock */) === 128 /* TNodeFlags.inSkipHydrationBlock */;\n}\n/**\n * Helper function that determines if a given node is within a skip hydration block\n * by navigating up the TNode tree to see if any parent nodes have skip hydration\n * attribute.\n *\n * TODO(akushnir): this function should contain the logic of `hasInSkipHydrationBlockFlag`,\n * there is no need to traverse parent nodes when we have a TNode flag (which would also\n * make this lookup O(1)).\n */\nfunction isInSkipHydrationBlock(tNode) {\n  let currentTNode = tNode.parent;\n  while (currentTNode) {\n    if (hasSkipHydrationAttrOnTNode(currentTNode)) {\n      return true;\n    }\n    currentTNode = currentTNode.parent;\n  }\n  return false;\n}\n\n/**\n * Flags for renderer-specific style modifiers.\n * @publicApi\n */\nvar RendererStyleFlags2;\n(function (RendererStyleFlags2) {\n  // TODO(misko): This needs to be refactored into a separate file so that it can be imported from\n  // `node_manipulation.ts` Currently doing the import cause resolution order to change and fails\n  // the tests. The work around is to have hard coded value in `node_manipulation.ts` for now.\n  /**\n   * Marks a style as important.\n   */\n  RendererStyleFlags2[RendererStyleFlags2[\"Important\"] = 1] = \"Important\";\n  /**\n   * Marks a style as using dash case naming (this-is-dash-case).\n   */\n  RendererStyleFlags2[RendererStyleFlags2[\"DashCase\"] = 2] = \"DashCase\";\n})(RendererStyleFlags2 || (RendererStyleFlags2 = {}));\n\n/**\n * Disallowed strings in the comment.\n *\n * see: https://html.spec.whatwg.org/multipage/syntax.html#comments\n */\nconst COMMENT_DISALLOWED = /^>|^->|<!--|-->|--!>|<!-$/g;\n/**\n * Delimiter in the disallowed strings which needs to be wrapped with zero with character.\n */\nconst COMMENT_DELIMITER = /(<|>)/g;\nconst COMMENT_DELIMITER_ESCAPED = '\\u200B$1\\u200B';\n/**\n * Escape the content of comment strings so that it can be safely inserted into a comment node.\n *\n * The issue is that HTML does not specify any way to escape comment end text inside the comment.\n * Consider: `<!-- The way you close a comment is with \">\", and \"->\" at the beginning or by \"-->\" or\n * \"--!>\" at the end. -->`. Above the `\"-->\"` is meant to be text not an end to the comment. This\n * can be created programmatically through DOM APIs. (`<!--` are also disallowed.)\n *\n * see: https://html.spec.whatwg.org/multipage/syntax.html#comments\n *\n * ```\n * div.innerHTML = div.innerHTML\n * ```\n *\n * One would expect that the above code would be safe to do, but it turns out that because comment\n * text is not escaped, the comment may contain text which will prematurely close the comment\n * opening up the application for XSS attack. (In SSR we programmatically create comment nodes which\n * may contain such text and expect them to be safe.)\n *\n * This function escapes the comment text by looking for comment delimiters (`<` and `>`) and\n * surrounding them with `_>_` where the `_` is a zero width space `\\u200B`. The result is that if a\n * comment contains any of the comment start/end delimiters (such as `<!--`, `-->` or `--!>`) the\n * text it will render normally but it will not cause the HTML parser to close/open the comment.\n *\n * @param value text to make safe for comment node by escaping the comment open/close character\n *     sequence.\n */\nfunction escapeCommentText(value) {\n  return value.replace(COMMENT_DISALLOWED, text => text.replace(COMMENT_DELIMITER, COMMENT_DELIMITER_ESCAPED));\n}\n\n// Keeps track of the currently-active LViews.\nconst TRACKED_LVIEWS = new Map();\n// Used for generating unique IDs for LViews.\nlet uniqueIdCounter = 0;\n/** Gets a unique ID that can be assigned to an LView. */\nfunction getUniqueLViewId() {\n  return uniqueIdCounter++;\n}\n/** Starts tracking an LView. */\nfunction registerLView(lView) {\n  ngDevMode && assertNumber(lView[ID], 'LView must have an ID in order to be registered');\n  TRACKED_LVIEWS.set(lView[ID], lView);\n}\n/** Gets an LView by its unique ID. */\nfunction getLViewById(id) {\n  ngDevMode && assertNumber(id, 'ID used for LView lookup must be a number');\n  return TRACKED_LVIEWS.get(id) || null;\n}\n/** Stops tracking an LView. */\nfunction unregisterLView(lView) {\n  ngDevMode && assertNumber(lView[ID], 'Cannot stop tracking an LView that does not have an ID');\n  TRACKED_LVIEWS.delete(lView[ID]);\n}\n\n/**\n * The internal view context which is specific to a given DOM element, directive or\n * component instance. Each value in here (besides the LView and element node details)\n * can be present, null or undefined. If undefined then it implies the value has not been\n * looked up yet, otherwise, if null, then a lookup was executed and nothing was found.\n *\n * Each value will get filled when the respective value is examined within the getContext\n * function. The component, element and each directive instance will share the same instance\n * of the context.\n */\nclass LContext {\n  /** Component's parent view data. */\n  get lView() {\n    return getLViewById(this.lViewId);\n  }\n  constructor(\n  /**\n   * ID of the component's parent view data.\n   */\n  lViewId,\n  /**\n   * The index instance of the node.\n   */\n  nodeIndex,\n  /**\n   * The instance of the DOM node that is attached to the lNode.\n   */\n  native) {\n    this.lViewId = lViewId;\n    this.nodeIndex = nodeIndex;\n    this.native = native;\n  }\n}\n\n/**\n * Returns the matching `LContext` data for a given DOM node, directive or component instance.\n *\n * This function will examine the provided DOM element, component, or directive instance\\'s\n * monkey-patched property to derive the `LContext` data. Once called then the monkey-patched\n * value will be that of the newly created `LContext`.\n *\n * If the monkey-patched value is the `LView` instance then the context value for that\n * target will be created and the monkey-patch reference will be updated. Therefore when this\n * function is called it may mutate the provided element\\'s, component\\'s or any of the associated\n * directive\\'s monkey-patch values.\n *\n * If the monkey-patch value is not detected then the code will walk up the DOM until an element\n * is found which contains a monkey-patch reference. When that occurs then the provided element\n * will be updated with a new context (which is then returned). If the monkey-patch value is not\n * detected for a component/directive instance then it will throw an error (all components and\n * directives should be automatically monkey-patched by ivy).\n *\n * @param target Component, Directive or DOM Node.\n */\nfunction getLContext(target) {\n  let mpValue = readPatchedData(target);\n  if (mpValue) {\n    // only when it's an array is it considered an LView instance\n    // ... otherwise it's an already constructed LContext instance\n    if (isLView(mpValue)) {\n      const lView = mpValue;\n      let nodeIndex;\n      let component = undefined;\n      let directives = undefined;\n      if (isComponentInstance(target)) {\n        nodeIndex = findViaComponent(lView, target);\n        if (nodeIndex == -1) {\n          throw new Error('The provided component was not found in the application');\n        }\n        component = target;\n      } else if (isDirectiveInstance(target)) {\n        nodeIndex = findViaDirective(lView, target);\n        if (nodeIndex == -1) {\n          throw new Error('The provided directive was not found in the application');\n        }\n        directives = getDirectivesAtNodeIndex(nodeIndex, lView);\n      } else {\n        nodeIndex = findViaNativeElement(lView, target);\n        if (nodeIndex == -1) {\n          return null;\n        }\n      }\n      // the goal is not to fill the entire context full of data because the lookups\n      // are expensive. Instead, only the target data (the element, component, container, ICU\n      // expression or directive details) are filled into the context. If called multiple times\n      // with different target values then the missing target data will be filled in.\n      const native = unwrapRNode(lView[nodeIndex]);\n      const existingCtx = readPatchedData(native);\n      const context = existingCtx && !Array.isArray(existingCtx) ? existingCtx : createLContext(lView, nodeIndex, native);\n      // only when the component has been discovered then update the monkey-patch\n      if (component && context.component === undefined) {\n        context.component = component;\n        attachPatchData(context.component, context);\n      }\n      // only when the directives have been discovered then update the monkey-patch\n      if (directives && context.directives === undefined) {\n        context.directives = directives;\n        for (let i = 0; i < directives.length; i++) {\n          attachPatchData(directives[i], context);\n        }\n      }\n      attachPatchData(context.native, context);\n      mpValue = context;\n    }\n  } else {\n    const rElement = target;\n    ngDevMode && assertDomNode(rElement);\n    // if the context is not found then we need to traverse upwards up the DOM\n    // to find the nearest element that has already been monkey patched with data\n    let parent = rElement;\n    while (parent = parent.parentNode) {\n      const parentContext = readPatchedData(parent);\n      if (parentContext) {\n        const lView = Array.isArray(parentContext) ? parentContext : parentContext.lView;\n        // the edge of the app was also reached here through another means\n        // (maybe because the DOM was changed manually).\n        if (!lView) {\n          return null;\n        }\n        const index = findViaNativeElement(lView, rElement);\n        if (index >= 0) {\n          const native = unwrapRNode(lView[index]);\n          const context = createLContext(lView, index, native);\n          attachPatchData(native, context);\n          mpValue = context;\n          break;\n        }\n      }\n    }\n  }\n  return mpValue || null;\n}\n/**\n * Creates an empty instance of a `LContext` context\n */\nfunction createLContext(lView, nodeIndex, native) {\n  return new LContext(lView[ID], nodeIndex, native);\n}\n/**\n * Takes a component instance and returns the view for that component.\n *\n * @param componentInstance\n * @returns The component's view\n */\nfunction getComponentViewByInstance(componentInstance) {\n  let patchedData = readPatchedData(componentInstance);\n  let lView;\n  if (isLView(patchedData)) {\n    const contextLView = patchedData;\n    const nodeIndex = findViaComponent(contextLView, componentInstance);\n    lView = getComponentLViewByIndex(nodeIndex, contextLView);\n    const context = createLContext(contextLView, nodeIndex, lView[HOST]);\n    context.component = componentInstance;\n    attachPatchData(componentInstance, context);\n    attachPatchData(context.native, context);\n  } else {\n    const context = patchedData;\n    const contextLView = context.lView;\n    ngDevMode && assertLView(contextLView);\n    lView = getComponentLViewByIndex(context.nodeIndex, contextLView);\n  }\n  return lView;\n}\n/**\n * This property will be monkey-patched on elements, components and directives.\n */\nconst MONKEY_PATCH_KEY_NAME = '__ngContext__';\n/**\n * Assigns the given data to the given target (which could be a component,\n * directive or DOM node instance) using monkey-patching.\n */\nfunction attachPatchData(target, data) {\n  ngDevMode && assertDefined(target, 'Target expected');\n  // Only attach the ID of the view in order to avoid memory leaks (see #41047). We only do this\n  // for `LView`, because we have control over when an `LView` is created and destroyed, whereas\n  // we can't know when to remove an `LContext`.\n  if (isLView(data)) {\n    target[MONKEY_PATCH_KEY_NAME] = data[ID];\n    registerLView(data);\n  } else {\n    target[MONKEY_PATCH_KEY_NAME] = data;\n  }\n}\n/**\n * Returns the monkey-patch value data present on the target (which could be\n * a component, directive or a DOM node).\n */\nfunction readPatchedData(target) {\n  ngDevMode && assertDefined(target, 'Target expected');\n  const data = target[MONKEY_PATCH_KEY_NAME];\n  return typeof data === 'number' ? getLViewById(data) : data || null;\n}\nfunction readPatchedLView(target) {\n  const value = readPatchedData(target);\n  if (value) {\n    return isLView(value) ? value : value.lView;\n  }\n  return null;\n}\nfunction isComponentInstance(instance) {\n  return instance && instance.constructor && instance.constructor.ɵcmp;\n}\nfunction isDirectiveInstance(instance) {\n  return instance && instance.constructor && instance.constructor.ɵdir;\n}\n/**\n * Locates the element within the given LView and returns the matching index\n */\nfunction findViaNativeElement(lView, target) {\n  const tView = lView[TVIEW];\n  for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {\n    if (unwrapRNode(lView[i]) === target) {\n      return i;\n    }\n  }\n  return -1;\n}\n/**\n * Locates the next tNode (child, sibling or parent).\n */\nfunction traverseNextElement(tNode) {\n  if (tNode.child) {\n    return tNode.child;\n  } else if (tNode.next) {\n    return tNode.next;\n  } else {\n    // Let's take the following template: <div><span>text</span></div><component/>\n    // After checking the text node, we need to find the next parent that has a \"next\" TNode,\n    // in this case the parent `div`, so that we can find the component.\n    while (tNode.parent && !tNode.parent.next) {\n      tNode = tNode.parent;\n    }\n    return tNode.parent && tNode.parent.next;\n  }\n}\n/**\n * Locates the component within the given LView and returns the matching index\n */\nfunction findViaComponent(lView, componentInstance) {\n  const componentIndices = lView[TVIEW].components;\n  if (componentIndices) {\n    for (let i = 0; i < componentIndices.length; i++) {\n      const elementComponentIndex = componentIndices[i];\n      const componentView = getComponentLViewByIndex(elementComponentIndex, lView);\n      if (componentView[CONTEXT] === componentInstance) {\n        return elementComponentIndex;\n      }\n    }\n  } else {\n    const rootComponentView = getComponentLViewByIndex(HEADER_OFFSET, lView);\n    const rootComponent = rootComponentView[CONTEXT];\n    if (rootComponent === componentInstance) {\n      // we are dealing with the root element here therefore we know that the\n      // element is the very first element after the HEADER data in the lView\n      return HEADER_OFFSET;\n    }\n  }\n  return -1;\n}\n/**\n * Locates the directive within the given LView and returns the matching index\n */\nfunction findViaDirective(lView, directiveInstance) {\n  // if a directive is monkey patched then it will (by default)\n  // have a reference to the LView of the current view. The\n  // element bound to the directive being search lives somewhere\n  // in the view data. We loop through the nodes and check their\n  // list of directives for the instance.\n  let tNode = lView[TVIEW].firstChild;\n  while (tNode) {\n    const directiveIndexStart = tNode.directiveStart;\n    const directiveIndexEnd = tNode.directiveEnd;\n    for (let i = directiveIndexStart; i < directiveIndexEnd; i++) {\n      if (lView[i] === directiveInstance) {\n        return tNode.index;\n      }\n    }\n    tNode = traverseNextElement(tNode);\n  }\n  return -1;\n}\n/**\n * Returns a list of directives applied to a node at a specific index. The list includes\n * directives matched by selector and any host directives, but it excludes components.\n * Use `getComponentAtNodeIndex` to find the component applied to a node.\n *\n * @param nodeIndex The node index\n * @param lView The target view data\n */\nfunction getDirectivesAtNodeIndex(nodeIndex, lView) {\n  const tNode = lView[TVIEW].data[nodeIndex];\n  if (tNode.directiveStart === 0) return EMPTY_ARRAY;\n  const results = [];\n  for (let i = tNode.directiveStart; i < tNode.directiveEnd; i++) {\n    const directiveInstance = lView[i];\n    if (!isComponentInstance(directiveInstance)) {\n      results.push(directiveInstance);\n    }\n  }\n  return results;\n}\nfunction getComponentAtNodeIndex(nodeIndex, lView) {\n  const tNode = lView[TVIEW].data[nodeIndex];\n  const {\n    directiveStart,\n    componentOffset\n  } = tNode;\n  return componentOffset > -1 ? lView[directiveStart + componentOffset] : null;\n}\n/**\n * Returns a map of local references (local reference name => element or directive instance) that\n * exist on a given element.\n */\nfunction discoverLocalRefs(lView, nodeIndex) {\n  const tNode = lView[TVIEW].data[nodeIndex];\n  if (tNode && tNode.localNames) {\n    const result = {};\n    let localIndex = tNode.index + 1;\n    for (let i = 0; i < tNode.localNames.length; i += 2) {\n      result[tNode.localNames[i]] = lView[localIndex];\n      localIndex++;\n    }\n    return result;\n  }\n  return null;\n}\nlet _icuContainerIterate;\n/**\n * Iterator which provides ability to visit all of the `TIcuContainerNode` root `RNode`s.\n */\nfunction icuContainerIterate(tIcuContainerNode, lView) {\n  return _icuContainerIterate(tIcuContainerNode, lView);\n}\n/**\n * Ensures that `IcuContainerVisitor`'s implementation is present.\n *\n * This function is invoked when i18n instruction comes across an ICU. The purpose is to allow the\n * bundler to tree shake ICU logic and only load it if ICU instruction is executed.\n */\nfunction ensureIcuContainerVisitorLoaded(loader) {\n  if (_icuContainerIterate === undefined) {\n    // Do not inline this function. We want to keep `ensureIcuContainerVisitorLoaded` light, so it\n    // can be inlined into call-site.\n    _icuContainerIterate = loader();\n  }\n}\n\n/**\n * Gets the parent LView of the passed LView, if the PARENT is an LContainer, will get the parent of\n * that LContainer, which is an LView\n * @param lView the lView whose parent to get\n */\nfunction getLViewParent(lView) {\n  ngDevMode && assertLView(lView);\n  const parent = lView[PARENT];\n  return isLContainer(parent) ? parent[PARENT] : parent;\n}\n/**\n * Retrieve the root view from any component or `LView` by walking the parent `LView` until\n * reaching the root `LView`.\n *\n * @param componentOrLView any component or `LView`\n */\nfunction getRootView(componentOrLView) {\n  ngDevMode && assertDefined(componentOrLView, 'component');\n  let lView = isLView(componentOrLView) ? componentOrLView : readPatchedLView(componentOrLView);\n  while (lView && !(lView[FLAGS] & 512 /* LViewFlags.IsRoot */)) {\n    lView = getLViewParent(lView);\n  }\n  ngDevMode && assertLView(lView);\n  return lView;\n}\n/**\n * Returns the context information associated with the application where the target is situated. It\n * does this by walking the parent views until it gets to the root view, then getting the context\n * off of that.\n *\n * @param viewOrComponent the `LView` or component to get the root context for.\n */\nfunction getRootContext(viewOrComponent) {\n  const rootView = getRootView(viewOrComponent);\n  ngDevMode && assertDefined(rootView[CONTEXT], 'Root view has no context. Perhaps it is disconnected?');\n  return rootView[CONTEXT];\n}\n/**\n * Gets the first `LContainer` in the LView or `null` if none exists.\n */\nfunction getFirstLContainer(lView) {\n  return getNearestLContainer(lView[CHILD_HEAD]);\n}\n/**\n * Gets the next `LContainer` that is a sibling of the given container.\n */\nfunction getNextLContainer(container) {\n  return getNearestLContainer(container[NEXT]);\n}\nfunction getNearestLContainer(viewOrContainer) {\n  while (viewOrContainer !== null && !isLContainer(viewOrContainer)) {\n    viewOrContainer = viewOrContainer[NEXT];\n  }\n  return viewOrContainer;\n}\n\n/**\n * NOTE: for performance reasons, the possible actions are inlined within the function instead of\n * being passed as an argument.\n */\nfunction applyToElementOrContainer(action, renderer, parent, lNodeToHandle, beforeNode) {\n  // If this slot was allocated for a text node dynamically created by i18n, the text node itself\n  // won't be created until i18nApply() in the update block, so this node should be skipped.\n  // For more info, see \"ICU expressions should work inside an ngTemplateOutlet inside an ngFor\"\n  // in `i18n_spec.ts`.\n  if (lNodeToHandle != null) {\n    let lContainer;\n    let isComponent = false;\n    // We are expecting an RNode, but in the case of a component or LContainer the `RNode` is\n    // wrapped in an array which needs to be unwrapped. We need to know if it is a component and if\n    // it has LContainer so that we can process all of those cases appropriately.\n    if (isLContainer(lNodeToHandle)) {\n      lContainer = lNodeToHandle;\n    } else if (isLView(lNodeToHandle)) {\n      isComponent = true;\n      ngDevMode && assertDefined(lNodeToHandle[HOST], 'HOST must be defined for a component LView');\n      lNodeToHandle = lNodeToHandle[HOST];\n    }\n    const rNode = unwrapRNode(lNodeToHandle);\n    if (action === 0 /* WalkTNodeTreeAction.Create */ && parent !== null) {\n      if (beforeNode == null) {\n        nativeAppendChild(renderer, parent, rNode);\n      } else {\n        nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);\n      }\n    } else if (action === 1 /* WalkTNodeTreeAction.Insert */ && parent !== null) {\n      nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);\n    } else if (action === 2 /* WalkTNodeTreeAction.Detach */) {\n      nativeRemoveNode(renderer, rNode, isComponent);\n    } else if (action === 3 /* WalkTNodeTreeAction.Destroy */) {\n      ngDevMode && ngDevMode.rendererDestroyNode++;\n      renderer.destroyNode(rNode);\n    }\n    if (lContainer != null) {\n      applyContainer(renderer, action, lContainer, parent, beforeNode);\n    }\n  }\n}\nfunction createTextNode(renderer, value) {\n  ngDevMode && ngDevMode.rendererCreateTextNode++;\n  ngDevMode && ngDevMode.rendererSetText++;\n  return renderer.createText(value);\n}\nfunction updateTextNode(renderer, rNode, value) {\n  ngDevMode && ngDevMode.rendererSetText++;\n  renderer.setValue(rNode, value);\n}\nfunction createCommentNode(renderer, value) {\n  ngDevMode && ngDevMode.rendererCreateComment++;\n  return renderer.createComment(escapeCommentText(value));\n}\n/**\n * Creates a native element from a tag name, using a renderer.\n * @param renderer A renderer to use\n * @param name the tag name\n * @param namespace Optional namespace for element.\n * @returns the element created\n */\nfunction createElementNode(renderer, name, namespace) {\n  ngDevMode && ngDevMode.rendererCreateElement++;\n  return renderer.createElement(name, namespace);\n}\n/**\n * Removes all DOM elements associated with a view.\n *\n * Because some root nodes of the view may be containers, we sometimes need\n * to propagate deeply into the nested containers to remove all elements in the\n * views beneath it.\n *\n * @param tView The `TView' of the `LView` from which elements should be added or removed\n * @param lView The view from which elements should be added or removed\n */\nfunction removeViewFromDOM(tView, lView) {\n  const renderer = lView[RENDERER];\n  applyView(tView, lView, renderer, 2 /* WalkTNodeTreeAction.Detach */, null, null);\n  lView[HOST] = null;\n  lView[T_HOST] = null;\n}\n/**\n * Adds all DOM elements associated with a view.\n *\n * Because some root nodes of the view may be containers, we sometimes need\n * to propagate deeply into the nested containers to add all elements in the\n * views beneath it.\n *\n * @param tView The `TView' of the `LView` from which elements should be added or removed\n * @param parentTNode The `TNode` where the `LView` should be attached to.\n * @param renderer Current renderer to use for DOM manipulations.\n * @param lView The view from which elements should be added or removed\n * @param parentNativeNode The parent `RElement` where it should be inserted into.\n * @param beforeNode The node before which elements should be added, if insert mode\n */\nfunction addViewToDOM(tView, parentTNode, renderer, lView, parentNativeNode, beforeNode) {\n  lView[HOST] = parentNativeNode;\n  lView[T_HOST] = parentTNode;\n  applyView(tView, lView, renderer, 1 /* WalkTNodeTreeAction.Insert */, parentNativeNode, beforeNode);\n}\n/**\n * Detach a `LView` from the DOM by detaching its nodes.\n *\n * @param tView The `TView' of the `LView` to be detached\n * @param lView the `LView` to be detached.\n */\nfunction detachViewFromDOM(tView, lView) {\n  applyView(tView, lView, lView[RENDERER], 2 /* WalkTNodeTreeAction.Detach */, null, null);\n}\n/**\n * Traverses down and up the tree of views and containers to remove listeners and\n * call onDestroy callbacks.\n *\n * Notes:\n *  - Because it's used for onDestroy calls, it needs to be bottom-up.\n *  - Must process containers instead of their views to avoid splicing\n *  when views are destroyed and re-added.\n *  - Using a while loop because it's faster than recursion\n *  - Destroy only called on movement to sibling or movement to parent (laterally or up)\n *\n *  @param rootView The view to destroy\n */\nfunction destroyViewTree(rootView) {\n  // If the view has no children, we can clean it up and return early.\n  let lViewOrLContainer = rootView[CHILD_HEAD];\n  if (!lViewOrLContainer) {\n    return cleanUpView(rootView[TVIEW], rootView);\n  }\n  while (lViewOrLContainer) {\n    let next = null;\n    if (isLView(lViewOrLContainer)) {\n      // If LView, traverse down to child.\n      next = lViewOrLContainer[CHILD_HEAD];\n    } else {\n      ngDevMode && assertLContainer(lViewOrLContainer);\n      // If container, traverse down to its first LView.\n      const firstView = lViewOrLContainer[CONTAINER_HEADER_OFFSET];\n      if (firstView) next = firstView;\n    }\n    if (!next) {\n      // Only clean up view when moving to the side or up, as destroy hooks\n      // should be called in order from the bottom up.\n      while (lViewOrLContainer && !lViewOrLContainer[NEXT] && lViewOrLContainer !== rootView) {\n        if (isLView(lViewOrLContainer)) {\n          cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);\n        }\n        lViewOrLContainer = lViewOrLContainer[PARENT];\n      }\n      if (lViewOrLContainer === null) lViewOrLContainer = rootView;\n      if (isLView(lViewOrLContainer)) {\n        cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);\n      }\n      next = lViewOrLContainer && lViewOrLContainer[NEXT];\n    }\n    lViewOrLContainer = next;\n  }\n}\n/**\n * Inserts a view into a container.\n *\n * This adds the view to the container's array of active views in the correct\n * position. It also adds the view's elements to the DOM if the container isn't a\n * root node of another view (in that case, the view's elements will be added when\n * the container's parent view is added later).\n *\n * @param tView The `TView' of the `LView` to insert\n * @param lView The view to insert\n * @param lContainer The container into which the view should be inserted\n * @param index Which index in the container to insert the child view into\n */\nfunction insertView(tView, lView, lContainer, index) {\n  ngDevMode && assertLView(lView);\n  ngDevMode && assertLContainer(lContainer);\n  const indexInContainer = CONTAINER_HEADER_OFFSET + index;\n  const containerLength = lContainer.length;\n  if (index > 0) {\n    // This is a new view, we need to add it to the children.\n    lContainer[indexInContainer - 1][NEXT] = lView;\n  }\n  if (index < containerLength - CONTAINER_HEADER_OFFSET) {\n    lView[NEXT] = lContainer[indexInContainer];\n    addToArray(lContainer, CONTAINER_HEADER_OFFSET + index, lView);\n  } else {\n    lContainer.push(lView);\n    lView[NEXT] = null;\n  }\n  lView[PARENT] = lContainer;\n  // track views where declaration and insertion points are different\n  const declarationLContainer = lView[DECLARATION_LCONTAINER];\n  if (declarationLContainer !== null && lContainer !== declarationLContainer) {\n    trackMovedView(declarationLContainer, lView);\n  }\n  // notify query that a new view has been added\n  const lQueries = lView[QUERIES];\n  if (lQueries !== null) {\n    lQueries.insertView(tView);\n  }\n  // Sets the attached flag\n  lView[FLAGS] |= 128 /* LViewFlags.Attached */;\n}\n/**\n * Track views created from the declaration container (TemplateRef) and inserted into a\n * different LContainer.\n */\nfunction trackMovedView(declarationContainer, lView) {\n  ngDevMode && assertDefined(lView, 'LView required');\n  ngDevMode && assertLContainer(declarationContainer);\n  const movedViews = declarationContainer[MOVED_VIEWS];\n  const insertedLContainer = lView[PARENT];\n  ngDevMode && assertLContainer(insertedLContainer);\n  const insertedComponentLView = insertedLContainer[PARENT][DECLARATION_COMPONENT_VIEW];\n  ngDevMode && assertDefined(insertedComponentLView, 'Missing insertedComponentLView');\n  const declaredComponentLView = lView[DECLARATION_COMPONENT_VIEW];\n  ngDevMode && assertDefined(declaredComponentLView, 'Missing declaredComponentLView');\n  if (declaredComponentLView !== insertedComponentLView) {\n    // At this point the declaration-component is not same as insertion-component; this means that\n    // this is a transplanted view. Mark the declared lView as having transplanted views so that\n    // those views can participate in CD.\n    declarationContainer[HAS_TRANSPLANTED_VIEWS] = true;\n  }\n  if (movedViews === null) {\n    declarationContainer[MOVED_VIEWS] = [lView];\n  } else {\n    movedViews.push(lView);\n  }\n}\nfunction detachMovedView(declarationContainer, lView) {\n  ngDevMode && assertLContainer(declarationContainer);\n  ngDevMode && assertDefined(declarationContainer[MOVED_VIEWS], 'A projected view should belong to a non-empty projected views collection');\n  const movedViews = declarationContainer[MOVED_VIEWS];\n  const declarationViewIndex = movedViews.indexOf(lView);\n  const insertionLContainer = lView[PARENT];\n  ngDevMode && assertLContainer(insertionLContainer);\n  // If the view was marked for refresh but then detached before it was checked (where the flag\n  // would be cleared and the counter decremented), we need to update the status here.\n  clearViewRefreshFlag(lView);\n  movedViews.splice(declarationViewIndex, 1);\n}\n/**\n * Detaches a view from a container.\n *\n * This method removes the view from the container's array of active views. It also\n * removes the view's elements from the DOM.\n *\n * @param lContainer The container from which to detach a view\n * @param removeIndex The index of the view to detach\n * @returns Detached LView instance.\n */\nfunction detachView(lContainer, removeIndex) {\n  if (lContainer.length <= CONTAINER_HEADER_OFFSET) return;\n  const indexInContainer = CONTAINER_HEADER_OFFSET + removeIndex;\n  const viewToDetach = lContainer[indexInContainer];\n  if (viewToDetach) {\n    const declarationLContainer = viewToDetach[DECLARATION_LCONTAINER];\n    if (declarationLContainer !== null && declarationLContainer !== lContainer) {\n      detachMovedView(declarationLContainer, viewToDetach);\n    }\n    if (removeIndex > 0) {\n      lContainer[indexInContainer - 1][NEXT] = viewToDetach[NEXT];\n    }\n    const removedLView = removeFromArray(lContainer, CONTAINER_HEADER_OFFSET + removeIndex);\n    removeViewFromDOM(viewToDetach[TVIEW], viewToDetach);\n    // notify query that a view has been removed\n    const lQueries = removedLView[QUERIES];\n    if (lQueries !== null) {\n      lQueries.detachView(removedLView[TVIEW]);\n    }\n    viewToDetach[PARENT] = null;\n    viewToDetach[NEXT] = null;\n    // Unsets the attached flag\n    viewToDetach[FLAGS] &= ~128 /* LViewFlags.Attached */;\n  }\n\n  return viewToDetach;\n}\n/**\n * A standalone function which destroys an LView,\n * conducting clean up (e.g. removing listeners, calling onDestroys).\n *\n * @param tView The `TView' of the `LView` to be destroyed\n * @param lView The view to be destroyed.\n */\nfunction destroyLView(tView, lView) {\n  if (!(lView[FLAGS] & 256 /* LViewFlags.Destroyed */)) {\n    const renderer = lView[RENDERER];\n    lView[REACTIVE_TEMPLATE_CONSUMER] && consumerDestroy(lView[REACTIVE_TEMPLATE_CONSUMER]);\n    lView[REACTIVE_HOST_BINDING_CONSUMER] && consumerDestroy(lView[REACTIVE_HOST_BINDING_CONSUMER]);\n    if (renderer.destroyNode) {\n      applyView(tView, lView, renderer, 3 /* WalkTNodeTreeAction.Destroy */, null, null);\n    }\n    destroyViewTree(lView);\n  }\n}\n/**\n * Calls onDestroys hooks for all directives and pipes in a given view and then removes all\n * listeners. Listeners are removed as the last step so events delivered in the onDestroys hooks\n * can be propagated to @Output listeners.\n *\n * @param tView `TView` for the `LView` to clean up.\n * @param lView The LView to clean up\n */\nfunction cleanUpView(tView, lView) {\n  if (!(lView[FLAGS] & 256 /* LViewFlags.Destroyed */)) {\n    // Usually the Attached flag is removed when the view is detached from its parent, however\n    // if it's a root view, the flag won't be unset hence why we're also removing on destroy.\n    lView[FLAGS] &= ~128 /* LViewFlags.Attached */;\n    // Mark the LView as destroyed *before* executing the onDestroy hooks. An onDestroy hook\n    // runs arbitrary user code, which could include its own `viewRef.destroy()` (or similar). If\n    // We don't flag the view as destroyed before the hooks, this could lead to an infinite loop.\n    // This also aligns with the ViewEngine behavior. It also means that the onDestroy hook is\n    // really more of an \"afterDestroy\" hook if you think about it.\n    lView[FLAGS] |= 256 /* LViewFlags.Destroyed */;\n    executeOnDestroys(tView, lView);\n    processCleanups(tView, lView);\n    // For component views only, the local renderer is destroyed at clean up time.\n    if (lView[TVIEW].type === 1 /* TViewType.Component */) {\n      ngDevMode && ngDevMode.rendererDestroy++;\n      lView[RENDERER].destroy();\n    }\n    const declarationContainer = lView[DECLARATION_LCONTAINER];\n    // we are dealing with an embedded view that is still inserted into a container\n    if (declarationContainer !== null && isLContainer(lView[PARENT])) {\n      // and this is a projected view\n      if (declarationContainer !== lView[PARENT]) {\n        detachMovedView(declarationContainer, lView);\n      }\n      // For embedded views still attached to a container: remove query result from this view.\n      const lQueries = lView[QUERIES];\n      if (lQueries !== null) {\n        lQueries.detachView(tView);\n      }\n    }\n    // Unregister the view once everything else has been cleaned up.\n    unregisterLView(lView);\n  }\n}\n/** Removes listeners and unsubscribes from output subscriptions */\nfunction processCleanups(tView, lView) {\n  const tCleanup = tView.cleanup;\n  const lCleanup = lView[CLEANUP];\n  if (tCleanup !== null) {\n    for (let i = 0; i < tCleanup.length - 1; i += 2) {\n      if (typeof tCleanup[i] === 'string') {\n        // This is a native DOM listener. It will occupy 4 entries in the TCleanup array (hence i +=\n        // 2 at the end of this block).\n        const targetIdx = tCleanup[i + 3];\n        ngDevMode && assertNumber(targetIdx, 'cleanup target must be a number');\n        if (targetIdx >= 0) {\n          // unregister\n          lCleanup[targetIdx]();\n        } else {\n          // Subscription\n          lCleanup[-targetIdx].unsubscribe();\n        }\n        i += 2;\n      } else {\n        // This is a cleanup function that is grouped with the index of its context\n        const context = lCleanup[tCleanup[i + 1]];\n        tCleanup[i].call(context);\n      }\n    }\n  }\n  if (lCleanup !== null) {\n    lView[CLEANUP] = null;\n  }\n  const destroyHooks = lView[ON_DESTROY_HOOKS];\n  if (destroyHooks !== null) {\n    // Reset the ON_DESTROY_HOOKS array before iterating over it to prevent hooks that unregister\n    // themselves from mutating the array during iteration.\n    lView[ON_DESTROY_HOOKS] = null;\n    for (let i = 0; i < destroyHooks.length; i++) {\n      const destroyHooksFn = destroyHooks[i];\n      ngDevMode && assertFunction(destroyHooksFn, 'Expecting destroy hook to be a function.');\n      destroyHooksFn();\n    }\n  }\n}\n/** Calls onDestroy hooks for this view */\nfunction executeOnDestroys(tView, lView) {\n  let destroyHooks;\n  if (tView != null && (destroyHooks = tView.destroyHooks) != null) {\n    for (let i = 0; i < destroyHooks.length; i += 2) {\n      const context = lView[destroyHooks[i]];\n      // Only call the destroy hook if the context has been requested.\n      if (!(context instanceof NodeInjectorFactory)) {\n        const toCall = destroyHooks[i + 1];\n        if (Array.isArray(toCall)) {\n          for (let j = 0; j < toCall.length; j += 2) {\n            const callContext = context[toCall[j]];\n            const hook = toCall[j + 1];\n            profiler(4 /* ProfilerEvent.LifecycleHookStart */, callContext, hook);\n            try {\n              hook.call(callContext);\n            } finally {\n              profiler(5 /* ProfilerEvent.LifecycleHookEnd */, callContext, hook);\n            }\n          }\n        } else {\n          profiler(4 /* ProfilerEvent.LifecycleHookStart */, context, toCall);\n          try {\n            toCall.call(context);\n          } finally {\n            profiler(5 /* ProfilerEvent.LifecycleHookEnd */, context, toCall);\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Returns a native element if a node can be inserted into the given parent.\n *\n * There are two reasons why we may not be able to insert a element immediately.\n * - Projection: When creating a child content element of a component, we have to skip the\n *   insertion because the content of a component will be projected.\n *   `<component><content>delayed due to projection</content></component>`\n * - Parent container is disconnected: This can happen when we are inserting a view into\n *   parent container, which itself is disconnected. For example the parent container is part\n *   of a View which has not be inserted or is made for projection but has not been inserted\n *   into destination.\n *\n * @param tView: Current `TView`.\n * @param tNode: `TNode` for which we wish to retrieve render parent.\n * @param lView: Current `LView`.\n */\nfunction getParentRElement(tView, tNode, lView) {\n  return getClosestRElement(tView, tNode.parent, lView);\n}\n/**\n * Get closest `RElement` or `null` if it can't be found.\n *\n * If `TNode` is `TNodeType.Element` => return `RElement` at `LView[tNode.index]` location.\n * If `TNode` is `TNodeType.ElementContainer|IcuContain` => return the parent (recursively).\n * If `TNode` is `null` then return host `RElement`:\n *   - return `null` if projection\n *   - return `null` if parent container is disconnected (we have no parent.)\n *\n * @param tView: Current `TView`.\n * @param tNode: `TNode` for which we wish to retrieve `RElement` (or `null` if host element is\n *     needed).\n * @param lView: Current `LView`.\n * @returns `null` if the `RElement` can't be determined at this time (no parent / projection)\n */\nfunction getClosestRElement(tView, tNode, lView) {\n  let parentTNode = tNode;\n  // Skip over element and ICU containers as those are represented by a comment node and\n  // can't be used as a render parent.\n  while (parentTNode !== null && parentTNode.type & (8 /* TNodeType.ElementContainer */ | 32 /* TNodeType.Icu */)) {\n    tNode = parentTNode;\n    parentTNode = tNode.parent;\n  }\n  // If the parent tNode is null, then we are inserting across views: either into an embedded view\n  // or a component view.\n  if (parentTNode === null) {\n    // We are inserting a root element of the component view into the component host element and\n    // it should always be eager.\n    return lView[HOST];\n  } else {\n    ngDevMode && assertTNodeType(parentTNode, 3 /* TNodeType.AnyRNode */ | 4 /* TNodeType.Container */);\n    const {\n      componentOffset\n    } = parentTNode;\n    if (componentOffset > -1) {\n      ngDevMode && assertTNodeForLView(parentTNode, lView);\n      const {\n        encapsulation\n      } = tView.data[parentTNode.directiveStart + componentOffset];\n      // We've got a parent which is an element in the current view. We just need to verify if the\n      // parent element is not a component. Component's content nodes are not inserted immediately\n      // because they will be projected, and so doing insert at this point would be wasteful.\n      // Since the projection would then move it to its final destination. Note that we can't\n      // make this assumption when using the Shadow DOM, because the native projection placeholders\n      // (<content> or <slot>) have to be in place as elements are being inserted.\n      if (encapsulation === ViewEncapsulation.None || encapsulation === ViewEncapsulation.Emulated) {\n        return null;\n      }\n    }\n    return getNativeByTNode(parentTNode, lView);\n  }\n}\n/**\n * Inserts a native node before another native node for a given parent.\n * This is a utility function that can be used when native nodes were determined.\n */\nfunction nativeInsertBefore(renderer, parent, child, beforeNode, isMove) {\n  ngDevMode && ngDevMode.rendererInsertBefore++;\n  renderer.insertBefore(parent, child, beforeNode, isMove);\n}\nfunction nativeAppendChild(renderer, parent, child) {\n  ngDevMode && ngDevMode.rendererAppendChild++;\n  ngDevMode && assertDefined(parent, 'parent node must be defined');\n  renderer.appendChild(parent, child);\n}\nfunction nativeAppendOrInsertBefore(renderer, parent, child, beforeNode, isMove) {\n  if (beforeNode !== null) {\n    nativeInsertBefore(renderer, parent, child, beforeNode, isMove);\n  } else {\n    nativeAppendChild(renderer, parent, child);\n  }\n}\n/** Removes a node from the DOM given its native parent. */\nfunction nativeRemoveChild(renderer, parent, child, isHostElement) {\n  renderer.removeChild(parent, child, isHostElement);\n}\n/** Checks if an element is a `<template>` node. */\nfunction isTemplateNode(node) {\n  return node.tagName === 'TEMPLATE' && node.content !== undefined;\n}\n/**\n * Returns a native parent of a given native node.\n */\nfunction nativeParentNode(renderer, node) {\n  return renderer.parentNode(node);\n}\n/**\n * Returns a native sibling of a given native node.\n */\nfunction nativeNextSibling(renderer, node) {\n  return renderer.nextSibling(node);\n}\n/**\n * Find a node in front of which `currentTNode` should be inserted.\n *\n * This method determines the `RNode` in front of which we should insert the `currentRNode`. This\n * takes `TNode.insertBeforeIndex` into account if i18n code has been invoked.\n *\n * @param parentTNode parent `TNode`\n * @param currentTNode current `TNode` (The node which we would like to insert into the DOM)\n * @param lView current `LView`\n */\nfunction getInsertInFrontOfRNode(parentTNode, currentTNode, lView) {\n  return _getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView);\n}\n/**\n * Find a node in front of which `currentTNode` should be inserted. (Does not take i18n into\n * account)\n *\n * This method determines the `RNode` in front of which we should insert the `currentRNode`. This\n * does not take `TNode.insertBeforeIndex` into account.\n *\n * @param parentTNode parent `TNode`\n * @param currentTNode current `TNode` (The node which we would like to insert into the DOM)\n * @param lView current `LView`\n */\nfunction getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView) {\n  if (parentTNode.type & (8 /* TNodeType.ElementContainer */ | 32 /* TNodeType.Icu */)) {\n    return getNativeByTNode(parentTNode, lView);\n  }\n  return null;\n}\n/**\n * Tree shakable boundary for `getInsertInFrontOfRNodeWithI18n` function.\n *\n * This function will only be set if i18n code runs.\n */\nlet _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithNoI18n;\n/**\n * Tree shakable boundary for `processI18nInsertBefore` function.\n *\n * This function will only be set if i18n code runs.\n */\nlet _processI18nInsertBefore;\nfunction setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore) {\n  _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithI18n;\n  _processI18nInsertBefore = processI18nInsertBefore;\n}\n/**\n * Appends the `child` native node (or a collection of nodes) to the `parent`.\n *\n * @param tView The `TView' to be appended\n * @param lView The current LView\n * @param childRNode The native child (or children) that should be appended\n * @param childTNode The TNode of the child element\n */\nfunction appendChild(tView, lView, childRNode, childTNode) {\n  const parentRNode = getParentRElement(tView, childTNode, lView);\n  const renderer = lView[RENDERER];\n  const parentTNode = childTNode.parent || lView[T_HOST];\n  const anchorNode = getInsertInFrontOfRNode(parentTNode, childTNode, lView);\n  if (parentRNode != null) {\n    if (Array.isArray(childRNode)) {\n      for (let i = 0; i < childRNode.length; i++) {\n        nativeAppendOrInsertBefore(renderer, parentRNode, childRNode[i], anchorNode, false);\n      }\n    } else {\n      nativeAppendOrInsertBefore(renderer, parentRNode, childRNode, anchorNode, false);\n    }\n  }\n  _processI18nInsertBefore !== undefined && _processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRNode);\n}\n/**\n * Returns the first native node for a given LView, starting from the provided TNode.\n *\n * Native nodes are returned in the order in which those appear in the native tree (DOM).\n */\nfunction getFirstNativeNode(lView, tNode) {\n  if (tNode !== null) {\n    ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 12 /* TNodeType.AnyContainer */ | 32 /* TNodeType.Icu */ | 16 /* TNodeType.Projection */);\n    const tNodeType = tNode.type;\n    if (tNodeType & 3 /* TNodeType.AnyRNode */) {\n      return getNativeByTNode(tNode, lView);\n    } else if (tNodeType & 4 /* TNodeType.Container */) {\n      return getBeforeNodeForView(-1, lView[tNode.index]);\n    } else if (tNodeType & 8 /* TNodeType.ElementContainer */) {\n      const elIcuContainerChild = tNode.child;\n      if (elIcuContainerChild !== null) {\n        return getFirstNativeNode(lView, elIcuContainerChild);\n      } else {\n        const rNodeOrLContainer = lView[tNode.index];\n        if (isLContainer(rNodeOrLContainer)) {\n          return getBeforeNodeForView(-1, rNodeOrLContainer);\n        } else {\n          return unwrapRNode(rNodeOrLContainer);\n        }\n      }\n    } else if (tNodeType & 32 /* TNodeType.Icu */) {\n      let nextRNode = icuContainerIterate(tNode, lView);\n      let rNode = nextRNode();\n      // If the ICU container has no nodes, than we use the ICU anchor as the node.\n      return rNode || unwrapRNode(lView[tNode.index]);\n    } else {\n      const projectionNodes = getProjectionNodes(lView, tNode);\n      if (projectionNodes !== null) {\n        if (Array.isArray(projectionNodes)) {\n          return projectionNodes[0];\n        }\n        const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);\n        ngDevMode && assertParentView(parentView);\n        return getFirstNativeNode(parentView, projectionNodes);\n      } else {\n        return getFirstNativeNode(lView, tNode.next);\n      }\n    }\n  }\n  return null;\n}\nfunction getProjectionNodes(lView, tNode) {\n  if (tNode !== null) {\n    const componentView = lView[DECLARATION_COMPONENT_VIEW];\n    const componentHost = componentView[T_HOST];\n    const slotIdx = tNode.projection;\n    ngDevMode && assertProjectionSlots(lView);\n    return componentHost.projection[slotIdx];\n  }\n  return null;\n}\nfunction getBeforeNodeForView(viewIndexInContainer, lContainer) {\n  const nextViewIndex = CONTAINER_HEADER_OFFSET + viewIndexInContainer + 1;\n  if (nextViewIndex < lContainer.length) {\n    const lView = lContainer[nextViewIndex];\n    const firstTNodeOfView = lView[TVIEW].firstChild;\n    if (firstTNodeOfView !== null) {\n      return getFirstNativeNode(lView, firstTNodeOfView);\n    }\n  }\n  return lContainer[NATIVE];\n}\n/**\n * Removes a native node itself using a given renderer. To remove the node we are looking up its\n * parent from the native tree as not all platforms / browsers support the equivalent of\n * node.remove().\n *\n * @param renderer A renderer to be used\n * @param rNode The native node that should be removed\n * @param isHostElement A flag indicating if a node to be removed is a host of a component.\n */\nfunction nativeRemoveNode(renderer, rNode, isHostElement) {\n  ngDevMode && ngDevMode.rendererRemoveNode++;\n  const nativeParent = nativeParentNode(renderer, rNode);\n  if (nativeParent) {\n    nativeRemoveChild(renderer, nativeParent, rNode, isHostElement);\n  }\n}\n/**\n * Clears the contents of a given RElement.\n *\n * @param rElement the native RElement to be cleared\n */\nfunction clearElementContents(rElement) {\n  rElement.textContent = '';\n}\n/**\n * Performs the operation of `action` on the node. Typically this involves inserting or removing\n * nodes on the LView or projection boundary.\n */\nfunction applyNodes(renderer, action, tNode, lView, parentRElement, beforeNode, isProjection) {\n  while (tNode != null) {\n    ngDevMode && assertTNodeForLView(tNode, lView);\n    ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 12 /* TNodeType.AnyContainer */ | 16 /* TNodeType.Projection */ | 32 /* TNodeType.Icu */);\n    const rawSlotValue = lView[tNode.index];\n    const tNodeType = tNode.type;\n    if (isProjection) {\n      if (action === 0 /* WalkTNodeTreeAction.Create */) {\n        rawSlotValue && attachPatchData(unwrapRNode(rawSlotValue), lView);\n        tNode.flags |= 2 /* TNodeFlags.isProjected */;\n      }\n    }\n\n    if ((tNode.flags & 32 /* TNodeFlags.isDetached */) !== 32 /* TNodeFlags.isDetached */) {\n      if (tNodeType & 8 /* TNodeType.ElementContainer */) {\n        applyNodes(renderer, action, tNode.child, lView, parentRElement, beforeNode, false);\n        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);\n      } else if (tNodeType & 32 /* TNodeType.Icu */) {\n        const nextRNode = icuContainerIterate(tNode, lView);\n        let rNode;\n        while (rNode = nextRNode()) {\n          applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);\n        }\n        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);\n      } else if (tNodeType & 16 /* TNodeType.Projection */) {\n        applyProjectionRecursive(renderer, action, lView, tNode, parentRElement, beforeNode);\n      } else {\n        ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 4 /* TNodeType.Container */);\n        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);\n      }\n    }\n    tNode = isProjection ? tNode.projectionNext : tNode.next;\n  }\n}\nfunction applyView(tView, lView, renderer, action, parentRElement, beforeNode) {\n  applyNodes(renderer, action, tView.firstChild, lView, parentRElement, beforeNode, false);\n}\n/**\n * `applyProjection` performs operation on the projection.\n *\n * Inserting a projection requires us to locate the projected nodes from the parent component. The\n * complication is that those nodes themselves could be re-projected from their parent component.\n *\n * @param tView The `TView` of `LView` which needs to be inserted, detached, destroyed\n * @param lView The `LView` which needs to be inserted, detached, destroyed.\n * @param tProjectionNode node to project\n */\nfunction applyProjection(tView, lView, tProjectionNode) {\n  const renderer = lView[RENDERER];\n  const parentRNode = getParentRElement(tView, tProjectionNode, lView);\n  const parentTNode = tProjectionNode.parent || lView[T_HOST];\n  let beforeNode = getInsertInFrontOfRNode(parentTNode, tProjectionNode, lView);\n  applyProjectionRecursive(renderer, 0 /* WalkTNodeTreeAction.Create */, lView, tProjectionNode, parentRNode, beforeNode);\n}\n/**\n * `applyProjectionRecursive` performs operation on the projection specified by `action` (insert,\n * detach, destroy)\n *\n * Inserting a projection requires us to locate the projected nodes from the parent component. The\n * complication is that those nodes themselves could be re-projected from their parent component.\n *\n * @param renderer Render to use\n * @param action action to perform (insert, detach, destroy)\n * @param lView The LView which needs to be inserted, detached, destroyed.\n * @param tProjectionNode node to project\n * @param parentRElement parent DOM element for insertion/removal.\n * @param beforeNode Before which node the insertions should happen.\n */\nfunction applyProjectionRecursive(renderer, action, lView, tProjectionNode, parentRElement, beforeNode) {\n  const componentLView = lView[DECLARATION_COMPONENT_VIEW];\n  const componentNode = componentLView[T_HOST];\n  ngDevMode && assertEqual(typeof tProjectionNode.projection, 'number', 'expecting projection index');\n  const nodeToProjectOrRNodes = componentNode.projection[tProjectionNode.projection];\n  if (Array.isArray(nodeToProjectOrRNodes)) {\n    // This should not exist, it is a bit of a hack. When we bootstrap a top level node and we\n    // need to support passing projectable nodes, so we cheat and put them in the TNode\n    // of the Host TView. (Yes we put instance info at the T Level). We can get away with it\n    // because we know that that TView is not shared and therefore it will not be a problem.\n    // This should be refactored and cleaned up.\n    for (let i = 0; i < nodeToProjectOrRNodes.length; i++) {\n      const rNode = nodeToProjectOrRNodes[i];\n      applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);\n    }\n  } else {\n    let nodeToProject = nodeToProjectOrRNodes;\n    const projectedComponentLView = componentLView[PARENT];\n    // If a parent <ng-content> is located within a skip hydration block,\n    // annotate an actual node that is being projected with the same flag too.\n    if (hasInSkipHydrationBlockFlag(tProjectionNode)) {\n      nodeToProject.flags |= 128 /* TNodeFlags.inSkipHydrationBlock */;\n    }\n\n    applyNodes(renderer, action, nodeToProject, projectedComponentLView, parentRElement, beforeNode, true);\n  }\n}\n/**\n * `applyContainer` performs an operation on the container and its views as specified by\n * `action` (insert, detach, destroy)\n *\n * Inserting a Container is complicated by the fact that the container may have Views which\n * themselves have containers or projections.\n *\n * @param renderer Renderer to use\n * @param action action to perform (insert, detach, destroy)\n * @param lContainer The LContainer which needs to be inserted, detached, destroyed.\n * @param parentRElement parent DOM element for insertion/removal.\n * @param beforeNode Before which node the insertions should happen.\n */\nfunction applyContainer(renderer, action, lContainer, parentRElement, beforeNode) {\n  ngDevMode && assertLContainer(lContainer);\n  const anchor = lContainer[NATIVE]; // LContainer has its own before node.\n  const native = unwrapRNode(lContainer);\n  // An LContainer can be created dynamically on any node by injecting ViewContainerRef.\n  // Asking for a ViewContainerRef on an element will result in a creation of a separate anchor\n  // node (comment in the DOM) that will be different from the LContainer's host node. In this\n  // particular case we need to execute action on 2 nodes:\n  // - container's host node (this is done in the executeActionOnElementOrContainer)\n  // - container's host node (this is done here)\n  if (anchor !== native) {\n    // This is very strange to me (Misko). I would expect that the native is same as anchor. I\n    // don't see a reason why they should be different, but they are.\n    //\n    // If they are we need to process the second anchor as well.\n    applyToElementOrContainer(action, renderer, parentRElement, anchor, beforeNode);\n  }\n  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n    const lView = lContainer[i];\n    applyView(lView[TVIEW], lView, renderer, action, parentRElement, anchor);\n  }\n}\n/**\n * Writes class/style to element.\n *\n * @param renderer Renderer to use.\n * @param isClassBased `true` if it should be written to `class` (`false` to write to `style`)\n * @param rNode The Node to write to.\n * @param prop Property to write to. This would be the class/style name.\n * @param value Value to write. If `null`/`undefined`/`false` this is considered a remove (set/add\n *        otherwise).\n */\nfunction applyStyling(renderer, isClassBased, rNode, prop, value) {\n  if (isClassBased) {\n    // We actually want JS true/false here because any truthy value should add the class\n    if (!value) {\n      ngDevMode && ngDevMode.rendererRemoveClass++;\n      renderer.removeClass(rNode, prop);\n    } else {\n      ngDevMode && ngDevMode.rendererAddClass++;\n      renderer.addClass(rNode, prop);\n    }\n  } else {\n    let flags = prop.indexOf('-') === -1 ? undefined : RendererStyleFlags2.DashCase;\n    if (value == null /** || value === undefined */) {\n      ngDevMode && ngDevMode.rendererRemoveStyle++;\n      renderer.removeStyle(rNode, prop, flags);\n    } else {\n      // A value is important if it ends with `!important`. The style\n      // parser strips any semicolons at the end of the value.\n      const isImportant = typeof value === 'string' ? value.endsWith('!important') : false;\n      if (isImportant) {\n        // !important has to be stripped from the value for it to be valid.\n        value = value.slice(0, -10);\n        flags |= RendererStyleFlags2.Important;\n      }\n      ngDevMode && ngDevMode.rendererSetStyle++;\n      renderer.setStyle(rNode, prop, value, flags);\n    }\n  }\n}\n/**\n * Write `cssText` to `RElement`.\n *\n * This function does direct write without any reconciliation. Used for writing initial values, so\n * that static styling values do not pull in the style parser.\n *\n * @param renderer Renderer to use\n * @param element The element which needs to be updated.\n * @param newValue The new class list to write.\n */\nfunction writeDirectStyle(renderer, element, newValue) {\n  ngDevMode && assertString(newValue, '\\'newValue\\' should be a string');\n  renderer.setAttribute(element, 'style', newValue);\n  ngDevMode && ngDevMode.rendererSetStyle++;\n}\n/**\n * Write `className` to `RElement`.\n *\n * This function does direct write without any reconciliation. Used for writing initial values, so\n * that static styling values do not pull in the style parser.\n *\n * @param renderer Renderer to use\n * @param element The element which needs to be updated.\n * @param newValue The new class list to write.\n */\nfunction writeDirectClass(renderer, element, newValue) {\n  ngDevMode && assertString(newValue, '\\'newValue\\' should be a string');\n  if (newValue === '') {\n    // There are tests in `google3` which expect `element.getAttribute('class')` to be `null`.\n    renderer.removeAttribute(element, 'class');\n  } else {\n    renderer.setAttribute(element, 'class', newValue);\n  }\n  ngDevMode && ngDevMode.rendererSetClassName++;\n}\n/** Sets up the static DOM attributes on an `RNode`. */\nfunction setupStaticAttributes(renderer, element, tNode) {\n  const {\n    mergedAttrs,\n    classes,\n    styles\n  } = tNode;\n  if (mergedAttrs !== null) {\n    setUpAttributes(renderer, element, mergedAttrs);\n  }\n  if (classes !== null) {\n    writeDirectClass(renderer, element, classes);\n  }\n  if (styles !== null) {\n    writeDirectStyle(renderer, element, styles);\n  }\n}\n\n/**\n * @fileoverview\n * A module to facilitate use of a Trusted Types policy internally within\n * Angular. It lazily constructs the Trusted Types policy, providing helper\n * utilities for promoting strings to Trusted Types. When Trusted Types are not\n * available, strings are used as a fallback.\n * @security All use of this module is security-sensitive and should go through\n * security review.\n */\n/**\n * The Trusted Types policy, or null if Trusted Types are not\n * enabled/supported, or undefined if the policy has not been created yet.\n */\nlet policy$1;\n/**\n * Returns the Trusted Types policy, or null if Trusted Types are not\n * enabled/supported. The first call to this function will create the policy.\n */\nfunction getPolicy$1() {\n  if (policy$1 === undefined) {\n    policy$1 = null;\n    if (_global.trustedTypes) {\n      try {\n        policy$1 = _global.trustedTypes.createPolicy('angular', {\n          createHTML: s => s,\n          createScript: s => s,\n          createScriptURL: s => s\n        });\n      } catch {\n        // trustedTypes.createPolicy throws if called with a name that is\n        // already registered, even in report-only mode. Until the API changes,\n        // catch the error not to break the applications functionally. In such\n        // cases, the code will fall back to using strings.\n      }\n    }\n  }\n  return policy$1;\n}\n/**\n * Unsafely promote a string to a TrustedHTML, falling back to strings when\n * Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that the\n * provided string will never cause an XSS vulnerability if used in a context\n * that will be interpreted as HTML by a browser, e.g. when assigning to\n * element.innerHTML.\n */\nfunction trustedHTMLFromString(html) {\n  return getPolicy$1()?.createHTML(html) || html;\n}\n/**\n * Unsafely promote a string to a TrustedScript, falling back to strings when\n * Trusted Types are not available.\n * @security In particular, it must be assured that the provided string will\n * never cause an XSS vulnerability if used in a context that will be\n * interpreted and executed as a script by a browser, e.g. when calling eval.\n */\nfunction trustedScriptFromString(script) {\n  return getPolicy$1()?.createScript(script) || script;\n}\n/**\n * Unsafely promote a string to a TrustedScriptURL, falling back to strings\n * when Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that the\n * provided string will never cause an XSS vulnerability if used in a context\n * that will cause a browser to load and execute a resource, e.g. when\n * assigning to script.src.\n */\nfunction trustedScriptURLFromString(url) {\n  return getPolicy$1()?.createScriptURL(url) || url;\n}\n/**\n * Unsafely call the Function constructor with the given string arguments. It\n * is only available in development mode, and should be stripped out of\n * production code.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only called from development code, as use in production code can lead to\n * XSS vulnerabilities.\n */\nfunction newTrustedFunctionForDev(...args) {\n  if (typeof ngDevMode === 'undefined') {\n    throw new Error('newTrustedFunctionForDev should never be called in production');\n  }\n  if (!_global.trustedTypes) {\n    // In environments that don't support Trusted Types, fall back to the most\n    // straightforward implementation:\n    return new Function(...args);\n  }\n  // Chrome currently does not support passing TrustedScript to the Function\n  // constructor. The following implements the workaround proposed on the page\n  // below, where the Chromium bug is also referenced:\n  // https://github.com/w3c/webappsec-trusted-types/wiki/Trusted-Types-for-function-constructor\n  const fnArgs = args.slice(0, -1).join(',');\n  const fnBody = args[args.length - 1];\n  const body = `(function anonymous(${fnArgs}\n) { ${fnBody}\n})`;\n  // Using eval directly confuses the compiler and prevents this module from\n  // being stripped out of JS binaries even if not used. The global['eval']\n  // indirection fixes that.\n  const fn = _global['eval'](trustedScriptFromString(body));\n  if (fn.bind === undefined) {\n    // Workaround for a browser bug that only exists in Chrome 83, where passing\n    // a TrustedScript to eval just returns the TrustedScript back without\n    // evaluating it. In that case, fall back to the most straightforward\n    // implementation:\n    return new Function(...args);\n  }\n  // To completely mimic the behavior of calling \"new Function\", two more\n  // things need to happen:\n  // 1. Stringifying the resulting function should return its source code\n  fn.toString = () => body;\n  // 2. When calling the resulting function, `this` should refer to `global`\n  return fn.bind(_global);\n  // When Trusted Types support in Function constructors is widely available,\n  // the implementation of this function can be simplified to:\n  // return new Function(...args.map(a => trustedScriptFromString(a)));\n}\n\n/**\n * Validation function invoked at runtime for each binding that might potentially\n * represent a security-sensitive attribute of an <iframe>.\n * See `IFRAME_SECURITY_SENSITIVE_ATTRS` in the\n * `packages/compiler/src/schema/dom_security_schema.ts` script for the full list\n * of such attributes.\n *\n * @codeGenApi\n */\nfunction ɵɵvalidateIframeAttribute(attrValue, tagName, attrName) {\n  const lView = getLView();\n  const tNode = getSelectedTNode();\n  const element = getNativeByTNode(tNode, lView);\n  // Restrict any dynamic bindings of security-sensitive attributes/properties\n  // on an <iframe> for security reasons.\n  if (tNode.type === 2 /* TNodeType.Element */ && tagName.toLowerCase() === 'iframe') {\n    const iframe = element;\n    // Unset previously applied `src` and `srcdoc` if we come across a situation when\n    // a security-sensitive attribute is set later via an attribute/property binding.\n    iframe.src = '';\n    iframe.srcdoc = trustedHTMLFromString('');\n    // Also remove the <iframe> from the document.\n    nativeRemoveNode(lView[RENDERER], iframe);\n    const errorMessage = ngDevMode && `Angular has detected that the \\`${attrName}\\` was applied ` + `as a binding to an <iframe>${getTemplateLocationDetails(lView)}. ` + `For security reasons, the \\`${attrName}\\` can be set on an <iframe> ` + `as a static attribute only. \\n` + `To fix this, switch the \\`${attrName}\\` binding to a static attribute ` + `in a template or in host bindings section.`;\n    throw new RuntimeError(-910 /* RuntimeErrorCode.UNSAFE_IFRAME_ATTRS */, errorMessage);\n  }\n  return attrValue;\n}\n\n/**\n * @fileoverview\n * A module to facilitate use of a Trusted Types policy internally within\n * Angular specifically for bypassSecurityTrust* and custom sanitizers. It\n * lazily constructs the Trusted Types policy, providing helper utilities for\n * promoting strings to Trusted Types. When Trusted Types are not available,\n * strings are used as a fallback.\n * @security All use of this module is security-sensitive and should go through\n * security review.\n */\n/**\n * The Trusted Types policy, or null if Trusted Types are not\n * enabled/supported, or undefined if the policy has not been created yet.\n */\nlet policy;\n/**\n * Returns the Trusted Types policy, or null if Trusted Types are not\n * enabled/supported. The first call to this function will create the policy.\n */\nfunction getPolicy() {\n  if (policy === undefined) {\n    policy = null;\n    if (_global.trustedTypes) {\n      try {\n        policy = _global.trustedTypes.createPolicy('angular#unsafe-bypass', {\n          createHTML: s => s,\n          createScript: s => s,\n          createScriptURL: s => s\n        });\n      } catch {\n        // trustedTypes.createPolicy throws if called with a name that is\n        // already registered, even in report-only mode. Until the API changes,\n        // catch the error not to break the applications functionally. In such\n        // cases, the code will fall back to using strings.\n      }\n    }\n  }\n  return policy;\n}\n/**\n * Unsafely promote a string to a TrustedHTML, falling back to strings when\n * Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only passed strings that come directly from custom sanitizers or the\n * bypassSecurityTrust* functions.\n */\nfunction trustedHTMLFromStringBypass(html) {\n  return getPolicy()?.createHTML(html) || html;\n}\n/**\n * Unsafely promote a string to a TrustedScript, falling back to strings when\n * Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only passed strings that come directly from custom sanitizers or the\n * bypassSecurityTrust* functions.\n */\nfunction trustedScriptFromStringBypass(script) {\n  return getPolicy()?.createScript(script) || script;\n}\n/**\n * Unsafely promote a string to a TrustedScriptURL, falling back to strings\n * when Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only passed strings that come directly from custom sanitizers or the\n * bypassSecurityTrust* functions.\n */\nfunction trustedScriptURLFromStringBypass(url) {\n  return getPolicy()?.createScriptURL(url) || url;\n}\nclass SafeValueImpl {\n  constructor(changingThisBreaksApplicationSecurity) {\n    this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;\n  }\n  toString() {\n    return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity}` + ` (see ${XSS_SECURITY_URL})`;\n  }\n}\nclass SafeHtmlImpl extends SafeValueImpl {\n  getTypeName() {\n    return \"HTML\" /* BypassType.Html */;\n  }\n}\n\nclass SafeStyleImpl extends SafeValueImpl {\n  getTypeName() {\n    return \"Style\" /* BypassType.Style */;\n  }\n}\n\nclass SafeScriptImpl extends SafeValueImpl {\n  getTypeName() {\n    return \"Script\" /* BypassType.Script */;\n  }\n}\n\nclass SafeUrlImpl extends SafeValueImpl {\n  getTypeName() {\n    return \"URL\" /* BypassType.Url */;\n  }\n}\n\nclass SafeResourceUrlImpl extends SafeValueImpl {\n  getTypeName() {\n    return \"ResourceURL\" /* BypassType.ResourceUrl */;\n  }\n}\n\nfunction unwrapSafeValue(value) {\n  return value instanceof SafeValueImpl ? value.changingThisBreaksApplicationSecurity : value;\n}\nfunction allowSanitizationBypassAndThrow(value, type) {\n  const actualType = getSanitizationBypassType(value);\n  if (actualType != null && actualType !== type) {\n    // Allow ResourceURLs in URL contexts, they are strictly more trusted.\n    if (actualType === \"ResourceURL\" /* BypassType.ResourceUrl */ && type === \"URL\" /* BypassType.Url */) return true;\n    throw new Error(`Required a safe ${type}, got a ${actualType} (see ${XSS_SECURITY_URL})`);\n  }\n  return actualType === type;\n}\nfunction getSanitizationBypassType(value) {\n  return value instanceof SafeValueImpl && value.getTypeName() || null;\n}\n/**\n * Mark `html` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link htmlSanitizer} to be trusted implicitly.\n *\n * @param trustedHtml `html` string which needs to be implicitly trusted.\n * @returns a `html` which has been branded to be implicitly trusted.\n */\nfunction bypassSanitizationTrustHtml(trustedHtml) {\n  return new SafeHtmlImpl(trustedHtml);\n}\n/**\n * Mark `style` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link styleSanitizer} to be trusted implicitly.\n *\n * @param trustedStyle `style` string which needs to be implicitly trusted.\n * @returns a `style` hich has been branded to be implicitly trusted.\n */\nfunction bypassSanitizationTrustStyle(trustedStyle) {\n  return new SafeStyleImpl(trustedStyle);\n}\n/**\n * Mark `script` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link scriptSanitizer} to be trusted implicitly.\n *\n * @param trustedScript `script` string which needs to be implicitly trusted.\n * @returns a `script` which has been branded to be implicitly trusted.\n */\nfunction bypassSanitizationTrustScript(trustedScript) {\n  return new SafeScriptImpl(trustedScript);\n}\n/**\n * Mark `url` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link urlSanitizer} to be trusted implicitly.\n *\n * @param trustedUrl `url` string which needs to be implicitly trusted.\n * @returns a `url`  which has been branded to be implicitly trusted.\n */\nfunction bypassSanitizationTrustUrl(trustedUrl) {\n  return new SafeUrlImpl(trustedUrl);\n}\n/**\n * Mark `url` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link resourceUrlSanitizer} to be trusted implicitly.\n *\n * @param trustedResourceUrl `url` string which needs to be implicitly trusted.\n * @returns a `url` which has been branded to be implicitly trusted.\n */\nfunction bypassSanitizationTrustResourceUrl(trustedResourceUrl) {\n  return new SafeResourceUrlImpl(trustedResourceUrl);\n}\n\n/**\n * This helper is used to get hold of an inert tree of DOM elements containing dirty HTML\n * that needs sanitizing.\n * Depending upon browser support we use one of two strategies for doing this.\n * Default: DOMParser strategy\n * Fallback: InertDocument strategy\n */\nfunction getInertBodyHelper(defaultDoc) {\n  const inertDocumentHelper = new InertDocumentHelper(defaultDoc);\n  return isDOMParserAvailable() ? new DOMParserHelper(inertDocumentHelper) : inertDocumentHelper;\n}\n/**\n * Uses DOMParser to create and fill an inert body element.\n * This is the default strategy used in browsers that support it.\n */\nclass DOMParserHelper {\n  constructor(inertDocumentHelper) {\n    this.inertDocumentHelper = inertDocumentHelper;\n  }\n  getInertBodyElement(html) {\n    // We add these extra elements to ensure that the rest of the content is parsed as expected\n    // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the\n    // `<head>` tag. Note that the `<body>` tag is closed implicitly to prevent unclosed tags\n    // in `html` from consuming the otherwise explicit `</body>` tag.\n    html = '<body><remove></remove>' + html;\n    try {\n      const body = new window.DOMParser().parseFromString(trustedHTMLFromString(html), 'text/html').body;\n      if (body === null) {\n        // In some browsers (e.g. Mozilla/5.0 iPad AppleWebKit Mobile) the `body` property only\n        // becomes available in the following tick of the JS engine. In that case we fall back to\n        // the `inertDocumentHelper` instead.\n        return this.inertDocumentHelper.getInertBodyElement(html);\n      }\n      body.removeChild(body.firstChild);\n      return body;\n    } catch {\n      return null;\n    }\n  }\n}\n/**\n * Use an HTML5 `template` element to create and fill an inert DOM element.\n * This is the fallback strategy if the browser does not support DOMParser.\n */\nclass InertDocumentHelper {\n  constructor(defaultDoc) {\n    this.defaultDoc = defaultDoc;\n    this.inertDocument = this.defaultDoc.implementation.createHTMLDocument('sanitization-inert');\n  }\n  getInertBodyElement(html) {\n    const templateEl = this.inertDocument.createElement('template');\n    templateEl.innerHTML = trustedHTMLFromString(html);\n    return templateEl;\n  }\n}\n/**\n * We need to determine whether the DOMParser exists in the global context and\n * supports parsing HTML; HTML parsing support is not as wide as other formats, see\n * https://developer.mozilla.org/en-US/docs/Web/API/DOMParser#Browser_compatibility.\n *\n * @suppress {uselessCode}\n */\nfunction isDOMParserAvailable() {\n  try {\n    return !!new window.DOMParser().parseFromString(trustedHTMLFromString(''), 'text/html');\n  } catch {\n    return false;\n  }\n}\n\n/**\n * A pattern that recognizes URLs that are safe wrt. XSS in URL navigation\n * contexts.\n *\n * This regular expression matches a subset of URLs that will not cause script\n * execution if used in URL context within a HTML document. Specifically, this\n * regular expression matches if:\n * (1) Either a protocol that is not javascript:, and that has valid characters\n *     (alphanumeric or [+-.]).\n * (2) or no protocol.  A protocol must be followed by a colon. The below\n *     allows that by allowing colons only after one of the characters [/?#].\n *     A colon after a hash (#) must be in the fragment.\n *     Otherwise, a colon after a (?) must be in a query.\n *     Otherwise, a colon after a single solidus (/) must be in a path.\n *     Otherwise, a colon after a double solidus (//) must be in the authority\n *     (before port).\n *\n * The pattern disallows &, used in HTML entity declarations before\n * one of the characters in [/?#]. This disallows HTML entities used in the\n * protocol name, which should never happen, e.g. \"h&#116;tp\" for \"http\".\n * It also disallows HTML entities in the first path part of a relative path,\n * e.g. \"foo&lt;bar/baz\".  Our existing escaping functions should not produce\n * that. More importantly, it disallows masking of a colon,\n * e.g. \"javascript&#58;...\".\n *\n * This regular expression was taken from the Closure sanitization library.\n */\nconst SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\\/?#]*(?:[\\/?#]|$))/i;\nfunction _sanitizeUrl(url) {\n  url = String(url);\n  if (url.match(SAFE_URL_PATTERN)) return url;\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    console.warn(`WARNING: sanitizing unsafe URL value ${url} (see ${XSS_SECURITY_URL})`);\n  }\n  return 'unsafe:' + url;\n}\nfunction tagSet(tags) {\n  const res = {};\n  for (const t of tags.split(',')) res[t] = true;\n  return res;\n}\nfunction merge(...sets) {\n  const res = {};\n  for (const s of sets) {\n    for (const v in s) {\n      if (s.hasOwnProperty(v)) res[v] = true;\n    }\n  }\n  return res;\n}\n// Good source of info about elements and attributes\n// https://html.spec.whatwg.org/#semantics\n// https://simon.html5.org/html-elements\n// Safe Void Elements - HTML5\n// https://html.spec.whatwg.org/#void-elements\nconst VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');\n// Elements that you can, intentionally, leave open (and which close themselves)\n// https://html.spec.whatwg.org/#optional-tags\nconst OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');\nconst OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');\nconst OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);\n// Safe Block Elements - HTML5\nconst BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet('address,article,' + 'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' + 'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'));\n// Inline Elements - HTML5\nconst INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet('a,abbr,acronym,audio,b,' + 'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' + 'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));\nconst VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);\n// Attributes that have href and hence need to be sanitized\nconst URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');\nconst HTML_ATTRS = tagSet('abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' + 'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' + 'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' + 'scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,' + 'valign,value,vspace,width');\n// Accessibility attributes as per WAI-ARIA 1.1 (W3C Working Draft 14 December 2018)\nconst ARIA_ATTRS = tagSet('aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,' + 'aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,' + 'aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,' + 'aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,' + 'aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,' + 'aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,' + 'aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext');\n// NB: This currently consciously doesn't support SVG. SVG sanitization has had several security\n// issues in the past, so it seems safer to leave it out if possible. If support for binding SVG via\n// innerHTML is required, SVG attributes should be added here.\n// NB: Sanitization does not allow <form> elements or other active elements (<button> etc). Those\n// can be sanitized, but they increase security surface area without a legitimate use case, so they\n// are left out here.\nconst VALID_ATTRS = merge(URI_ATTRS, HTML_ATTRS, ARIA_ATTRS);\n// Elements whose content should not be traversed/preserved, if the elements themselves are invalid.\n//\n// Typically, `<invalid>Some content</invalid>` would traverse (and in this case preserve)\n// `Some content`, but strip `invalid-element` opening/closing tags. For some elements, though, we\n// don't want to preserve the content, if the elements themselves are going to be removed.\nconst SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet('script,style,template');\n/**\n * SanitizingHtmlSerializer serializes a DOM fragment, stripping out any unsafe elements and unsafe\n * attributes.\n */\nclass SanitizingHtmlSerializer {\n  constructor() {\n    // Explicitly track if something was stripped, to avoid accidentally warning of sanitization just\n    // because characters were re-encoded.\n    this.sanitizedSomething = false;\n    this.buf = [];\n  }\n  sanitizeChildren(el) {\n    // This cannot use a TreeWalker, as it has to run on Angular's various DOM adapters.\n    // However this code never accesses properties off of `document` before deleting its contents\n    // again, so it shouldn't be vulnerable to DOM clobbering.\n    let current = el.firstChild;\n    let traverseContent = true;\n    while (current) {\n      if (current.nodeType === Node.ELEMENT_NODE) {\n        traverseContent = this.startElement(current);\n      } else if (current.nodeType === Node.TEXT_NODE) {\n        this.chars(current.nodeValue);\n      } else {\n        // Strip non-element, non-text nodes.\n        this.sanitizedSomething = true;\n      }\n      if (traverseContent && current.firstChild) {\n        current = current.firstChild;\n        continue;\n      }\n      while (current) {\n        // Leaving the element. Walk up and to the right, closing tags as we go.\n        if (current.nodeType === Node.ELEMENT_NODE) {\n          this.endElement(current);\n        }\n        let next = this.checkClobberedElement(current, current.nextSibling);\n        if (next) {\n          current = next;\n          break;\n        }\n        current = this.checkClobberedElement(current, current.parentNode);\n      }\n    }\n    return this.buf.join('');\n  }\n  /**\n   * Sanitizes an opening element tag (if valid) and returns whether the element's contents should\n   * be traversed. Element content must always be traversed (even if the element itself is not\n   * valid/safe), unless the element is one of `SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS`.\n   *\n   * @param element The element to sanitize.\n   * @return True if the element's contents should be traversed.\n   */\n  startElement(element) {\n    const tagName = element.nodeName.toLowerCase();\n    if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {\n      this.sanitizedSomething = true;\n      return !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);\n    }\n    this.buf.push('<');\n    this.buf.push(tagName);\n    const elAttrs = element.attributes;\n    for (let i = 0; i < elAttrs.length; i++) {\n      const elAttr = elAttrs.item(i);\n      const attrName = elAttr.name;\n      const lower = attrName.toLowerCase();\n      if (!VALID_ATTRS.hasOwnProperty(lower)) {\n        this.sanitizedSomething = true;\n        continue;\n      }\n      let value = elAttr.value;\n      // TODO(martinprobst): Special case image URIs for data:image/...\n      if (URI_ATTRS[lower]) value = _sanitizeUrl(value);\n      this.buf.push(' ', attrName, '=\"', encodeEntities(value), '\"');\n    }\n    this.buf.push('>');\n    return true;\n  }\n  endElement(current) {\n    const tagName = current.nodeName.toLowerCase();\n    if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {\n      this.buf.push('</');\n      this.buf.push(tagName);\n      this.buf.push('>');\n    }\n  }\n  chars(chars) {\n    this.buf.push(encodeEntities(chars));\n  }\n  checkClobberedElement(node, nextNode) {\n    if (nextNode && (node.compareDocumentPosition(nextNode) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) {\n      throw new Error(`Failed to sanitize html because the element is clobbered: ${node.outerHTML}`);\n    }\n    return nextNode;\n  }\n}\n// Regular Expressions for parsing tags and attributes\nconst SURROGATE_PAIR_REGEXP = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n// ! to ~ is the ASCII range.\nconst NON_ALPHANUMERIC_REGEXP = /([^\\#-~ |!])/g;\n/**\n * Escapes all potentially dangerous characters, so that the\n * resulting string can be safely inserted into attribute or\n * element text.\n * @param value\n */\nfunction encodeEntities(value) {\n  return value.replace(/&/g, '&amp;').replace(SURROGATE_PAIR_REGEXP, function (match) {\n    const hi = match.charCodeAt(0);\n    const low = match.charCodeAt(1);\n    return '&#' + ((hi - 0xD800) * 0x400 + (low - 0xDC00) + 0x10000) + ';';\n  }).replace(NON_ALPHANUMERIC_REGEXP, function (match) {\n    return '&#' + match.charCodeAt(0) + ';';\n  }).replace(/</g, '&lt;').replace(/>/g, '&gt;');\n}\nlet inertBodyHelper;\n/**\n * Sanitizes the given unsafe, untrusted HTML fragment, and returns HTML text that is safe to add to\n * the DOM in a browser environment.\n */\nfunction _sanitizeHtml(defaultDoc, unsafeHtmlInput) {\n  let inertBodyElement = null;\n  try {\n    inertBodyHelper = inertBodyHelper || getInertBodyHelper(defaultDoc);\n    // Make sure unsafeHtml is actually a string (TypeScript types are not enforced at runtime).\n    let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';\n    inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);\n    // mXSS protection. Repeatedly parse the document to make sure it stabilizes, so that a browser\n    // trying to auto-correct incorrect HTML cannot cause formerly inert HTML to become dangerous.\n    let mXSSAttempts = 5;\n    let parsedHtml = unsafeHtml;\n    do {\n      if (mXSSAttempts === 0) {\n        throw new Error('Failed to sanitize html because the input is unstable');\n      }\n      mXSSAttempts--;\n      unsafeHtml = parsedHtml;\n      parsedHtml = inertBodyElement.innerHTML;\n      inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);\n    } while (unsafeHtml !== parsedHtml);\n    const sanitizer = new SanitizingHtmlSerializer();\n    const safeHtml = sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement) || inertBodyElement);\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && sanitizer.sanitizedSomething) {\n      console.warn(`WARNING: sanitizing HTML stripped some content, see ${XSS_SECURITY_URL}`);\n    }\n    return trustedHTMLFromString(safeHtml);\n  } finally {\n    // In case anything goes wrong, clear out inertElement to reset the entire DOM structure.\n    if (inertBodyElement) {\n      const parent = getTemplateContent(inertBodyElement) || inertBodyElement;\n      while (parent.firstChild) {\n        parent.removeChild(parent.firstChild);\n      }\n    }\n  }\n}\nfunction getTemplateContent(el) {\n  return 'content' in el /** Microsoft/TypeScript#21517 */ && isTemplateElement(el) ? el.content : null;\n}\nfunction isTemplateElement(el) {\n  return el.nodeType === Node.ELEMENT_NODE && el.nodeName === 'TEMPLATE';\n}\n\n/**\n * A SecurityContext marks a location that has dangerous security implications, e.g. a DOM property\n * like `innerHTML` that could cause Cross Site Scripting (XSS) security bugs when improperly\n * handled.\n *\n * See DomSanitizer for more details on security in Angular applications.\n *\n * @publicApi\n */\nvar SecurityContext;\n(function (SecurityContext) {\n  SecurityContext[SecurityContext[\"NONE\"] = 0] = \"NONE\";\n  SecurityContext[SecurityContext[\"HTML\"] = 1] = \"HTML\";\n  SecurityContext[SecurityContext[\"STYLE\"] = 2] = \"STYLE\";\n  SecurityContext[SecurityContext[\"SCRIPT\"] = 3] = \"SCRIPT\";\n  SecurityContext[SecurityContext[\"URL\"] = 4] = \"URL\";\n  SecurityContext[SecurityContext[\"RESOURCE_URL\"] = 5] = \"RESOURCE_URL\";\n})(SecurityContext || (SecurityContext = {}));\n\n/**\n * An `html` sanitizer which converts untrusted `html` **string** into trusted string by removing\n * dangerous content.\n *\n * This method parses the `html` and locates potentially dangerous content (such as urls and\n * javascript) and removes it.\n *\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustHtml}.\n *\n * @param unsafeHtml untrusted `html`, typically from the user.\n * @returns `html` string which is safe to display to user, because all of the dangerous javascript\n * and urls have been removed.\n *\n * @codeGenApi\n */\nfunction ɵɵsanitizeHtml(unsafeHtml) {\n  const sanitizer = getSanitizer();\n  if (sanitizer) {\n    return trustedHTMLFromStringBypass(sanitizer.sanitize(SecurityContext.HTML, unsafeHtml) || '');\n  }\n  if (allowSanitizationBypassAndThrow(unsafeHtml, \"HTML\" /* BypassType.Html */)) {\n    return trustedHTMLFromStringBypass(unwrapSafeValue(unsafeHtml));\n  }\n  return _sanitizeHtml(getDocument(), renderStringify(unsafeHtml));\n}\n/**\n * A `style` sanitizer which converts untrusted `style` **string** into trusted string by removing\n * dangerous content.\n *\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustStyle}.\n *\n * @param unsafeStyle untrusted `style`, typically from the user.\n * @returns `style` string which is safe to bind to the `style` properties.\n *\n * @codeGenApi\n */\nfunction ɵɵsanitizeStyle(unsafeStyle) {\n  const sanitizer = getSanitizer();\n  if (sanitizer) {\n    return sanitizer.sanitize(SecurityContext.STYLE, unsafeStyle) || '';\n  }\n  if (allowSanitizationBypassAndThrow(unsafeStyle, \"Style\" /* BypassType.Style */)) {\n    return unwrapSafeValue(unsafeStyle);\n  }\n  return renderStringify(unsafeStyle);\n}\n/**\n * A `url` sanitizer which converts untrusted `url` **string** into trusted string by removing\n * dangerous\n * content.\n *\n * This method parses the `url` and locates potentially dangerous content (such as javascript) and\n * removes it.\n *\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustUrl}.\n *\n * @param unsafeUrl untrusted `url`, typically from the user.\n * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because\n * all of the dangerous javascript has been removed.\n *\n * @codeGenApi\n */\nfunction ɵɵsanitizeUrl(unsafeUrl) {\n  const sanitizer = getSanitizer();\n  if (sanitizer) {\n    return sanitizer.sanitize(SecurityContext.URL, unsafeUrl) || '';\n  }\n  if (allowSanitizationBypassAndThrow(unsafeUrl, \"URL\" /* BypassType.Url */)) {\n    return unwrapSafeValue(unsafeUrl);\n  }\n  return _sanitizeUrl(renderStringify(unsafeUrl));\n}\n/**\n * A `url` sanitizer which only lets trusted `url`s through.\n *\n * This passes only `url`s marked trusted by calling {@link bypassSanitizationTrustResourceUrl}.\n *\n * @param unsafeResourceUrl untrusted `url`, typically from the user.\n * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because\n * only trusted `url`s have been allowed to pass.\n *\n * @codeGenApi\n */\nfunction ɵɵsanitizeResourceUrl(unsafeResourceUrl) {\n  const sanitizer = getSanitizer();\n  if (sanitizer) {\n    return trustedScriptURLFromStringBypass(sanitizer.sanitize(SecurityContext.RESOURCE_URL, unsafeResourceUrl) || '');\n  }\n  if (allowSanitizationBypassAndThrow(unsafeResourceUrl, \"ResourceURL\" /* BypassType.ResourceUrl */)) {\n    return trustedScriptURLFromStringBypass(unwrapSafeValue(unsafeResourceUrl));\n  }\n  throw new RuntimeError(904 /* RuntimeErrorCode.UNSAFE_VALUE_IN_RESOURCE_URL */, ngDevMode && `unsafe value used in a resource URL context (see ${XSS_SECURITY_URL})`);\n}\n/**\n * A `script` sanitizer which only lets trusted javascript through.\n *\n * This passes only `script`s marked trusted by calling {@link\n * bypassSanitizationTrustScript}.\n *\n * @param unsafeScript untrusted `script`, typically from the user.\n * @returns `url` string which is safe to bind to the `<script>` element such as `<img src>`,\n * because only trusted `scripts` have been allowed to pass.\n *\n * @codeGenApi\n */\nfunction ɵɵsanitizeScript(unsafeScript) {\n  const sanitizer = getSanitizer();\n  if (sanitizer) {\n    return trustedScriptFromStringBypass(sanitizer.sanitize(SecurityContext.SCRIPT, unsafeScript) || '');\n  }\n  if (allowSanitizationBypassAndThrow(unsafeScript, \"Script\" /* BypassType.Script */)) {\n    return trustedScriptFromStringBypass(unwrapSafeValue(unsafeScript));\n  }\n  throw new RuntimeError(905 /* RuntimeErrorCode.UNSAFE_VALUE_IN_SCRIPT */, ngDevMode && 'unsafe value used in a script context');\n}\n/**\n * A template tag function for promoting the associated constant literal to a\n * TrustedHTML. Interpolation is explicitly not allowed.\n *\n * @param html constant template literal containing trusted HTML.\n * @returns TrustedHTML wrapping `html`.\n *\n * @security This is a security-sensitive function and should only be used to\n * convert constant values of attributes and properties found in\n * application-provided Angular templates to TrustedHTML.\n *\n * @codeGenApi\n */\nfunction ɵɵtrustConstantHtml(html) {\n  // The following runtime check ensures that the function was called as a\n  // template tag (e.g. ɵɵtrustConstantHtml`content`), without any interpolation\n  // (e.g. not ɵɵtrustConstantHtml`content ${variable}`). A TemplateStringsArray\n  // is an array with a `raw` property that is also an array. The associated\n  // template literal has no interpolation if and only if the length of the\n  // TemplateStringsArray is 1.\n  if (ngDevMode && (!Array.isArray(html) || !Array.isArray(html.raw) || html.length !== 1)) {\n    throw new Error(`Unexpected interpolation in trusted HTML constant: ${html.join('?')}`);\n  }\n  return trustedHTMLFromString(html[0]);\n}\n/**\n * A template tag function for promoting the associated constant literal to a\n * TrustedScriptURL. Interpolation is explicitly not allowed.\n *\n * @param url constant template literal containing a trusted script URL.\n * @returns TrustedScriptURL wrapping `url`.\n *\n * @security This is a security-sensitive function and should only be used to\n * convert constant values of attributes and properties found in\n * application-provided Angular templates to TrustedScriptURL.\n *\n * @codeGenApi\n */\nfunction ɵɵtrustConstantResourceUrl(url) {\n  // The following runtime check ensures that the function was called as a\n  // template tag (e.g. ɵɵtrustConstantResourceUrl`content`), without any\n  // interpolation (e.g. not ɵɵtrustConstantResourceUrl`content ${variable}`). A\n  // TemplateStringsArray is an array with a `raw` property that is also an\n  // array. The associated template literal has no interpolation if and only if\n  // the length of the TemplateStringsArray is 1.\n  if (ngDevMode && (!Array.isArray(url) || !Array.isArray(url.raw) || url.length !== 1)) {\n    throw new Error(`Unexpected interpolation in trusted URL constant: ${url.join('?')}`);\n  }\n  return trustedScriptURLFromString(url[0]);\n}\n/**\n * Detects which sanitizer to use for URL property, based on tag name and prop name.\n *\n * The rules are based on the RESOURCE_URL context config from\n * `packages/compiler/src/schema/dom_security_schema.ts`.\n * If tag and prop names don't match Resource URL schema, use URL sanitizer.\n */\nfunction getUrlSanitizer(tag, prop) {\n  if (prop === 'src' && (tag === 'embed' || tag === 'frame' || tag === 'iframe' || tag === 'media' || tag === 'script') || prop === 'href' && (tag === 'base' || tag === 'link')) {\n    return ɵɵsanitizeResourceUrl;\n  }\n  return ɵɵsanitizeUrl;\n}\n/**\n * Sanitizes URL, selecting sanitizer function based on tag and property names.\n *\n * This function is used in case we can't define security context at compile time, when only prop\n * name is available. This happens when we generate host bindings for Directives/Components. The\n * host element is unknown at compile time, so we defer calculation of specific sanitizer to\n * runtime.\n *\n * @param unsafeUrl untrusted `url`, typically from the user.\n * @param tag target element tag name.\n * @param prop name of the property that contains the value.\n * @returns `url` string which is safe to bind.\n *\n * @codeGenApi\n */\nfunction ɵɵsanitizeUrlOrResourceUrl(unsafeUrl, tag, prop) {\n  return getUrlSanitizer(tag, prop)(unsafeUrl);\n}\nfunction validateAgainstEventProperties(name) {\n  if (name.toLowerCase().startsWith('on')) {\n    const errorMessage = `Binding to event property '${name}' is disallowed for security reasons, ` + `please use (${name.slice(2)})=...` + `\\nIf '${name}' is a directive input, make sure the directive is imported by the` + ` current module.`;\n    throw new RuntimeError(306 /* RuntimeErrorCode.INVALID_EVENT_BINDING */, errorMessage);\n  }\n}\nfunction validateAgainstEventAttributes(name) {\n  if (name.toLowerCase().startsWith('on')) {\n    const errorMessage = `Binding to event attribute '${name}' is disallowed for security reasons, ` + `please use (${name.slice(2)})=...`;\n    throw new RuntimeError(306 /* RuntimeErrorCode.INVALID_EVENT_BINDING */, errorMessage);\n  }\n}\nfunction getSanitizer() {\n  const lView = getLView();\n  return lView && lView[ENVIRONMENT].sanitizer;\n}\n\n/**\n * Create a `StateKey<T>` that can be used to store value of type T with `TransferState`.\n *\n * Example:\n *\n * ```\n * const COUNTER_KEY = makeStateKey<number>('counter');\n * let value = 10;\n *\n * transferState.set(COUNTER_KEY, value);\n * ```\n *\n * @publicApi\n */\nfunction makeStateKey(key) {\n  return key;\n}\nfunction initTransferState() {\n  const transferState = new TransferState();\n  if (inject$1(PLATFORM_ID) === 'browser') {\n    transferState.store = retrieveTransferredState(getDocument(), inject$1(APP_ID));\n  }\n  return transferState;\n}\n/**\n * A key value store that is transferred from the application on the server side to the application\n * on the client side.\n *\n * The `TransferState` is available as an injectable token.\n * On the client, just inject this token using DI and use it, it will be lazily initialized.\n * On the server it's already included if `renderApplication` function is used. Otherwise, import\n * the `ServerTransferStateModule` module to make the `TransferState` available.\n *\n * The values in the store are serialized/deserialized using JSON.stringify/JSON.parse. So only\n * boolean, number, string, null and non-class objects will be serialized and deserialized in a\n * non-lossy manner.\n *\n * @publicApi\n */\nclass TransferState {\n  constructor() {\n    /** @internal */\n    this.store = {};\n    this.onSerializeCallbacks = {};\n  }\n  /** @nocollapse */\n  static #_ = this.ɵprov = /** @pureOrBreakMyCode */ɵɵdefineInjectable({\n    token: TransferState,\n    providedIn: 'root',\n    factory: initTransferState\n  });\n  /**\n   * Get the value corresponding to a key. Return `defaultValue` if key is not found.\n   */\n  get(key, defaultValue) {\n    return this.store[key] !== undefined ? this.store[key] : defaultValue;\n  }\n  /**\n   * Set the value corresponding to a key.\n   */\n  set(key, value) {\n    this.store[key] = value;\n  }\n  /**\n   * Remove a key from the store.\n   */\n  remove(key) {\n    delete this.store[key];\n  }\n  /**\n   * Test whether a key exists in the store.\n   */\n  hasKey(key) {\n    return this.store.hasOwnProperty(key);\n  }\n  /**\n   * Indicates whether the state is empty.\n   */\n  get isEmpty() {\n    return Object.keys(this.store).length === 0;\n  }\n  /**\n   * Register a callback to provide the value for a key when `toJson` is called.\n   */\n  onSerialize(key, callback) {\n    this.onSerializeCallbacks[key] = callback;\n  }\n  /**\n   * Serialize the current state of the store to JSON.\n   */\n  toJson() {\n    // Call the onSerialize callbacks and put those values into the store.\n    for (const key in this.onSerializeCallbacks) {\n      if (this.onSerializeCallbacks.hasOwnProperty(key)) {\n        try {\n          this.store[key] = this.onSerializeCallbacks[key]();\n        } catch (e) {\n          console.warn('Exception in onSerialize callback: ', e);\n        }\n      }\n    }\n    // Escape script tag to avoid break out of <script> tag in serialized output.\n    // Encoding of `<` is the same behaviour as G3 script_builders.\n    return JSON.stringify(this.store).replace(/</g, '\\\\u003C');\n  }\n}\nfunction retrieveTransferredState(doc, appId) {\n  // Locate the script tag with the JSON data transferred from the server.\n  // The id of the script tag is set to the Angular appId + 'state'.\n  const script = doc.getElementById(appId + '-state');\n  if (script?.textContent) {\n    try {\n      // Avoid using any here as it triggers lint errors in google3 (any is not allowed).\n      // Decoding of `<` is done of the box by browsers and node.js, same behaviour as G3\n      // script_builders.\n      return JSON.parse(script.textContent);\n    } catch (e) {\n      console.warn('Exception while restoring TransferState for app ' + appId, e);\n    }\n  }\n  return {};\n}\n\n/** Encodes that the node lookup should start from the host node of this component. */\nconst REFERENCE_NODE_HOST = 'h';\n/** Encodes that the node lookup should start from the document body node. */\nconst REFERENCE_NODE_BODY = 'b';\n/**\n * Describes navigation steps that the runtime logic need to perform,\n * starting from a given (known) element.\n */\nvar NodeNavigationStep;\n(function (NodeNavigationStep) {\n  NodeNavigationStep[\"FirstChild\"] = \"f\";\n  NodeNavigationStep[\"NextSibling\"] = \"n\";\n})(NodeNavigationStep || (NodeNavigationStep = {}));\n/**\n * Keys within serialized view data structure to represent various\n * parts. See the `SerializedView` interface below for additional information.\n */\nconst ELEMENT_CONTAINERS = 'e';\nconst TEMPLATES = 't';\nconst CONTAINERS = 'c';\nconst MULTIPLIER = 'x';\nconst NUM_ROOT_NODES = 'r';\nconst TEMPLATE_ID = 'i'; // as it's also an \"id\"\nconst NODES = 'n';\nconst DISCONNECTED_NODES = 'd';\n\n/**\n * The name of the key used in the TransferState collection,\n * where hydration information is located.\n */\nconst TRANSFER_STATE_TOKEN_ID = '__ɵnghData__';\n/**\n * Lookup key used to reference DOM hydration data (ngh) in `TransferState`.\n */\nconst NGH_DATA_KEY = makeStateKey(TRANSFER_STATE_TOKEN_ID);\n/**\n * The name of the attribute that would be added to host component\n * nodes and contain a reference to a particular slot in transferred\n * state that contains the necessary hydration info for this component.\n */\nconst NGH_ATTR_NAME = 'ngh';\n/**\n * Marker used in a comment node to ensure hydration content integrity\n */\nconst SSR_CONTENT_INTEGRITY_MARKER = 'nghm';\n/**\n * Reference to a function that reads `ngh` attribute value from a given RNode\n * and retrieves hydration information from the TransferState using that value\n * as an index. Returns `null` by default, when hydration is not enabled.\n *\n * @param rNode Component's host element.\n * @param injector Injector that this component has access to.\n * @param isRootView Specifies whether we trying to read hydration info for the root view.\n */\nlet _retrieveHydrationInfoImpl = (rNode, injector, isRootView) => null;\nfunction retrieveHydrationInfoImpl(rNode, injector, isRootView = false) {\n  let nghAttrValue = rNode.getAttribute(NGH_ATTR_NAME);\n  if (nghAttrValue == null) return null;\n  // For cases when a root component also acts as an anchor node for a ViewContainerRef\n  // (for example, when ViewContainerRef is injected in a root component), there is a need\n  // to serialize information about the component itself, as well as an LContainer that\n  // represents this ViewContainerRef. Effectively, we need to serialize 2 pieces of info:\n  // (1) hydration info for the root component itself and (2) hydration info for the\n  // ViewContainerRef instance (an LContainer). Each piece of information is included into\n  // the hydration data (in the TransferState object) separately, thus we end up with 2 ids.\n  // Since we only have 1 root element, we encode both bits of info into a single string:\n  // ids are separated by the `|` char (e.g. `10|25`, where `10` is the ngh for a component view\n  // and 25 is the `ngh` for a root view which holds LContainer).\n  const [componentViewNgh, rootViewNgh] = nghAttrValue.split('|');\n  nghAttrValue = isRootView ? rootViewNgh : componentViewNgh;\n  if (!nghAttrValue) return null;\n  // We've read one of the ngh ids, keep the remaining one, so that\n  // we can set it back on the DOM element.\n  const remainingNgh = isRootView ? componentViewNgh : rootViewNgh ? `|${rootViewNgh}` : '';\n  let data = {};\n  // An element might have an empty `ngh` attribute value (e.g. `<comp ngh=\"\" />`),\n  // which means that no special annotations are required. Do not attempt to read\n  // from the TransferState in this case.\n  if (nghAttrValue !== '') {\n    const transferState = injector.get(TransferState, null, {\n      optional: true\n    });\n    if (transferState !== null) {\n      const nghData = transferState.get(NGH_DATA_KEY, []);\n      // The nghAttrValue is always a number referencing an index\n      // in the hydration TransferState data.\n      data = nghData[Number(nghAttrValue)];\n      // If the `ngh` attribute exists and has a non-empty value,\n      // the hydration info *must* be present in the TransferState.\n      // If there is no data for some reasons, this is an error.\n      ngDevMode && assertDefined(data, 'Unable to retrieve hydration info from the TransferState.');\n    }\n  }\n  const dehydratedView = {\n    data,\n    firstChild: rNode.firstChild ?? null\n  };\n  if (isRootView) {\n    // If there is hydration info present for the root view, it means that there was\n    // a ViewContainerRef injected in the root component. The root component host element\n    // acted as an anchor node in this scenario. As a result, the DOM nodes that represent\n    // embedded views in this ViewContainerRef are located as siblings to the host node,\n    // i.e. `<app-root /><#VIEW1><#VIEW2>...<!--container-->`. In this case, the current\n    // node becomes the first child of this root view and the next sibling is the first\n    // element in the DOM segment.\n    dehydratedView.firstChild = rNode;\n    // We use `0` here, since this is the slot (right after the HEADER_OFFSET)\n    // where a component LView or an LContainer is located in a root LView.\n    setSegmentHead(dehydratedView, 0, rNode.nextSibling);\n  }\n  if (remainingNgh) {\n    // If we have only used one of the ngh ids, store the remaining one\n    // back on this RNode.\n    rNode.setAttribute(NGH_ATTR_NAME, remainingNgh);\n  } else {\n    // The `ngh` attribute is cleared from the DOM node now\n    // that the data has been retrieved for all indices.\n    rNode.removeAttribute(NGH_ATTR_NAME);\n  }\n  // Note: don't check whether this node was claimed for hydration,\n  // because this node might've been previously claimed while processing\n  // template instructions.\n  ngDevMode && markRNodeAsClaimedByHydration(rNode, /* checkIfAlreadyClaimed */false);\n  ngDevMode && ngDevMode.hydratedComponents++;\n  return dehydratedView;\n}\n/**\n * Sets the implementation for the `retrieveHydrationInfo` function.\n */\nfunction enableRetrieveHydrationInfoImpl() {\n  _retrieveHydrationInfoImpl = retrieveHydrationInfoImpl;\n}\n/**\n * Retrieves hydration info by reading the value from the `ngh` attribute\n * and accessing a corresponding slot in TransferState storage.\n */\nfunction retrieveHydrationInfo(rNode, injector, isRootView = false) {\n  return _retrieveHydrationInfoImpl(rNode, injector, isRootView);\n}\n/**\n * Retrieves the necessary object from a given ViewRef to serialize:\n *  - an LView for component views\n *  - an LContainer for cases when component acts as a ViewContainerRef anchor\n *  - `null` in case of an embedded view\n */\nfunction getLNodeForHydration(viewRef) {\n  // Reading an internal field from `ViewRef` instance.\n  let lView = viewRef._lView;\n  const tView = lView[TVIEW];\n  // A registered ViewRef might represent an instance of an\n  // embedded view, in which case we do not need to annotate it.\n  if (tView.type === 2 /* TViewType.Embedded */) {\n    return null;\n  }\n  // Check if it's a root view and if so, retrieve component's\n  // LView from the first slot after the header.\n  if (isRootView(lView)) {\n    lView = lView[HEADER_OFFSET];\n  }\n  return lView;\n}\nfunction getTextNodeContent(node) {\n  return node.textContent?.replace(/\\s/gm, '');\n}\n/**\n * Restores text nodes and separators into the DOM that were lost during SSR\n * serialization. The hydration process replaces empty text nodes and text\n * nodes that are immediately adjacent to other text nodes with comment nodes\n * that this method filters on to restore those missing nodes that the\n * hydration process is expecting to be present.\n *\n * @param node The app's root HTML Element\n */\nfunction processTextNodeMarkersBeforeHydration(node) {\n  const doc = getDocument();\n  const commentNodesIterator = doc.createNodeIterator(node, NodeFilter.SHOW_COMMENT, {\n    acceptNode(node) {\n      const content = getTextNodeContent(node);\n      const isTextNodeMarker = content === \"ngetn\" /* TextNodeMarker.EmptyNode */ || content === \"ngtns\" /* TextNodeMarker.Separator */;\n      return isTextNodeMarker ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;\n    }\n  });\n  let currentNode;\n  // We cannot modify the DOM while using the commentIterator,\n  // because it throws off the iterator state.\n  // So we collect all marker nodes first and then follow up with\n  // applying the changes to the DOM: either inserting an empty node\n  // or just removing the marker if it was used as a separator.\n  const nodes = [];\n  while (currentNode = commentNodesIterator.nextNode()) {\n    nodes.push(currentNode);\n  }\n  for (const node of nodes) {\n    if (node.textContent === \"ngetn\" /* TextNodeMarker.EmptyNode */) {\n      node.replaceWith(doc.createTextNode(''));\n    } else {\n      node.remove();\n    }\n  }\n}\n/**\n * Marks a node as \"claimed\" by hydration process.\n * This is needed to make assessments in tests whether\n * the hydration process handled all nodes.\n */\nfunction markRNodeAsClaimedByHydration(node, checkIfAlreadyClaimed = true) {\n  if (!ngDevMode) {\n    throw new Error('Calling `markRNodeAsClaimedByHydration` in prod mode ' + 'is not supported and likely a mistake.');\n  }\n  if (checkIfAlreadyClaimed && isRNodeClaimedForHydration(node)) {\n    throw new Error('Trying to claim a node, which was claimed already.');\n  }\n  node.__claimed = true;\n  ngDevMode.hydratedNodes++;\n}\nfunction isRNodeClaimedForHydration(node) {\n  return !!node.__claimed;\n}\nfunction setSegmentHead(hydrationInfo, index, node) {\n  hydrationInfo.segmentHeads ??= {};\n  hydrationInfo.segmentHeads[index] = node;\n}\nfunction getSegmentHead(hydrationInfo, index) {\n  return hydrationInfo.segmentHeads?.[index] ?? null;\n}\n/**\n * Returns the size of an <ng-container>, using either the information\n * serialized in `ELEMENT_CONTAINERS` (element container size) or by\n * computing the sum of root nodes in all dehydrated views in a given\n * container (in case this `<ng-container>` was also used as a view\n * container host node, e.g. <ng-container *ngIf>).\n */\nfunction getNgContainerSize(hydrationInfo, index) {\n  const data = hydrationInfo.data;\n  let size = data[ELEMENT_CONTAINERS]?.[index] ?? null;\n  // If there is no serialized information available in the `ELEMENT_CONTAINERS` slot,\n  // check if we have info about view containers at this location (e.g.\n  // `<ng-container *ngIf>`) and use container size as a number of root nodes in this\n  // element container.\n  if (size === null && data[CONTAINERS]?.[index]) {\n    size = calcSerializedContainerSize(hydrationInfo, index);\n  }\n  return size;\n}\nfunction getSerializedContainerViews(hydrationInfo, index) {\n  return hydrationInfo.data[CONTAINERS]?.[index] ?? null;\n}\n/**\n * Computes the size of a serialized container (the number of root nodes)\n * by calculating the sum of root nodes in all dehydrated views in this container.\n */\nfunction calcSerializedContainerSize(hydrationInfo, index) {\n  const views = getSerializedContainerViews(hydrationInfo, index) ?? [];\n  let numNodes = 0;\n  for (let view of views) {\n    numNodes += view[NUM_ROOT_NODES] * (view[MULTIPLIER] ?? 1);\n  }\n  return numNodes;\n}\n/**\n * Checks whether a node is annotated as \"disconnected\", i.e. not present\n * in the DOM at serialization time. We should not attempt hydration for\n * such nodes and instead, use a regular \"creation mode\".\n */\nfunction isDisconnectedNode(hydrationInfo, index) {\n  // Check if we are processing disconnected info for the first time.\n  if (typeof hydrationInfo.disconnectedNodes === 'undefined') {\n    const nodeIds = hydrationInfo.data[DISCONNECTED_NODES];\n    hydrationInfo.disconnectedNodes = nodeIds ? new Set(nodeIds) : null;\n  }\n  return !!hydrationInfo.disconnectedNodes?.has(index);\n}\n\n/**\n * Represents a component created by a `ComponentFactory`.\n * Provides access to the component instance and related objects,\n * and provides the means of destroying the instance.\n *\n * @publicApi\n */\nclass ComponentRef$1 {}\n/**\n * Base class for a factory that can create a component dynamically.\n * Instantiate a factory for a given type of component with `resolveComponentFactory()`.\n * Use the resulting `ComponentFactory.create()` method to create a component of that type.\n *\n * @see [Dynamic Components](guide/dynamic-component-loader)\n *\n * @publicApi\n *\n * @deprecated Angular no longer requires Component factories. Please use other APIs where\n *     Component class can be used directly.\n */\nclass ComponentFactory$1 {}\nfunction noComponentFactoryError(component) {\n  const error = Error(`No component factory found for ${stringify(component)}.`);\n  error[ERROR_COMPONENT] = component;\n  return error;\n}\nconst ERROR_COMPONENT = 'ngComponent';\nfunction getComponent$1(error) {\n  return error[ERROR_COMPONENT];\n}\nclass _NullComponentFactoryResolver {\n  resolveComponentFactory(component) {\n    throw noComponentFactoryError(component);\n  }\n}\n/**\n * A simple registry that maps `Components` to generated `ComponentFactory` classes\n * that can be used to create instances of components.\n * Use to obtain the factory for a given component type,\n * then use the factory's `create()` method to create a component of that type.\n *\n * Note: since v13, dynamic component creation via\n * [`ViewContainerRef.createComponent`](api/core/ViewContainerRef#createComponent)\n * does **not** require resolving component factory: component class can be used directly.\n *\n * @publicApi\n *\n * @deprecated Angular no longer requires Component factories. Please use other APIs where\n *     Component class can be used directly.\n */\nclass ComponentFactoryResolver$1 {\n  static #_ = this.NULL = /* @__PURE__ */new _NullComponentFactoryResolver();\n}\n\n/**\n * Creates an ElementRef from the most recent node.\n *\n * @returns The ElementRef instance to use\n */\nfunction injectElementRef() {\n  return createElementRef(getCurrentTNode(), getLView());\n}\n/**\n * Creates an ElementRef given a node.\n *\n * @param tNode The node for which you'd like an ElementRef\n * @param lView The view to which the node belongs\n * @returns The ElementRef instance to use\n */\nfunction createElementRef(tNode, lView) {\n  return new ElementRef(getNativeByTNode(tNode, lView));\n}\n/**\n * A wrapper around a native element inside of a View.\n *\n * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM\n * element.\n *\n * @security Permitting direct access to the DOM can make your application more vulnerable to\n * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the\n * [Security Guide](https://g.co/ng/security).\n *\n * @publicApi\n */\n// Note: We don't expose things like `Injector`, `ViewContainer`, ... here,\n// i.e. users have to ask for what they need. With that, we can build better analysis tools\n// and could do better codegen in the future.\nclass ElementRef {\n  constructor(nativeElement) {\n    this.nativeElement = nativeElement;\n  }\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static #_ = this.__NG_ELEMENT_ID__ = injectElementRef;\n}\n/**\n * Unwraps `ElementRef` and return the `nativeElement`.\n *\n * @param value value to unwrap\n * @returns `nativeElement` if `ElementRef` otherwise returns value as is.\n */\nfunction unwrapElementRef(value) {\n  return value instanceof ElementRef ? value.nativeElement : value;\n}\n\n/**\n * Creates and initializes a custom renderer that implements the `Renderer2` base class.\n *\n * @publicApi\n */\nclass RendererFactory2 {}\n/**\n * Extend this base class to implement custom rendering. By default, Angular\n * renders a template into DOM. You can use custom rendering to intercept\n * rendering calls, or to render to something other than DOM.\n *\n * Create your custom renderer using `RendererFactory2`.\n *\n * Use a custom renderer to bypass Angular's templating and\n * make custom UI changes that can't be expressed declaratively.\n * For example if you need to set a property or an attribute whose name is\n * not statically known, use the `setProperty()` or\n * `setAttribute()` method.\n *\n * @publicApi\n */\nclass Renderer2 {\n  constructor() {\n    /**\n     * If null or undefined, the view engine won't call it.\n     * This is used as a performance optimization for production mode.\n     */\n    this.destroyNode = null;\n  }\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static #_ = this.__NG_ELEMENT_ID__ = () => injectRenderer2();\n}\n/** Injects a Renderer2 for the current component. */\nfunction injectRenderer2() {\n  // We need the Renderer to be based on the component that it's being injected into, however since\n  // DI happens before we've entered its view, `getLView` will return the parent view instead.\n  const lView = getLView();\n  const tNode = getCurrentTNode();\n  const nodeAtIndex = getComponentLViewByIndex(tNode.index, lView);\n  return (isLView(nodeAtIndex) ? nodeAtIndex : lView)[RENDERER];\n}\n\n/**\n * Sanitizer is used by the views to sanitize potentially dangerous values.\n *\n * @publicApi\n */\nclass Sanitizer {\n  /** @nocollapse */\n  static #_ = this.ɵprov = ɵɵdefineInjectable({\n    token: Sanitizer,\n    providedIn: 'root',\n    factory: () => null\n  });\n}\n\n/**\n * @description Represents the version of Angular\n *\n * @publicApi\n */\nclass Version {\n  constructor(full) {\n    this.full = full;\n    this.major = full.split('.')[0];\n    this.minor = full.split('.')[1];\n    this.patch = full.split('.').slice(2).join('.');\n  }\n}\n/**\n * @publicApi\n */\nconst VERSION = new Version('16.2.6');\n\n// This default value is when checking the hierarchy for a token.\n//\n// It means both:\n// - the token is not provided by the current injector,\n// - only the element injectors should be checked (ie do not check module injectors\n//\n//          mod1\n//         /\n//       el1   mod2\n//         \\  /\n//         el2\n//\n// When requesting el2.injector.get(token), we should check in the following order and return the\n// first found value:\n// - el2.injector.get(token, default)\n// - el1.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) -> do not check the module\n// - mod2.injector.get(token, default)\nconst NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};\nconst ERROR_ORIGINAL_ERROR = 'ngOriginalError';\nfunction wrappedError(message, originalError) {\n  const msg = `${message} caused by: ${originalError instanceof Error ? originalError.message : originalError}`;\n  const error = Error(msg);\n  error[ERROR_ORIGINAL_ERROR] = originalError;\n  return error;\n}\nfunction getOriginalError(error) {\n  return error[ERROR_ORIGINAL_ERROR];\n}\n\n/**\n * Provides a hook for centralized exception handling.\n *\n * The default implementation of `ErrorHandler` prints error messages to the `console`. To\n * intercept error handling, write a custom exception handler that replaces this default as\n * appropriate for your app.\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * class MyErrorHandler implements ErrorHandler {\n *   handleError(error) {\n *     // do something with the exception\n *   }\n * }\n *\n * @NgModule({\n *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]\n * })\n * class MyModule {}\n * ```\n *\n * @publicApi\n */\nclass ErrorHandler {\n  constructor() {\n    /**\n     * @internal\n     */\n    this._console = console;\n  }\n  handleError(error) {\n    const originalError = this._findOriginalError(error);\n    this._console.error('ERROR', error);\n    if (originalError) {\n      this._console.error('ORIGINAL ERROR', originalError);\n    }\n  }\n  /** @internal */\n  _findOriginalError(error) {\n    let e = error && getOriginalError(error);\n    while (e && getOriginalError(e)) {\n      e = getOriginalError(e);\n    }\n    return e || null;\n  }\n}\n\n/**\n * `DestroyRef` lets you set callbacks to run for any cleanup or destruction behavior.\n * The scope of this destruction depends on where `DestroyRef` is injected. If `DestroyRef`\n * is injected in a component or directive, the callbacks run when that component or\n * directive is destroyed. Otherwise the callbacks run when a corresponding injector is destroyed.\n *\n * @publicApi\n */\nclass DestroyRef {\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static #_ = this.__NG_ELEMENT_ID__ = injectDestroyRef;\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static #_2 = this.__NG_ENV_ID__ = injector => injector;\n}\nclass NodeInjectorDestroyRef extends DestroyRef {\n  constructor(_lView) {\n    super();\n    this._lView = _lView;\n  }\n  onDestroy(callback) {\n    storeLViewOnDestroy(this._lView, callback);\n    return () => removeLViewOnDestroy(this._lView, callback);\n  }\n}\nfunction injectDestroyRef() {\n  return new NodeInjectorDestroyRef(getLView());\n}\n\n/// <reference types=\"rxjs\" />\nclass EventEmitter_ extends Subject {\n  constructor(isAsync = false) {\n    super();\n    this.__isAsync = isAsync;\n  }\n  emit(value) {\n    super.next(value);\n  }\n  subscribe(observerOrNext, error, complete) {\n    let nextFn = observerOrNext;\n    let errorFn = error || (() => null);\n    let completeFn = complete;\n    if (observerOrNext && typeof observerOrNext === 'object') {\n      const observer = observerOrNext;\n      nextFn = observer.next?.bind(observer);\n      errorFn = observer.error?.bind(observer);\n      completeFn = observer.complete?.bind(observer);\n    }\n    if (this.__isAsync) {\n      errorFn = _wrapInTimeout(errorFn);\n      if (nextFn) {\n        nextFn = _wrapInTimeout(nextFn);\n      }\n      if (completeFn) {\n        completeFn = _wrapInTimeout(completeFn);\n      }\n    }\n    const sink = super.subscribe({\n      next: nextFn,\n      error: errorFn,\n      complete: completeFn\n    });\n    if (observerOrNext instanceof Subscription) {\n      observerOrNext.add(sink);\n    }\n    return sink;\n  }\n}\nfunction _wrapInTimeout(fn) {\n  return value => {\n    setTimeout(fn, undefined, value);\n  };\n}\n/**\n * @publicApi\n */\nconst EventEmitter = EventEmitter_;\nfunction noop(...args) {\n  // Do nothing.\n}\nfunction getNativeRequestAnimationFrame() {\n  // Note: the `getNativeRequestAnimationFrame` is used in the `NgZone` class, but we cannot use the\n  // `inject` function. The `NgZone` instance may be created manually, and thus the injection\n  // context will be unavailable. This might be enough to check whether `requestAnimationFrame` is\n  // available because otherwise, we'll fall back to `setTimeout`.\n  const isBrowser = typeof _global['requestAnimationFrame'] === 'function';\n  // Note: `requestAnimationFrame` is unavailable when the code runs in the Node.js environment. We\n  // use `setTimeout` because no changes are required other than checking if the current platform is\n  // the browser. `setTimeout` is a well-established API that is available in both environments.\n  // `requestAnimationFrame` is used in the browser to coalesce event tasks since event tasks are\n  // usually executed within the same rendering frame (but this is more implementation details of\n  // browsers).\n  let nativeRequestAnimationFrame = _global[isBrowser ? 'requestAnimationFrame' : 'setTimeout'];\n  let nativeCancelAnimationFrame = _global[isBrowser ? 'cancelAnimationFrame' : 'clearTimeout'];\n  if (typeof Zone !== 'undefined' && nativeRequestAnimationFrame && nativeCancelAnimationFrame) {\n    // Note: zone.js sets original implementations on patched APIs behind the\n    // `__zone_symbol__OriginalDelegate` key (see `attachOriginToPatched`). Given the following\n    // example: `window.requestAnimationFrame.__zone_symbol__OriginalDelegate`; this would return an\n    // unpatched implementation of the `requestAnimationFrame`, which isn't intercepted by the\n    // Angular zone. We use the unpatched implementation to avoid another change detection when\n    // coalescing tasks.\n    const unpatchedRequestAnimationFrame = nativeRequestAnimationFrame[Zone.__symbol__('OriginalDelegate')];\n    if (unpatchedRequestAnimationFrame) {\n      nativeRequestAnimationFrame = unpatchedRequestAnimationFrame;\n    }\n    const unpatchedCancelAnimationFrame = nativeCancelAnimationFrame[Zone.__symbol__('OriginalDelegate')];\n    if (unpatchedCancelAnimationFrame) {\n      nativeCancelAnimationFrame = unpatchedCancelAnimationFrame;\n    }\n  }\n  return {\n    nativeRequestAnimationFrame,\n    nativeCancelAnimationFrame\n  };\n}\nclass AsyncStackTaggingZoneSpec {\n  constructor(namePrefix, consoleAsyncStackTaggingImpl = console) {\n    this.name = 'asyncStackTagging for ' + namePrefix;\n    this.createTask = consoleAsyncStackTaggingImpl?.createTask ?? (() => null);\n  }\n  onScheduleTask(delegate, _current, target, task) {\n    task.consoleTask = this.createTask(`Zone - ${task.source || task.type}`);\n    return delegate.scheduleTask(target, task);\n  }\n  onInvokeTask(delegate, _currentZone, targetZone, task, applyThis, applyArgs) {\n    let ret;\n    if (task.consoleTask) {\n      ret = task.consoleTask.run(() => delegate.invokeTask(targetZone, task, applyThis, applyArgs));\n    } else {\n      ret = delegate.invokeTask(targetZone, task, applyThis, applyArgs);\n    }\n    return ret;\n  }\n}\n\n/**\n * An injectable service for executing work inside or outside of the Angular zone.\n *\n * The most common use of this service is to optimize performance when starting a work consisting of\n * one or more asynchronous tasks that don't require UI updates or error handling to be handled by\n * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks\n * can reenter the Angular zone via {@link #run}.\n *\n * <!-- TODO: add/fix links to:\n *   - docs explaining zones and the use of zones in Angular and change-detection\n *   - link to runOutsideAngular/run (throughout this file!)\n *   -->\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * import {Component, NgZone} from '@angular/core';\n * import {NgIf} from '@angular/common';\n *\n * @Component({\n *   selector: 'ng-zone-demo',\n *   template: `\n *     <h2>Demo: NgZone</h2>\n *\n *     <p>Progress: {{progress}}%</p>\n *     <p *ngIf=\"progress >= 100\">Done processing {{label}} of Angular zone!</p>\n *\n *     <button (click)=\"processWithinAngularZone()\">Process within Angular zone</button>\n *     <button (click)=\"processOutsideOfAngularZone()\">Process outside of Angular zone</button>\n *   `,\n * })\n * export class NgZoneDemo {\n *   progress: number = 0;\n *   label: string;\n *\n *   constructor(private _ngZone: NgZone) {}\n *\n *   // Loop inside the Angular zone\n *   // so the UI DOES refresh after each setTimeout cycle\n *   processWithinAngularZone() {\n *     this.label = 'inside';\n *     this.progress = 0;\n *     this._increaseProgress(() => console.log('Inside Done!'));\n *   }\n *\n *   // Loop outside of the Angular zone\n *   // so the UI DOES NOT refresh after each setTimeout cycle\n *   processOutsideOfAngularZone() {\n *     this.label = 'outside';\n *     this.progress = 0;\n *     this._ngZone.runOutsideAngular(() => {\n *       this._increaseProgress(() => {\n *         // reenter the Angular zone and display done\n *         this._ngZone.run(() => { console.log('Outside Done!'); });\n *       });\n *     });\n *   }\n *\n *   _increaseProgress(doneCallback: () => void) {\n *     this.progress += 1;\n *     console.log(`Current progress: ${this.progress}%`);\n *\n *     if (this.progress < 100) {\n *       window.setTimeout(() => this._increaseProgress(doneCallback), 10);\n *     } else {\n *       doneCallback();\n *     }\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nclass NgZone {\n  constructor({\n    enableLongStackTrace = false,\n    shouldCoalesceEventChangeDetection = false,\n    shouldCoalesceRunChangeDetection = false\n  }) {\n    this.hasPendingMacrotasks = false;\n    this.hasPendingMicrotasks = false;\n    /**\n     * Whether there are no outstanding microtasks or macrotasks.\n     */\n    this.isStable = true;\n    /**\n     * Notifies when code enters Angular Zone. This gets fired first on VM Turn.\n     */\n    this.onUnstable = new EventEmitter(false);\n    /**\n     * Notifies when there is no more microtasks enqueued in the current VM Turn.\n     * This is a hint for Angular to do change detection, which may enqueue more microtasks.\n     * For this reason this event can fire multiple times per VM Turn.\n     */\n    this.onMicrotaskEmpty = new EventEmitter(false);\n    /**\n     * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which\n     * implies we are about to relinquish VM turn.\n     * This event gets called just once.\n     */\n    this.onStable = new EventEmitter(false);\n    /**\n     * Notifies that an error has been delivered.\n     */\n    this.onError = new EventEmitter(false);\n    if (typeof Zone == 'undefined') {\n      throw new RuntimeError(908 /* RuntimeErrorCode.MISSING_ZONEJS */, ngDevMode && `In this configuration Angular requires Zone.js`);\n    }\n    Zone.assertZonePatched();\n    const self = this;\n    self._nesting = 0;\n    self._outer = self._inner = Zone.current;\n    // AsyncStackTaggingZoneSpec provides `linked stack traces` to show\n    // where the async operation is scheduled. For more details, refer\n    // to this article, https://developer.chrome.com/blog/devtools-better-angular-debugging/\n    // And we only import this AsyncStackTaggingZoneSpec in development mode,\n    // in the production mode, the AsyncStackTaggingZoneSpec will be tree shaken away.\n    if (ngDevMode) {\n      self._inner = self._inner.fork(new AsyncStackTaggingZoneSpec('Angular'));\n    }\n    if (Zone['TaskTrackingZoneSpec']) {\n      self._inner = self._inner.fork(new Zone['TaskTrackingZoneSpec']());\n    }\n    if (enableLongStackTrace && Zone['longStackTraceZoneSpec']) {\n      self._inner = self._inner.fork(Zone['longStackTraceZoneSpec']);\n    }\n    // if shouldCoalesceRunChangeDetection is true, all tasks including event tasks will be\n    // coalesced, so shouldCoalesceEventChangeDetection option is not necessary and can be skipped.\n    self.shouldCoalesceEventChangeDetection = !shouldCoalesceRunChangeDetection && shouldCoalesceEventChangeDetection;\n    self.shouldCoalesceRunChangeDetection = shouldCoalesceRunChangeDetection;\n    self.lastRequestAnimationFrameId = -1;\n    self.nativeRequestAnimationFrame = getNativeRequestAnimationFrame().nativeRequestAnimationFrame;\n    forkInnerZoneWithAngularBehavior(self);\n  }\n  /**\n    This method checks whether the method call happens within an Angular Zone instance.\n  */\n  static isInAngularZone() {\n    // Zone needs to be checked, because this method might be called even when NoopNgZone is used.\n    return typeof Zone !== 'undefined' && Zone.current.get('isAngularZone') === true;\n  }\n  /**\n    Assures that the method is called within the Angular Zone, otherwise throws an error.\n  */\n  static assertInAngularZone() {\n    if (!NgZone.isInAngularZone()) {\n      throw new RuntimeError(909 /* RuntimeErrorCode.UNEXPECTED_ZONE_STATE */, ngDevMode && 'Expected to be in Angular Zone, but it is not!');\n    }\n  }\n  /**\n    Assures that the method is called outside of the Angular Zone, otherwise throws an error.\n  */\n  static assertNotInAngularZone() {\n    if (NgZone.isInAngularZone()) {\n      throw new RuntimeError(909 /* RuntimeErrorCode.UNEXPECTED_ZONE_STATE */, ngDevMode && 'Expected to not be in Angular Zone, but it is!');\n    }\n  }\n  /**\n   * Executes the `fn` function synchronously within the Angular zone and returns value returned by\n   * the function.\n   *\n   * Running functions via `run` allows you to reenter Angular zone from a task that was executed\n   * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\n   *\n   * Any future tasks or microtasks scheduled from within this function will continue executing from\n   * within the Angular zone.\n   *\n   * If a synchronous error happens it will be rethrown and not reported via `onError`.\n   */\n  run(fn, applyThis, applyArgs) {\n    return this._inner.run(fn, applyThis, applyArgs);\n  }\n  /**\n   * Executes the `fn` function synchronously within the Angular zone as a task and returns value\n   * returned by the function.\n   *\n   * Running functions via `run` allows you to reenter Angular zone from a task that was executed\n   * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\n   *\n   * Any future tasks or microtasks scheduled from within this function will continue executing from\n   * within the Angular zone.\n   *\n   * If a synchronous error happens it will be rethrown and not reported via `onError`.\n   */\n  runTask(fn, applyThis, applyArgs, name) {\n    const zone = this._inner;\n    const task = zone.scheduleEventTask('NgZoneEvent: ' + name, fn, EMPTY_PAYLOAD, noop, noop);\n    try {\n      return zone.runTask(task, applyThis, applyArgs);\n    } finally {\n      zone.cancelTask(task);\n    }\n  }\n  /**\n   * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not\n   * rethrown.\n   */\n  runGuarded(fn, applyThis, applyArgs) {\n    return this._inner.runGuarded(fn, applyThis, applyArgs);\n  }\n  /**\n   * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by\n   * the function.\n   *\n   * Running functions via {@link #runOutsideAngular} allows you to escape Angular's zone and do\n   * work that\n   * doesn't trigger Angular change-detection or is subject to Angular's error handling.\n   *\n   * Any future tasks or microtasks scheduled from within this function will continue executing from\n   * outside of the Angular zone.\n   *\n   * Use {@link #run} to reenter the Angular zone and do work that updates the application model.\n   */\n  runOutsideAngular(fn) {\n    return this._outer.run(fn);\n  }\n}\nconst EMPTY_PAYLOAD = {};\nfunction checkStable(zone) {\n  // TODO: @JiaLiPassion, should check zone.isCheckStableRunning to prevent\n  // re-entry. The case is:\n  //\n  // @Component({...})\n  // export class AppComponent {\n  // constructor(private ngZone: NgZone) {\n  //   this.ngZone.onStable.subscribe(() => {\n  //     this.ngZone.run(() => console.log('stable'););\n  //   });\n  // }\n  //\n  // The onStable subscriber run another function inside ngZone\n  // which causes `checkStable()` re-entry.\n  // But this fix causes some issues in g3, so this fix will be\n  // launched in another PR.\n  if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {\n    try {\n      zone._nesting++;\n      zone.onMicrotaskEmpty.emit(null);\n    } finally {\n      zone._nesting--;\n      if (!zone.hasPendingMicrotasks) {\n        try {\n          zone.runOutsideAngular(() => zone.onStable.emit(null));\n        } finally {\n          zone.isStable = true;\n        }\n      }\n    }\n  }\n}\nfunction delayChangeDetectionForEvents(zone) {\n  /**\n   * We also need to check _nesting here\n   * Consider the following case with shouldCoalesceRunChangeDetection = true\n   *\n   * ngZone.run(() => {});\n   * ngZone.run(() => {});\n   *\n   * We want the two `ngZone.run()` only trigger one change detection\n   * when shouldCoalesceRunChangeDetection is true.\n   * And because in this case, change detection run in async way(requestAnimationFrame),\n   * so we also need to check the _nesting here to prevent multiple\n   * change detections.\n   */\n  if (zone.isCheckStableRunning || zone.lastRequestAnimationFrameId !== -1) {\n    return;\n  }\n  zone.lastRequestAnimationFrameId = zone.nativeRequestAnimationFrame.call(_global, () => {\n    // This is a work around for https://github.com/angular/angular/issues/36839.\n    // The core issue is that when event coalescing is enabled it is possible for microtasks\n    // to get flushed too early (As is the case with `Promise.then`) between the\n    // coalescing eventTasks.\n    //\n    // To workaround this we schedule a \"fake\" eventTask before we process the\n    // coalescing eventTasks. The benefit of this is that the \"fake\" container eventTask\n    //  will prevent the microtasks queue from getting drained in between the coalescing\n    // eventTask execution.\n    if (!zone.fakeTopEventTask) {\n      zone.fakeTopEventTask = Zone.root.scheduleEventTask('fakeTopEventTask', () => {\n        zone.lastRequestAnimationFrameId = -1;\n        updateMicroTaskStatus(zone);\n        zone.isCheckStableRunning = true;\n        checkStable(zone);\n        zone.isCheckStableRunning = false;\n      }, undefined, () => {}, () => {});\n    }\n    zone.fakeTopEventTask.invoke();\n  });\n  updateMicroTaskStatus(zone);\n}\nfunction forkInnerZoneWithAngularBehavior(zone) {\n  const delayChangeDetectionForEventsDelegate = () => {\n    delayChangeDetectionForEvents(zone);\n  };\n  zone._inner = zone._inner.fork({\n    name: 'angular',\n    properties: {\n      'isAngularZone': true\n    },\n    onInvokeTask: (delegate, current, target, task, applyThis, applyArgs) => {\n      if (shouldBeIgnoredByZone(applyArgs)) {\n        return delegate.invokeTask(target, task, applyThis, applyArgs);\n      }\n      try {\n        onEnter(zone);\n        return delegate.invokeTask(target, task, applyThis, applyArgs);\n      } finally {\n        if (zone.shouldCoalesceEventChangeDetection && task.type === 'eventTask' || zone.shouldCoalesceRunChangeDetection) {\n          delayChangeDetectionForEventsDelegate();\n        }\n        onLeave(zone);\n      }\n    },\n    onInvoke: (delegate, current, target, callback, applyThis, applyArgs, source) => {\n      try {\n        onEnter(zone);\n        return delegate.invoke(target, callback, applyThis, applyArgs, source);\n      } finally {\n        if (zone.shouldCoalesceRunChangeDetection) {\n          delayChangeDetectionForEventsDelegate();\n        }\n        onLeave(zone);\n      }\n    },\n    onHasTask: (delegate, current, target, hasTaskState) => {\n      delegate.hasTask(target, hasTaskState);\n      if (current === target) {\n        // We are only interested in hasTask events which originate from our zone\n        // (A child hasTask event is not interesting to us)\n        if (hasTaskState.change == 'microTask') {\n          zone._hasPendingMicrotasks = hasTaskState.microTask;\n          updateMicroTaskStatus(zone);\n          checkStable(zone);\n        } else if (hasTaskState.change == 'macroTask') {\n          zone.hasPendingMacrotasks = hasTaskState.macroTask;\n        }\n      }\n    },\n    onHandleError: (delegate, current, target, error) => {\n      delegate.handleError(target, error);\n      zone.runOutsideAngular(() => zone.onError.emit(error));\n      return false;\n    }\n  });\n}\nfunction updateMicroTaskStatus(zone) {\n  if (zone._hasPendingMicrotasks || (zone.shouldCoalesceEventChangeDetection || zone.shouldCoalesceRunChangeDetection) && zone.lastRequestAnimationFrameId !== -1) {\n    zone.hasPendingMicrotasks = true;\n  } else {\n    zone.hasPendingMicrotasks = false;\n  }\n}\nfunction onEnter(zone) {\n  zone._nesting++;\n  if (zone.isStable) {\n    zone.isStable = false;\n    zone.onUnstable.emit(null);\n  }\n}\nfunction onLeave(zone) {\n  zone._nesting--;\n  checkStable(zone);\n}\n/**\n * Provides a noop implementation of `NgZone` which does nothing. This zone requires explicit calls\n * to framework to perform rendering.\n */\nclass NoopNgZone {\n  constructor() {\n    this.hasPendingMicrotasks = false;\n    this.hasPendingMacrotasks = false;\n    this.isStable = true;\n    this.onUnstable = new EventEmitter();\n    this.onMicrotaskEmpty = new EventEmitter();\n    this.onStable = new EventEmitter();\n    this.onError = new EventEmitter();\n  }\n  run(fn, applyThis, applyArgs) {\n    return fn.apply(applyThis, applyArgs);\n  }\n  runGuarded(fn, applyThis, applyArgs) {\n    return fn.apply(applyThis, applyArgs);\n  }\n  runOutsideAngular(fn) {\n    return fn();\n  }\n  runTask(fn, applyThis, applyArgs, name) {\n    return fn.apply(applyThis, applyArgs);\n  }\n}\n/**\n * Token used to drive ApplicationRef.isStable\n *\n * TODO: This should be moved entirely to NgZone (as a breaking change) so it can be tree-shakeable\n * for `NoopNgZone` which is always just an `Observable` of `true`. Additionally, we should consider\n * whether the property on `NgZone` should be `Observable` or `Signal`.\n */\nconst ZONE_IS_STABLE_OBSERVABLE = new InjectionToken(ngDevMode ? 'isStable Observable' : '', {\n  providedIn: 'root',\n  // TODO(atscott): Replace this with a suitable default like `new\n  // BehaviorSubject(true).asObservable`. Again, long term this won't exist on ApplicationRef at\n  // all but until we can remove it, we need a default value zoneless.\n  factory: isStableFactory\n});\nfunction isStableFactory() {\n  const zone = inject$1(NgZone);\n  let _stable = true;\n  const isCurrentlyStable = new Observable(observer => {\n    _stable = zone.isStable && !zone.hasPendingMacrotasks && !zone.hasPendingMicrotasks;\n    zone.runOutsideAngular(() => {\n      observer.next(_stable);\n      observer.complete();\n    });\n  });\n  const isStable = new Observable(observer => {\n    // Create the subscription to onStable outside the Angular Zone so that\n    // the callback is run outside the Angular Zone.\n    let stableSub;\n    zone.runOutsideAngular(() => {\n      stableSub = zone.onStable.subscribe(() => {\n        NgZone.assertNotInAngularZone();\n        // Check whether there are no pending macro/micro tasks in the next tick\n        // to allow for NgZone to update the state.\n        queueMicrotask(() => {\n          if (!_stable && !zone.hasPendingMacrotasks && !zone.hasPendingMicrotasks) {\n            _stable = true;\n            observer.next(true);\n          }\n        });\n      });\n    });\n    const unstableSub = zone.onUnstable.subscribe(() => {\n      NgZone.assertInAngularZone();\n      if (_stable) {\n        _stable = false;\n        zone.runOutsideAngular(() => {\n          observer.next(false);\n        });\n      }\n    });\n    return () => {\n      stableSub.unsubscribe();\n      unstableSub.unsubscribe();\n    };\n  });\n  return merge$1(isCurrentlyStable, isStable.pipe(share()));\n}\nfunction shouldBeIgnoredByZone(applyArgs) {\n  if (!Array.isArray(applyArgs)) {\n    return false;\n  }\n  // We should only ever get 1 arg passed through to invokeTask.\n  // Short circuit here incase that behavior changes.\n  if (applyArgs.length !== 1) {\n    return false;\n  }\n  // Prevent triggering change detection when the __ignore_ng_zone__ flag is detected.\n  return applyArgs[0].data?.['__ignore_ng_zone__'] === true;\n}\n\n// Public API for Zone\n\n/**\n * Register a callback to be invoked each time the application\n * finishes rendering.\n *\n * Note that the callback will run\n * - in the order it was registered\n * - once per render\n * - on browser platforms only\n *\n * <div class=\"alert is-important\">\n *\n * Components are not guaranteed to be [hydrated](guide/hydration) before the callback runs.\n * You must use caution when directly reading or writing the DOM and layout.\n *\n * </div>\n *\n * @param callback A callback function to register\n *\n * @usageNotes\n *\n * Use `afterRender` to read or write the DOM after each render.\n *\n * ### Example\n * ```ts\n * @Component({\n *   selector: 'my-cmp',\n *   template: `<span #content>{{ ... }}</span>`,\n * })\n * export class MyComponent {\n *   @ViewChild('content') contentRef: ElementRef;\n *\n *   constructor() {\n *     afterRender(() => {\n *       console.log('content height: ' + this.contentRef.nativeElement.scrollHeight);\n *     });\n *   }\n * }\n * ```\n *\n * @developerPreview\n */\nfunction afterRender(callback, options) {\n  !options && assertInInjectionContext(afterRender);\n  const injector = options?.injector ?? inject$1(Injector);\n  if (!isPlatformBrowser(injector)) {\n    return {\n      destroy() {}\n    };\n  }\n  let destroy;\n  const unregisterFn = injector.get(DestroyRef).onDestroy(() => destroy?.());\n  const afterRenderEventManager = injector.get(AfterRenderEventManager);\n  // Lazily initialize the handler implementation, if necessary. This is so that it can be\n  // tree-shaken if `afterRender` and `afterNextRender` aren't used.\n  const callbackHandler = afterRenderEventManager.handler ??= new AfterRenderCallbackHandlerImpl();\n  const ngZone = injector.get(NgZone);\n  const errorHandler = injector.get(ErrorHandler, null, {\n    optional: true\n  });\n  const instance = new AfterRenderCallback(ngZone, errorHandler, callback);\n  destroy = () => {\n    callbackHandler.unregister(instance);\n    unregisterFn();\n  };\n  callbackHandler.register(instance);\n  return {\n    destroy\n  };\n}\n/**\n * Register a callback to be invoked the next time the application\n * finishes rendering.\n *\n * Note that the callback will run\n * - in the order it was registered\n * - on browser platforms only\n *\n * <div class=\"alert is-important\">\n *\n * Components are not guaranteed to be [hydrated](guide/hydration) before the callback runs.\n * You must use caution when directly reading or writing the DOM and layout.\n *\n * </div>\n *\n * @param callback A callback function to register\n *\n * @usageNotes\n *\n * Use `afterNextRender` to read or write the DOM once,\n * for example to initialize a non-Angular library.\n *\n * ### Example\n * ```ts\n * @Component({\n *   selector: 'my-chart-cmp',\n *   template: `<div #chart>{{ ... }}</div>`,\n * })\n * export class MyChartCmp {\n *   @ViewChild('chart') chartRef: ElementRef;\n *   chart: MyChart|null;\n *\n *   constructor() {\n *     afterNextRender(() => {\n *       this.chart = new MyChart(this.chartRef.nativeElement);\n *     });\n *   }\n * }\n * ```\n *\n * @developerPreview\n */\nfunction afterNextRender(callback, options) {\n  !options && assertInInjectionContext(afterNextRender);\n  const injector = options?.injector ?? inject$1(Injector);\n  if (!isPlatformBrowser(injector)) {\n    return {\n      destroy() {}\n    };\n  }\n  let destroy;\n  const unregisterFn = injector.get(DestroyRef).onDestroy(() => destroy?.());\n  const afterRenderEventManager = injector.get(AfterRenderEventManager);\n  // Lazily initialize the handler implementation, if necessary. This is so that it can be\n  // tree-shaken if `afterRender` and `afterNextRender` aren't used.\n  const callbackHandler = afterRenderEventManager.handler ??= new AfterRenderCallbackHandlerImpl();\n  const ngZone = injector.get(NgZone);\n  const errorHandler = injector.get(ErrorHandler, null, {\n    optional: true\n  });\n  const instance = new AfterRenderCallback(ngZone, errorHandler, () => {\n    destroy?.();\n    callback();\n  });\n  destroy = () => {\n    callbackHandler.unregister(instance);\n    unregisterFn();\n  };\n  callbackHandler.register(instance);\n  return {\n    destroy\n  };\n}\n/**\n * A wrapper around a function to be used as an after render callback.\n */\nclass AfterRenderCallback {\n  constructor(zone, errorHandler, callbackFn) {\n    this.zone = zone;\n    this.errorHandler = errorHandler;\n    this.callbackFn = callbackFn;\n  }\n  invoke() {\n    try {\n      this.zone.runOutsideAngular(this.callbackFn);\n    } catch (err) {\n      this.errorHandler?.handleError(err);\n    }\n  }\n}\n/**\n * Core functionality for `afterRender` and `afterNextRender`. Kept separate from\n * `AfterRenderEventManager` for tree-shaking.\n */\nclass AfterRenderCallbackHandlerImpl {\n  constructor() {\n    this.executingCallbacks = false;\n    this.callbacks = new Set();\n    this.deferredCallbacks = new Set();\n  }\n  validateBegin() {\n    if (this.executingCallbacks) {\n      throw new RuntimeError(102 /* RuntimeErrorCode.RECURSIVE_APPLICATION_RENDER */, ngDevMode && 'A new render operation began before the previous operation ended. ' + 'Did you trigger change detection from afterRender or afterNextRender?');\n    }\n  }\n  register(callback) {\n    // If we're currently running callbacks, new callbacks should be deferred\n    // until the next render operation.\n    const target = this.executingCallbacks ? this.deferredCallbacks : this.callbacks;\n    target.add(callback);\n  }\n  unregister(callback) {\n    this.callbacks.delete(callback);\n    this.deferredCallbacks.delete(callback);\n  }\n  execute() {\n    this.executingCallbacks = true;\n    for (const callback of this.callbacks) {\n      callback.invoke();\n    }\n    this.executingCallbacks = false;\n    for (const callback of this.deferredCallbacks) {\n      this.callbacks.add(callback);\n    }\n    this.deferredCallbacks.clear();\n  }\n  destroy() {\n    this.callbacks.clear();\n    this.deferredCallbacks.clear();\n  }\n}\n/**\n * Implements core timing for `afterRender` and `afterNextRender` events.\n * Delegates to an optional `AfterRenderCallbackHandler` for implementation.\n */\nclass AfterRenderEventManager {\n  constructor() {\n    this.renderDepth = 0;\n    /* @internal */\n    this.handler = null;\n  }\n  /**\n   * Mark the beginning of a render operation (i.e. CD cycle).\n   * Throws if called while executing callbacks.\n   */\n  begin() {\n    this.handler?.validateBegin();\n    this.renderDepth++;\n  }\n  /**\n   * Mark the end of a render operation. Callbacks will be\n   * executed if there are no more pending operations.\n   */\n  end() {\n    ngDevMode && assertGreaterThan(this.renderDepth, 0, 'renderDepth must be greater than 0');\n    this.renderDepth--;\n    if (this.renderDepth === 0) {\n      this.handler?.execute();\n    }\n  }\n  ngOnDestroy() {\n    this.handler?.destroy();\n    this.handler = null;\n  }\n  /** @nocollapse */\n  static #_ = this.ɵprov = ɵɵdefineInjectable({\n    token: AfterRenderEventManager,\n    providedIn: 'root',\n    factory: () => new AfterRenderEventManager()\n  });\n}\n\n/**\n * Marks current view and all ancestors dirty.\n *\n * Returns the root view because it is found as a byproduct of marking the view tree\n * dirty, and can be used by methods that consume markViewDirty() to easily schedule\n * change detection. Otherwise, such methods would need to traverse up the view tree\n * an additional time to get the root view and schedule a tick on it.\n *\n * @param lView The starting LView to mark dirty\n * @returns the root LView\n */\nfunction markViewDirty(lView) {\n  while (lView) {\n    lView[FLAGS] |= 64 /* LViewFlags.Dirty */;\n    const parent = getLViewParent(lView);\n    // Stop traversing up as soon as you find a root view that wasn't attached to any container\n    if (isRootView(lView) && !parent) {\n      return lView;\n    }\n    // continue otherwise\n    lView = parent;\n  }\n  return null;\n}\n\n/**\n * Internal token that specifies whether DOM reuse logic\n * during hydration is enabled.\n */\nconst IS_HYDRATION_DOM_REUSE_ENABLED = new InjectionToken(typeof ngDevMode === 'undefined' || !!ngDevMode ? 'IS_HYDRATION_DOM_REUSE_ENABLED' : '');\n// By default (in client rendering mode), we remove all the contents\n// of the host element and render an application after that.\nconst PRESERVE_HOST_CONTENT_DEFAULT = false;\n/**\n * Internal token that indicates whether host element content should be\n * retained during the bootstrap.\n */\nconst PRESERVE_HOST_CONTENT = new InjectionToken(typeof ngDevMode === 'undefined' || !!ngDevMode ? 'PRESERVE_HOST_CONTENT' : '', {\n  providedIn: 'root',\n  factory: () => PRESERVE_HOST_CONTENT_DEFAULT\n});\nfunction normalizeDebugBindingName(name) {\n  // Attribute names with `$` (eg `x-y$`) are valid per spec, but unsupported by some browsers\n  name = camelCaseToDashCase(name.replace(/[$@]/g, '_'));\n  return `ng-reflect-${name}`;\n}\nconst CAMEL_CASE_REGEXP = /([A-Z])/g;\nfunction camelCaseToDashCase(input) {\n  return input.replace(CAMEL_CASE_REGEXP, (...m) => '-' + m[1].toLowerCase());\n}\nfunction normalizeDebugBindingValue(value) {\n  try {\n    // Limit the size of the value as otherwise the DOM just gets polluted.\n    return value != null ? value.toString().slice(0, 30) : value;\n  } catch (e) {\n    return '[ERROR] Exception while trying to serialize the value';\n  }\n}\n\n/**\n * The max length of the string representation of a value in an error message\n */\nconst VALUE_STRING_LENGTH_LIMIT = 200;\n/** Verifies that a given type is a Standalone Component. */\nfunction assertStandaloneComponentType(type) {\n  assertComponentDef(type);\n  const componentDef = getComponentDef$1(type);\n  if (!componentDef.standalone) {\n    throw new RuntimeError(907 /* RuntimeErrorCode.TYPE_IS_NOT_STANDALONE */, `The ${stringifyForError(type)} component is not marked as standalone, ` + `but Angular expects to have a standalone component here. ` + `Please make sure the ${stringifyForError(type)} component has ` + `the \\`standalone: true\\` flag in the decorator.`);\n  }\n}\n/** Verifies whether a given type is a component */\nfunction assertComponentDef(type) {\n  if (!getComponentDef$1(type)) {\n    throw new RuntimeError(906 /* RuntimeErrorCode.MISSING_GENERATED_DEF */, `The ${stringifyForError(type)} is not an Angular component, ` + `make sure it has the \\`@Component\\` decorator.`);\n  }\n}\n/** Called when there are multiple component selectors that match a given node */\nfunction throwMultipleComponentError(tNode, first, second) {\n  throw new RuntimeError(-300 /* RuntimeErrorCode.MULTIPLE_COMPONENTS_MATCH */, `Multiple components match node with tagname ${tNode.value}: ` + `${stringifyForError(first)} and ` + `${stringifyForError(second)}`);\n}\n/** Throws an ExpressionChangedAfterChecked error if checkNoChanges mode is on. */\nfunction throwErrorIfNoChangesMode(creationMode, oldValue, currValue, propName, lView) {\n  const hostComponentDef = getDeclarationComponentDef(lView);\n  const componentClassName = hostComponentDef?.type?.name;\n  const field = propName ? ` for '${propName}'` : '';\n  let msg = `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value${field}: '${formatValue(oldValue)}'. Current value: '${formatValue(currValue)}'.${componentClassName ? ` Expression location: ${componentClassName} component` : ''}`;\n  if (creationMode) {\n    msg += ` It seems like the view has been created after its parent and its children have been dirty checked.` + ` Has it been created in a change detection hook?`;\n  }\n  throw new RuntimeError(-100 /* RuntimeErrorCode.EXPRESSION_CHANGED_AFTER_CHECKED */, msg);\n}\nfunction formatValue(value) {\n  let strValue = String(value);\n  // JSON.stringify will throw on circular references\n  try {\n    if (Array.isArray(value) || strValue === '[object Object]') {\n      strValue = JSON.stringify(value);\n    }\n  } catch (error) {}\n  return strValue.length > VALUE_STRING_LENGTH_LIMIT ? strValue.substring(0, VALUE_STRING_LENGTH_LIMIT) + '…' : strValue;\n}\nfunction constructDetailsForInterpolation(lView, rootIndex, expressionIndex, meta, changedValue) {\n  const [propName, prefix, ...chunks] = meta.split(INTERPOLATION_DELIMITER);\n  let oldValue = prefix,\n    newValue = prefix;\n  for (let i = 0; i < chunks.length; i++) {\n    const slotIdx = rootIndex + i;\n    oldValue += `${lView[slotIdx]}${chunks[i]}`;\n    newValue += `${slotIdx === expressionIndex ? changedValue : lView[slotIdx]}${chunks[i]}`;\n  }\n  return {\n    propName,\n    oldValue,\n    newValue\n  };\n}\n/**\n * Constructs an object that contains details for the ExpressionChangedAfterItHasBeenCheckedError:\n * - property name (for property bindings or interpolations)\n * - old and new values, enriched using information from metadata\n *\n * More information on the metadata storage format can be found in `storePropertyBindingMetadata`\n * function description.\n */\nfunction getExpressionChangedErrorDetails(lView, bindingIndex, oldValue, newValue) {\n  const tData = lView[TVIEW].data;\n  const metadata = tData[bindingIndex];\n  if (typeof metadata === 'string') {\n    // metadata for property interpolation\n    if (metadata.indexOf(INTERPOLATION_DELIMITER) > -1) {\n      return constructDetailsForInterpolation(lView, bindingIndex, bindingIndex, metadata, newValue);\n    }\n    // metadata for property binding\n    return {\n      propName: metadata,\n      oldValue,\n      newValue\n    };\n  }\n  // metadata is not available for this expression, check if this expression is a part of the\n  // property interpolation by going from the current binding index left and look for a string that\n  // contains INTERPOLATION_DELIMITER, the layout in tView.data for this case will look like this:\n  // [..., 'id�Prefix � and � suffix', null, null, null, ...]\n  if (metadata === null) {\n    let idx = bindingIndex - 1;\n    while (typeof tData[idx] !== 'string' && tData[idx + 1] === null) {\n      idx--;\n    }\n    const meta = tData[idx];\n    if (typeof meta === 'string') {\n      const matches = meta.match(new RegExp(INTERPOLATION_DELIMITER, 'g'));\n      // first interpolation delimiter separates property name from interpolation parts (in case of\n      // property interpolations), so we subtract one from total number of found delimiters\n      if (matches && matches.length - 1 > bindingIndex - idx) {\n        return constructDetailsForInterpolation(lView, idx, bindingIndex, meta, newValue);\n      }\n    }\n  }\n  return {\n    propName: undefined,\n    oldValue,\n    newValue\n  };\n}\nlet currentConsumer = null;\nfunction setLViewForConsumer(node, lView) {\n  (typeof ngDevMode === 'undefined' || ngDevMode) && assertEqual(node.lView, null, 'Consumer already associated with a view.');\n  node.lView = lView;\n}\n/**\n * Create a new template consumer pointing at the specified LView.\n * Sometimes, a previously created consumer may be reused, in order to save on allocations. In that\n * case, the LView will be updated.\n */\nfunction getReactiveLViewConsumer(lView, slot) {\n  return lView[slot] ?? getOrCreateCurrentLViewConsumer();\n}\n/**\n * Assigns the `currentTemplateContext` to its LView's `REACTIVE_CONSUMER` slot if there are tracked\n * producers.\n *\n * The presence of producers means that a signal was read while the consumer was the active\n * consumer.\n *\n * If no producers are present, we do not assign the current template context. This also means we\n * can just reuse the template context for the next LView.\n */\nfunction commitLViewConsumerIfHasProducers(lView, slot) {\n  const consumer = getOrCreateCurrentLViewConsumer();\n  if (!consumer.producerNode?.length) {\n    return;\n  }\n  lView[slot] = currentConsumer;\n  consumer.lView = lView;\n  currentConsumer = createLViewConsumer();\n}\nconst REACTIVE_LVIEW_CONSUMER_NODE = {\n  ...REACTIVE_NODE,\n  consumerIsAlwaysLive: true,\n  consumerMarkedDirty: node => {\n    (typeof ngDevMode === 'undefined' || ngDevMode) && assertDefined(node.lView, 'Updating a signal during template or host binding execution is not allowed.');\n    markViewDirty(node.lView);\n  },\n  lView: null\n};\nfunction createLViewConsumer() {\n  return Object.create(REACTIVE_LVIEW_CONSUMER_NODE);\n}\nfunction getOrCreateCurrentLViewConsumer() {\n  currentConsumer ??= createLViewConsumer();\n  return currentConsumer;\n}\n\n/** A special value which designates that a value has not changed. */\nconst NO_CHANGE = typeof ngDevMode === 'undefined' || ngDevMode ? {\n  __brand__: 'NO_CHANGE'\n} : {};\n\n/**\n * Advances to an element for later binding instructions.\n *\n * Used in conjunction with instructions like {@link property} to act on elements with specified\n * indices, for example those created with {@link element} or {@link elementStart}.\n *\n * ```ts\n * (rf: RenderFlags, ctx: any) => {\n *   if (rf & 1) {\n *     text(0, 'Hello');\n *     text(1, 'Goodbye')\n *     element(2, 'div');\n *   }\n *   if (rf & 2) {\n *     advance(2); // Advance twice to the <div>.\n *     property('title', 'test');\n *   }\n *  }\n * ```\n * @param delta Number of elements to advance forwards by.\n *\n * @codeGenApi\n */\nfunction ɵɵadvance(delta) {\n  ngDevMode && assertGreaterThan(delta, 0, 'Can only advance forward');\n  selectIndexInternal(getTView(), getLView(), getSelectedIndex() + delta, !!ngDevMode && isInCheckNoChangesMode());\n}\nfunction selectIndexInternal(tView, lView, index, checkNoChangesMode) {\n  ngDevMode && assertIndexInDeclRange(lView, index);\n  // Flush the initial hooks for elements in the view that have been added up to this point.\n  // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n  if (!checkNoChangesMode) {\n    const hooksInitPhaseCompleted = (lView[FLAGS] & 3 /* LViewFlags.InitPhaseStateMask */) === 3 /* InitPhaseState.InitPhaseCompleted */;\n    if (hooksInitPhaseCompleted) {\n      const preOrderCheckHooks = tView.preOrderCheckHooks;\n      if (preOrderCheckHooks !== null) {\n        executeCheckHooks(lView, preOrderCheckHooks, index);\n      }\n    } else {\n      const preOrderHooks = tView.preOrderHooks;\n      if (preOrderHooks !== null) {\n        executeInitAndCheckHooks(lView, preOrderHooks, 0 /* InitPhaseState.OnInitHooksToBeRun */, index);\n      }\n    }\n  }\n  // We must set the selected index *after* running the hooks, because hooks may have side-effects\n  // that cause other template functions to run, thus updating the selected index, which is global\n  // state. If we run `setSelectedIndex` *before* we run the hooks, in some cases the selected index\n  // will be altered by the time we leave the `ɵɵadvance` instruction.\n  setSelectedIndex(index);\n}\nfunction ɵɵdirectiveInject(token, flags = InjectFlags.Default) {\n  const lView = getLView();\n  // Fall back to inject() if view hasn't been created. This situation can happen in tests\n  // if inject utilities are used before bootstrapping.\n  if (lView === null) {\n    // Verify that we will not get into infinite loop.\n    ngDevMode && assertInjectImplementationNotEqual(ɵɵdirectiveInject);\n    return ɵɵinject(token, flags);\n  }\n  const tNode = getCurrentTNode();\n  const value = getOrCreateInjectable(tNode, lView, resolveForwardRef(token), flags);\n  ngDevMode && emitInjectEvent(token, value, flags);\n  return value;\n}\n/**\n * Throws an error indicating that a factory function could not be generated by the compiler for a\n * particular class.\n *\n * This instruction allows the actual error message to be optimized away when ngDevMode is turned\n * off, saving bytes of generated code while still providing a good experience in dev mode.\n *\n * The name of the class is not mentioned here, but will be in the generated factory function name\n * and thus in the stack trace.\n *\n * @codeGenApi\n */\nfunction ɵɵinvalidFactory() {\n  const msg = ngDevMode ? `This constructor was not compatible with Dependency Injection.` : 'invalid';\n  throw new Error(msg);\n}\n\n/**\n * Invoke `HostBindingsFunction`s for view.\n *\n * This methods executes `TView.hostBindingOpCodes`. It is used to execute the\n * `HostBindingsFunction`s associated with the current `LView`.\n *\n * @param tView Current `TView`.\n * @param lView Current `LView`.\n */\nfunction processHostBindingOpCodes(tView, lView) {\n  const hostBindingOpCodes = tView.hostBindingOpCodes;\n  if (hostBindingOpCodes === null) return;\n  const consumer = getReactiveLViewConsumer(lView, REACTIVE_HOST_BINDING_CONSUMER);\n  try {\n    for (let i = 0; i < hostBindingOpCodes.length; i++) {\n      const opCode = hostBindingOpCodes[i];\n      if (opCode < 0) {\n        // Negative numbers are element indexes.\n        setSelectedIndex(~opCode);\n      } else {\n        // Positive numbers are NumberTuple which store bindingRootIndex and directiveIndex.\n        const directiveIdx = opCode;\n        const bindingRootIndx = hostBindingOpCodes[++i];\n        const hostBindingFn = hostBindingOpCodes[++i];\n        setBindingRootForHostBindings(bindingRootIndx, directiveIdx);\n        consumer.dirty = false;\n        const prevConsumer = consumerBeforeComputation(consumer);\n        try {\n          const context = lView[directiveIdx];\n          hostBindingFn(2 /* RenderFlags.Update */, context);\n        } finally {\n          consumerAfterComputation(consumer, prevConsumer);\n        }\n      }\n    }\n  } finally {\n    if (lView[REACTIVE_HOST_BINDING_CONSUMER] === null) {\n      commitLViewConsumerIfHasProducers(lView, REACTIVE_HOST_BINDING_CONSUMER);\n    }\n    setSelectedIndex(-1);\n  }\n}\nfunction createLView(parentLView, tView, context, flags, host, tHostNode, environment, renderer, injector, embeddedViewInjector, hydrationInfo) {\n  const lView = tView.blueprint.slice();\n  lView[HOST] = host;\n  lView[FLAGS] = flags | 4 /* LViewFlags.CreationMode */ | 128 /* LViewFlags.Attached */ | 8 /* LViewFlags.FirstLViewPass */;\n  if (embeddedViewInjector !== null || parentLView && parentLView[FLAGS] & 2048 /* LViewFlags.HasEmbeddedViewInjector */) {\n    lView[FLAGS] |= 2048 /* LViewFlags.HasEmbeddedViewInjector */;\n  }\n\n  resetPreOrderHookFlags(lView);\n  ngDevMode && tView.declTNode && parentLView && assertTNodeForLView(tView.declTNode, parentLView);\n  lView[PARENT] = lView[DECLARATION_VIEW] = parentLView;\n  lView[CONTEXT] = context;\n  lView[ENVIRONMENT] = environment || parentLView && parentLView[ENVIRONMENT];\n  ngDevMode && assertDefined(lView[ENVIRONMENT], 'LViewEnvironment is required');\n  lView[RENDERER] = renderer || parentLView && parentLView[RENDERER];\n  ngDevMode && assertDefined(lView[RENDERER], 'Renderer is required');\n  lView[INJECTOR$1] = injector || parentLView && parentLView[INJECTOR$1] || null;\n  lView[T_HOST] = tHostNode;\n  lView[ID] = getUniqueLViewId();\n  lView[HYDRATION] = hydrationInfo;\n  lView[EMBEDDED_VIEW_INJECTOR] = embeddedViewInjector;\n  ngDevMode && assertEqual(tView.type == 2 /* TViewType.Embedded */ ? parentLView !== null : true, true, 'Embedded views must have parentLView');\n  lView[DECLARATION_COMPONENT_VIEW] = tView.type == 2 /* TViewType.Embedded */ ? parentLView[DECLARATION_COMPONENT_VIEW] : lView;\n  return lView;\n}\nfunction getOrCreateTNode(tView, index, type, name, attrs) {\n  ngDevMode && index !== 0 &&\n  // 0 are bogus nodes and they are OK. See `createContainerRef` in\n  // `view_engine_compatibility` for additional context.\n  assertGreaterThanOrEqual(index, HEADER_OFFSET, 'TNodes can\\'t be in the LView header.');\n  // Keep this function short, so that the VM will inline it.\n  ngDevMode && assertPureTNodeType(type);\n  let tNode = tView.data[index];\n  if (tNode === null) {\n    tNode = createTNodeAtIndex(tView, index, type, name, attrs);\n    if (isInI18nBlock()) {\n      // If we are in i18n block then all elements should be pre declared through `Placeholder`\n      // See `TNodeType.Placeholder` and `LFrame.inI18n` for more context.\n      // If the `TNode` was not pre-declared than it means it was not mentioned which means it was\n      // removed, so we mark it as detached.\n      tNode.flags |= 32 /* TNodeFlags.isDetached */;\n    }\n  } else if (tNode.type & 64 /* TNodeType.Placeholder */) {\n    tNode.type = type;\n    tNode.value = name;\n    tNode.attrs = attrs;\n    const parent = getCurrentParentTNode();\n    tNode.injectorIndex = parent === null ? -1 : parent.injectorIndex;\n    ngDevMode && assertTNodeForTView(tNode, tView);\n    ngDevMode && assertEqual(index, tNode.index, 'Expecting same index');\n  }\n  setCurrentTNode(tNode, true);\n  return tNode;\n}\nfunction createTNodeAtIndex(tView, index, type, name, attrs) {\n  const currentTNode = getCurrentTNodePlaceholderOk();\n  const isParent = isCurrentTNodeParent();\n  const parent = isParent ? currentTNode : currentTNode && currentTNode.parent;\n  // Parents cannot cross component boundaries because components will be used in multiple places.\n  const tNode = tView.data[index] = createTNode(tView, parent, type, index, name, attrs);\n  // Assign a pointer to the first child node of a given view. The first node is not always the one\n  // at index 0, in case of i18n, index 0 can be the instruction `i18nStart` and the first node has\n  // the index 1 or more, so we can't just check node index.\n  if (tView.firstChild === null) {\n    tView.firstChild = tNode;\n  }\n  if (currentTNode !== null) {\n    if (isParent) {\n      // FIXME(misko): This logic looks unnecessarily complicated. Could we simplify?\n      if (currentTNode.child == null && tNode.parent !== null) {\n        // We are in the same view, which means we are adding content node to the parent view.\n        currentTNode.child = tNode;\n      }\n    } else {\n      if (currentTNode.next === null) {\n        // In the case of i18n the `currentTNode` may already be linked, in which case we don't want\n        // to break the links which i18n created.\n        currentTNode.next = tNode;\n        tNode.prev = currentTNode;\n      }\n    }\n  }\n  return tNode;\n}\n/**\n * When elements are created dynamically after a view blueprint is created (e.g. through\n * i18nApply()), we need to adjust the blueprint for future\n * template passes.\n *\n * @param tView `TView` associated with `LView`\n * @param lView The `LView` containing the blueprint to adjust\n * @param numSlotsToAlloc The number of slots to alloc in the LView, should be >0\n * @param initialValue Initial value to store in blueprint\n */\nfunction allocExpando(tView, lView, numSlotsToAlloc, initialValue) {\n  if (numSlotsToAlloc === 0) return -1;\n  if (ngDevMode) {\n    assertFirstCreatePass(tView);\n    assertSame(tView, lView[TVIEW], '`LView` must be associated with `TView`!');\n    assertEqual(tView.data.length, lView.length, 'Expecting LView to be same size as TView');\n    assertEqual(tView.data.length, tView.blueprint.length, 'Expecting Blueprint to be same size as TView');\n    assertFirstUpdatePass(tView);\n  }\n  const allocIdx = lView.length;\n  for (let i = 0; i < numSlotsToAlloc; i++) {\n    lView.push(initialValue);\n    tView.blueprint.push(initialValue);\n    tView.data.push(null);\n  }\n  return allocIdx;\n}\nfunction executeTemplate(tView, lView, templateFn, rf, context) {\n  const consumer = getReactiveLViewConsumer(lView, REACTIVE_TEMPLATE_CONSUMER);\n  const prevSelectedIndex = getSelectedIndex();\n  const isUpdatePhase = rf & 2 /* RenderFlags.Update */;\n  try {\n    setSelectedIndex(-1);\n    if (isUpdatePhase && lView.length > HEADER_OFFSET) {\n      // When we're updating, inherently select 0 so we don't\n      // have to generate that instruction for most update blocks.\n      selectIndexInternal(tView, lView, HEADER_OFFSET, !!ngDevMode && isInCheckNoChangesMode());\n    }\n    const preHookType = isUpdatePhase ? 2 /* ProfilerEvent.TemplateUpdateStart */ : 0 /* ProfilerEvent.TemplateCreateStart */;\n    profiler(preHookType, context);\n    const effectiveConsumer = isUpdatePhase ? consumer : null;\n    const prevConsumer = consumerBeforeComputation(effectiveConsumer);\n    try {\n      if (effectiveConsumer !== null) {\n        effectiveConsumer.dirty = false;\n      }\n      templateFn(rf, context);\n    } finally {\n      consumerAfterComputation(effectiveConsumer, prevConsumer);\n    }\n  } finally {\n    if (isUpdatePhase && lView[REACTIVE_TEMPLATE_CONSUMER] === null) {\n      commitLViewConsumerIfHasProducers(lView, REACTIVE_TEMPLATE_CONSUMER);\n    }\n    setSelectedIndex(prevSelectedIndex);\n    const postHookType = isUpdatePhase ? 3 /* ProfilerEvent.TemplateUpdateEnd */ : 1 /* ProfilerEvent.TemplateCreateEnd */;\n    profiler(postHookType, context);\n  }\n}\n//////////////////////////\n//// Element\n//////////////////////////\nfunction executeContentQueries(tView, tNode, lView) {\n  if (isContentQueryHost(tNode)) {\n    const prevConsumer = setActiveConsumer(null);\n    try {\n      const start = tNode.directiveStart;\n      const end = tNode.directiveEnd;\n      for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {\n        const def = tView.data[directiveIndex];\n        if (def.contentQueries) {\n          def.contentQueries(1 /* RenderFlags.Create */, lView[directiveIndex], directiveIndex);\n        }\n      }\n    } finally {\n      setActiveConsumer(prevConsumer);\n    }\n  }\n}\n/**\n * Creates directive instances.\n */\nfunction createDirectivesInstances(tView, lView, tNode) {\n  if (!getBindingsEnabled()) return;\n  instantiateAllDirectives(tView, lView, tNode, getNativeByTNode(tNode, lView));\n  if ((tNode.flags & 64 /* TNodeFlags.hasHostBindings */) === 64 /* TNodeFlags.hasHostBindings */) {\n    invokeDirectivesHostBindings(tView, lView, tNode);\n  }\n}\n/**\n * Takes a list of local names and indices and pushes the resolved local variable values\n * to LView in the same order as they are loaded in the template with load().\n */\nfunction saveResolvedLocalsInData(viewData, tNode, localRefExtractor = getNativeByTNode) {\n  const localNames = tNode.localNames;\n  if (localNames !== null) {\n    let localIndex = tNode.index + 1;\n    for (let i = 0; i < localNames.length; i += 2) {\n      const index = localNames[i + 1];\n      const value = index === -1 ? localRefExtractor(tNode, viewData) : viewData[index];\n      viewData[localIndex++] = value;\n    }\n  }\n}\n/**\n * Gets TView from a template function or creates a new TView\n * if it doesn't already exist.\n *\n * @param def ComponentDef\n * @returns TView\n */\nfunction getOrCreateComponentTView(def) {\n  const tView = def.tView;\n  // Create a TView if there isn't one, or recreate it if the first create pass didn't\n  // complete successfully since we can't know for sure whether it's in a usable shape.\n  if (tView === null || tView.incompleteFirstPass) {\n    // Declaration node here is null since this function is called when we dynamically create a\n    // component and hence there is no declaration.\n    const declTNode = null;\n    return def.tView = createTView(1 /* TViewType.Component */, declTNode, def.template, def.decls, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery, def.schemas, def.consts, def.id);\n  }\n  return tView;\n}\n/**\n * Creates a TView instance\n *\n * @param type Type of `TView`.\n * @param declTNode Declaration location of this `TView`.\n * @param templateFn Template function\n * @param decls The number of nodes, local refs, and pipes in this template\n * @param directives Registry of directives for this view\n * @param pipes Registry of pipes for this view\n * @param viewQuery View queries for this view\n * @param schemas Schemas for this view\n * @param consts Constants for this view\n */\nfunction createTView(type, declTNode, templateFn, decls, vars, directives, pipes, viewQuery, schemas, constsOrFactory, ssrId) {\n  ngDevMode && ngDevMode.tView++;\n  const bindingStartIndex = HEADER_OFFSET + decls;\n  // This length does not yet contain host bindings from child directives because at this point,\n  // we don't know which directives are active on this template. As soon as a directive is matched\n  // that has a host binding, we will update the blueprint with that def's hostVars count.\n  const initialViewLength = bindingStartIndex + vars;\n  const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);\n  const consts = typeof constsOrFactory === 'function' ? constsOrFactory() : constsOrFactory;\n  const tView = blueprint[TVIEW] = {\n    type: type,\n    blueprint: blueprint,\n    template: templateFn,\n    queries: null,\n    viewQuery: viewQuery,\n    declTNode: declTNode,\n    data: blueprint.slice().fill(null, bindingStartIndex),\n    bindingStartIndex: bindingStartIndex,\n    expandoStartIndex: initialViewLength,\n    hostBindingOpCodes: null,\n    firstCreatePass: true,\n    firstUpdatePass: true,\n    staticViewQueries: false,\n    staticContentQueries: false,\n    preOrderHooks: null,\n    preOrderCheckHooks: null,\n    contentHooks: null,\n    contentCheckHooks: null,\n    viewHooks: null,\n    viewCheckHooks: null,\n    destroyHooks: null,\n    cleanup: null,\n    contentQueries: null,\n    components: null,\n    directiveRegistry: typeof directives === 'function' ? directives() : directives,\n    pipeRegistry: typeof pipes === 'function' ? pipes() : pipes,\n    firstChild: null,\n    schemas: schemas,\n    consts: consts,\n    incompleteFirstPass: false,\n    ssrId\n  };\n  if (ngDevMode) {\n    // For performance reasons it is important that the tView retains the same shape during runtime.\n    // (To make sure that all of the code is monomorphic.) For this reason we seal the object to\n    // prevent class transitions.\n    Object.seal(tView);\n  }\n  return tView;\n}\nfunction createViewBlueprint(bindingStartIndex, initialViewLength) {\n  const blueprint = [];\n  for (let i = 0; i < initialViewLength; i++) {\n    blueprint.push(i < bindingStartIndex ? null : NO_CHANGE);\n  }\n  return blueprint;\n}\n/**\n * Locates the host native element, used for bootstrapping existing nodes into rendering pipeline.\n *\n * @param renderer the renderer used to locate the element.\n * @param elementOrSelector Render element or CSS selector to locate the element.\n * @param encapsulation View Encapsulation defined for component that requests host element.\n * @param injector Root view injector instance.\n */\nfunction locateHostElement(renderer, elementOrSelector, encapsulation, injector) {\n  // Note: we use default value for the `PRESERVE_HOST_CONTENT` here even though it's a\n  // tree-shakable one (providedIn:'root'). This code path can be triggered during dynamic\n  // component creation (after calling ViewContainerRef.createComponent) when an injector\n  // instance can be provided. The injector instance might be disconnected from the main DI\n  // tree, thus the `PRESERVE_HOST_CONTENT` would not be able to instantiate. In this case, the\n  // default value will be used.\n  const preserveHostContent = injector.get(PRESERVE_HOST_CONTENT, PRESERVE_HOST_CONTENT_DEFAULT);\n  // When using native Shadow DOM, do not clear host element to allow native slot\n  // projection.\n  const preserveContent = preserveHostContent || encapsulation === ViewEncapsulation.ShadowDom;\n  const rootElement = renderer.selectRootElement(elementOrSelector, preserveContent);\n  applyRootElementTransform(rootElement);\n  return rootElement;\n}\n/**\n * Applies any root element transformations that are needed. If hydration is enabled,\n * this will process corrupted text nodes.\n *\n * @param rootElement the app root HTML Element\n */\nfunction applyRootElementTransform(rootElement) {\n  _applyRootElementTransformImpl(rootElement);\n}\n/**\n * Reference to a function that applies transformations to the root HTML element\n * of an app. When hydration is enabled, this processes any corrupt text nodes\n * so they are properly hydratable on the client.\n *\n * @param rootElement the app root HTML Element\n */\nlet _applyRootElementTransformImpl = rootElement => null;\n/**\n * Processes text node markers before hydration begins. This replaces any special comment\n * nodes that were added prior to serialization are swapped out to restore proper text\n * nodes before hydration.\n *\n * @param rootElement the app root HTML Element\n */\nfunction applyRootElementTransformImpl(rootElement) {\n  if (hasSkipHydrationAttrOnRElement(rootElement)) {\n    // Handle a situation when the `ngSkipHydration` attribute is applied\n    // to the root node of an application. In this case, we should clear\n    // the contents and render everything from scratch.\n    clearElementContents(rootElement);\n  } else {\n    processTextNodeMarkersBeforeHydration(rootElement);\n  }\n}\n/**\n * Sets the implementation for the `applyRootElementTransform` function.\n */\nfunction enableApplyRootElementTransformImpl() {\n  _applyRootElementTransformImpl = applyRootElementTransformImpl;\n}\n/**\n * Saves context for this cleanup function in LView.cleanupInstances.\n *\n * On the first template pass, saves in TView:\n * - Cleanup function\n * - Index of context we just saved in LView.cleanupInstances\n */\nfunction storeCleanupWithContext(tView, lView, context, cleanupFn) {\n  const lCleanup = getOrCreateLViewCleanup(lView);\n  // Historically the `storeCleanupWithContext` was used to register both framework-level and\n  // user-defined cleanup callbacks, but over time those two types of cleanups were separated.\n  // This dev mode checks assures that user-level cleanup callbacks are _not_ stored in data\n  // structures reserved for framework-specific hooks.\n  ngDevMode && assertDefined(context, 'Cleanup context is mandatory when registering framework-level destroy hooks');\n  lCleanup.push(context);\n  if (tView.firstCreatePass) {\n    getOrCreateTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);\n  } else {\n    // Make sure that no new framework-level cleanup functions are registered after the first\n    // template pass is done (and TView data structures are meant to fully constructed).\n    if (ngDevMode) {\n      Object.freeze(getOrCreateTViewCleanup(tView));\n    }\n  }\n}\nfunction createTNode(tView, tParent, type, index, value, attrs) {\n  ngDevMode && index !== 0 &&\n  // 0 are bogus nodes and they are OK. See `createContainerRef` in\n  // `view_engine_compatibility` for additional context.\n  assertGreaterThanOrEqual(index, HEADER_OFFSET, 'TNodes can\\'t be in the LView header.');\n  ngDevMode && assertNotSame(attrs, undefined, '\\'undefined\\' is not valid value for \\'attrs\\'');\n  ngDevMode && ngDevMode.tNode++;\n  ngDevMode && tParent && assertTNodeForTView(tParent, tView);\n  let injectorIndex = tParent ? tParent.injectorIndex : -1;\n  let flags = 0;\n  if (isInSkipHydrationBlock$1()) {\n    flags |= 128 /* TNodeFlags.inSkipHydrationBlock */;\n  }\n\n  const tNode = {\n    type,\n    index,\n    insertBeforeIndex: null,\n    injectorIndex,\n    directiveStart: -1,\n    directiveEnd: -1,\n    directiveStylingLast: -1,\n    componentOffset: -1,\n    propertyBindings: null,\n    flags,\n    providerIndexes: 0,\n    value: value,\n    attrs: attrs,\n    mergedAttrs: null,\n    localNames: null,\n    initialInputs: undefined,\n    inputs: null,\n    outputs: null,\n    tView: null,\n    next: null,\n    prev: null,\n    projectionNext: null,\n    child: null,\n    parent: tParent,\n    projection: null,\n    styles: null,\n    stylesWithoutHost: null,\n    residualStyles: undefined,\n    classes: null,\n    classesWithoutHost: null,\n    residualClasses: undefined,\n    classBindings: 0,\n    styleBindings: 0\n  };\n  if (ngDevMode) {\n    // For performance reasons it is important that the tNode retains the same shape during runtime.\n    // (To make sure that all of the code is monomorphic.) For this reason we seal the object to\n    // prevent class transitions.\n    Object.seal(tNode);\n  }\n  return tNode;\n}\n/**\n * Generates the `PropertyAliases` data structure from the provided input/output mapping.\n * @param aliasMap Input/output mapping from the directive definition.\n * @param directiveIndex Index of the directive.\n * @param propertyAliases Object in which to store the results.\n * @param hostDirectiveAliasMap Object used to alias or filter out properties for host directives.\n * If the mapping is provided, it'll act as an allowlist, as well as a mapping of what public\n * name inputs/outputs should be exposed under.\n */\nfunction generatePropertyAliases(aliasMap, directiveIndex, propertyAliases, hostDirectiveAliasMap) {\n  for (let publicName in aliasMap) {\n    if (aliasMap.hasOwnProperty(publicName)) {\n      propertyAliases = propertyAliases === null ? {} : propertyAliases;\n      const internalName = aliasMap[publicName];\n      // If there are no host directive mappings, we want to remap using the alias map from the\n      // definition itself. If there is an alias map, it has two functions:\n      // 1. It serves as an allowlist of bindings that are exposed by the host directives. Only the\n      // ones inside the host directive map will be exposed on the host.\n      // 2. The public name of the property is aliased using the host directive alias map, rather\n      // than the alias map from the definition.\n      if (hostDirectiveAliasMap === null) {\n        addPropertyAlias(propertyAliases, directiveIndex, publicName, internalName);\n      } else if (hostDirectiveAliasMap.hasOwnProperty(publicName)) {\n        addPropertyAlias(propertyAliases, directiveIndex, hostDirectiveAliasMap[publicName], internalName);\n      }\n    }\n  }\n  return propertyAliases;\n}\nfunction addPropertyAlias(propertyAliases, directiveIndex, publicName, internalName) {\n  if (propertyAliases.hasOwnProperty(publicName)) {\n    propertyAliases[publicName].push(directiveIndex, internalName);\n  } else {\n    propertyAliases[publicName] = [directiveIndex, internalName];\n  }\n}\n/**\n * Initializes data structures required to work with directive inputs and outputs.\n * Initialization is done for all directives matched on a given TNode.\n */\nfunction initializeInputAndOutputAliases(tView, tNode, hostDirectiveDefinitionMap) {\n  ngDevMode && assertFirstCreatePass(tView);\n  const start = tNode.directiveStart;\n  const end = tNode.directiveEnd;\n  const tViewData = tView.data;\n  const tNodeAttrs = tNode.attrs;\n  const inputsFromAttrs = [];\n  let inputsStore = null;\n  let outputsStore = null;\n  for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {\n    const directiveDef = tViewData[directiveIndex];\n    const aliasData = hostDirectiveDefinitionMap ? hostDirectiveDefinitionMap.get(directiveDef) : null;\n    const aliasedInputs = aliasData ? aliasData.inputs : null;\n    const aliasedOutputs = aliasData ? aliasData.outputs : null;\n    inputsStore = generatePropertyAliases(directiveDef.inputs, directiveIndex, inputsStore, aliasedInputs);\n    outputsStore = generatePropertyAliases(directiveDef.outputs, directiveIndex, outputsStore, aliasedOutputs);\n    // Do not use unbound attributes as inputs to structural directives, since structural\n    // directive inputs can only be set using microsyntax (e.g. `<div *dir=\"exp\">`).\n    // TODO(FW-1930): microsyntax expressions may also contain unbound/static attributes, which\n    // should be set for inline templates.\n    const initialInputs = inputsStore !== null && tNodeAttrs !== null && !isInlineTemplate(tNode) ? generateInitialInputs(inputsStore, directiveIndex, tNodeAttrs) : null;\n    inputsFromAttrs.push(initialInputs);\n  }\n  if (inputsStore !== null) {\n    if (inputsStore.hasOwnProperty('class')) {\n      tNode.flags |= 8 /* TNodeFlags.hasClassInput */;\n    }\n\n    if (inputsStore.hasOwnProperty('style')) {\n      tNode.flags |= 16 /* TNodeFlags.hasStyleInput */;\n    }\n  }\n\n  tNode.initialInputs = inputsFromAttrs;\n  tNode.inputs = inputsStore;\n  tNode.outputs = outputsStore;\n}\n/**\n * Mapping between attributes names that don't correspond to their element property names.\n *\n * Performance note: this function is written as a series of if checks (instead of, say, a property\n * object lookup) for performance reasons - the series of `if` checks seems to be the fastest way of\n * mapping property names. Do NOT change without benchmarking.\n *\n * Note: this mapping has to be kept in sync with the equally named mapping in the template\n * type-checking machinery of ngtsc.\n */\nfunction mapPropName(name) {\n  if (name === 'class') return 'className';\n  if (name === 'for') return 'htmlFor';\n  if (name === 'formaction') return 'formAction';\n  if (name === 'innerHtml') return 'innerHTML';\n  if (name === 'readonly') return 'readOnly';\n  if (name === 'tabindex') return 'tabIndex';\n  return name;\n}\nfunction elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, nativeOnly) {\n  ngDevMode && assertNotSame(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');\n  const element = getNativeByTNode(tNode, lView);\n  let inputData = tNode.inputs;\n  let dataValue;\n  if (!nativeOnly && inputData != null && (dataValue = inputData[propName])) {\n    setInputsForProperty(tView, lView, dataValue, propName, value);\n    if (isComponentHost(tNode)) markDirtyIfOnPush(lView, tNode.index);\n    if (ngDevMode) {\n      setNgReflectProperties(lView, element, tNode.type, dataValue, value);\n    }\n  } else if (tNode.type & 3 /* TNodeType.AnyRNode */) {\n    propName = mapPropName(propName);\n    if (ngDevMode) {\n      validateAgainstEventProperties(propName);\n      if (!isPropertyValid(element, propName, tNode.value, tView.schemas)) {\n        handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);\n      }\n      ngDevMode.rendererSetProperty++;\n    }\n    // It is assumed that the sanitizer is only added when the compiler determines that the\n    // property is risky, so sanitization can be done without further checks.\n    value = sanitizer != null ? sanitizer(value, tNode.value || '', propName) : value;\n    renderer.setProperty(element, propName, value);\n  } else if (tNode.type & 12 /* TNodeType.AnyContainer */) {\n    // If the node is a container and the property didn't\n    // match any of the inputs or schemas we should throw.\n    if (ngDevMode && !matchingSchemas(tView.schemas, tNode.value)) {\n      handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);\n    }\n  }\n}\n/** If node is an OnPush component, marks its LView dirty. */\nfunction markDirtyIfOnPush(lView, viewIndex) {\n  ngDevMode && assertLView(lView);\n  const childComponentLView = getComponentLViewByIndex(viewIndex, lView);\n  if (!(childComponentLView[FLAGS] & 16 /* LViewFlags.CheckAlways */)) {\n    childComponentLView[FLAGS] |= 64 /* LViewFlags.Dirty */;\n  }\n}\n\nfunction setNgReflectProperty(lView, element, type, attrName, value) {\n  const renderer = lView[RENDERER];\n  attrName = normalizeDebugBindingName(attrName);\n  const debugValue = normalizeDebugBindingValue(value);\n  if (type & 3 /* TNodeType.AnyRNode */) {\n    if (value == null) {\n      renderer.removeAttribute(element, attrName);\n    } else {\n      renderer.setAttribute(element, attrName, debugValue);\n    }\n  } else {\n    const textContent = escapeCommentText(`bindings=${JSON.stringify({\n      [attrName]: debugValue\n    }, null, 2)}`);\n    renderer.setValue(element, textContent);\n  }\n}\nfunction setNgReflectProperties(lView, element, type, dataValue, value) {\n  if (type & (3 /* TNodeType.AnyRNode */ | 4 /* TNodeType.Container */)) {\n    /**\n     * dataValue is an array containing runtime input or output names for the directives:\n     * i+0: directive instance index\n     * i+1: privateName\n     *\n     * e.g. [0, 'change', 'change-minified']\n     * we want to set the reflected property with the privateName: dataValue[i+1]\n     */\n    for (let i = 0; i < dataValue.length; i += 2) {\n      setNgReflectProperty(lView, element, type, dataValue[i + 1], value);\n    }\n  }\n}\n/**\n * Resolve the matched directives on a node.\n */\nfunction resolveDirectives(tView, lView, tNode, localRefs) {\n  // Please make sure to have explicit type for `exportsMap`. Inferred type triggers bug in\n  // tsickle.\n  ngDevMode && assertFirstCreatePass(tView);\n  if (getBindingsEnabled()) {\n    const exportsMap = localRefs === null ? null : {\n      '': -1\n    };\n    const matchResult = findDirectiveDefMatches(tView, tNode);\n    let directiveDefs;\n    let hostDirectiveDefs;\n    if (matchResult === null) {\n      directiveDefs = hostDirectiveDefs = null;\n    } else {\n      [directiveDefs, hostDirectiveDefs] = matchResult;\n    }\n    if (directiveDefs !== null) {\n      initializeDirectives(tView, lView, tNode, directiveDefs, exportsMap, hostDirectiveDefs);\n    }\n    if (exportsMap) cacheMatchingLocalNames(tNode, localRefs, exportsMap);\n  }\n  // Merge the template attrs last so that they have the highest priority.\n  tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);\n}\n/** Initializes the data structures necessary for a list of directives to be instantiated. */\nfunction initializeDirectives(tView, lView, tNode, directives, exportsMap, hostDirectiveDefs) {\n  ngDevMode && assertFirstCreatePass(tView);\n  // Publishes the directive types to DI so they can be injected. Needs to\n  // happen in a separate pass before the TNode flags have been initialized.\n  for (let i = 0; i < directives.length; i++) {\n    diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, directives[i].type);\n  }\n  initTNodeFlags(tNode, tView.data.length, directives.length);\n  // When the same token is provided by several directives on the same node, some rules apply in\n  // the viewEngine:\n  // - viewProviders have priority over providers\n  // - the last directive in NgModule.declarations has priority over the previous one\n  // So to match these rules, the order in which providers are added in the arrays is very\n  // important.\n  for (let i = 0; i < directives.length; i++) {\n    const def = directives[i];\n    if (def.providersResolver) def.providersResolver(def);\n  }\n  let preOrderHooksFound = false;\n  let preOrderCheckHooksFound = false;\n  let directiveIdx = allocExpando(tView, lView, directives.length, null);\n  ngDevMode && assertSame(directiveIdx, tNode.directiveStart, 'TNode.directiveStart should point to just allocated space');\n  for (let i = 0; i < directives.length; i++) {\n    const def = directives[i];\n    // Merge the attrs in the order of matches. This assumes that the first directive is the\n    // component itself, so that the component has the least priority.\n    tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);\n    configureViewWithDirective(tView, tNode, lView, directiveIdx, def);\n    saveNameToExportMap(directiveIdx, def, exportsMap);\n    if (def.contentQueries !== null) tNode.flags |= 4 /* TNodeFlags.hasContentQuery */;\n    if (def.hostBindings !== null || def.hostAttrs !== null || def.hostVars !== 0) tNode.flags |= 64 /* TNodeFlags.hasHostBindings */;\n    const lifeCycleHooks = def.type.prototype;\n    // Only push a node index into the preOrderHooks array if this is the first\n    // pre-order hook found on this node.\n    if (!preOrderHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngOnInit || lifeCycleHooks.ngDoCheck)) {\n      // We will push the actual hook function into this array later during dir instantiation.\n      // We cannot do it now because we must ensure hooks are registered in the same\n      // order that directives are created (i.e. injection order).\n      (tView.preOrderHooks ??= []).push(tNode.index);\n      preOrderHooksFound = true;\n    }\n    if (!preOrderCheckHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngDoCheck)) {\n      (tView.preOrderCheckHooks ??= []).push(tNode.index);\n      preOrderCheckHooksFound = true;\n    }\n    directiveIdx++;\n  }\n  initializeInputAndOutputAliases(tView, tNode, hostDirectiveDefs);\n}\n/**\n * Add `hostBindings` to the `TView.hostBindingOpCodes`.\n *\n * @param tView `TView` to which the `hostBindings` should be added.\n * @param tNode `TNode` the element which contains the directive\n * @param directiveIdx Directive index in view.\n * @param directiveVarsIdx Where will the directive's vars be stored\n * @param def `ComponentDef`/`DirectiveDef`, which contains the `hostVars`/`hostBindings` to add.\n */\nfunction registerHostBindingOpCodes(tView, tNode, directiveIdx, directiveVarsIdx, def) {\n  ngDevMode && assertFirstCreatePass(tView);\n  const hostBindings = def.hostBindings;\n  if (hostBindings) {\n    let hostBindingOpCodes = tView.hostBindingOpCodes;\n    if (hostBindingOpCodes === null) {\n      hostBindingOpCodes = tView.hostBindingOpCodes = [];\n    }\n    const elementIndx = ~tNode.index;\n    if (lastSelectedElementIdx(hostBindingOpCodes) != elementIndx) {\n      // Conditionally add select element so that we are more efficient in execution.\n      // NOTE: this is strictly not necessary and it trades code size for runtime perf.\n      // (We could just always add it.)\n      hostBindingOpCodes.push(elementIndx);\n    }\n    hostBindingOpCodes.push(directiveIdx, directiveVarsIdx, hostBindings);\n  }\n}\n/**\n * Returns the last selected element index in the `HostBindingOpCodes`\n *\n * For perf reasons we don't need to update the selected element index in `HostBindingOpCodes` only\n * if it changes. This method returns the last index (or '0' if not found.)\n *\n * Selected element index are only the ones which are negative.\n */\nfunction lastSelectedElementIdx(hostBindingOpCodes) {\n  let i = hostBindingOpCodes.length;\n  while (i > 0) {\n    const value = hostBindingOpCodes[--i];\n    if (typeof value === 'number' && value < 0) {\n      return value;\n    }\n  }\n  return 0;\n}\n/**\n * Instantiate all the directives that were previously resolved on the current node.\n */\nfunction instantiateAllDirectives(tView, lView, tNode, native) {\n  const start = tNode.directiveStart;\n  const end = tNode.directiveEnd;\n  // The component view needs to be created before creating the node injector\n  // since it is used to inject some special symbols like `ChangeDetectorRef`.\n  if (isComponentHost(tNode)) {\n    ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */);\n    addComponentLogic(lView, tNode, tView.data[start + tNode.componentOffset]);\n  }\n  if (!tView.firstCreatePass) {\n    getOrCreateNodeInjectorForNode(tNode, lView);\n  }\n  attachPatchData(native, lView);\n  const initialInputs = tNode.initialInputs;\n  for (let i = start; i < end; i++) {\n    const def = tView.data[i];\n    const directive = getNodeInjectable(lView, tView, i, tNode);\n    attachPatchData(directive, lView);\n    if (initialInputs !== null) {\n      setInputsFromAttrs(lView, i - start, directive, def, tNode, initialInputs);\n    }\n    if (isComponentDef(def)) {\n      const componentView = getComponentLViewByIndex(tNode.index, lView);\n      componentView[CONTEXT] = getNodeInjectable(lView, tView, i, tNode);\n    }\n  }\n}\nfunction invokeDirectivesHostBindings(tView, lView, tNode) {\n  const start = tNode.directiveStart;\n  const end = tNode.directiveEnd;\n  const elementIndex = tNode.index;\n  const currentDirectiveIndex = getCurrentDirectiveIndex();\n  try {\n    setSelectedIndex(elementIndex);\n    for (let dirIndex = start; dirIndex < end; dirIndex++) {\n      const def = tView.data[dirIndex];\n      const directive = lView[dirIndex];\n      setCurrentDirectiveIndex(dirIndex);\n      if (def.hostBindings !== null || def.hostVars !== 0 || def.hostAttrs !== null) {\n        invokeHostBindingsInCreationMode(def, directive);\n      }\n    }\n  } finally {\n    setSelectedIndex(-1);\n    setCurrentDirectiveIndex(currentDirectiveIndex);\n  }\n}\n/**\n * Invoke the host bindings in creation mode.\n *\n * @param def `DirectiveDef` which may contain the `hostBindings` function.\n * @param directive Instance of directive.\n */\nfunction invokeHostBindingsInCreationMode(def, directive) {\n  if (def.hostBindings !== null) {\n    def.hostBindings(1 /* RenderFlags.Create */, directive);\n  }\n}\n/**\n * Matches the current node against all available selectors.\n * If a component is matched (at most one), it is returned in first position in the array.\n */\nfunction findDirectiveDefMatches(tView, tNode) {\n  ngDevMode && assertFirstCreatePass(tView);\n  ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 12 /* TNodeType.AnyContainer */);\n  const registry = tView.directiveRegistry;\n  let matches = null;\n  let hostDirectiveDefs = null;\n  if (registry) {\n    for (let i = 0; i < registry.length; i++) {\n      const def = registry[i];\n      if (isNodeMatchingSelectorList(tNode, def.selectors, /* isProjectionMode */false)) {\n        matches || (matches = []);\n        if (isComponentDef(def)) {\n          if (ngDevMode) {\n            assertTNodeType(tNode, 2 /* TNodeType.Element */, `\"${tNode.value}\" tags cannot be used as component hosts. ` + `Please use a different tag to activate the ${stringify(def.type)} component.`);\n            if (isComponentHost(tNode)) {\n              throwMultipleComponentError(tNode, matches.find(isComponentDef).type, def.type);\n            }\n          }\n          // Components are inserted at the front of the matches array so that their lifecycle\n          // hooks run before any directive lifecycle hooks. This appears to be for ViewEngine\n          // compatibility. This logic doesn't make sense with host directives, because it\n          // would allow the host directives to undo any overrides the host may have made.\n          // To handle this case, the host directives of components are inserted at the beginning\n          // of the array, followed by the component. As such, the insertion order is as follows:\n          // 1. Host directives belonging to the selector-matched component.\n          // 2. Selector-matched component.\n          // 3. Host directives belonging to selector-matched directives.\n          // 4. Selector-matched directives.\n          if (def.findHostDirectiveDefs !== null) {\n            const hostDirectiveMatches = [];\n            hostDirectiveDefs = hostDirectiveDefs || new Map();\n            def.findHostDirectiveDefs(def, hostDirectiveMatches, hostDirectiveDefs);\n            // Add all host directives declared on this component, followed by the component itself.\n            // Host directives should execute first so the host has a chance to override changes\n            // to the DOM made by them.\n            matches.unshift(...hostDirectiveMatches, def);\n            // Component is offset starting from the beginning of the host directives array.\n            const componentOffset = hostDirectiveMatches.length;\n            markAsComponentHost(tView, tNode, componentOffset);\n          } else {\n            // No host directives on this component, just add the\n            // component def to the beginning of the matches.\n            matches.unshift(def);\n            markAsComponentHost(tView, tNode, 0);\n          }\n        } else {\n          // Append any host directives to the matches first.\n          hostDirectiveDefs = hostDirectiveDefs || new Map();\n          def.findHostDirectiveDefs?.(def, matches, hostDirectiveDefs);\n          matches.push(def);\n        }\n      }\n    }\n  }\n  return matches === null ? null : [matches, hostDirectiveDefs];\n}\n/**\n * Marks a given TNode as a component's host. This consists of:\n * - setting the component offset on the TNode.\n * - storing index of component's host element so it will be queued for view refresh during CD.\n */\nfunction markAsComponentHost(tView, hostTNode, componentOffset) {\n  ngDevMode && assertFirstCreatePass(tView);\n  ngDevMode && assertGreaterThan(componentOffset, -1, 'componentOffset must be great than -1');\n  hostTNode.componentOffset = componentOffset;\n  (tView.components ??= []).push(hostTNode.index);\n}\n/** Caches local names and their matching directive indices for query and template lookups. */\nfunction cacheMatchingLocalNames(tNode, localRefs, exportsMap) {\n  if (localRefs) {\n    const localNames = tNode.localNames = [];\n    // Local names must be stored in tNode in the same order that localRefs are defined\n    // in the template to ensure the data is loaded in the same slots as their refs\n    // in the template (for template queries).\n    for (let i = 0; i < localRefs.length; i += 2) {\n      const index = exportsMap[localRefs[i + 1]];\n      if (index == null) throw new RuntimeError(-301 /* RuntimeErrorCode.EXPORT_NOT_FOUND */, ngDevMode && `Export of name '${localRefs[i + 1]}' not found!`);\n      localNames.push(localRefs[i], index);\n    }\n  }\n}\n/**\n * Builds up an export map as directives are created, so local refs can be quickly mapped\n * to their directive instances.\n */\nfunction saveNameToExportMap(directiveIdx, def, exportsMap) {\n  if (exportsMap) {\n    if (def.exportAs) {\n      for (let i = 0; i < def.exportAs.length; i++) {\n        exportsMap[def.exportAs[i]] = directiveIdx;\n      }\n    }\n    if (isComponentDef(def)) exportsMap[''] = directiveIdx;\n  }\n}\n/**\n * Initializes the flags on the current node, setting all indices to the initial index,\n * the directive count to 0, and adding the isComponent flag.\n * @param index the initial index\n */\nfunction initTNodeFlags(tNode, index, numberOfDirectives) {\n  ngDevMode && assertNotEqual(numberOfDirectives, tNode.directiveEnd - tNode.directiveStart, 'Reached the max number of directives');\n  tNode.flags |= 1 /* TNodeFlags.isDirectiveHost */;\n  // When the first directive is created on a node, save the index\n  tNode.directiveStart = index;\n  tNode.directiveEnd = index + numberOfDirectives;\n  tNode.providerIndexes = index;\n}\n/**\n * Setup directive for instantiation.\n *\n * We need to create a `NodeInjectorFactory` which is then inserted in both the `Blueprint` as well\n * as `LView`. `TView` gets the `DirectiveDef`.\n *\n * @param tView `TView`\n * @param tNode `TNode`\n * @param lView `LView`\n * @param directiveIndex Index where the directive will be stored in the Expando.\n * @param def `DirectiveDef`\n */\nfunction configureViewWithDirective(tView, tNode, lView, directiveIndex, def) {\n  ngDevMode && assertGreaterThanOrEqual(directiveIndex, HEADER_OFFSET, 'Must be in Expando section');\n  tView.data[directiveIndex] = def;\n  const directiveFactory = def.factory || (def.factory = getFactoryDef(def.type, true));\n  // Even though `directiveFactory` will already be using `ɵɵdirectiveInject` in its generated code,\n  // we also want to support `inject()` directly from the directive constructor context so we set\n  // `ɵɵdirectiveInject` as the inject implementation here too.\n  const nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), ɵɵdirectiveInject);\n  tView.blueprint[directiveIndex] = nodeInjectorFactory;\n  lView[directiveIndex] = nodeInjectorFactory;\n  registerHostBindingOpCodes(tView, tNode, directiveIndex, allocExpando(tView, lView, def.hostVars, NO_CHANGE), def);\n}\nfunction addComponentLogic(lView, hostTNode, def) {\n  const native = getNativeByTNode(hostTNode, lView);\n  const tView = getOrCreateComponentTView(def);\n  // Only component views should be added to the view tree directly. Embedded views are\n  // accessed through their containers because they may be removed / re-added later.\n  const rendererFactory = lView[ENVIRONMENT].rendererFactory;\n  let lViewFlags = 16 /* LViewFlags.CheckAlways */;\n  if (def.signals) {\n    lViewFlags = 4096 /* LViewFlags.SignalView */;\n  } else if (def.onPush) {\n    lViewFlags = 64 /* LViewFlags.Dirty */;\n  }\n\n  const componentView = addToViewTree(lView, createLView(lView, tView, null, lViewFlags, native, hostTNode, null, rendererFactory.createRenderer(native, def), null, null, null));\n  // Component view will always be created before any injected LContainers,\n  // so this is a regular element, wrap it with the component view\n  lView[hostTNode.index] = componentView;\n}\nfunction elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace) {\n  if (ngDevMode) {\n    assertNotSame(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');\n    validateAgainstEventAttributes(name);\n    assertTNodeType(tNode, 2 /* TNodeType.Element */, `Attempted to set attribute \\`${name}\\` on a container node. ` + `Host bindings are not valid on ng-container or ng-template.`);\n  }\n  const element = getNativeByTNode(tNode, lView);\n  setElementAttribute(lView[RENDERER], element, namespace, tNode.value, name, value, sanitizer);\n}\nfunction setElementAttribute(renderer, element, namespace, tagName, name, value, sanitizer) {\n  if (value == null) {\n    ngDevMode && ngDevMode.rendererRemoveAttribute++;\n    renderer.removeAttribute(element, name, namespace);\n  } else {\n    ngDevMode && ngDevMode.rendererSetAttribute++;\n    const strValue = sanitizer == null ? renderStringify(value) : sanitizer(value, tagName || '', name);\n    renderer.setAttribute(element, name, strValue, namespace);\n  }\n}\n/**\n * Sets initial input properties on directive instances from attribute data\n *\n * @param lView Current LView that is being processed.\n * @param directiveIndex Index of the directive in directives array\n * @param instance Instance of the directive on which to set the initial inputs\n * @param def The directive def that contains the list of inputs\n * @param tNode The static data for this node\n */\nfunction setInputsFromAttrs(lView, directiveIndex, instance, def, tNode, initialInputData) {\n  const initialInputs = initialInputData[directiveIndex];\n  if (initialInputs !== null) {\n    for (let i = 0; i < initialInputs.length;) {\n      const publicName = initialInputs[i++];\n      const privateName = initialInputs[i++];\n      const value = initialInputs[i++];\n      writeToDirectiveInput(def, instance, publicName, privateName, value);\n      if (ngDevMode) {\n        const nativeElement = getNativeByTNode(tNode, lView);\n        setNgReflectProperty(lView, nativeElement, tNode.type, privateName, value);\n      }\n    }\n  }\n}\nfunction writeToDirectiveInput(def, instance, publicName, privateName, value) {\n  const prevConsumer = setActiveConsumer(null);\n  try {\n    const inputTransforms = def.inputTransforms;\n    if (inputTransforms !== null && inputTransforms.hasOwnProperty(privateName)) {\n      value = inputTransforms[privateName].call(instance, value);\n    }\n    if (def.setInput !== null) {\n      def.setInput(instance, value, publicName, privateName);\n    } else {\n      instance[privateName] = value;\n    }\n  } finally {\n    setActiveConsumer(prevConsumer);\n  }\n}\n/**\n * Generates initialInputData for a node and stores it in the template's static storage\n * so subsequent template invocations don't have to recalculate it.\n *\n * initialInputData is an array containing values that need to be set as input properties\n * for directives on this node, but only once on creation. We need this array to support\n * the case where you set an @Input property of a directive using attribute-like syntax.\n * e.g. if you have a `name` @Input, you can set it once like this:\n *\n * <my-component name=\"Bess\"></my-component>\n *\n * @param inputs Input alias map that was generated from the directive def inputs.\n * @param directiveIndex Index of the directive that is currently being processed.\n * @param attrs Static attrs on this node.\n */\nfunction generateInitialInputs(inputs, directiveIndex, attrs) {\n  let inputsToStore = null;\n  let i = 0;\n  while (i < attrs.length) {\n    const attrName = attrs[i];\n    if (attrName === 0 /* AttributeMarker.NamespaceURI */) {\n      // We do not allow inputs on namespaced attributes.\n      i += 4;\n      continue;\n    } else if (attrName === 5 /* AttributeMarker.ProjectAs */) {\n      // Skip over the `ngProjectAs` value.\n      i += 2;\n      continue;\n    }\n    // If we hit any other attribute markers, we're done anyway. None of those are valid inputs.\n    if (typeof attrName === 'number') break;\n    if (inputs.hasOwnProperty(attrName)) {\n      if (inputsToStore === null) inputsToStore = [];\n      // Find the input's public name from the input store. Note that we can be found easier\n      // through the directive def, but we want to do it using the inputs store so that it can\n      // account for host directive aliases.\n      const inputConfig = inputs[attrName];\n      for (let j = 0; j < inputConfig.length; j += 2) {\n        if (inputConfig[j] === directiveIndex) {\n          inputsToStore.push(attrName, inputConfig[j + 1], attrs[i + 1]);\n          // A directive can't have multiple inputs with the same name so we can break here.\n          break;\n        }\n      }\n    }\n    i += 2;\n  }\n  return inputsToStore;\n}\n//////////////////////////\n//// ViewContainer & View\n//////////////////////////\n/**\n * Creates a LContainer, either from a container instruction, or for a ViewContainerRef.\n *\n * @param hostNative The host element for the LContainer\n * @param hostTNode The host TNode for the LContainer\n * @param currentView The parent view of the LContainer\n * @param native The native comment element\n * @param isForViewContainerRef Optional a flag indicating the ViewContainerRef case\n * @returns LContainer\n */\nfunction createLContainer(hostNative, currentView, native, tNode) {\n  ngDevMode && assertLView(currentView);\n  const lContainer = [hostNative, true, false, currentView, null, 0, tNode, native, null, null, null // dehydrated views\n  ];\n\n  ngDevMode && assertEqual(lContainer.length, CONTAINER_HEADER_OFFSET, 'Should allocate correct number of slots for LContainer header.');\n  return lContainer;\n}\n/** Refreshes all content queries declared by directives in a given view */\nfunction refreshContentQueries(tView, lView) {\n  const contentQueries = tView.contentQueries;\n  if (contentQueries !== null) {\n    for (let i = 0; i < contentQueries.length; i += 2) {\n      const queryStartIdx = contentQueries[i];\n      const directiveDefIdx = contentQueries[i + 1];\n      if (directiveDefIdx !== -1) {\n        const directiveDef = tView.data[directiveDefIdx];\n        ngDevMode && assertDefined(directiveDef, 'DirectiveDef not found.');\n        ngDevMode && assertDefined(directiveDef.contentQueries, 'contentQueries function should be defined');\n        setCurrentQueryIndex(queryStartIdx);\n        directiveDef.contentQueries(2 /* RenderFlags.Update */, lView[directiveDefIdx], directiveDefIdx);\n      }\n    }\n  }\n}\n/**\n * Adds LView or LContainer to the end of the current view tree.\n *\n * This structure will be used to traverse through nested views to remove listeners\n * and call onDestroy callbacks.\n *\n * @param lView The view where LView or LContainer should be added\n * @param adjustedHostIndex Index of the view's host node in LView[], adjusted for header\n * @param lViewOrLContainer The LView or LContainer to add to the view tree\n * @returns The state passed in\n */\nfunction addToViewTree(lView, lViewOrLContainer) {\n  // TODO(benlesh/misko): This implementation is incorrect, because it always adds the LContainer\n  // to the end of the queue, which means if the developer retrieves the LContainers from RNodes out\n  // of order, the change detection will run out of order, as the act of retrieving the the\n  // LContainer from the RNode is what adds it to the queue.\n  if (lView[CHILD_HEAD]) {\n    lView[CHILD_TAIL][NEXT] = lViewOrLContainer;\n  } else {\n    lView[CHILD_HEAD] = lViewOrLContainer;\n  }\n  lView[CHILD_TAIL] = lViewOrLContainer;\n  return lViewOrLContainer;\n}\n///////////////////////////////\n//// Change detection\n///////////////////////////////\nfunction executeViewQueryFn(flags, viewQueryFn, component) {\n  ngDevMode && assertDefined(viewQueryFn, 'View queries function to execute must be defined.');\n  setCurrentQueryIndex(0);\n  const prevConsumer = setActiveConsumer(null);\n  try {\n    viewQueryFn(flags, component);\n  } finally {\n    setActiveConsumer(prevConsumer);\n  }\n}\n///////////////////////////////\n//// Bindings & interpolations\n///////////////////////////////\n/**\n * Stores meta-data for a property binding to be used by TestBed's `DebugElement.properties`.\n *\n * In order to support TestBed's `DebugElement.properties` we need to save, for each binding:\n * - a bound property name;\n * - a static parts of interpolated strings;\n *\n * A given property metadata is saved at the binding's index in the `TView.data` (in other words, a\n * property binding metadata will be stored in `TView.data` at the same index as a bound value in\n * `LView`). Metadata are represented as `INTERPOLATION_DELIMITER`-delimited string with the\n * following format:\n * - `propertyName` for bound properties;\n * - `propertyName�prefix�interpolation_static_part1�..interpolation_static_partN�suffix` for\n * interpolated properties.\n *\n * @param tData `TData` where meta-data will be saved;\n * @param tNode `TNode` that is a target of the binding;\n * @param propertyName bound property name;\n * @param bindingIndex binding index in `LView`\n * @param interpolationParts static interpolation parts (for property interpolations)\n */\nfunction storePropertyBindingMetadata(tData, tNode, propertyName, bindingIndex, ...interpolationParts) {\n  // Binding meta-data are stored only the first time a given property instruction is processed.\n  // Since we don't have a concept of the \"first update pass\" we need to check for presence of the\n  // binding meta-data to decide if one should be stored (or if was stored already).\n  if (tData[bindingIndex] === null) {\n    if (tNode.inputs == null || !tNode.inputs[propertyName]) {\n      const propBindingIdxs = tNode.propertyBindings || (tNode.propertyBindings = []);\n      propBindingIdxs.push(bindingIndex);\n      let bindingMetadata = propertyName;\n      if (interpolationParts.length > 0) {\n        bindingMetadata += INTERPOLATION_DELIMITER + interpolationParts.join(INTERPOLATION_DELIMITER);\n      }\n      tData[bindingIndex] = bindingMetadata;\n    }\n  }\n}\nfunction getOrCreateLViewCleanup(view) {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return view[CLEANUP] || (view[CLEANUP] = []);\n}\nfunction getOrCreateTViewCleanup(tView) {\n  return tView.cleanup || (tView.cleanup = []);\n}\n/**\n * There are cases where the sub component's renderer needs to be included\n * instead of the current renderer (see the componentSyntheticHost* instructions).\n */\nfunction loadComponentRenderer(currentDef, tNode, lView) {\n  // TODO(FW-2043): the `currentDef` is null when host bindings are invoked while creating root\n  // component (see packages/core/src/render3/component.ts). This is not consistent with the process\n  // of creating inner components, when current directive index is available in the state. In order\n  // to avoid relying on current def being `null` (thus special-casing root component creation), the\n  // process of creating root component should be unified with the process of creating inner\n  // components.\n  if (currentDef === null || isComponentDef(currentDef)) {\n    lView = unwrapLView(lView[tNode.index]);\n  }\n  return lView[RENDERER];\n}\n/** Handles an error thrown in an LView. */\nfunction handleError(lView, error) {\n  const injector = lView[INJECTOR$1];\n  const errorHandler = injector ? injector.get(ErrorHandler, null) : null;\n  errorHandler && errorHandler.handleError(error);\n}\n/**\n * Set the inputs of directives at the current node to corresponding value.\n *\n * @param tView The current TView\n * @param lView the `LView` which contains the directives.\n * @param inputs mapping between the public \"input\" name and privately-known,\n *        possibly minified, property names to write to.\n * @param value Value to set.\n */\nfunction setInputsForProperty(tView, lView, inputs, publicName, value) {\n  for (let i = 0; i < inputs.length;) {\n    const index = inputs[i++];\n    const privateName = inputs[i++];\n    const instance = lView[index];\n    ngDevMode && assertIndexInRange(lView, index);\n    const def = tView.data[index];\n    writeToDirectiveInput(def, instance, publicName, privateName, value);\n  }\n}\n/**\n * Updates a text binding at a given index in a given LView.\n */\nfunction textBindingInternal(lView, index, value) {\n  ngDevMode && assertString(value, 'Value should be a string');\n  ngDevMode && assertNotSame(value, NO_CHANGE, 'value should not be NO_CHANGE');\n  ngDevMode && assertIndexInRange(lView, index);\n  const element = getNativeByIndex(index, lView);\n  ngDevMode && assertDefined(element, 'native element should exist');\n  updateTextNode(lView[RENDERER], element, value);\n}\nfunction renderComponent(hostLView, componentHostIdx) {\n  ngDevMode && assertEqual(isCreationMode(hostLView), true, 'Should be run in creation mode');\n  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);\n  const componentTView = componentView[TVIEW];\n  syncViewWithBlueprint(componentTView, componentView);\n  const hostRNode = componentView[HOST];\n  // Populate an LView with hydration info retrieved from the DOM via TransferState.\n  if (hostRNode !== null && componentView[HYDRATION] === null) {\n    componentView[HYDRATION] = retrieveHydrationInfo(hostRNode, componentView[INJECTOR$1]);\n  }\n  renderView(componentTView, componentView, componentView[CONTEXT]);\n}\n/**\n * Syncs an LView instance with its blueprint if they have gotten out of sync.\n *\n * Typically, blueprints and their view instances should always be in sync, so the loop here\n * will be skipped. However, consider this case of two components side-by-side:\n *\n * App template:\n * ```\n * <comp></comp>\n * <comp></comp>\n * ```\n *\n * The following will happen:\n * 1. App template begins processing.\n * 2. First <comp> is matched as a component and its LView is created.\n * 3. Second <comp> is matched as a component and its LView is created.\n * 4. App template completes processing, so it's time to check child templates.\n * 5. First <comp> template is checked. It has a directive, so its def is pushed to blueprint.\n * 6. Second <comp> template is checked. Its blueprint has been updated by the first\n * <comp> template, but its LView was created before this update, so it is out of sync.\n *\n * Note that embedded views inside ngFor loops will never be out of sync because these views\n * are processed as soon as they are created.\n *\n * @param tView The `TView` that contains the blueprint for syncing\n * @param lView The view to sync\n */\nfunction syncViewWithBlueprint(tView, lView) {\n  for (let i = lView.length; i < tView.blueprint.length; i++) {\n    lView.push(tView.blueprint[i]);\n  }\n}\n/**\n * Processes a view in the creation mode. This includes a number of steps in a specific order:\n * - creating view query functions (if any);\n * - executing a template function in the creation mode;\n * - updating static queries (if any);\n * - creating child components defined in a given view.\n */\nfunction renderView(tView, lView, context) {\n  ngDevMode && assertEqual(isCreationMode(lView), true, 'Should be run in creation mode');\n  enterView(lView);\n  try {\n    const viewQuery = tView.viewQuery;\n    if (viewQuery !== null) {\n      executeViewQueryFn(1 /* RenderFlags.Create */, viewQuery, context);\n    }\n    // Execute a template associated with this view, if it exists. A template function might not be\n    // defined for the root component views.\n    const templateFn = tView.template;\n    if (templateFn !== null) {\n      executeTemplate(tView, lView, templateFn, 1 /* RenderFlags.Create */, context);\n    }\n    // This needs to be set before children are processed to support recursive components.\n    // This must be set to false immediately after the first creation run because in an\n    // ngFor loop, all the views will be created together before update mode runs and turns\n    // off firstCreatePass. If we don't set it here, instances will perform directive\n    // matching, etc again and again.\n    if (tView.firstCreatePass) {\n      tView.firstCreatePass = false;\n    }\n    // We resolve content queries specifically marked as `static` in creation mode. Dynamic\n    // content queries are resolved during change detection (i.e. update mode), after embedded\n    // views are refreshed (see block above).\n    if (tView.staticContentQueries) {\n      refreshContentQueries(tView, lView);\n    }\n    // We must materialize query results before child components are processed\n    // in case a child component has projected a container. The LContainer needs\n    // to exist so the embedded views are properly attached by the container.\n    if (tView.staticViewQueries) {\n      executeViewQueryFn(2 /* RenderFlags.Update */, tView.viewQuery, context);\n    }\n    // Render child component views.\n    const components = tView.components;\n    if (components !== null) {\n      renderChildComponents(lView, components);\n    }\n  } catch (error) {\n    // If we didn't manage to get past the first template pass due to\n    // an error, mark the view as corrupted so we can try to recover.\n    if (tView.firstCreatePass) {\n      tView.incompleteFirstPass = true;\n      tView.firstCreatePass = false;\n    }\n    throw error;\n  } finally {\n    lView[FLAGS] &= ~4 /* LViewFlags.CreationMode */;\n    leaveView();\n  }\n}\n/** Renders child components in the current view (creation mode). */\nfunction renderChildComponents(hostLView, components) {\n  for (let i = 0; i < components.length; i++) {\n    renderComponent(hostLView, components[i]);\n  }\n}\n\n/**\n * Tracks all effects registered within a given application and runs them via `flush`.\n */\nclass EffectManager {\n  constructor() {\n    this.all = new Set();\n    this.queue = new Map();\n  }\n  create(effectFn, destroyRef, allowSignalWrites) {\n    const zone = typeof Zone === 'undefined' ? null : Zone.current;\n    const w = watch(effectFn, watch => {\n      if (!this.all.has(watch)) {\n        return;\n      }\n      this.queue.set(watch, zone);\n    }, allowSignalWrites);\n    this.all.add(w);\n    // Effects start dirty.\n    w.notify();\n    let unregisterOnDestroy;\n    const destroy = () => {\n      w.cleanup();\n      unregisterOnDestroy?.();\n      this.all.delete(w);\n      this.queue.delete(w);\n    };\n    unregisterOnDestroy = destroyRef?.onDestroy(destroy);\n    return {\n      destroy\n    };\n  }\n  flush() {\n    if (this.queue.size === 0) {\n      return;\n    }\n    for (const [watch, zone] of this.queue) {\n      this.queue.delete(watch);\n      if (zone) {\n        zone.run(() => watch.run());\n      } else {\n        watch.run();\n      }\n    }\n  }\n  get isQueueEmpty() {\n    return this.queue.size === 0;\n  }\n  /** @nocollapse */\n  static #_ = this.ɵprov = ɵɵdefineInjectable({\n    token: EffectManager,\n    providedIn: 'root',\n    factory: () => new EffectManager()\n  });\n}\n/**\n * Create a global `Effect` for the given reactive function.\n *\n * @developerPreview\n */\nfunction effect(effectFn, options) {\n  !options?.injector && assertInInjectionContext(effect);\n  const injector = options?.injector ?? inject$1(Injector);\n  const effectManager = injector.get(EffectManager);\n  const destroyRef = options?.manualCleanup !== true ? injector.get(DestroyRef) : null;\n  return effectManager.create(effectFn, destroyRef, !!options?.allowSignalWrites);\n}\n\n/**\n * Compute the static styling (class/style) from `TAttributes`.\n *\n * This function should be called during `firstCreatePass` only.\n *\n * @param tNode The `TNode` into which the styling information should be loaded.\n * @param attrs `TAttributes` containing the styling information.\n * @param writeToHost Where should the resulting static styles be written?\n *   - `false` Write to `TNode.stylesWithoutHost` / `TNode.classesWithoutHost`\n *   - `true` Write to `TNode.styles` / `TNode.classes`\n */\nfunction computeStaticStyling(tNode, attrs, writeToHost) {\n  ngDevMode && assertFirstCreatePass(getTView(), 'Expecting to be called in first template pass only');\n  let styles = writeToHost ? tNode.styles : null;\n  let classes = writeToHost ? tNode.classes : null;\n  let mode = 0;\n  if (attrs !== null) {\n    for (let i = 0; i < attrs.length; i++) {\n      const value = attrs[i];\n      if (typeof value === 'number') {\n        mode = value;\n      } else if (mode == 1 /* AttributeMarker.Classes */) {\n        classes = concatStringsWithSpace(classes, value);\n      } else if (mode == 2 /* AttributeMarker.Styles */) {\n        const style = value;\n        const styleValue = attrs[++i];\n        styles = concatStringsWithSpace(styles, style + ': ' + styleValue + ';');\n      }\n    }\n  }\n  writeToHost ? tNode.styles = styles : tNode.stylesWithoutHost = styles;\n  writeToHost ? tNode.classes = classes : tNode.classesWithoutHost = classes;\n}\nfunction collectNativeNodes(tView, lView, tNode, result, isProjection = false) {\n  while (tNode !== null) {\n    ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 12 /* TNodeType.AnyContainer */ | 16 /* TNodeType.Projection */ | 32 /* TNodeType.Icu */);\n    const lNode = lView[tNode.index];\n    if (lNode !== null) {\n      result.push(unwrapRNode(lNode));\n    }\n    // A given lNode can represent either a native node or a LContainer (when it is a host of a\n    // ViewContainerRef). When we find a LContainer we need to descend into it to collect root nodes\n    // from the views in this container.\n    if (isLContainer(lNode)) {\n      collectNativeNodesInLContainer(lNode, result);\n    }\n    const tNodeType = tNode.type;\n    if (tNodeType & 8 /* TNodeType.ElementContainer */) {\n      collectNativeNodes(tView, lView, tNode.child, result);\n    } else if (tNodeType & 32 /* TNodeType.Icu */) {\n      const nextRNode = icuContainerIterate(tNode, lView);\n      let rNode;\n      while (rNode = nextRNode()) {\n        result.push(rNode);\n      }\n    } else if (tNodeType & 16 /* TNodeType.Projection */) {\n      const nodesInSlot = getProjectionNodes(lView, tNode);\n      if (Array.isArray(nodesInSlot)) {\n        result.push(...nodesInSlot);\n      } else {\n        const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);\n        ngDevMode && assertParentView(parentView);\n        collectNativeNodes(parentView[TVIEW], parentView, nodesInSlot, result, true);\n      }\n    }\n    tNode = isProjection ? tNode.projectionNext : tNode.next;\n  }\n  return result;\n}\n/**\n * Collects all root nodes in all views in a given LContainer.\n */\nfunction collectNativeNodesInLContainer(lContainer, result) {\n  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n    const lViewInAContainer = lContainer[i];\n    const lViewFirstChildTNode = lViewInAContainer[TVIEW].firstChild;\n    if (lViewFirstChildTNode !== null) {\n      collectNativeNodes(lViewInAContainer[TVIEW], lViewInAContainer, lViewFirstChildTNode, result);\n    }\n  }\n  // When an LContainer is created, the anchor (comment) node is:\n  // - (1) either reused in case of an ElementContainer (<ng-container>)\n  // - (2) or a new comment node is created\n  // In the first case, the anchor comment node would be added to the final\n  // list by the code in the `collectNativeNodes` function\n  // (see the `result.push(unwrapRNode(lNode))` line), but the second\n  // case requires extra handling: the anchor node needs to be added to the\n  // final list manually. See additional information in the `createAnchorNode`\n  // function in the `view_container_ref.ts`.\n  //\n  // In the first case, the same reference would be stored in the `NATIVE`\n  // and `HOST` slots in an LContainer. Otherwise, this is the second case and\n  // we should add an element to the final list.\n  if (lContainer[NATIVE] !== lContainer[HOST]) {\n    result.push(lContainer[NATIVE]);\n  }\n}\nfunction detectChangesInternal(tView, lView, context, notifyErrorHandler = true) {\n  const environment = lView[ENVIRONMENT];\n  const rendererFactory = environment.rendererFactory;\n  const afterRenderEventManager = environment.afterRenderEventManager;\n  // Check no changes mode is a dev only mode used to verify that bindings have not changed\n  // since they were assigned. We do not want to invoke renderer factory functions in that mode\n  // to avoid any possible side-effects.\n  const checkNoChangesMode = !!ngDevMode && isInCheckNoChangesMode();\n  if (!checkNoChangesMode) {\n    rendererFactory.begin?.();\n    afterRenderEventManager?.begin();\n  }\n  try {\n    refreshView(tView, lView, tView.template, context);\n  } catch (error) {\n    if (notifyErrorHandler) {\n      handleError(lView, error);\n    }\n    throw error;\n  } finally {\n    if (!checkNoChangesMode) {\n      rendererFactory.end?.();\n      // One final flush of the effects queue to catch any effects created in `ngAfterViewInit` or\n      // other post-order hooks.\n      environment.effectManager?.flush();\n      // Invoke all callbacks registered via `after*Render`, if needed.\n      afterRenderEventManager?.end();\n    }\n  }\n}\nfunction checkNoChangesInternal(tView, lView, context, notifyErrorHandler = true) {\n  setIsInCheckNoChangesMode(true);\n  try {\n    detectChangesInternal(tView, lView, context, notifyErrorHandler);\n  } finally {\n    setIsInCheckNoChangesMode(false);\n  }\n}\n/**\n * Synchronously perform change detection on a component (and possibly its sub-components).\n *\n * This function triggers change detection in a synchronous way on a component.\n *\n * @param component The component which the change detection should be performed on.\n */\nfunction detectChanges(component) {\n  const view = getComponentViewByInstance(component);\n  detectChangesInternal(view[TVIEW], view, component);\n}\n/**\n * Processes a view in update mode. This includes a number of steps in a specific order:\n * - executing a template function in update mode;\n * - executing hooks;\n * - refreshing queries;\n * - setting host bindings;\n * - refreshing child (embedded and component) views.\n */\nfunction refreshView(tView, lView, templateFn, context) {\n  ngDevMode && assertEqual(isCreationMode(lView), false, 'Should be run in update mode');\n  const flags = lView[FLAGS];\n  if ((flags & 256 /* LViewFlags.Destroyed */) === 256 /* LViewFlags.Destroyed */) return;\n  // Check no changes mode is a dev only mode used to verify that bindings have not changed\n  // since they were assigned. We do not want to execute lifecycle hooks in that mode.\n  const isInCheckNoChangesPass = ngDevMode && isInCheckNoChangesMode();\n  !isInCheckNoChangesPass && lView[ENVIRONMENT].effectManager?.flush();\n  enterView(lView);\n  try {\n    resetPreOrderHookFlags(lView);\n    setBindingIndex(tView.bindingStartIndex);\n    if (templateFn !== null) {\n      executeTemplate(tView, lView, templateFn, 2 /* RenderFlags.Update */, context);\n    }\n    const hooksInitPhaseCompleted = (flags & 3 /* LViewFlags.InitPhaseStateMask */) === 3 /* InitPhaseState.InitPhaseCompleted */;\n    // execute pre-order hooks (OnInit, OnChanges, DoCheck)\n    // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n    if (!isInCheckNoChangesPass) {\n      if (hooksInitPhaseCompleted) {\n        const preOrderCheckHooks = tView.preOrderCheckHooks;\n        if (preOrderCheckHooks !== null) {\n          executeCheckHooks(lView, preOrderCheckHooks, null);\n        }\n      } else {\n        const preOrderHooks = tView.preOrderHooks;\n        if (preOrderHooks !== null) {\n          executeInitAndCheckHooks(lView, preOrderHooks, 0 /* InitPhaseState.OnInitHooksToBeRun */, null);\n        }\n        incrementInitPhaseFlags(lView, 0 /* InitPhaseState.OnInitHooksToBeRun */);\n      }\n    }\n    // First mark transplanted views that are declared in this lView as needing a refresh at their\n    // insertion points. This is needed to avoid the situation where the template is defined in this\n    // `LView` but its declaration appears after the insertion component.\n    markTransplantedViewsForRefresh(lView);\n    detectChangesInEmbeddedViews(lView, 2 /* ChangeDetectionMode.BugToForceRefreshAndIgnoreViewFlags */);\n    // Content query results must be refreshed before content hooks are called.\n    if (tView.contentQueries !== null) {\n      refreshContentQueries(tView, lView);\n    }\n    // execute content hooks (AfterContentInit, AfterContentChecked)\n    // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n    if (!isInCheckNoChangesPass) {\n      if (hooksInitPhaseCompleted) {\n        const contentCheckHooks = tView.contentCheckHooks;\n        if (contentCheckHooks !== null) {\n          executeCheckHooks(lView, contentCheckHooks);\n        }\n      } else {\n        const contentHooks = tView.contentHooks;\n        if (contentHooks !== null) {\n          executeInitAndCheckHooks(lView, contentHooks, 1 /* InitPhaseState.AfterContentInitHooksToBeRun */);\n        }\n\n        incrementInitPhaseFlags(lView, 1 /* InitPhaseState.AfterContentInitHooksToBeRun */);\n      }\n    }\n\n    processHostBindingOpCodes(tView, lView);\n    // Refresh child component views.\n    const components = tView.components;\n    if (components !== null) {\n      detectChangesInChildComponents(lView, components, 0 /* ChangeDetectionMode.Global */);\n    }\n    // View queries must execute after refreshing child components because a template in this view\n    // could be inserted in a child component. If the view query executes before child component\n    // refresh, the template might not yet be inserted.\n    const viewQuery = tView.viewQuery;\n    if (viewQuery !== null) {\n      executeViewQueryFn(2 /* RenderFlags.Update */, viewQuery, context);\n    }\n    // execute view hooks (AfterViewInit, AfterViewChecked)\n    // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n    if (!isInCheckNoChangesPass) {\n      if (hooksInitPhaseCompleted) {\n        const viewCheckHooks = tView.viewCheckHooks;\n        if (viewCheckHooks !== null) {\n          executeCheckHooks(lView, viewCheckHooks);\n        }\n      } else {\n        const viewHooks = tView.viewHooks;\n        if (viewHooks !== null) {\n          executeInitAndCheckHooks(lView, viewHooks, 2 /* InitPhaseState.AfterViewInitHooksToBeRun */);\n        }\n\n        incrementInitPhaseFlags(lView, 2 /* InitPhaseState.AfterViewInitHooksToBeRun */);\n      }\n    }\n\n    if (tView.firstUpdatePass === true) {\n      // We need to make sure that we only flip the flag on successful `refreshView` only\n      // Don't do this in `finally` block.\n      // If we did this in `finally` block then an exception could block the execution of styling\n      // instructions which in turn would be unable to insert themselves into the styling linked\n      // list. The result of this would be that if the exception would not be throw on subsequent CD\n      // the styling would be unable to process it data and reflect to the DOM.\n      tView.firstUpdatePass = false;\n    }\n    // Do not reset the dirty state when running in check no changes mode. We don't want components\n    // to behave differently depending on whether check no changes is enabled or not. For example:\n    // Marking an OnPush component as dirty from within the `ngAfterViewInit` hook in order to\n    // refresh a `NgClass` binding should work. If we would reset the dirty state in the check\n    // no changes cycle, the component would be not be dirty for the next update pass. This would\n    // be different in production mode where the component dirty state is not reset.\n    if (!isInCheckNoChangesPass) {\n      lView[FLAGS] &= ~(64 /* LViewFlags.Dirty */ | 8 /* LViewFlags.FirstLViewPass */);\n    }\n\n    clearViewRefreshFlag(lView);\n  } finally {\n    leaveView();\n  }\n}\n/**\n * Goes over embedded views (ones created through ViewContainerRef APIs) and refreshes\n * them by executing an associated template function.\n */\nfunction detectChangesInEmbeddedViews(lView, mode) {\n  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {\n    for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n      const embeddedLView = lContainer[i];\n      detectChangesInView(embeddedLView, mode);\n    }\n  }\n}\n/**\n * Mark transplanted views as needing to be refreshed at their insertion points.\n *\n * @param lView The `LView` that may have transplanted views.\n */\nfunction markTransplantedViewsForRefresh(lView) {\n  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {\n    if (!lContainer[HAS_TRANSPLANTED_VIEWS]) continue;\n    const movedViews = lContainer[MOVED_VIEWS];\n    ngDevMode && assertDefined(movedViews, 'Transplanted View flags set but missing MOVED_VIEWS');\n    for (let i = 0; i < movedViews.length; i++) {\n      const movedLView = movedViews[i];\n      const insertionLContainer = movedLView[PARENT];\n      ngDevMode && assertLContainer(insertionLContainer);\n      markViewForRefresh(movedLView);\n    }\n  }\n}\n/**\n * Detects changes in a component by entering the component view and processing its bindings,\n * queries, etc. if it is CheckAlways, OnPush and Dirty, etc.\n *\n * @param componentHostIdx  Element index in LView[] (adjusted for HEADER_OFFSET)\n */\nfunction detectChangesInComponent(hostLView, componentHostIdx, mode) {\n  ngDevMode && assertEqual(isCreationMode(hostLView), false, 'Should be run in update mode');\n  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);\n  detectChangesInView(componentView, mode);\n}\n/**\n * Visits a view as part of change detection traversal.\n *\n * - If the view is detached, no additional traversal happens.\n *\n * The view is refreshed if:\n * - If the view is CheckAlways or Dirty and ChangeDetectionMode is `Global`\n * - If the view has the `RefreshTransplantedView` flag\n *\n * The view is not refreshed, but descendants are traversed in `ChangeDetectionMode.Targeted` if the\n * view has a non-zero TRANSPLANTED_VIEWS_TO_REFRESH counter.\n *\n */\nfunction detectChangesInView(lView, mode) {\n  if (!viewAttachedToChangeDetector(lView)) {\n    return;\n  }\n  const tView = lView[TVIEW];\n  const flags = lView[FLAGS];\n  if (flags & (16 /* LViewFlags.CheckAlways */ | 64 /* LViewFlags.Dirty */) && mode === 0 /* ChangeDetectionMode.Global */ || flags & 1024 /* LViewFlags.RefreshView */ || mode === 2 /* ChangeDetectionMode.BugToForceRefreshAndIgnoreViewFlags */) {\n    refreshView(tView, lView, tView.template, lView[CONTEXT]);\n  } else if (lView[DESCENDANT_VIEWS_TO_REFRESH] > 0) {\n    detectChangesInEmbeddedViews(lView, 1 /* ChangeDetectionMode.Targeted */);\n    const components = tView.components;\n    if (components !== null) {\n      detectChangesInChildComponents(lView, components, 1 /* ChangeDetectionMode.Targeted */);\n    }\n  }\n}\n/** Refreshes child components in the current view (update mode). */\nfunction detectChangesInChildComponents(hostLView, components, mode) {\n  for (let i = 0; i < components.length; i++) {\n    detectChangesInComponent(hostLView, components[i], mode);\n  }\n}\nclass ViewRef {\n  get rootNodes() {\n    const lView = this._lView;\n    const tView = lView[TVIEW];\n    return collectNativeNodes(tView, lView, tView.firstChild, []);\n  }\n  constructor(\n  /**\n   * This represents `LView` associated with the component when ViewRef is a ChangeDetectorRef.\n   *\n   * When ViewRef is created for a dynamic component, this also represents the `LView` for the\n   * component.\n   *\n   * For a \"regular\" ViewRef created for an embedded view, this is the `LView` for the embedded\n   * view.\n   *\n   * @internal\n   */\n  _lView,\n  /**\n   * This represents the `LView` associated with the point where `ChangeDetectorRef` was\n   * requested.\n   *\n   * This may be different from `_lView` if the `_cdRefInjectingView` is an embedded view.\n   */\n  _cdRefInjectingView) {\n    this._lView = _lView;\n    this._cdRefInjectingView = _cdRefInjectingView;\n    this._appRef = null;\n    this._attachedToViewContainer = false;\n  }\n  get context() {\n    return this._lView[CONTEXT];\n  }\n  set context(value) {\n    this._lView[CONTEXT] = value;\n  }\n  get destroyed() {\n    return (this._lView[FLAGS] & 256 /* LViewFlags.Destroyed */) === 256 /* LViewFlags.Destroyed */;\n  }\n\n  destroy() {\n    if (this._appRef) {\n      this._appRef.detachView(this);\n    } else if (this._attachedToViewContainer) {\n      const parent = this._lView[PARENT];\n      if (isLContainer(parent)) {\n        const viewRefs = parent[VIEW_REFS];\n        const index = viewRefs ? viewRefs.indexOf(this) : -1;\n        if (index > -1) {\n          ngDevMode && assertEqual(index, parent.indexOf(this._lView) - CONTAINER_HEADER_OFFSET, 'An attached view should be in the same position within its container as its ViewRef in the VIEW_REFS array.');\n          detachView(parent, index);\n          removeFromArray(viewRefs, index);\n        }\n      }\n      this._attachedToViewContainer = false;\n    }\n    destroyLView(this._lView[TVIEW], this._lView);\n  }\n  onDestroy(callback) {\n    storeLViewOnDestroy(this._lView, callback);\n  }\n  /**\n   * Marks a view and all of its ancestors dirty.\n   *\n   * This can be used to ensure an {@link ChangeDetectionStrategy#OnPush} component is\n   * checked when it needs to be re-rendered but the two normal triggers haven't marked it\n   * dirty (i.e. inputs haven't changed and events haven't fired in the view).\n   *\n   * <!-- TODO: Add a link to a chapter on OnPush components -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Component({\n   *   selector: 'app-root',\n   *   template: `Number of ticks: {{numberOfTicks}}`\n   *   changeDetection: ChangeDetectionStrategy.OnPush,\n   * })\n   * class AppComponent {\n   *   numberOfTicks = 0;\n   *\n   *   constructor(private ref: ChangeDetectorRef) {\n   *     setInterval(() => {\n   *       this.numberOfTicks++;\n   *       // the following is required, otherwise the view will not be updated\n   *       this.ref.markForCheck();\n   *     }, 1000);\n   *   }\n   * }\n   * ```\n   */\n  markForCheck() {\n    markViewDirty(this._cdRefInjectingView || this._lView);\n  }\n  /**\n   * Detaches the view from the change detection tree.\n   *\n   * Detached views will not be checked during change detection runs until they are\n   * re-attached, even if they are dirty. `detach` can be used in combination with\n   * {@link ChangeDetectorRef#detectChanges} to implement local change\n   * detection checks.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example defines a component with a large list of readonly data.\n   * Imagine the data changes constantly, many times per second. For performance reasons,\n   * we want to check and update the list every five seconds. We can do that by detaching\n   * the component's change detector and doing a local check every five seconds.\n   *\n   * ```typescript\n   * class DataProvider {\n   *   // in a real application the returned data will be different every time\n   *   get data() {\n   *     return [1,2,3,4,5];\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'giant-list',\n   *   template: `\n   *     <li *ngFor=\"let d of dataProvider.data\">Data {{d}}</li>\n   *   `,\n   * })\n   * class GiantList {\n   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {\n   *     ref.detach();\n   *     setInterval(() => {\n   *       this.ref.detectChanges();\n   *     }, 5000);\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'app',\n   *   providers: [DataProvider],\n   *   template: `\n   *     <giant-list><giant-list>\n   *   `,\n   * })\n   * class App {\n   * }\n   * ```\n   */\n  detach() {\n    this._lView[FLAGS] &= ~128 /* LViewFlags.Attached */;\n  }\n  /**\n   * Re-attaches a view to the change detection tree.\n   *\n   * This can be used to re-attach views that were previously detached from the tree\n   * using {@link ChangeDetectorRef#detach}. Views are attached to the tree by default.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example creates a component displaying `live` data. The component will detach\n   * its change detector from the main change detector tree when the component's live property\n   * is set to false.\n   *\n   * ```typescript\n   * class DataProvider {\n   *   data = 1;\n   *\n   *   constructor() {\n   *     setInterval(() => {\n   *       this.data = this.data * 2;\n   *     }, 500);\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'live-data',\n   *   inputs: ['live'],\n   *   template: 'Data: {{dataProvider.data}}'\n   * })\n   * class LiveData {\n   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}\n   *\n   *   set live(value) {\n   *     if (value) {\n   *       this.ref.reattach();\n   *     } else {\n   *       this.ref.detach();\n   *     }\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'app-root',\n   *   providers: [DataProvider],\n   *   template: `\n   *     Live Update: <input type=\"checkbox\" [(ngModel)]=\"live\">\n   *     <live-data [live]=\"live\"><live-data>\n   *   `,\n   * })\n   * class AppComponent {\n   *   live = true;\n   * }\n   * ```\n   */\n  reattach() {\n    this._lView[FLAGS] |= 128 /* LViewFlags.Attached */;\n  }\n  /**\n   * Checks the view and its children.\n   *\n   * This can also be used in combination with {@link ChangeDetectorRef#detach} to implement\n   * local change detection checks.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example defines a component with a large list of readonly data.\n   * Imagine, the data changes constantly, many times per second. For performance reasons,\n   * we want to check and update the list every five seconds.\n   *\n   * We can do that by detaching the component's change detector and doing a local change detection\n   * check every five seconds.\n   *\n   * See {@link ChangeDetectorRef#detach} for more information.\n   */\n  detectChanges() {\n    detectChangesInternal(this._lView[TVIEW], this._lView, this.context);\n  }\n  /**\n   * Checks the change detector and its children, and throws if any changes are detected.\n   *\n   * This is used in development mode to verify that running change detection doesn't\n   * introduce other changes.\n   */\n  checkNoChanges() {\n    if (ngDevMode) {\n      checkNoChangesInternal(this._lView[TVIEW], this._lView, this.context);\n    }\n  }\n  attachToViewContainerRef() {\n    if (this._appRef) {\n      throw new RuntimeError(902 /* RuntimeErrorCode.VIEW_ALREADY_ATTACHED */, ngDevMode && 'This view is already attached directly to the ApplicationRef!');\n    }\n    this._attachedToViewContainer = true;\n  }\n  detachFromAppRef() {\n    this._appRef = null;\n    detachViewFromDOM(this._lView[TVIEW], this._lView);\n  }\n  attachToAppRef(appRef) {\n    if (this._attachedToViewContainer) {\n      throw new RuntimeError(902 /* RuntimeErrorCode.VIEW_ALREADY_ATTACHED */, ngDevMode && 'This view is already attached to a ViewContainer!');\n    }\n    this._appRef = appRef;\n  }\n}\n/** @internal */\nclass RootViewRef extends ViewRef {\n  constructor(_view) {\n    super(_view);\n    this._view = _view;\n  }\n  detectChanges() {\n    const lView = this._view;\n    const tView = lView[TVIEW];\n    const context = lView[CONTEXT];\n    detectChangesInternal(tView, lView, context, false);\n  }\n  checkNoChanges() {\n    if (ngDevMode) {\n      const lView = this._view;\n      const tView = lView[TVIEW];\n      const context = lView[CONTEXT];\n      checkNoChangesInternal(tView, lView, context, false);\n    }\n  }\n  get context() {\n    return null;\n  }\n}\nclass ComponentFactoryResolver extends ComponentFactoryResolver$1 {\n  /**\n   * @param ngModule The NgModuleRef to which all resolved factories are bound.\n   */\n  constructor(ngModule) {\n    super();\n    this.ngModule = ngModule;\n  }\n  resolveComponentFactory(component) {\n    ngDevMode && assertComponentType(component);\n    const componentDef = getComponentDef$1(component);\n    return new ComponentFactory(componentDef, this.ngModule);\n  }\n}\nfunction toRefArray(map) {\n  const array = [];\n  for (let nonMinified in map) {\n    if (map.hasOwnProperty(nonMinified)) {\n      const minified = map[nonMinified];\n      array.push({\n        propName: minified,\n        templateName: nonMinified\n      });\n    }\n  }\n  return array;\n}\nfunction getNamespace(elementName) {\n  const name = elementName.toLowerCase();\n  return name === 'svg' ? SVG_NAMESPACE : name === 'math' ? MATH_ML_NAMESPACE : null;\n}\n/**\n * Injector that looks up a value using a specific injector, before falling back to the module\n * injector. Used primarily when creating components or embedded views dynamically.\n */\nclass ChainedInjector {\n  constructor(injector, parentInjector) {\n    this.injector = injector;\n    this.parentInjector = parentInjector;\n  }\n  get(token, notFoundValue, flags) {\n    flags = convertToBitFlags(flags);\n    const value = this.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, flags);\n    if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR || notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {\n      // Return the value from the root element injector when\n      // - it provides it\n      //   (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\n      // - the module injector should not be checked\n      //   (notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\n      return value;\n    }\n    return this.parentInjector.get(token, notFoundValue, flags);\n  }\n}\n/**\n * ComponentFactory interface implementation.\n */\nclass ComponentFactory extends ComponentFactory$1 {\n  get inputs() {\n    const componentDef = this.componentDef;\n    const inputTransforms = componentDef.inputTransforms;\n    const refArray = toRefArray(componentDef.inputs);\n    if (inputTransforms !== null) {\n      for (const input of refArray) {\n        if (inputTransforms.hasOwnProperty(input.propName)) {\n          input.transform = inputTransforms[input.propName];\n        }\n      }\n    }\n    return refArray;\n  }\n  get outputs() {\n    return toRefArray(this.componentDef.outputs);\n  }\n  /**\n   * @param componentDef The component definition.\n   * @param ngModule The NgModuleRef to which the factory is bound.\n   */\n  constructor(componentDef, ngModule) {\n    super();\n    this.componentDef = componentDef;\n    this.ngModule = ngModule;\n    this.componentType = componentDef.type;\n    this.selector = stringifyCSSSelectorList(componentDef.selectors);\n    this.ngContentSelectors = componentDef.ngContentSelectors ? componentDef.ngContentSelectors : [];\n    this.isBoundToModule = !!ngModule;\n  }\n  create(injector, projectableNodes, rootSelectorOrNode, environmentInjector) {\n    environmentInjector = environmentInjector || this.ngModule;\n    let realEnvironmentInjector = environmentInjector instanceof EnvironmentInjector ? environmentInjector : environmentInjector?.injector;\n    if (realEnvironmentInjector && this.componentDef.getStandaloneInjector !== null) {\n      realEnvironmentInjector = this.componentDef.getStandaloneInjector(realEnvironmentInjector) || realEnvironmentInjector;\n    }\n    const rootViewInjector = realEnvironmentInjector ? new ChainedInjector(injector, realEnvironmentInjector) : injector;\n    const rendererFactory = rootViewInjector.get(RendererFactory2, null);\n    if (rendererFactory === null) {\n      throw new RuntimeError(407 /* RuntimeErrorCode.RENDERER_NOT_FOUND */, ngDevMode && 'Angular was not able to inject a renderer (RendererFactory2). ' + 'Likely this is due to a broken DI hierarchy. ' + 'Make sure that any injector used to create this component has a correct parent.');\n    }\n    const sanitizer = rootViewInjector.get(Sanitizer, null);\n    const effectManager = rootViewInjector.get(EffectManager, null);\n    const afterRenderEventManager = rootViewInjector.get(AfterRenderEventManager, null);\n    const environment = {\n      rendererFactory,\n      sanitizer,\n      effectManager,\n      afterRenderEventManager\n    };\n    const hostRenderer = rendererFactory.createRenderer(null, this.componentDef);\n    // Determine a tag name used for creating host elements when this component is created\n    // dynamically. Default to 'div' if this component did not specify any tag name in its selector.\n    const elementName = this.componentDef.selectors[0][0] || 'div';\n    const hostRNode = rootSelectorOrNode ? locateHostElement(hostRenderer, rootSelectorOrNode, this.componentDef.encapsulation, rootViewInjector) : createElementNode(hostRenderer, elementName, getNamespace(elementName));\n    // Signal components use the granular \"RefreshView\"  for change detection\n    const signalFlags = 4096 /* LViewFlags.SignalView */ | 512 /* LViewFlags.IsRoot */;\n    // Non-signal components use the traditional \"CheckAlways or OnPush/Dirty\" change detection\n    const nonSignalFlags = this.componentDef.onPush ? 64 /* LViewFlags.Dirty */ | 512 /* LViewFlags.IsRoot */ : 16 /* LViewFlags.CheckAlways */ | 512 /* LViewFlags.IsRoot */;\n    const rootFlags = this.componentDef.signals ? signalFlags : nonSignalFlags;\n    let hydrationInfo = null;\n    if (hostRNode !== null) {\n      hydrationInfo = retrieveHydrationInfo(hostRNode, rootViewInjector, true /* isRootView */);\n    }\n    // Create the root view. Uses empty TView and ContentTemplate.\n    const rootTView = createTView(0 /* TViewType.Root */, null, null, 1, 0, null, null, null, null, null, null);\n    const rootLView = createLView(null, rootTView, null, rootFlags, null, null, environment, hostRenderer, rootViewInjector, null, hydrationInfo);\n    // rootView is the parent when bootstrapping\n    // TODO(misko): it looks like we are entering view here but we don't really need to as\n    // `renderView` does that. However as the code is written it is needed because\n    // `createRootComponentView` and `createRootComponent` both read global state. Fixing those\n    // issues would allow us to drop this.\n    enterView(rootLView);\n    let component;\n    let tElementNode;\n    try {\n      const rootComponentDef = this.componentDef;\n      let rootDirectives;\n      let hostDirectiveDefs = null;\n      if (rootComponentDef.findHostDirectiveDefs) {\n        rootDirectives = [];\n        hostDirectiveDefs = new Map();\n        rootComponentDef.findHostDirectiveDefs(rootComponentDef, rootDirectives, hostDirectiveDefs);\n        rootDirectives.push(rootComponentDef);\n      } else {\n        rootDirectives = [rootComponentDef];\n      }\n      const hostTNode = createRootComponentTNode(rootLView, hostRNode);\n      const componentView = createRootComponentView(hostTNode, hostRNode, rootComponentDef, rootDirectives, rootLView, environment, hostRenderer);\n      tElementNode = getTNode(rootTView, HEADER_OFFSET);\n      // TODO(crisbeto): in practice `hostRNode` should always be defined, but there are some tests\n      // where the renderer is mocked out and `undefined` is returned. We should update the tests so\n      // that this check can be removed.\n      if (hostRNode) {\n        setRootNodeAttributes(hostRenderer, rootComponentDef, hostRNode, rootSelectorOrNode);\n      }\n      if (projectableNodes !== undefined) {\n        projectNodes(tElementNode, this.ngContentSelectors, projectableNodes);\n      }\n      // TODO: should LifecycleHooksFeature and other host features be generated by the compiler and\n      // executed here?\n      // Angular 5 reference: https://stackblitz.com/edit/lifecycle-hooks-vcref\n      component = createRootComponent(componentView, rootComponentDef, rootDirectives, hostDirectiveDefs, rootLView, [LifecycleHooksFeature]);\n      renderView(rootTView, rootLView, null);\n    } finally {\n      leaveView();\n    }\n    return new ComponentRef(this.componentType, component, createElementRef(tElementNode, rootLView), rootLView, tElementNode);\n  }\n}\n/**\n * Represents an instance of a Component created via a {@link ComponentFactory}.\n *\n * `ComponentRef` provides access to the Component Instance as well other objects related to this\n * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}\n * method.\n *\n */\nclass ComponentRef extends ComponentRef$1 {\n  constructor(componentType, instance, location, _rootLView, _tNode) {\n    super();\n    this.location = location;\n    this._rootLView = _rootLView;\n    this._tNode = _tNode;\n    this.previousInputValues = null;\n    this.instance = instance;\n    this.hostView = this.changeDetectorRef = new RootViewRef(_rootLView);\n    this.componentType = componentType;\n  }\n  setInput(name, value) {\n    const inputData = this._tNode.inputs;\n    let dataValue;\n    if (inputData !== null && (dataValue = inputData[name])) {\n      this.previousInputValues ??= new Map();\n      // Do not set the input if it is the same as the last value\n      // This behavior matches `bindingUpdated` when binding inputs in templates.\n      if (this.previousInputValues.has(name) && Object.is(this.previousInputValues.get(name), value)) {\n        return;\n      }\n      const lView = this._rootLView;\n      setInputsForProperty(lView[TVIEW], lView, dataValue, name, value);\n      this.previousInputValues.set(name, value);\n      const childComponentLView = getComponentLViewByIndex(this._tNode.index, lView);\n      markViewDirty(childComponentLView);\n    } else {\n      if (ngDevMode) {\n        const cmpNameForError = stringifyForError(this.componentType);\n        let message = `Can't set value of the '${name}' input on the '${cmpNameForError}' component. `;\n        message += `Make sure that the '${name}' property is annotated with @Input() or a mapped @Input('${name}') exists.`;\n        reportUnknownPropertyError(message);\n      }\n    }\n  }\n  get injector() {\n    return new NodeInjector(this._tNode, this._rootLView);\n  }\n  destroy() {\n    this.hostView.destroy();\n  }\n  onDestroy(callback) {\n    this.hostView.onDestroy(callback);\n  }\n}\n/** Creates a TNode that can be used to instantiate a root component. */\nfunction createRootComponentTNode(lView, rNode) {\n  const tView = lView[TVIEW];\n  const index = HEADER_OFFSET;\n  ngDevMode && assertIndexInRange(lView, index);\n  lView[index] = rNode;\n  // '#host' is added here as we don't know the real host DOM name (we don't want to read it) and at\n  // the same time we want to communicate the debug `TNode` that this is a special `TNode`\n  // representing a host element.\n  return getOrCreateTNode(tView, index, 2 /* TNodeType.Element */, '#host', null);\n}\n/**\n * Creates the root component view and the root component node.\n *\n * @param hostRNode Render host element.\n * @param rootComponentDef ComponentDef\n * @param rootView The parent view where the host node is stored\n * @param rendererFactory Factory to be used for creating child renderers.\n * @param hostRenderer The current renderer\n * @param sanitizer The sanitizer, if provided\n *\n * @returns Component view created\n */\nfunction createRootComponentView(tNode, hostRNode, rootComponentDef, rootDirectives, rootView, environment, hostRenderer) {\n  const tView = rootView[TVIEW];\n  applyRootComponentStyling(rootDirectives, tNode, hostRNode, hostRenderer);\n  // Hydration info is on the host element and needs to be retrieved\n  // and passed to the component LView.\n  let hydrationInfo = null;\n  if (hostRNode !== null) {\n    hydrationInfo = retrieveHydrationInfo(hostRNode, rootView[INJECTOR$1]);\n  }\n  const viewRenderer = environment.rendererFactory.createRenderer(hostRNode, rootComponentDef);\n  let lViewFlags = 16 /* LViewFlags.CheckAlways */;\n  if (rootComponentDef.signals) {\n    lViewFlags = 4096 /* LViewFlags.SignalView */;\n  } else if (rootComponentDef.onPush) {\n    lViewFlags = 64 /* LViewFlags.Dirty */;\n  }\n\n  const componentView = createLView(rootView, getOrCreateComponentTView(rootComponentDef), null, lViewFlags, rootView[tNode.index], tNode, environment, viewRenderer, null, null, hydrationInfo);\n  if (tView.firstCreatePass) {\n    markAsComponentHost(tView, tNode, rootDirectives.length - 1);\n  }\n  addToViewTree(rootView, componentView);\n  // Store component view at node index, with node as the HOST\n  return rootView[tNode.index] = componentView;\n}\n/** Sets up the styling information on a root component. */\nfunction applyRootComponentStyling(rootDirectives, tNode, rNode, hostRenderer) {\n  for (const def of rootDirectives) {\n    tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);\n  }\n  if (tNode.mergedAttrs !== null) {\n    computeStaticStyling(tNode, tNode.mergedAttrs, true);\n    if (rNode !== null) {\n      setupStaticAttributes(hostRenderer, rNode, tNode);\n    }\n  }\n}\n/**\n * Creates a root component and sets it up with features and host bindings.Shared by\n * renderComponent() and ViewContainerRef.createComponent().\n */\nfunction createRootComponent(componentView, rootComponentDef, rootDirectives, hostDirectiveDefs, rootLView, hostFeatures) {\n  const rootTNode = getCurrentTNode();\n  ngDevMode && assertDefined(rootTNode, 'tNode should have been already created');\n  const tView = rootLView[TVIEW];\n  const native = getNativeByTNode(rootTNode, rootLView);\n  initializeDirectives(tView, rootLView, rootTNode, rootDirectives, null, hostDirectiveDefs);\n  for (let i = 0; i < rootDirectives.length; i++) {\n    const directiveIndex = rootTNode.directiveStart + i;\n    const directiveInstance = getNodeInjectable(rootLView, tView, directiveIndex, rootTNode);\n    attachPatchData(directiveInstance, rootLView);\n  }\n  invokeDirectivesHostBindings(tView, rootLView, rootTNode);\n  if (native) {\n    attachPatchData(native, rootLView);\n  }\n  // We're guaranteed for the `componentOffset` to be positive here\n  // since a root component always matches a component def.\n  ngDevMode && assertGreaterThan(rootTNode.componentOffset, -1, 'componentOffset must be great than -1');\n  const component = getNodeInjectable(rootLView, tView, rootTNode.directiveStart + rootTNode.componentOffset, rootTNode);\n  componentView[CONTEXT] = rootLView[CONTEXT] = component;\n  if (hostFeatures !== null) {\n    for (const feature of hostFeatures) {\n      feature(component, rootComponentDef);\n    }\n  }\n  // We want to generate an empty QueryList for root content queries for backwards\n  // compatibility with ViewEngine.\n  executeContentQueries(tView, rootTNode, componentView);\n  return component;\n}\n/** Sets the static attributes on a root component. */\nfunction setRootNodeAttributes(hostRenderer, componentDef, hostRNode, rootSelectorOrNode) {\n  if (rootSelectorOrNode) {\n    setUpAttributes(hostRenderer, hostRNode, ['ng-version', VERSION.full]);\n  } else {\n    // If host element is created as a part of this function call (i.e. `rootSelectorOrNode`\n    // is not defined), also apply attributes and classes extracted from component selector.\n    // Extract attributes and classes from the first selector only to match VE behavior.\n    const {\n      attrs,\n      classes\n    } = extractAttrsAndClassesFromSelector(componentDef.selectors[0]);\n    if (attrs) {\n      setUpAttributes(hostRenderer, hostRNode, attrs);\n    }\n    if (classes && classes.length > 0) {\n      writeDirectClass(hostRenderer, hostRNode, classes.join(' '));\n    }\n  }\n}\n/** Projects the `projectableNodes` that were specified when creating a root component. */\nfunction projectNodes(tNode, ngContentSelectors, projectableNodes) {\n  const projection = tNode.projection = [];\n  for (let i = 0; i < ngContentSelectors.length; i++) {\n    const nodesforSlot = projectableNodes[i];\n    // Projectable nodes can be passed as array of arrays or an array of iterables (ngUpgrade\n    // case). Here we do normalize passed data structure to be an array of arrays to avoid\n    // complex checks down the line.\n    // We also normalize the length of the passed in projectable nodes (to match the number of\n    // <ng-container> slots defined by a component).\n    projection.push(nodesforSlot != null ? Array.from(nodesforSlot) : null);\n  }\n}\n/**\n * Used to enable lifecycle hooks on the root component.\n *\n * Include this feature when calling `renderComponent` if the root component\n * you are rendering has lifecycle hooks defined. Otherwise, the hooks won't\n * be called properly.\n *\n * Example:\n *\n * ```\n * renderComponent(AppComponent, {hostFeatures: [LifecycleHooksFeature]});\n * ```\n */\nfunction LifecycleHooksFeature() {\n  const tNode = getCurrentTNode();\n  ngDevMode && assertDefined(tNode, 'TNode is required');\n  registerPostOrderHooks(getLView()[TVIEW], tNode);\n}\nfunction getSuperType(type) {\n  return Object.getPrototypeOf(type.prototype).constructor;\n}\n/**\n * Merges the definition from a super class to a sub class.\n * @param definition The definition that is a SubClass of another directive of component\n *\n * @codeGenApi\n */\nfunction ɵɵInheritDefinitionFeature(definition) {\n  let superType = getSuperType(definition.type);\n  let shouldInheritFields = true;\n  const inheritanceChain = [definition];\n  while (superType) {\n    let superDef = undefined;\n    if (isComponentDef(definition)) {\n      // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n      superDef = superType.ɵcmp || superType.ɵdir;\n    } else {\n      if (superType.ɵcmp) {\n        throw new RuntimeError(903 /* RuntimeErrorCode.INVALID_INHERITANCE */, ngDevMode && `Directives cannot inherit Components. Directive ${stringifyForError(definition.type)} is attempting to extend component ${stringifyForError(superType)}`);\n      }\n      // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n      superDef = superType.ɵdir;\n    }\n    if (superDef) {\n      if (shouldInheritFields) {\n        inheritanceChain.push(superDef);\n        // Some fields in the definition may be empty, if there were no values to put in them that\n        // would've justified object creation. Unwrap them if necessary.\n        const writeableDef = definition;\n        writeableDef.inputs = maybeUnwrapEmpty(definition.inputs);\n        writeableDef.inputTransforms = maybeUnwrapEmpty(definition.inputTransforms);\n        writeableDef.declaredInputs = maybeUnwrapEmpty(definition.declaredInputs);\n        writeableDef.outputs = maybeUnwrapEmpty(definition.outputs);\n        // Merge hostBindings\n        const superHostBindings = superDef.hostBindings;\n        superHostBindings && inheritHostBindings(definition, superHostBindings);\n        // Merge queries\n        const superViewQuery = superDef.viewQuery;\n        const superContentQueries = superDef.contentQueries;\n        superViewQuery && inheritViewQuery(definition, superViewQuery);\n        superContentQueries && inheritContentQueries(definition, superContentQueries);\n        // Merge inputs and outputs\n        fillProperties(definition.inputs, superDef.inputs);\n        fillProperties(definition.declaredInputs, superDef.declaredInputs);\n        fillProperties(definition.outputs, superDef.outputs);\n        if (superDef.inputTransforms !== null) {\n          if (writeableDef.inputTransforms === null) {\n            writeableDef.inputTransforms = {};\n          }\n          fillProperties(writeableDef.inputTransforms, superDef.inputTransforms);\n        }\n        // Merge animations metadata.\n        // If `superDef` is a Component, the `data` field is present (defaults to an empty object).\n        if (isComponentDef(superDef) && superDef.data.animation) {\n          // If super def is a Component, the `definition` is also a Component, since Directives can\n          // not inherit Components (we throw an error above and cannot reach this code).\n          const defData = definition.data;\n          defData.animation = (defData.animation || []).concat(superDef.data.animation);\n        }\n      }\n      // Run parent features\n      const features = superDef.features;\n      if (features) {\n        for (let i = 0; i < features.length; i++) {\n          const feature = features[i];\n          if (feature && feature.ngInherit) {\n            feature(definition);\n          }\n          // If `InheritDefinitionFeature` is a part of the current `superDef`, it means that this\n          // def already has all the necessary information inherited from its super class(es), so we\n          // can stop merging fields from super classes. However we need to iterate through the\n          // prototype chain to look for classes that might contain other \"features\" (like\n          // NgOnChanges), which we should invoke for the original `definition`. We set the\n          // `shouldInheritFields` flag to indicate that, essentially skipping fields inheritance\n          // logic and only invoking functions from the \"features\" list.\n          if (feature === ɵɵInheritDefinitionFeature) {\n            shouldInheritFields = false;\n          }\n        }\n      }\n    }\n    superType = Object.getPrototypeOf(superType);\n  }\n  mergeHostAttrsAcrossInheritance(inheritanceChain);\n}\n/**\n * Merge the `hostAttrs` and `hostVars` from the inherited parent to the base class.\n *\n * @param inheritanceChain A list of `WritableDefs` starting at the top most type and listing\n * sub-types in order. For each type take the `hostAttrs` and `hostVars` and merge it with the child\n * type.\n */\nfunction mergeHostAttrsAcrossInheritance(inheritanceChain) {\n  let hostVars = 0;\n  let hostAttrs = null;\n  // We process the inheritance order from the base to the leaves here.\n  for (let i = inheritanceChain.length - 1; i >= 0; i--) {\n    const def = inheritanceChain[i];\n    // For each `hostVars`, we need to add the superclass amount.\n    def.hostVars = hostVars += def.hostVars;\n    // for each `hostAttrs` we need to merge it with superclass.\n    def.hostAttrs = mergeHostAttrs(def.hostAttrs, hostAttrs = mergeHostAttrs(hostAttrs, def.hostAttrs));\n  }\n}\nfunction maybeUnwrapEmpty(value) {\n  if (value === EMPTY_OBJ) {\n    return {};\n  } else if (value === EMPTY_ARRAY) {\n    return [];\n  } else {\n    return value;\n  }\n}\nfunction inheritViewQuery(definition, superViewQuery) {\n  const prevViewQuery = definition.viewQuery;\n  if (prevViewQuery) {\n    definition.viewQuery = (rf, ctx) => {\n      superViewQuery(rf, ctx);\n      prevViewQuery(rf, ctx);\n    };\n  } else {\n    definition.viewQuery = superViewQuery;\n  }\n}\nfunction inheritContentQueries(definition, superContentQueries) {\n  const prevContentQueries = definition.contentQueries;\n  if (prevContentQueries) {\n    definition.contentQueries = (rf, ctx, directiveIndex) => {\n      superContentQueries(rf, ctx, directiveIndex);\n      prevContentQueries(rf, ctx, directiveIndex);\n    };\n  } else {\n    definition.contentQueries = superContentQueries;\n  }\n}\nfunction inheritHostBindings(definition, superHostBindings) {\n  const prevHostBindings = definition.hostBindings;\n  if (prevHostBindings) {\n    definition.hostBindings = (rf, ctx) => {\n      superHostBindings(rf, ctx);\n      prevHostBindings(rf, ctx);\n    };\n  } else {\n    definition.hostBindings = superHostBindings;\n  }\n}\n\n/**\n * Fields which exist on either directive or component definitions, and need to be copied from\n * parent to child classes by the `ɵɵCopyDefinitionFeature`.\n */\nconst COPY_DIRECTIVE_FIELDS = [\n// The child class should use the providers of its parent.\n'providersResolver'\n// Not listed here are any fields which are handled by the `ɵɵInheritDefinitionFeature`, such\n// as inputs, outputs, and host binding functions.\n];\n/**\n * Fields which exist only on component definitions, and need to be copied from parent to child\n * classes by the `ɵɵCopyDefinitionFeature`.\n *\n * The type here allows any field of `ComponentDef` which is not also a property of `DirectiveDef`,\n * since those should go in `COPY_DIRECTIVE_FIELDS` above.\n */\nconst COPY_COMPONENT_FIELDS = [\n// The child class should use the template function of its parent, including all template\n// semantics.\n'template', 'decls', 'consts', 'vars', 'onPush', 'ngContentSelectors',\n// The child class should use the CSS styles of its parent, including all styling semantics.\n'styles', 'encapsulation',\n// The child class should be checked by the runtime in the same way as its parent.\n'schemas'];\n/**\n * Copies the fields not handled by the `ɵɵInheritDefinitionFeature` from the supertype of a\n * definition.\n *\n * This exists primarily to support ngcc migration of an existing View Engine pattern, where an\n * entire decorator is inherited from a parent to a child class. When ngcc detects this case, it\n * generates a skeleton definition on the child class, and applies this feature.\n *\n * The `ɵɵCopyDefinitionFeature` then copies any needed fields from the parent class' definition,\n * including things like the component template function.\n *\n * @param definition The definition of a child class which inherits from a parent class with its\n * own definition.\n *\n * @codeGenApi\n */\nfunction ɵɵCopyDefinitionFeature(definition) {\n  let superType = getSuperType(definition.type);\n  let superDef = undefined;\n  if (isComponentDef(definition)) {\n    // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n    superDef = superType.ɵcmp;\n  } else {\n    // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n    superDef = superType.ɵdir;\n  }\n  // Needed because `definition` fields are readonly.\n  const defAny = definition;\n  // Copy over any fields that apply to either directives or components.\n  for (const field of COPY_DIRECTIVE_FIELDS) {\n    defAny[field] = superDef[field];\n  }\n  if (isComponentDef(superDef)) {\n    // Copy over any component-specific fields.\n    for (const field of COPY_COMPONENT_FIELDS) {\n      defAny[field] = superDef[field];\n    }\n  }\n}\n\n/**\n * This feature adds the host directives behavior to a directive definition by patching a\n * function onto it. The expectation is that the runtime will invoke the function during\n * directive matching.\n *\n * For example:\n * ```ts\n * class ComponentWithHostDirective {\n *   static ɵcmp = defineComponent({\n *    type: ComponentWithHostDirective,\n *    features: [ɵɵHostDirectivesFeature([\n *      SimpleHostDirective,\n *      {directive: AdvancedHostDirective, inputs: ['foo: alias'], outputs: ['bar']},\n *    ])]\n *  });\n * }\n * ```\n *\n * @codeGenApi\n */\nfunction ɵɵHostDirectivesFeature(rawHostDirectives) {\n  return definition => {\n    definition.findHostDirectiveDefs = findHostDirectiveDefs;\n    definition.hostDirectives = (Array.isArray(rawHostDirectives) ? rawHostDirectives : rawHostDirectives()).map(dir => {\n      return typeof dir === 'function' ? {\n        directive: resolveForwardRef(dir),\n        inputs: EMPTY_OBJ,\n        outputs: EMPTY_OBJ\n      } : {\n        directive: resolveForwardRef(dir.directive),\n        inputs: bindingArrayToMap(dir.inputs),\n        outputs: bindingArrayToMap(dir.outputs)\n      };\n    });\n  };\n}\nfunction findHostDirectiveDefs(currentDef, matchedDefs, hostDirectiveDefs) {\n  if (currentDef.hostDirectives !== null) {\n    for (const hostDirectiveConfig of currentDef.hostDirectives) {\n      const hostDirectiveDef = getDirectiveDef(hostDirectiveConfig.directive);\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        validateHostDirective(hostDirectiveConfig, hostDirectiveDef, matchedDefs);\n      }\n      // We need to patch the `declaredInputs` so that\n      // `ngOnChanges` can map the properties correctly.\n      patchDeclaredInputs(hostDirectiveDef.declaredInputs, hostDirectiveConfig.inputs);\n      // Host directives execute before the host so that its host bindings can be overwritten.\n      findHostDirectiveDefs(hostDirectiveDef, matchedDefs, hostDirectiveDefs);\n      hostDirectiveDefs.set(hostDirectiveDef, hostDirectiveConfig);\n      matchedDefs.push(hostDirectiveDef);\n    }\n  }\n}\n/**\n * Converts an array in the form of `['publicName', 'alias', 'otherPublicName', 'otherAlias']` into\n * a map in the form of `{publicName: 'alias', otherPublicName: 'otherAlias'}`.\n */\nfunction bindingArrayToMap(bindings) {\n  if (bindings === undefined || bindings.length === 0) {\n    return EMPTY_OBJ;\n  }\n  const result = {};\n  for (let i = 0; i < bindings.length; i += 2) {\n    result[bindings[i]] = bindings[i + 1];\n  }\n  return result;\n}\n/**\n * `ngOnChanges` has some leftover legacy ViewEngine behavior where the keys inside the\n * `SimpleChanges` event refer to the *declared* name of the input, not its public name or its\n * minified name. E.g. in `@Input('alias') foo: string`, the name in the `SimpleChanges` object\n * will always be `foo`, and not `alias` or the minified name of `foo` in apps using property\n * minification.\n *\n * This is achieved through the `DirectiveDef.declaredInputs` map that is constructed when the\n * definition is declared. When a property is written to the directive instance, the\n * `NgOnChangesFeature` will try to remap the property name being written to using the\n * `declaredInputs`.\n *\n * Since the host directive input remapping happens during directive matching, `declaredInputs`\n * won't contain the new alias that the input is available under. This function addresses the\n * issue by patching the host directive aliases to the `declaredInputs`. There is *not* a risk of\n * this patching accidentally introducing new inputs to the host directive, because `declaredInputs`\n * is used *only* by the `NgOnChangesFeature` when determining what name is used in the\n * `SimpleChanges` object which won't be reached if an input doesn't exist.\n */\nfunction patchDeclaredInputs(declaredInputs, exposedInputs) {\n  for (const publicName in exposedInputs) {\n    if (exposedInputs.hasOwnProperty(publicName)) {\n      const remappedPublicName = exposedInputs[publicName];\n      const privateName = declaredInputs[publicName];\n      // We *technically* shouldn't be able to hit this case because we can't have multiple\n      // inputs on the same property and we have validations against conflicting aliases in\n      // `validateMappings`. If we somehow did, it would lead to `ngOnChanges` being invoked\n      // with the wrong name so we have a non-user-friendly assertion here just in case.\n      if ((typeof ngDevMode === 'undefined' || ngDevMode) && declaredInputs.hasOwnProperty(remappedPublicName)) {\n        assertEqual(declaredInputs[remappedPublicName], declaredInputs[publicName], `Conflicting host directive input alias ${publicName}.`);\n      }\n      declaredInputs[remappedPublicName] = privateName;\n    }\n  }\n}\n/**\n * Verifies that the host directive has been configured correctly.\n * @param hostDirectiveConfig Host directive configuration object.\n * @param directiveDef Directive definition of the host directive.\n * @param matchedDefs Directives that have been matched so far.\n */\nfunction validateHostDirective(hostDirectiveConfig, directiveDef, matchedDefs) {\n  const type = hostDirectiveConfig.directive;\n  if (directiveDef === null) {\n    if (getComponentDef$1(type) !== null) {\n      throw new RuntimeError(310 /* RuntimeErrorCode.HOST_DIRECTIVE_COMPONENT */, `Host directive ${type.name} cannot be a component.`);\n    }\n    throw new RuntimeError(307 /* RuntimeErrorCode.HOST_DIRECTIVE_UNRESOLVABLE */, `Could not resolve metadata for host directive ${type.name}. ` + `Make sure that the ${type.name} class is annotated with an @Directive decorator.`);\n  }\n  if (!directiveDef.standalone) {\n    throw new RuntimeError(308 /* RuntimeErrorCode.HOST_DIRECTIVE_NOT_STANDALONE */, `Host directive ${directiveDef.type.name} must be standalone.`);\n  }\n  if (matchedDefs.indexOf(directiveDef) > -1) {\n    throw new RuntimeError(309 /* RuntimeErrorCode.DUPLICATE_DIRECTITVE */, `Directive ${directiveDef.type.name} matches multiple times on the same element. ` + `Directives can only match an element once.`);\n  }\n  validateMappings('input', directiveDef, hostDirectiveConfig.inputs);\n  validateMappings('output', directiveDef, hostDirectiveConfig.outputs);\n}\n/**\n * Checks that the host directive inputs/outputs configuration is valid.\n * @param bindingType Kind of binding that is being validated. Used in the error message.\n * @param def Definition of the host directive that is being validated against.\n * @param hostDirectiveBindings Host directive mapping object that shold be validated.\n */\nfunction validateMappings(bindingType, def, hostDirectiveBindings) {\n  const className = def.type.name;\n  const bindings = bindingType === 'input' ? def.inputs : def.outputs;\n  for (const publicName in hostDirectiveBindings) {\n    if (hostDirectiveBindings.hasOwnProperty(publicName)) {\n      if (!bindings.hasOwnProperty(publicName)) {\n        throw new RuntimeError(311 /* RuntimeErrorCode.HOST_DIRECTIVE_UNDEFINED_BINDING */, `Directive ${className} does not have an ${bindingType} with a public name of ${publicName}.`);\n      }\n      const remappedPublicName = hostDirectiveBindings[publicName];\n      if (bindings.hasOwnProperty(remappedPublicName) && remappedPublicName !== publicName && bindings[remappedPublicName] !== publicName) {\n        throw new RuntimeError(312 /* RuntimeErrorCode.HOST_DIRECTIVE_CONFLICTING_ALIAS */, `Cannot alias ${bindingType} ${publicName} of host directive ${className} to ${remappedPublicName}, because it already has a different ${bindingType} with the same public name.`);\n      }\n    }\n  }\n}\n\n/**\n * Decorates the directive definition with support for input transform functions.\n *\n * If the directive uses inheritance, the feature should be included before the\n * `InheritDefinitionFeature` to ensure that the `inputTransforms` field is populated.\n *\n * @codeGenApi\n */\nfunction ɵɵInputTransformsFeature(definition) {\n  const inputs = definition.inputConfig;\n  const inputTransforms = {};\n  for (const minifiedKey in inputs) {\n    if (inputs.hasOwnProperty(minifiedKey)) {\n      // Note: the private names are used for the keys, rather than the public ones, because public\n      // names can be re-aliased in host directives which would invalidate the lookup.\n      const value = inputs[minifiedKey];\n      if (Array.isArray(value) && value[2]) {\n        inputTransforms[minifiedKey] = value[2];\n      }\n    }\n  }\n  definition.inputTransforms = inputTransforms;\n}\nfunction isIterable(obj) {\n  return obj !== null && typeof obj === 'object' && obj[Symbol.iterator] !== undefined;\n}\nfunction isListLikeIterable(obj) {\n  if (!isJsObject(obj)) return false;\n  return Array.isArray(obj) || !(obj instanceof Map) &&\n  // JS Map are iterables but return entries as [k, v]\n  Symbol.iterator in obj; // JS Iterable have a Symbol.iterator prop\n}\n\nfunction areIterablesEqual(a, b, comparator) {\n  const iterator1 = a[Symbol.iterator]();\n  const iterator2 = b[Symbol.iterator]();\n  while (true) {\n    const item1 = iterator1.next();\n    const item2 = iterator2.next();\n    if (item1.done && item2.done) return true;\n    if (item1.done || item2.done) return false;\n    if (!comparator(item1.value, item2.value)) return false;\n  }\n}\nfunction iterateListLike(obj, fn) {\n  if (Array.isArray(obj)) {\n    for (let i = 0; i < obj.length; i++) {\n      fn(obj[i]);\n    }\n  } else {\n    const iterator = obj[Symbol.iterator]();\n    let item;\n    while (!(item = iterator.next()).done) {\n      fn(item.value);\n    }\n  }\n}\nfunction isJsObject(o) {\n  return o !== null && (typeof o === 'function' || typeof o === 'object');\n}\nfunction devModeEqual(a, b) {\n  const isListLikeIterableA = isListLikeIterable(a);\n  const isListLikeIterableB = isListLikeIterable(b);\n  if (isListLikeIterableA && isListLikeIterableB) {\n    return areIterablesEqual(a, b, devModeEqual);\n  } else {\n    const isAObject = a && (typeof a === 'object' || typeof a === 'function');\n    const isBObject = b && (typeof b === 'object' || typeof b === 'function');\n    if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {\n      return true;\n    } else {\n      return Object.is(a, b);\n    }\n  }\n}\n\n// TODO(misko): consider inlining\n/** Updates binding and returns the value. */\nfunction updateBinding(lView, bindingIndex, value) {\n  return lView[bindingIndex] = value;\n}\n/** Gets the current binding value. */\nfunction getBinding(lView, bindingIndex) {\n  ngDevMode && assertIndexInRange(lView, bindingIndex);\n  ngDevMode && assertNotSame(lView[bindingIndex], NO_CHANGE, 'Stored value should never be NO_CHANGE.');\n  return lView[bindingIndex];\n}\n/**\n * Updates binding if changed, then returns whether it was updated.\n *\n * This function also checks the `CheckNoChangesMode` and throws if changes are made.\n * Some changes (Objects/iterables) during `CheckNoChangesMode` are exempt to comply with VE\n * behavior.\n *\n * @param lView current `LView`\n * @param bindingIndex The binding in the `LView` to check\n * @param value New value to check against `lView[bindingIndex]`\n * @returns `true` if the bindings has changed. (Throws if binding has changed during\n *          `CheckNoChangesMode`)\n */\nfunction bindingUpdated(lView, bindingIndex, value) {\n  ngDevMode && assertNotSame(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');\n  ngDevMode && assertLessThan(bindingIndex, lView.length, `Slot should have been initialized to NO_CHANGE`);\n  const oldValue = lView[bindingIndex];\n  if (Object.is(oldValue, value)) {\n    return false;\n  } else {\n    if (ngDevMode && isInCheckNoChangesMode()) {\n      // View engine didn't report undefined values as changed on the first checkNoChanges pass\n      // (before the change detection was run).\n      const oldValueToCompare = oldValue !== NO_CHANGE ? oldValue : undefined;\n      if (!devModeEqual(oldValueToCompare, value)) {\n        const details = getExpressionChangedErrorDetails(lView, bindingIndex, oldValueToCompare, value);\n        throwErrorIfNoChangesMode(oldValue === NO_CHANGE, details.oldValue, details.newValue, details.propName, lView);\n      }\n      // There was a change, but the `devModeEqual` decided that the change is exempt from an error.\n      // For this reason we exit as if no change. The early exit is needed to prevent the changed\n      // value to be written into `LView` (If we would write the new value that we would not see it\n      // as change on next CD.)\n      return false;\n    }\n    lView[bindingIndex] = value;\n    return true;\n  }\n}\n/** Updates 2 bindings if changed, then returns whether either was updated. */\nfunction bindingUpdated2(lView, bindingIndex, exp1, exp2) {\n  const different = bindingUpdated(lView, bindingIndex, exp1);\n  return bindingUpdated(lView, bindingIndex + 1, exp2) || different;\n}\n/** Updates 3 bindings if changed, then returns whether any was updated. */\nfunction bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) {\n  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);\n  return bindingUpdated(lView, bindingIndex + 2, exp3) || different;\n}\n/** Updates 4 bindings if changed, then returns whether any was updated. */\nfunction bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) {\n  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);\n  return bindingUpdated2(lView, bindingIndex + 2, exp3, exp4) || different;\n}\n\n/**\n * Updates the value of or removes a bound attribute on an Element.\n *\n * Used in the case of `[attr.title]=\"value\"`\n *\n * @param name name The name of the attribute.\n * @param value value The attribute is removed when value is `null` or `undefined`.\n *                  Otherwise the attribute value is set to the stringified value.\n * @param sanitizer An optional function used to sanitize the value.\n * @param namespace Optional namespace to use when setting the attribute.\n *\n * @codeGenApi\n */\nfunction ɵɵattribute(name, value, sanitizer, namespace) {\n  const lView = getLView();\n  const bindingIndex = nextBindingIndex();\n  if (bindingUpdated(lView, bindingIndex, value)) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, 'attr.' + name, bindingIndex);\n  }\n  return ɵɵattribute;\n}\n\n/**\n * Create interpolation bindings with a variable number of expressions.\n *\n * If there are 1 to 8 expressions `interpolation1()` to `interpolation8()` should be used instead.\n * Those are faster because there is no need to create an array of expressions and iterate over it.\n *\n * `values`:\n * - has static text at even indexes,\n * - has evaluated expressions at odd indexes.\n *\n * Returns the concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nfunction interpolationV(lView, values) {\n  ngDevMode && assertLessThan(2, values.length, 'should have at least 3 values');\n  ngDevMode && assertEqual(values.length % 2, 1, 'should have an odd number of values');\n  let isBindingUpdated = false;\n  let bindingIndex = getBindingIndex();\n  for (let i = 1; i < values.length; i += 2) {\n    // Check if bindings (odd indexes) have changed\n    isBindingUpdated = bindingUpdated(lView, bindingIndex++, values[i]) || isBindingUpdated;\n  }\n  setBindingIndex(bindingIndex);\n  if (!isBindingUpdated) {\n    return NO_CHANGE;\n  }\n  // Build the updated content\n  let content = values[0];\n  for (let i = 1; i < values.length; i += 2) {\n    content += renderStringify(values[i]) + values[i + 1];\n  }\n  return content;\n}\n/**\n * Creates an interpolation binding with 1 expression.\n *\n * @param prefix static value used for concatenation only.\n * @param v0 value checked for change.\n * @param suffix static value used for concatenation only.\n */\nfunction interpolation1(lView, prefix, v0, suffix) {\n  const different = bindingUpdated(lView, nextBindingIndex(), v0);\n  return different ? prefix + renderStringify(v0) + suffix : NO_CHANGE;\n}\n/**\n * Creates an interpolation binding with 2 expressions.\n */\nfunction interpolation2(lView, prefix, v0, i0, v1, suffix) {\n  const bindingIndex = getBindingIndex();\n  const different = bindingUpdated2(lView, bindingIndex, v0, v1);\n  incrementBindingIndex(2);\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + suffix : NO_CHANGE;\n}\n/**\n * Creates an interpolation binding with 3 expressions.\n */\nfunction interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix) {\n  const bindingIndex = getBindingIndex();\n  const different = bindingUpdated3(lView, bindingIndex, v0, v1, v2);\n  incrementBindingIndex(3);\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + suffix : NO_CHANGE;\n}\n/**\n * Create an interpolation binding with 4 expressions.\n */\nfunction interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {\n  const bindingIndex = getBindingIndex();\n  const different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  incrementBindingIndex(4);\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + suffix : NO_CHANGE;\n}\n/**\n * Creates an interpolation binding with 5 expressions.\n */\nfunction interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {\n  const bindingIndex = getBindingIndex();\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated(lView, bindingIndex + 4, v4) || different;\n  incrementBindingIndex(5);\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + suffix : NO_CHANGE;\n}\n/**\n * Creates an interpolation binding with 6 expressions.\n */\nfunction interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {\n  const bindingIndex = getBindingIndex();\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated2(lView, bindingIndex + 4, v4, v5) || different;\n  incrementBindingIndex(6);\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + suffix : NO_CHANGE;\n}\n/**\n * Creates an interpolation binding with 7 expressions.\n */\nfunction interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {\n  const bindingIndex = getBindingIndex();\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated3(lView, bindingIndex + 4, v4, v5, v6) || different;\n  incrementBindingIndex(7);\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + suffix : NO_CHANGE;\n}\n/**\n * Creates an interpolation binding with 8 expressions.\n */\nfunction interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {\n  const bindingIndex = getBindingIndex();\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated4(lView, bindingIndex + 4, v4, v5, v6, v7) || different;\n  incrementBindingIndex(8);\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + i6 + renderStringify(v7) + suffix : NO_CHANGE;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate1('title', 'prefix', v0, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵattributeInterpolate1(attrName, prefix, v0, suffix, sanitizer, namespace) {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 1, prefix, suffix);\n  }\n  return ɵɵattributeInterpolate1;\n}\n/**\n *\n * Update an interpolated attribute on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate2('title', 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵattributeInterpolate2(attrName, prefix, v0, i0, v1, suffix, sanitizer, namespace) {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 2, prefix, i0, suffix);\n  }\n  return ɵɵattributeInterpolate2;\n}\n/**\n *\n * Update an interpolated attribute on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate3(\n * 'title', 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵattributeInterpolate3(attrName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer, namespace) {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 3, prefix, i0, i1, suffix);\n  }\n  return ɵɵattributeInterpolate3;\n}\n/**\n *\n * Update an interpolated attribute on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate4(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵattributeInterpolate4(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer, namespace) {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);\n  }\n  return ɵɵattributeInterpolate4;\n}\n/**\n *\n * Update an interpolated attribute on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate5(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵattributeInterpolate5(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer, namespace) {\n  const lView = getLView();\n  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);\n  }\n  return ɵɵattributeInterpolate5;\n}\n/**\n *\n * Update an interpolated attribute on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate6(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵattributeInterpolate6(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer, namespace) {\n  const lView = getLView();\n  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);\n  }\n  return ɵɵattributeInterpolate6;\n}\n/**\n *\n * Update an interpolated attribute on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate7(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵattributeInterpolate7(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer, namespace) {\n  const lView = getLView();\n  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5, suffix);\n  }\n  return ɵɵattributeInterpolate7;\n}\n/**\n *\n * Update an interpolated attribute on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate8(\n *  'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵattributeInterpolate8(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer, namespace) {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6, suffix);\n  }\n  return ɵɵattributeInterpolate8;\n}\n/**\n * Update an interpolated attribute on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolateV(\n *  'title', ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * @param attrName The name of the attribute to update.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵattributeInterpolateV(attrName, values, sanitizer, namespace) {\n  const lView = getLView();\n  const interpolated = interpolationV(lView, values);\n  if (interpolated !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolated, sanitizer, namespace);\n    if (ngDevMode) {\n      const interpolationInBetween = [values[0]]; // prefix\n      for (let i = 2; i < values.length; i += 2) {\n        interpolationInBetween.push(values[i]);\n      }\n      storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);\n    }\n  }\n  return ɵɵattributeInterpolateV;\n}\nconst AT_THIS_LOCATION = '<-- AT THIS LOCATION';\n/**\n * Retrieves a user friendly string for a given TNodeType for use in\n * friendly error messages\n *\n * @param tNodeType\n * @returns\n */\nfunction getFriendlyStringFromTNodeType(tNodeType) {\n  switch (tNodeType) {\n    case 4 /* TNodeType.Container */:\n      return 'view container';\n    case 2 /* TNodeType.Element */:\n      return 'element';\n    case 8 /* TNodeType.ElementContainer */:\n      return 'ng-container';\n    case 32 /* TNodeType.Icu */:\n      return 'icu';\n    case 64 /* TNodeType.Placeholder */:\n      return 'i18n';\n    case 16 /* TNodeType.Projection */:\n      return 'projection';\n    case 1 /* TNodeType.Text */:\n      return 'text';\n    default:\n      // This should not happen as we cover all possible TNode types above.\n      return '<unknown>';\n  }\n}\n/**\n * Validates that provided nodes match during the hydration process.\n */\nfunction validateMatchingNode(node, nodeType, tagName, lView, tNode, isViewContainerAnchor = false) {\n  if (!node || node.nodeType !== nodeType || node.nodeType === Node.ELEMENT_NODE && node.tagName.toLowerCase() !== tagName?.toLowerCase()) {\n    const expectedNode = shortRNodeDescription(nodeType, tagName, null);\n    let header = `During hydration Angular expected ${expectedNode} but `;\n    const hostComponentDef = getDeclarationComponentDef(lView);\n    const componentClassName = hostComponentDef?.type?.name;\n    const expected = `Angular expected this DOM:\\n\\n${describeExpectedDom(lView, tNode, isViewContainerAnchor)}\\n\\n`;\n    let actual = '';\n    if (!node) {\n      // No node found during hydration.\n      header += `the node was not found.\\n\\n`;\n    } else {\n      const actualNode = shortRNodeDescription(node.nodeType, node.tagName ?? null, node.textContent ?? null);\n      header += `found ${actualNode}.\\n\\n`;\n      actual = `Actual DOM is:\\n\\n${describeDomFromNode(node)}\\n\\n`;\n    }\n    const footer = getHydrationErrorFooter(componentClassName);\n    const message = header + expected + actual + getHydrationAttributeNote() + footer;\n    throw new RuntimeError(-500 /* RuntimeErrorCode.HYDRATION_NODE_MISMATCH */, message);\n  }\n}\n/**\n * Validates that a given node has sibling nodes\n */\nfunction validateSiblingNodeExists(node) {\n  validateNodeExists(node);\n  if (!node.nextSibling) {\n    const header = 'During hydration Angular expected more sibling nodes to be present.\\n\\n';\n    const actual = `Actual DOM is:\\n\\n${describeDomFromNode(node)}\\n\\n`;\n    const footer = getHydrationErrorFooter();\n    const message = header + actual + footer;\n    throw new RuntimeError(-501 /* RuntimeErrorCode.HYDRATION_MISSING_SIBLINGS */, message);\n  }\n}\n/**\n * Validates that a node exists or throws\n */\nfunction validateNodeExists(node, lView = null, tNode = null) {\n  if (!node) {\n    const header = 'During hydration, Angular expected an element to be present at this location.\\n\\n';\n    let expected = '';\n    let footer = '';\n    if (lView !== null && tNode !== null) {\n      expected = `${describeExpectedDom(lView, tNode, false)}\\n\\n`;\n      footer = getHydrationErrorFooter();\n    }\n    throw new RuntimeError(-502 /* RuntimeErrorCode.HYDRATION_MISSING_NODE */, header + expected + footer);\n  }\n}\n/**\n * Builds the hydration error message when a node is not found\n *\n * @param lView the LView where the node exists\n * @param tNode the TNode\n */\nfunction nodeNotFoundError(lView, tNode) {\n  const header = 'During serialization, Angular was unable to find an element in the DOM:\\n\\n';\n  const expected = `${describeExpectedDom(lView, tNode, false)}\\n\\n`;\n  const footer = getHydrationErrorFooter();\n  throw new RuntimeError(-502 /* RuntimeErrorCode.HYDRATION_MISSING_NODE */, header + expected + footer);\n}\n/**\n * Builds a hydration error message when a node is not found at a path location\n *\n * @param host the Host Node\n * @param path the path to the node\n */\nfunction nodeNotFoundAtPathError(host, path) {\n  const header = `During hydration Angular was unable to locate a node ` + `using the \"${path}\" path, starting from the ${describeRNode(host)} node.\\n\\n`;\n  const footer = getHydrationErrorFooter();\n  throw new RuntimeError(-502 /* RuntimeErrorCode.HYDRATION_MISSING_NODE */, header + footer);\n}\n/**\n * Builds the hydration error message in the case that dom nodes are created outside of\n * the Angular context and are being used as projected nodes\n *\n * @param lView the LView\n * @param tNode the TNode\n * @returns an error\n */\nfunction unsupportedProjectionOfDomNodes(rNode) {\n  const header = 'During serialization, Angular detected DOM nodes ' + 'that were created outside of Angular context and provided as projectable nodes ' + '(likely via `ViewContainerRef.createComponent` or `createComponent` APIs). ' + 'Hydration is not supported for such cases, consider refactoring the code to avoid ' + 'this pattern or using `ngSkipHydration` on the host element of the component.\\n\\n';\n  const actual = `${describeDomFromNode(rNode)}\\n\\n`;\n  const message = header + actual + getHydrationAttributeNote();\n  return new RuntimeError(-503 /* RuntimeErrorCode.UNSUPPORTED_PROJECTION_DOM_NODES */, message);\n}\n/**\n * Builds the hydration error message in the case that ngSkipHydration was used on a\n * node that is not a component host element or host binding\n *\n * @param rNode the HTML Element\n * @returns an error\n */\nfunction invalidSkipHydrationHost(rNode) {\n  const header = 'The `ngSkipHydration` flag is applied on a node ' + 'that doesn\\'t act as a component host. Hydration can be ' + 'skipped only on per-component basis.\\n\\n';\n  const actual = `${describeDomFromNode(rNode)}\\n\\n`;\n  const footer = 'Please move the `ngSkipHydration` attribute to the component host element.\\n\\n';\n  const message = header + actual + footer;\n  return new RuntimeError(-504 /* RuntimeErrorCode.INVALID_SKIP_HYDRATION_HOST */, message);\n}\n// Stringification methods\n/**\n * Stringifies a given TNode's attributes\n *\n * @param tNode a provided TNode\n * @returns string\n */\nfunction stringifyTNodeAttrs(tNode) {\n  const results = [];\n  if (tNode.attrs) {\n    for (let i = 0; i < tNode.attrs.length;) {\n      const attrName = tNode.attrs[i++];\n      // Once we reach the first flag, we know that the list of\n      // attributes is over.\n      if (typeof attrName == 'number') {\n        break;\n      }\n      const attrValue = tNode.attrs[i++];\n      results.push(`${attrName}=\"${shorten(attrValue)}\"`);\n    }\n  }\n  return results.join(' ');\n}\n/**\n * The list of internal attributes that should be filtered out while\n * producing an error message.\n */\nconst internalAttrs = new Set(['ngh', 'ng-version', 'ng-server-context']);\n/**\n * Stringifies an HTML Element's attributes\n *\n * @param rNode an HTML Element\n * @returns string\n */\nfunction stringifyRNodeAttrs(rNode) {\n  const results = [];\n  for (let i = 0; i < rNode.attributes.length; i++) {\n    const attr = rNode.attributes[i];\n    if (internalAttrs.has(attr.name)) continue;\n    results.push(`${attr.name}=\"${shorten(attr.value)}\"`);\n  }\n  return results.join(' ');\n}\n// Methods for Describing the DOM\n/**\n * Converts a tNode to a helpful readable string value for use in error messages\n *\n * @param tNode a given TNode\n * @param innerContent the content of the node\n * @returns string\n */\nfunction describeTNode(tNode, innerContent = '…') {\n  switch (tNode.type) {\n    case 1 /* TNodeType.Text */:\n      const content = tNode.value ? `(${tNode.value})` : '';\n      return `#text${content}`;\n    case 2 /* TNodeType.Element */:\n      const attrs = stringifyTNodeAttrs(tNode);\n      const tag = tNode.value.toLowerCase();\n      return `<${tag}${attrs ? ' ' + attrs : ''}>${innerContent}</${tag}>`;\n    case 8 /* TNodeType.ElementContainer */:\n      return '<!-- ng-container -->';\n    case 4 /* TNodeType.Container */:\n      return '<!-- container -->';\n    default:\n      const typeAsString = getFriendlyStringFromTNodeType(tNode.type);\n      return `#node(${typeAsString})`;\n  }\n}\n/**\n * Converts an RNode to a helpful readable string value for use in error messages\n *\n * @param rNode a given RNode\n * @param innerContent the content of the node\n * @returns string\n */\nfunction describeRNode(rNode, innerContent = '…') {\n  const node = rNode;\n  switch (node.nodeType) {\n    case Node.ELEMENT_NODE:\n      const tag = node.tagName.toLowerCase();\n      const attrs = stringifyRNodeAttrs(node);\n      return `<${tag}${attrs ? ' ' + attrs : ''}>${innerContent}</${tag}>`;\n    case Node.TEXT_NODE:\n      const content = node.textContent ? shorten(node.textContent) : '';\n      return `#text${content ? `(${content})` : ''}`;\n    case Node.COMMENT_NODE:\n      return `<!-- ${shorten(node.textContent ?? '')} -->`;\n    default:\n      return `#node(${node.nodeType})`;\n  }\n}\n/**\n * Builds the string containing the expected DOM present given the LView and TNode\n * values for a readable error message\n *\n * @param lView the lView containing the DOM\n * @param tNode the tNode\n * @param isViewContainerAnchor boolean\n * @returns string\n */\nfunction describeExpectedDom(lView, tNode, isViewContainerAnchor) {\n  const spacer = '  ';\n  let content = '';\n  if (tNode.prev) {\n    content += spacer + '…\\n';\n    content += spacer + describeTNode(tNode.prev) + '\\n';\n  } else if (tNode.type && tNode.type & 12 /* TNodeType.AnyContainer */) {\n    content += spacer + '…\\n';\n  }\n  if (isViewContainerAnchor) {\n    content += spacer + describeTNode(tNode) + '\\n';\n    content += spacer + `<!-- container -->  ${AT_THIS_LOCATION}\\n`;\n  } else {\n    content += spacer + describeTNode(tNode) + `  ${AT_THIS_LOCATION}\\n`;\n  }\n  content += spacer + '…\\n';\n  const parentRNode = tNode.type ? getParentRElement(lView[TVIEW], tNode, lView) : null;\n  if (parentRNode) {\n    content = describeRNode(parentRNode, '\\n' + content);\n  }\n  return content;\n}\n/**\n * Builds the string containing the DOM present around a given RNode for a\n * readable error message\n *\n * @param node the RNode\n * @returns string\n */\nfunction describeDomFromNode(node) {\n  const spacer = '  ';\n  let content = '';\n  const currentNode = node;\n  if (currentNode.previousSibling) {\n    content += spacer + '…\\n';\n    content += spacer + describeRNode(currentNode.previousSibling) + '\\n';\n  }\n  content += spacer + describeRNode(currentNode) + `  ${AT_THIS_LOCATION}\\n`;\n  if (node.nextSibling) {\n    content += spacer + '…\\n';\n  }\n  if (node.parentNode) {\n    content = describeRNode(currentNode.parentNode, '\\n' + content);\n  }\n  return content;\n}\n/**\n * Shortens the description of a given RNode by its type for readability\n *\n * @param nodeType the type of node\n * @param tagName the node tag name\n * @param textContent the text content in the node\n * @returns string\n */\nfunction shortRNodeDescription(nodeType, tagName, textContent) {\n  switch (nodeType) {\n    case Node.ELEMENT_NODE:\n      return `<${tagName.toLowerCase()}>`;\n    case Node.TEXT_NODE:\n      const content = textContent ? ` (with the \"${shorten(textContent)}\" content)` : '';\n      return `a text node${content}`;\n    case Node.COMMENT_NODE:\n      return 'a comment node';\n    default:\n      return `#node(nodeType=${nodeType})`;\n  }\n}\n/**\n * Builds the footer hydration error message\n *\n * @param componentClassName the name of the component class\n * @returns string\n */\nfunction getHydrationErrorFooter(componentClassName) {\n  const componentInfo = componentClassName ? `the \"${componentClassName}\"` : 'corresponding';\n  return `To fix this problem:\\n` + `  * check ${componentInfo} component for hydration-related issues\\n` + `  * check to see if your template has valid HTML structure\\n` + `  * or skip hydration by adding the \\`ngSkipHydration\\` attribute ` + `to its host node in a template\\n\\n`;\n}\n/**\n * An attribute related note for hydration errors\n */\nfunction getHydrationAttributeNote() {\n  return 'Note: attributes are only displayed to better represent the DOM' + ' but have no effect on hydration mismatches.\\n\\n';\n}\n// Node string utility functions\n/**\n * Strips all newlines out of a given string\n *\n * @param input a string to be cleared of new line characters\n * @returns\n */\nfunction stripNewlines(input) {\n  return input.replace(/\\s+/gm, '');\n}\n/**\n * Reduces a string down to a maximum length of characters with ellipsis for readability\n *\n * @param input a string input\n * @param maxLength a maximum length in characters\n * @returns string\n */\nfunction shorten(input, maxLength = 50) {\n  if (!input) {\n    return '';\n  }\n  input = stripNewlines(input);\n  return input.length > maxLength ? `${input.substring(0, maxLength - 1)}…` : input;\n}\n\n/**\n * Regexp that extracts a reference node information from the compressed node location.\n * The reference node is represented as either:\n *  - a number which points to an LView slot\n *  - the `b` char which indicates that the lookup should start from the `document.body`\n *  - the `h` char to start lookup from the component host node (`lView[HOST]`)\n */\nconst REF_EXTRACTOR_REGEXP = new RegExp(`^(\\\\d+)*(${REFERENCE_NODE_BODY}|${REFERENCE_NODE_HOST})*(.*)`);\n/**\n * Helper function that takes a reference node location and a set of navigation steps\n * (from the reference node) to a target node and outputs a string that represents\n * a location.\n *\n * For example, given: referenceNode = 'b' (body) and path = ['firstChild', 'firstChild',\n * 'nextSibling'], the function returns: `bf2n`.\n */\nfunction compressNodeLocation(referenceNode, path) {\n  const result = [referenceNode];\n  for (const segment of path) {\n    const lastIdx = result.length - 1;\n    if (lastIdx > 0 && result[lastIdx - 1] === segment) {\n      // An empty string in a count slot represents 1 occurrence of an instruction.\n      const value = result[lastIdx] || 1;\n      result[lastIdx] = value + 1;\n    } else {\n      // Adding a new segment to the path.\n      // Using an empty string in a counter field to avoid encoding `1`s\n      // into the path, since they are implicit (e.g. `f1n1` vs `fn`), so\n      // it's enough to have a single char in this case.\n      result.push(segment, '');\n    }\n  }\n  return result.join('');\n}\n/**\n * Helper function that reverts the `compressNodeLocation` and transforms a given\n * string into an array where at 0th position there is a reference node info and\n * after that it contains information (in pairs) about a navigation step and the\n * number of repetitions.\n *\n * For example, the path like 'bf2n' will be transformed to:\n * ['b', 'firstChild', 2, 'nextSibling', 1].\n *\n * This information is later consumed by the code that navigates the DOM to find\n * a given node by its location.\n */\nfunction decompressNodeLocation(path) {\n  const matches = path.match(REF_EXTRACTOR_REGEXP);\n  const [_, refNodeId, refNodeName, rest] = matches;\n  // If a reference node is represented by an index, transform it to a number.\n  const ref = refNodeId ? parseInt(refNodeId, 10) : refNodeName;\n  const steps = [];\n  // Match all segments in a path.\n  for (const [_, step, count] of rest.matchAll(/(f|n)(\\d*)/g)) {\n    const repeat = parseInt(count, 10) || 1;\n    steps.push(step, repeat);\n  }\n  return [ref, ...steps];\n}\n\n/** Whether current TNode is a first node in an <ng-container>. */\nfunction isFirstElementInNgContainer(tNode) {\n  return !tNode.prev && tNode.parent?.type === 8 /* TNodeType.ElementContainer */;\n}\n/** Returns an instruction index (subtracting HEADER_OFFSET). */\nfunction getNoOffsetIndex(tNode) {\n  return tNode.index - HEADER_OFFSET;\n}\n/**\n * Locate a node in DOM tree that corresponds to a given TNode.\n *\n * @param hydrationInfo The hydration annotation data\n * @param tView the current tView\n * @param lView the current lView\n * @param tNode the current tNode\n * @returns an RNode that represents a given tNode\n */\nfunction locateNextRNode(hydrationInfo, tView, lView, tNode) {\n  let native = null;\n  const noOffsetIndex = getNoOffsetIndex(tNode);\n  const nodes = hydrationInfo.data[NODES];\n  if (nodes?.[noOffsetIndex]) {\n    // We know the exact location of the node.\n    native = locateRNodeByPath(nodes[noOffsetIndex], lView);\n  } else if (tView.firstChild === tNode) {\n    // We create a first node in this view, so we use a reference\n    // to the first child in this DOM segment.\n    native = hydrationInfo.firstChild;\n  } else {\n    // Locate a node based on a previous sibling or a parent node.\n    const previousTNodeParent = tNode.prev === null;\n    const previousTNode = tNode.prev ?? tNode.parent;\n    ngDevMode && assertDefined(previousTNode, 'Unexpected state: current TNode does not have a connection ' + 'to the previous node or a parent node.');\n    if (isFirstElementInNgContainer(tNode)) {\n      const noOffsetParentIndex = getNoOffsetIndex(tNode.parent);\n      native = getSegmentHead(hydrationInfo, noOffsetParentIndex);\n    } else {\n      let previousRElement = getNativeByTNode(previousTNode, lView);\n      if (previousTNodeParent) {\n        native = previousRElement.firstChild;\n      } else {\n        // If the previous node is an element, but it also has container info,\n        // this means that we are processing a node like `<div #vcrTarget>`, which is\n        // represented in the DOM as `<div></div>...<!--container-->`.\n        // In this case, there are nodes *after* this element and we need to skip\n        // all of them to reach an element that we are looking for.\n        const noOffsetPrevSiblingIndex = getNoOffsetIndex(previousTNode);\n        const segmentHead = getSegmentHead(hydrationInfo, noOffsetPrevSiblingIndex);\n        if (previousTNode.type === 2 /* TNodeType.Element */ && segmentHead) {\n          const numRootNodesToSkip = calcSerializedContainerSize(hydrationInfo, noOffsetPrevSiblingIndex);\n          // `+1` stands for an anchor comment node after all the views in this container.\n          const nodesToSkip = numRootNodesToSkip + 1;\n          // First node after this segment.\n          native = siblingAfter(nodesToSkip, segmentHead);\n        } else {\n          native = previousRElement.nextSibling;\n        }\n      }\n    }\n  }\n  return native;\n}\n/**\n * Skips over a specified number of nodes and returns the next sibling node after that.\n */\nfunction siblingAfter(skip, from) {\n  let currentNode = from;\n  for (let i = 0; i < skip; i++) {\n    ngDevMode && validateSiblingNodeExists(currentNode);\n    currentNode = currentNode.nextSibling;\n  }\n  return currentNode;\n}\n/**\n * Helper function to produce a string representation of the navigation steps\n * (in terms of `nextSibling` and `firstChild` navigations). Used in error\n * messages in dev mode.\n */\nfunction stringifyNavigationInstructions(instructions) {\n  const container = [];\n  for (let i = 0; i < instructions.length; i += 2) {\n    const step = instructions[i];\n    const repeat = instructions[i + 1];\n    for (let r = 0; r < repeat; r++) {\n      container.push(step === NodeNavigationStep.FirstChild ? 'firstChild' : 'nextSibling');\n    }\n  }\n  return container.join('.');\n}\n/**\n * Helper function that navigates from a starting point node (the `from` node)\n * using provided set of navigation instructions (within `path` argument).\n */\nfunction navigateToNode(from, instructions) {\n  let node = from;\n  for (let i = 0; i < instructions.length; i += 2) {\n    const step = instructions[i];\n    const repeat = instructions[i + 1];\n    for (let r = 0; r < repeat; r++) {\n      if (ngDevMode && !node) {\n        throw nodeNotFoundAtPathError(from, stringifyNavigationInstructions(instructions));\n      }\n      switch (step) {\n        case NodeNavigationStep.FirstChild:\n          node = node.firstChild;\n          break;\n        case NodeNavigationStep.NextSibling:\n          node = node.nextSibling;\n          break;\n      }\n    }\n  }\n  if (ngDevMode && !node) {\n    throw nodeNotFoundAtPathError(from, stringifyNavigationInstructions(instructions));\n  }\n  return node;\n}\n/**\n * Locates an RNode given a set of navigation instructions (which also contains\n * a starting point node info).\n */\nfunction locateRNodeByPath(path, lView) {\n  const [referenceNode, ...navigationInstructions] = decompressNodeLocation(path);\n  let ref;\n  if (referenceNode === REFERENCE_NODE_HOST) {\n    ref = lView[DECLARATION_COMPONENT_VIEW][HOST];\n  } else if (referenceNode === REFERENCE_NODE_BODY) {\n    ref = ɵɵresolveBody(lView[DECLARATION_COMPONENT_VIEW][HOST]);\n  } else {\n    const parentElementId = Number(referenceNode);\n    ref = unwrapRNode(lView[parentElementId + HEADER_OFFSET]);\n  }\n  return navigateToNode(ref, navigationInstructions);\n}\n/**\n * Generate a list of DOM navigation operations to get from node `start` to node `finish`.\n *\n * Note: assumes that node `start` occurs before node `finish` in an in-order traversal of the DOM\n * tree. That is, we should be able to get from `start` to `finish` purely by using `.firstChild`\n * and `.nextSibling` operations.\n */\nfunction navigateBetween(start, finish) {\n  if (start === finish) {\n    return [];\n  } else if (start.parentElement == null || finish.parentElement == null) {\n    return null;\n  } else if (start.parentElement === finish.parentElement) {\n    return navigateBetweenSiblings(start, finish);\n  } else {\n    // `finish` is a child of its parent, so the parent will always have a child.\n    const parent = finish.parentElement;\n    const parentPath = navigateBetween(start, parent);\n    const childPath = navigateBetween(parent.firstChild, finish);\n    if (!parentPath || !childPath) return null;\n    return [\n    // First navigate to `finish`'s parent\n    ...parentPath,\n    // Then to its first child.\n    NodeNavigationStep.FirstChild,\n    // And finally from that node to `finish` (maybe a no-op if we're already there).\n    ...childPath];\n  }\n}\n/**\n * Calculates a path between 2 sibling nodes (generates a number of `NextSibling` navigations).\n * Returns `null` if no such path exists between the given nodes.\n */\nfunction navigateBetweenSiblings(start, finish) {\n  const nav = [];\n  let node = null;\n  for (node = start; node != null && node !== finish; node = node.nextSibling) {\n    nav.push(NodeNavigationStep.NextSibling);\n  }\n  // If the `node` becomes `null` or `undefined` at the end, that means that we\n  // didn't find the `end` node, thus return `null` (which would trigger serialization\n  // error to be produced).\n  return node == null ? null : nav;\n}\n/**\n * Calculates a path between 2 nodes in terms of `nextSibling` and `firstChild`\n * navigations:\n * - the `from` node is a known node, used as an starting point for the lookup\n *   (the `fromNodeName` argument is a string representation of the node).\n * - the `to` node is a node that the runtime logic would be looking up,\n *   using the path generated by this function.\n */\nfunction calcPathBetween(from, to, fromNodeName) {\n  const path = navigateBetween(from, to);\n  return path === null ? null : compressNodeLocation(fromNodeName, path);\n}\n/**\n * Invoked at serialization time (on the server) when a set of navigation\n * instructions needs to be generated for a TNode.\n */\nfunction calcPathForNode(tNode, lView) {\n  const parentTNode = tNode.parent;\n  let parentIndex;\n  let parentRNode;\n  let referenceNodeName;\n  if (parentTNode === null || !(parentTNode.type & 3 /* TNodeType.AnyRNode */)) {\n    // If there is no parent TNode or a parent TNode does not represent an RNode\n    // (i.e. not a DOM node), use component host element as a reference node.\n    parentIndex = referenceNodeName = REFERENCE_NODE_HOST;\n    parentRNode = lView[DECLARATION_COMPONENT_VIEW][HOST];\n  } else {\n    // Use parent TNode as a reference node.\n    parentIndex = parentTNode.index;\n    parentRNode = unwrapRNode(lView[parentIndex]);\n    referenceNodeName = renderStringify(parentIndex - HEADER_OFFSET);\n  }\n  let rNode = unwrapRNode(lView[tNode.index]);\n  if (tNode.type & 12 /* TNodeType.AnyContainer */) {\n    // For <ng-container> nodes, instead of serializing a reference\n    // to the anchor comment node, serialize a location of the first\n    // DOM element. Paired with the container size (serialized as a part\n    // of `ngh.containers`), it should give enough information for runtime\n    // to hydrate nodes in this container.\n    const firstRNode = getFirstNativeNode(lView, tNode);\n    // If container is not empty, use a reference to the first element,\n    // otherwise, rNode would point to an anchor comment node.\n    if (firstRNode) {\n      rNode = firstRNode;\n    }\n  }\n  let path = calcPathBetween(parentRNode, rNode, referenceNodeName);\n  if (path === null && parentRNode !== rNode) {\n    // Searching for a path between elements within a host node failed.\n    // Trying to find a path to an element starting from the `document.body` instead.\n    //\n    // Important note: this type of reference is relatively unstable, since Angular\n    // may not be able to control parts of the page that the runtime logic navigates\n    // through. This is mostly needed to cover \"portals\" use-case (like menus, dialog boxes,\n    // etc), where nodes are content-projected (including direct DOM manipulations) outside\n    // of the host node. The better solution is to provide APIs to work with \"portals\",\n    // at which point this code path would not be needed.\n    const body = parentRNode.ownerDocument.body;\n    path = calcPathBetween(body, rNode, REFERENCE_NODE_BODY);\n    if (path === null) {\n      // If the path is still empty, it's likely that this node is detached and\n      // won't be found during hydration.\n      throw nodeNotFoundError(lView, tNode);\n    }\n  }\n  return path;\n}\nfunction templateFirstCreatePass(index, tView, lView, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex) {\n  ngDevMode && assertFirstCreatePass(tView);\n  ngDevMode && ngDevMode.firstCreatePass++;\n  const tViewConsts = tView.consts;\n  // TODO(pk): refactor getOrCreateTNode to have the \"create\" only version\n  const tNode = getOrCreateTNode(tView, index, 4 /* TNodeType.Container */, tagName || null, getConstant(tViewConsts, attrsIndex));\n  resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));\n  registerPostOrderHooks(tView, tNode);\n  const embeddedTView = tNode.tView = createTView(2 /* TViewType.Embedded */, tNode, templateFn, decls, vars, tView.directiveRegistry, tView.pipeRegistry, null, tView.schemas, tViewConsts, null /* ssrId */);\n  if (tView.queries !== null) {\n    tView.queries.template(tView, tNode);\n    embeddedTView.queries = tView.queries.embeddedTView(tNode);\n  }\n  return tNode;\n}\n/**\n * Creates an LContainer for an ng-template (dynamically-inserted view), e.g.\n *\n * <ng-template #foo>\n *    <div></div>\n * </ng-template>\n *\n * @param index The index of the container in the data array\n * @param templateFn Inline template\n * @param decls The number of nodes, local refs, and pipes for this template\n * @param vars The number of bindings for this template\n * @param tagName The name of the container element, if applicable\n * @param attrsIndex Index of template attributes in the `consts` array.\n * @param localRefs Index of the local references in the `consts` array.\n * @param localRefExtractor A function which extracts local-refs values from the template.\n *        Defaults to the current element associated with the local-ref.\n *\n * @codeGenApi\n */\nfunction ɵɵtemplate(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {\n  const lView = getLView();\n  const tView = getTView();\n  const adjustedIndex = index + HEADER_OFFSET;\n  const tNode = tView.firstCreatePass ? templateFirstCreatePass(adjustedIndex, tView, lView, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];\n  setCurrentTNode(tNode, false);\n  const comment = _locateOrCreateContainerAnchor(tView, lView, tNode, index);\n  if (wasLastNodeCreated()) {\n    appendChild(tView, lView, comment, tNode);\n  }\n  attachPatchData(comment, lView);\n  addToViewTree(lView, lView[adjustedIndex] = createLContainer(comment, lView, comment, tNode));\n  if (isDirectiveHost(tNode)) {\n    createDirectivesInstances(tView, lView, tNode);\n  }\n  if (localRefsIndex != null) {\n    saveResolvedLocalsInData(lView, tNode, localRefExtractor);\n  }\n}\nlet _locateOrCreateContainerAnchor = createContainerAnchorImpl;\n/**\n * Regular creation mode for LContainers and their anchor (comment) nodes.\n */\nfunction createContainerAnchorImpl(tView, lView, tNode, index) {\n  lastNodeWasCreated(true);\n  return lView[RENDERER].createComment(ngDevMode ? 'container' : '');\n}\n/**\n * Enables hydration code path (to lookup existing elements in DOM)\n * in addition to the regular creation mode for LContainers and their\n * anchor (comment) nodes.\n */\nfunction locateOrCreateContainerAnchorImpl(tView, lView, tNode, index) {\n  const hydrationInfo = lView[HYDRATION];\n  const isNodeCreationMode = !hydrationInfo || isInSkipHydrationBlock$1() || isDisconnectedNode(hydrationInfo, index);\n  lastNodeWasCreated(isNodeCreationMode);\n  // Regular creation mode.\n  if (isNodeCreationMode) {\n    return createContainerAnchorImpl(tView, lView, tNode, index);\n  }\n  const ssrId = hydrationInfo.data[TEMPLATES]?.[index] ?? null;\n  // Apply `ssrId` value to the underlying TView if it was not previously set.\n  //\n  // There might be situations when the same component is present in a template\n  // multiple times and some instances are opted-out of using hydration via\n  // `ngSkipHydration` attribute. In this scenario, at the time a TView is created,\n  // the `ssrId` might be `null` (if the first component is opted-out of hydration).\n  // The code below makes sure that the `ssrId` is applied to the TView if it's still\n  // `null` and verifies we never try to override it with a different value.\n  if (ssrId !== null && tNode.tView !== null) {\n    if (tNode.tView.ssrId === null) {\n      tNode.tView.ssrId = ssrId;\n    } else {\n      ngDevMode && assertEqual(tNode.tView.ssrId, ssrId, 'Unexpected value of the `ssrId` for this TView');\n    }\n  }\n  // Hydration mode, looking up existing elements in DOM.\n  const currentRNode = locateNextRNode(hydrationInfo, tView, lView, tNode);\n  ngDevMode && validateNodeExists(currentRNode, lView, tNode);\n  setSegmentHead(hydrationInfo, index, currentRNode);\n  const viewContainerSize = calcSerializedContainerSize(hydrationInfo, index);\n  const comment = siblingAfter(viewContainerSize, currentRNode);\n  if (ngDevMode) {\n    validateMatchingNode(comment, Node.COMMENT_NODE, null, lView, tNode);\n    markRNodeAsClaimedByHydration(comment);\n  }\n  return comment;\n}\nfunction enableLocateOrCreateContainerAnchorImpl() {\n  _locateOrCreateContainerAnchor = locateOrCreateContainerAnchorImpl;\n}\n\n/** Store a value in the `data` at a given `index`. */\nfunction store(tView, lView, index, value) {\n  // We don't store any static data for local variables, so the first time\n  // we see the template, we should store as null to avoid a sparse array\n  if (index >= tView.data.length) {\n    tView.data[index] = null;\n    tView.blueprint[index] = null;\n  }\n  lView[index] = value;\n}\n/**\n * Retrieves a local reference from the current contextViewData.\n *\n * If the reference to retrieve is in a parent view, this instruction is used in conjunction\n * with a nextContext() call, which walks up the tree and updates the contextViewData instance.\n *\n * @param index The index of the local ref in contextViewData.\n *\n * @codeGenApi\n */\nfunction ɵɵreference(index) {\n  const contextLView = getContextLView();\n  return load(contextLView, HEADER_OFFSET + index);\n}\n\n/**\n * Update a property on a selected element.\n *\n * Operates on the element selected by index via the {@link select} instruction.\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled\n *\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n * @returns This function returns itself so that it may be chained\n * (e.g. `property('name', ctx.name)('title', ctx.title)`)\n *\n * @codeGenApi\n */\nfunction ɵɵproperty(propName, value, sanitizer) {\n  const lView = getLView();\n  const bindingIndex = nextBindingIndex();\n  if (bindingUpdated(lView, bindingIndex, value)) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, false);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);\n  }\n  return ɵɵproperty;\n}\n/**\n * Given `<div style=\"...\" my-dir>` and `MyDir` with `@Input('style')` we need to write to\n * directive input.\n */\nfunction setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased) {\n  const inputs = tNode.inputs;\n  const property = isClassBased ? 'class' : 'style';\n  // We support both 'class' and `className` hence the fallback.\n  setInputsForProperty(tView, lView, inputs[property], property, value);\n}\nfunction elementStartFirstCreatePass(index, tView, lView, name, attrsIndex, localRefsIndex) {\n  ngDevMode && assertFirstCreatePass(tView);\n  ngDevMode && ngDevMode.firstCreatePass++;\n  const tViewConsts = tView.consts;\n  const attrs = getConstant(tViewConsts, attrsIndex);\n  const tNode = getOrCreateTNode(tView, index, 2 /* TNodeType.Element */, name, attrs);\n  resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));\n  if (tNode.attrs !== null) {\n    computeStaticStyling(tNode, tNode.attrs, false);\n  }\n  if (tNode.mergedAttrs !== null) {\n    computeStaticStyling(tNode, tNode.mergedAttrs, true);\n  }\n  if (tView.queries !== null) {\n    tView.queries.elementStart(tView, tNode);\n  }\n  return tNode;\n}\n/**\n * Create DOM element. The instruction must later be followed by `elementEnd()` call.\n *\n * @param index Index of the element in the LView array\n * @param name Name of the DOM Node\n * @param attrsIndex Index of the element's attributes in the `consts` array.\n * @param localRefsIndex Index of the element's local references in the `consts` array.\n * @returns This function returns itself so that it may be chained.\n *\n * Attributes and localRefs are passed as an array of strings where elements with an even index\n * hold an attribute name and elements with an odd index hold an attribute value, ex.:\n * ['id', 'warning5', 'class', 'alert']\n *\n * @codeGenApi\n */\nfunction ɵɵelementStart(index, name, attrsIndex, localRefsIndex) {\n  const lView = getLView();\n  const tView = getTView();\n  const adjustedIndex = HEADER_OFFSET + index;\n  ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, 'elements should be created before any bindings');\n  ngDevMode && assertIndexInRange(lView, adjustedIndex);\n  const renderer = lView[RENDERER];\n  const tNode = tView.firstCreatePass ? elementStartFirstCreatePass(adjustedIndex, tView, lView, name, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];\n  const native = _locateOrCreateElementNode(tView, lView, tNode, renderer, name, index);\n  lView[adjustedIndex] = native;\n  const hasDirectives = isDirectiveHost(tNode);\n  if (ngDevMode && tView.firstCreatePass) {\n    validateElementIsKnown(native, lView, tNode.value, tView.schemas, hasDirectives);\n  }\n  setCurrentTNode(tNode, true);\n  setupStaticAttributes(renderer, native, tNode);\n  if ((tNode.flags & 32 /* TNodeFlags.isDetached */) !== 32 /* TNodeFlags.isDetached */ && wasLastNodeCreated()) {\n    // In the i18n case, the translation may have removed this element, so only add it if it is not\n    // detached. See `TNodeType.Placeholder` and `LFrame.inI18n` for more context.\n    appendChild(tView, lView, native, tNode);\n  }\n  // any immediate children of a component or template container must be pre-emptively\n  // monkey-patched with the component view data so that the element can be inspected\n  // later on using any element discovery utility methods (see `element_discovery.ts`)\n  if (getElementDepthCount() === 0) {\n    attachPatchData(native, lView);\n  }\n  increaseElementDepthCount();\n  if (hasDirectives) {\n    createDirectivesInstances(tView, lView, tNode);\n    executeContentQueries(tView, tNode, lView);\n  }\n  if (localRefsIndex !== null) {\n    saveResolvedLocalsInData(lView, tNode);\n  }\n  return ɵɵelementStart;\n}\n/**\n * Mark the end of the element.\n * @returns This function returns itself so that it may be chained.\n *\n * @codeGenApi\n */\nfunction ɵɵelementEnd() {\n  let currentTNode = getCurrentTNode();\n  ngDevMode && assertDefined(currentTNode, 'No parent node to close.');\n  if (isCurrentTNodeParent()) {\n    setCurrentTNodeAsNotParent();\n  } else {\n    ngDevMode && assertHasParent(getCurrentTNode());\n    currentTNode = currentTNode.parent;\n    setCurrentTNode(currentTNode, false);\n  }\n  const tNode = currentTNode;\n  ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */);\n  if (isSkipHydrationRootTNode(tNode)) {\n    leaveSkipHydrationBlock();\n  }\n  decreaseElementDepthCount();\n  const tView = getTView();\n  if (tView.firstCreatePass) {\n    registerPostOrderHooks(tView, currentTNode);\n    if (isContentQueryHost(currentTNode)) {\n      tView.queries.elementEnd(currentTNode);\n    }\n  }\n  if (tNode.classesWithoutHost != null && hasClassInput(tNode)) {\n    setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.classesWithoutHost, true);\n  }\n  if (tNode.stylesWithoutHost != null && hasStyleInput(tNode)) {\n    setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.stylesWithoutHost, false);\n  }\n  return ɵɵelementEnd;\n}\n/**\n * Creates an empty element using {@link elementStart} and {@link elementEnd}\n *\n * @param index Index of the element in the data array\n * @param name Name of the DOM Node\n * @param attrsIndex Index of the element's attributes in the `consts` array.\n * @param localRefsIndex Index of the element's local references in the `consts` array.\n * @returns This function returns itself so that it may be chained.\n *\n * @codeGenApi\n */\nfunction ɵɵelement(index, name, attrsIndex, localRefsIndex) {\n  ɵɵelementStart(index, name, attrsIndex, localRefsIndex);\n  ɵɵelementEnd();\n  return ɵɵelement;\n}\nlet _locateOrCreateElementNode = (tView, lView, tNode, renderer, name, index) => {\n  lastNodeWasCreated(true);\n  return createElementNode(renderer, name, getNamespace$1());\n};\n/**\n * Enables hydration code path (to lookup existing elements in DOM)\n * in addition to the regular creation mode of element nodes.\n */\nfunction locateOrCreateElementNodeImpl(tView, lView, tNode, renderer, name, index) {\n  const hydrationInfo = lView[HYDRATION];\n  const isNodeCreationMode = !hydrationInfo || isInSkipHydrationBlock$1() || isDisconnectedNode(hydrationInfo, index);\n  lastNodeWasCreated(isNodeCreationMode);\n  // Regular creation mode.\n  if (isNodeCreationMode) {\n    return createElementNode(renderer, name, getNamespace$1());\n  }\n  // Hydration mode, looking up an existing element in DOM.\n  const native = locateNextRNode(hydrationInfo, tView, lView, tNode);\n  ngDevMode && validateMatchingNode(native, Node.ELEMENT_NODE, name, lView, tNode);\n  ngDevMode && markRNodeAsClaimedByHydration(native);\n  // This element might also be an anchor of a view container.\n  if (getSerializedContainerViews(hydrationInfo, index)) {\n    // Important note: this element acts as an anchor, but it's **not** a part\n    // of the embedded view, so we start the segment **after** this element, taking\n    // a reference to the next sibling. For example, the following template:\n    // `<div #vcrTarget>` is represented in the DOM as `<div></div>...<!--container-->`,\n    // so while processing a `<div>` instruction, point to the next sibling as a\n    // start of a segment.\n    ngDevMode && validateNodeExists(native.nextSibling, lView, tNode);\n    setSegmentHead(hydrationInfo, index, native.nextSibling);\n  }\n  // Checks if the skip hydration attribute is present during hydration so we know to\n  // skip attempting to hydrate this block. We check both TNode and RElement for an\n  // attribute: the RElement case is needed for i18n cases, when we add it to host\n  // elements during the annotation phase (after all internal data structures are setup).\n  if (hydrationInfo && (hasSkipHydrationAttrOnTNode(tNode) || hasSkipHydrationAttrOnRElement(native))) {\n    if (isComponentHost(tNode)) {\n      enterSkipHydrationBlock(tNode);\n      // Since this isn't hydratable, we need to empty the node\n      // so there's no duplicate content after render\n      clearElementContents(native);\n      ngDevMode && ngDevMode.componentsSkippedHydration++;\n    } else if (ngDevMode) {\n      // If this is not a component host, throw an error.\n      // Hydration can be skipped on per-component basis only.\n      throw invalidSkipHydrationHost(native);\n    }\n  }\n  return native;\n}\nfunction enableLocateOrCreateElementNodeImpl() {\n  _locateOrCreateElementNode = locateOrCreateElementNodeImpl;\n}\nfunction elementContainerStartFirstCreatePass(index, tView, lView, attrsIndex, localRefsIndex) {\n  ngDevMode && ngDevMode.firstCreatePass++;\n  const tViewConsts = tView.consts;\n  const attrs = getConstant(tViewConsts, attrsIndex);\n  const tNode = getOrCreateTNode(tView, index, 8 /* TNodeType.ElementContainer */, 'ng-container', attrs);\n  // While ng-container doesn't necessarily support styling, we use the style context to identify\n  // and execute directives on the ng-container.\n  if (attrs !== null) {\n    computeStaticStyling(tNode, attrs, true);\n  }\n  const localRefs = getConstant(tViewConsts, localRefsIndex);\n  resolveDirectives(tView, lView, tNode, localRefs);\n  if (tView.queries !== null) {\n    tView.queries.elementStart(tView, tNode);\n  }\n  return tNode;\n}\n/**\n * Creates a logical container for other nodes (<ng-container>) backed by a comment node in the DOM.\n * The instruction must later be followed by `elementContainerEnd()` call.\n *\n * @param index Index of the element in the LView array\n * @param attrsIndex Index of the container attributes in the `consts` array.\n * @param localRefsIndex Index of the container's local references in the `consts` array.\n * @returns This function returns itself so that it may be chained.\n *\n * Even if this instruction accepts a set of attributes no actual attribute values are propagated to\n * the DOM (as a comment node can't have attributes). Attributes are here only for directive\n * matching purposes and setting initial inputs of directives.\n *\n * @codeGenApi\n */\nfunction ɵɵelementContainerStart(index, attrsIndex, localRefsIndex) {\n  const lView = getLView();\n  const tView = getTView();\n  const adjustedIndex = index + HEADER_OFFSET;\n  ngDevMode && assertIndexInRange(lView, adjustedIndex);\n  ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, 'element containers should be created before any bindings');\n  const tNode = tView.firstCreatePass ? elementContainerStartFirstCreatePass(adjustedIndex, tView, lView, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];\n  setCurrentTNode(tNode, true);\n  const comment = _locateOrCreateElementContainerNode(tView, lView, tNode, index);\n  lView[adjustedIndex] = comment;\n  if (wasLastNodeCreated()) {\n    appendChild(tView, lView, comment, tNode);\n  }\n  attachPatchData(comment, lView);\n  if (isDirectiveHost(tNode)) {\n    createDirectivesInstances(tView, lView, tNode);\n    executeContentQueries(tView, tNode, lView);\n  }\n  if (localRefsIndex != null) {\n    saveResolvedLocalsInData(lView, tNode);\n  }\n  return ɵɵelementContainerStart;\n}\n/**\n * Mark the end of the <ng-container>.\n * @returns This function returns itself so that it may be chained.\n *\n * @codeGenApi\n */\nfunction ɵɵelementContainerEnd() {\n  let currentTNode = getCurrentTNode();\n  const tView = getTView();\n  if (isCurrentTNodeParent()) {\n    setCurrentTNodeAsNotParent();\n  } else {\n    ngDevMode && assertHasParent(currentTNode);\n    currentTNode = currentTNode.parent;\n    setCurrentTNode(currentTNode, false);\n  }\n  ngDevMode && assertTNodeType(currentTNode, 8 /* TNodeType.ElementContainer */);\n  if (tView.firstCreatePass) {\n    registerPostOrderHooks(tView, currentTNode);\n    if (isContentQueryHost(currentTNode)) {\n      tView.queries.elementEnd(currentTNode);\n    }\n  }\n  return ɵɵelementContainerEnd;\n}\n/**\n * Creates an empty logical container using {@link elementContainerStart}\n * and {@link elementContainerEnd}\n *\n * @param index Index of the element in the LView array\n * @param attrsIndex Index of the container attributes in the `consts` array.\n * @param localRefsIndex Index of the container's local references in the `consts` array.\n * @returns This function returns itself so that it may be chained.\n *\n * @codeGenApi\n */\nfunction ɵɵelementContainer(index, attrsIndex, localRefsIndex) {\n  ɵɵelementContainerStart(index, attrsIndex, localRefsIndex);\n  ɵɵelementContainerEnd();\n  return ɵɵelementContainer;\n}\nlet _locateOrCreateElementContainerNode = (tView, lView, tNode, index) => {\n  lastNodeWasCreated(true);\n  return createCommentNode(lView[RENDERER], ngDevMode ? 'ng-container' : '');\n};\n/**\n * Enables hydration code path (to lookup existing elements in DOM)\n * in addition to the regular creation mode of comment nodes that\n * represent <ng-container>'s anchor.\n */\nfunction locateOrCreateElementContainerNode(tView, lView, tNode, index) {\n  let comment;\n  const hydrationInfo = lView[HYDRATION];\n  const isNodeCreationMode = !hydrationInfo || isInSkipHydrationBlock$1();\n  lastNodeWasCreated(isNodeCreationMode);\n  // Regular creation mode.\n  if (isNodeCreationMode) {\n    return createCommentNode(lView[RENDERER], ngDevMode ? 'ng-container' : '');\n  }\n  // Hydration mode, looking up existing elements in DOM.\n  const currentRNode = locateNextRNode(hydrationInfo, tView, lView, tNode);\n  ngDevMode && validateNodeExists(currentRNode, lView, tNode);\n  const ngContainerSize = getNgContainerSize(hydrationInfo, index);\n  ngDevMode && assertNumber(ngContainerSize, 'Unexpected state: hydrating an <ng-container>, ' + 'but no hydration info is available.');\n  setSegmentHead(hydrationInfo, index, currentRNode);\n  comment = siblingAfter(ngContainerSize, currentRNode);\n  if (ngDevMode) {\n    validateMatchingNode(comment, Node.COMMENT_NODE, null, lView, tNode);\n    markRNodeAsClaimedByHydration(comment);\n  }\n  return comment;\n}\nfunction enableLocateOrCreateElementContainerNodeImpl() {\n  _locateOrCreateElementContainerNode = locateOrCreateElementContainerNode;\n}\n\n/**\n * Returns the current OpaqueViewState instance.\n *\n * Used in conjunction with the restoreView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n *\n * @codeGenApi\n */\nfunction ɵɵgetCurrentView() {\n  return getLView();\n}\n\n/**\n * Determine if the argument is shaped like a Promise\n */\nfunction isPromise(obj) {\n  // allow any Promise/A+ compliant thenable.\n  // It's up to the caller to ensure that obj.then conforms to the spec\n  return !!obj && typeof obj.then === 'function';\n}\n/**\n * Determine if the argument is a Subscribable\n */\nfunction isSubscribable(obj) {\n  return !!obj && typeof obj.subscribe === 'function';\n}\n\n/**\n * Adds an event listener to the current node.\n *\n * If an output exists on one of the node's directives, it also subscribes to the output\n * and saves the subscription for later cleanup.\n *\n * @param eventName Name of the event\n * @param listenerFn The function to be called when event emits\n * @param useCapture Whether or not to use capture in event listener - this argument is a reminder\n *     from the Renderer3 infrastructure and should be removed from the instruction arguments\n * @param eventTargetResolver Function that returns global target information in case this listener\n * should be attached to a global object like window, document or body\n *\n * @codeGenApi\n */\nfunction ɵɵlistener(eventName, listenerFn, useCapture, eventTargetResolver) {\n  const lView = getLView();\n  const tView = getTView();\n  const tNode = getCurrentTNode();\n  listenerInternal(tView, lView, lView[RENDERER], tNode, eventName, listenerFn, eventTargetResolver);\n  return ɵɵlistener;\n}\n/**\n * Registers a synthetic host listener (e.g. `(@foo.start)`) on a component or directive.\n *\n * This instruction is for compatibility purposes and is designed to ensure that a\n * synthetic host listener (e.g. `@HostListener('@foo.start')`) properly gets rendered\n * in the component's renderer. Normally all host listeners are evaluated with the\n * parent component's renderer, but, in the case of animation @triggers, they need\n * to be evaluated with the sub component's renderer (because that's where the\n * animation triggers are defined).\n *\n * Do not use this instruction as a replacement for `listener`. This instruction\n * only exists to ensure compatibility with the ViewEngine's host binding behavior.\n *\n * @param eventName Name of the event\n * @param listenerFn The function to be called when event emits\n * @param useCapture Whether or not to use capture in event listener\n * @param eventTargetResolver Function that returns global target information in case this listener\n * should be attached to a global object like window, document or body\n *\n * @codeGenApi\n */\nfunction ɵɵsyntheticHostListener(eventName, listenerFn) {\n  const tNode = getCurrentTNode();\n  const lView = getLView();\n  const tView = getTView();\n  const currentDef = getCurrentDirectiveDef(tView.data);\n  const renderer = loadComponentRenderer(currentDef, tNode, lView);\n  listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn);\n  return ɵɵsyntheticHostListener;\n}\n/**\n * A utility function that checks if a given element has already an event handler registered for an\n * event with a specified name. The TView.cleanup data structure is used to find out which events\n * are registered for a given element.\n */\nfunction findExistingListener(tView, lView, eventName, tNodeIdx) {\n  const tCleanup = tView.cleanup;\n  if (tCleanup != null) {\n    for (let i = 0; i < tCleanup.length - 1; i += 2) {\n      const cleanupEventName = tCleanup[i];\n      if (cleanupEventName === eventName && tCleanup[i + 1] === tNodeIdx) {\n        // We have found a matching event name on the same node but it might not have been\n        // registered yet, so we must explicitly verify entries in the LView cleanup data\n        // structures.\n        const lCleanup = lView[CLEANUP];\n        const listenerIdxInLCleanup = tCleanup[i + 2];\n        return lCleanup.length > listenerIdxInLCleanup ? lCleanup[listenerIdxInLCleanup] : null;\n      }\n      // TView.cleanup can have a mix of 4-elements entries (for event handler cleanups) or\n      // 2-element entries (for directive and queries destroy hooks). As such we can encounter\n      // blocks of 4 or 2 items in the tView.cleanup and this is why we iterate over 2 elements\n      // first and jump another 2 elements if we detect listeners cleanup (4 elements). Also check\n      // documentation of TView.cleanup for more details of this data structure layout.\n      if (typeof cleanupEventName === 'string') {\n        i += 2;\n      }\n    }\n  }\n  return null;\n}\nfunction listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn, eventTargetResolver) {\n  const isTNodeDirectiveHost = isDirectiveHost(tNode);\n  const firstCreatePass = tView.firstCreatePass;\n  const tCleanup = firstCreatePass && getOrCreateTViewCleanup(tView);\n  const context = lView[CONTEXT];\n  // When the ɵɵlistener instruction was generated and is executed we know that there is either a\n  // native listener or a directive output on this element. As such we we know that we will have to\n  // register a listener and store its cleanup function on LView.\n  const lCleanup = getOrCreateLViewCleanup(lView);\n  ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 12 /* TNodeType.AnyContainer */);\n  let processOutputs = true;\n  // Adding a native event listener is applicable when:\n  // - The corresponding TNode represents a DOM element.\n  // - The event target has a resolver (usually resulting in a global object,\n  //   such as `window` or `document`).\n  if (tNode.type & 3 /* TNodeType.AnyRNode */ || eventTargetResolver) {\n    const native = getNativeByTNode(tNode, lView);\n    const target = eventTargetResolver ? eventTargetResolver(native) : native;\n    const lCleanupIndex = lCleanup.length;\n    const idxOrTargetGetter = eventTargetResolver ? _lView => eventTargetResolver(unwrapRNode(_lView[tNode.index])) : tNode.index;\n    // In order to match current behavior, native DOM event listeners must be added for all\n    // events (including outputs).\n    // There might be cases where multiple directives on the same element try to register an event\n    // handler function for the same event. In this situation we want to avoid registration of\n    // several native listeners as each registration would be intercepted by NgZone and\n    // trigger change detection. This would mean that a single user action would result in several\n    // change detections being invoked. To avoid this situation we want to have only one call to\n    // native handler registration (for the same element and same type of event).\n    //\n    // In order to have just one native event handler in presence of multiple handler functions,\n    // we just register a first handler function as a native event listener and then chain\n    // (coalesce) other handler functions on top of the first native handler function.\n    let existingListener = null;\n    // Please note that the coalescing described here doesn't happen for events specifying an\n    // alternative target (ex. (document:click)) - this is to keep backward compatibility with the\n    // view engine.\n    // Also, we don't have to search for existing listeners is there are no directives\n    // matching on a given node as we can't register multiple event handlers for the same event in\n    // a template (this would mean having duplicate attributes).\n    if (!eventTargetResolver && isTNodeDirectiveHost) {\n      existingListener = findExistingListener(tView, lView, eventName, tNode.index);\n    }\n    if (existingListener !== null) {\n      // Attach a new listener to coalesced listeners list, maintaining the order in which\n      // listeners are registered. For performance reasons, we keep a reference to the last\n      // listener in that list (in `__ngLastListenerFn__` field), so we can avoid going through\n      // the entire set each time we need to add a new listener.\n      const lastListenerFn = existingListener.__ngLastListenerFn__ || existingListener;\n      lastListenerFn.__ngNextListenerFn__ = listenerFn;\n      existingListener.__ngLastListenerFn__ = listenerFn;\n      processOutputs = false;\n    } else {\n      listenerFn = wrapListener(tNode, lView, context, listenerFn, false /** preventDefault */);\n      const cleanupFn = renderer.listen(target, eventName, listenerFn);\n      ngDevMode && ngDevMode.rendererAddEventListener++;\n      lCleanup.push(listenerFn, cleanupFn);\n      tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, lCleanupIndex + 1);\n    }\n  } else {\n    // Even if there is no native listener to add, we still need to wrap the listener so that OnPush\n    // ancestors are marked dirty when an event occurs.\n    listenerFn = wrapListener(tNode, lView, context, listenerFn, false /** preventDefault */);\n  }\n  // subscribe to directive outputs\n  const outputs = tNode.outputs;\n  let props;\n  if (processOutputs && outputs !== null && (props = outputs[eventName])) {\n    const propsLength = props.length;\n    if (propsLength) {\n      for (let i = 0; i < propsLength; i += 2) {\n        const index = props[i];\n        ngDevMode && assertIndexInRange(lView, index);\n        const minifiedName = props[i + 1];\n        const directiveInstance = lView[index];\n        const output = directiveInstance[minifiedName];\n        if (ngDevMode && !isSubscribable(output)) {\n          throw new Error(`@Output ${minifiedName} not initialized in '${directiveInstance.constructor.name}'.`);\n        }\n        const subscription = output.subscribe(listenerFn);\n        const idx = lCleanup.length;\n        lCleanup.push(listenerFn, subscription);\n        tCleanup && tCleanup.push(eventName, tNode.index, idx, -(idx + 1));\n      }\n    }\n  }\n}\nfunction executeListenerWithErrorHandling(lView, context, listenerFn, e) {\n  try {\n    profiler(6 /* ProfilerEvent.OutputStart */, context, listenerFn);\n    // Only explicitly returning false from a listener should preventDefault\n    return listenerFn(e) !== false;\n  } catch (error) {\n    handleError(lView, error);\n    return false;\n  } finally {\n    profiler(7 /* ProfilerEvent.OutputEnd */, context, listenerFn);\n  }\n}\n/**\n * Wraps an event listener with a function that marks ancestors dirty and prevents default behavior,\n * if applicable.\n *\n * @param tNode The TNode associated with this listener\n * @param lView The LView that contains this listener\n * @param listenerFn The listener function to call\n * @param wrapWithPreventDefault Whether or not to prevent default behavior\n * (the procedural renderer does this already, so in those cases, we should skip)\n */\nfunction wrapListener(tNode, lView, context, listenerFn, wrapWithPreventDefault) {\n  // Note: we are performing most of the work in the listener function itself\n  // to optimize listener registration.\n  return function wrapListenerIn_markDirtyAndPreventDefault(e) {\n    // Ivy uses `Function` as a special token that allows us to unwrap the function\n    // so that it can be invoked programmatically by `DebugNode.triggerEventHandler`.\n    if (e === Function) {\n      return listenerFn;\n    }\n    // In order to be backwards compatible with View Engine, events on component host nodes\n    // must also mark the component view itself dirty (i.e. the view that it owns).\n    const startView = tNode.componentOffset > -1 ? getComponentLViewByIndex(tNode.index, lView) : lView;\n    markViewDirty(startView);\n    let result = executeListenerWithErrorHandling(lView, context, listenerFn, e);\n    // A just-invoked listener function might have coalesced listeners so we need to check for\n    // their presence and invoke as needed.\n    let nextListenerFn = wrapListenerIn_markDirtyAndPreventDefault.__ngNextListenerFn__;\n    while (nextListenerFn) {\n      // We should prevent default if any of the listeners explicitly return false\n      result = executeListenerWithErrorHandling(lView, context, nextListenerFn, e) && result;\n      nextListenerFn = nextListenerFn.__ngNextListenerFn__;\n    }\n    if (wrapWithPreventDefault && result === false) {\n      e.preventDefault();\n    }\n    return result;\n  };\n}\n\n/**\n * Retrieves a context at the level specified and saves it as the global, contextViewData.\n * Will get the next level up if level is not specified.\n *\n * This is used to save contexts of parent views so they can be bound in embedded views, or\n * in conjunction with reference() to bind a ref from a parent view.\n *\n * @param level The relative level of the view from which to grab context compared to contextVewData\n * @returns context\n *\n * @codeGenApi\n */\nfunction ɵɵnextContext(level = 1) {\n  return nextContextImpl(level);\n}\n\n/**\n * Checks a given node against matching projection slots and returns the\n * determined slot index. Returns \"null\" if no slot matched the given node.\n *\n * This function takes into account the parsed ngProjectAs selector from the\n * node's attributes. If present, it will check whether the ngProjectAs selector\n * matches any of the projection slot selectors.\n */\nfunction matchingProjectionSlotIndex(tNode, projectionSlots) {\n  let wildcardNgContentIndex = null;\n  const ngProjectAsAttrVal = getProjectAsAttrValue(tNode);\n  for (let i = 0; i < projectionSlots.length; i++) {\n    const slotValue = projectionSlots[i];\n    // The last wildcard projection slot should match all nodes which aren't matching\n    // any selector. This is necessary to be backwards compatible with view engine.\n    if (slotValue === '*') {\n      wildcardNgContentIndex = i;\n      continue;\n    }\n    // If we ran into an `ngProjectAs` attribute, we should match its parsed selector\n    // to the list of selectors, otherwise we fall back to matching against the node.\n    if (ngProjectAsAttrVal === null ? isNodeMatchingSelectorList(tNode, slotValue, /* isProjectionMode */true) : isSelectorInSelectorList(ngProjectAsAttrVal, slotValue)) {\n      return i; // first matching selector \"captures\" a given node\n    }\n  }\n\n  return wildcardNgContentIndex;\n}\n/**\n * Instruction to distribute projectable nodes among <ng-content> occurrences in a given template.\n * It takes all the selectors from the entire component's template and decides where\n * each projected node belongs (it re-distributes nodes among \"buckets\" where each \"bucket\" is\n * backed by a selector).\n *\n * This function requires CSS selectors to be provided in 2 forms: parsed (by a compiler) and text,\n * un-parsed form.\n *\n * The parsed form is needed for efficient matching of a node against a given CSS selector.\n * The un-parsed, textual form is needed for support of the ngProjectAs attribute.\n *\n * Having a CSS selector in 2 different formats is not ideal, but alternatives have even more\n * drawbacks:\n * - having only a textual form would require runtime parsing of CSS selectors;\n * - we can't have only a parsed as we can't re-construct textual form from it (as entered by a\n * template author).\n *\n * @param projectionSlots? A collection of projection slots. A projection slot can be based\n *        on a parsed CSS selectors or set to the wildcard selector (\"*\") in order to match\n *        all nodes which do not match any selector. If not specified, a single wildcard\n *        selector projection slot will be defined.\n *\n * @codeGenApi\n */\nfunction ɵɵprojectionDef(projectionSlots) {\n  const componentNode = getLView()[DECLARATION_COMPONENT_VIEW][T_HOST];\n  if (!componentNode.projection) {\n    // If no explicit projection slots are defined, fall back to a single\n    // projection slot with the wildcard selector.\n    const numProjectionSlots = projectionSlots ? projectionSlots.length : 1;\n    const projectionHeads = componentNode.projection = newArray(numProjectionSlots, null);\n    const tails = projectionHeads.slice();\n    let componentChild = componentNode.child;\n    while (componentChild !== null) {\n      const slotIndex = projectionSlots ? matchingProjectionSlotIndex(componentChild, projectionSlots) : 0;\n      if (slotIndex !== null) {\n        if (tails[slotIndex]) {\n          tails[slotIndex].projectionNext = componentChild;\n        } else {\n          projectionHeads[slotIndex] = componentChild;\n        }\n        tails[slotIndex] = componentChild;\n      }\n      componentChild = componentChild.next;\n    }\n  }\n}\n/**\n * Inserts previously re-distributed projected nodes. This instruction must be preceded by a call\n * to the projectionDef instruction.\n *\n * @param nodeIndex\n * @param selectorIndex:\n *        - 0 when the selector is `*` (or unspecified as this is the default value),\n *        - 1 based index of the selector from the {@link projectionDef}\n *\n * @codeGenApi\n */\nfunction ɵɵprojection(nodeIndex, selectorIndex = 0, attrs) {\n  const lView = getLView();\n  const tView = getTView();\n  const tProjectionNode = getOrCreateTNode(tView, HEADER_OFFSET + nodeIndex, 16 /* TNodeType.Projection */, null, attrs || null);\n  // We can't use viewData[HOST_NODE] because projection nodes can be nested in embedded views.\n  if (tProjectionNode.projection === null) tProjectionNode.projection = selectorIndex;\n  // `<ng-content>` has no content\n  setCurrentTNodeAsNotParent();\n  const hydrationInfo = lView[HYDRATION];\n  const isNodeCreationMode = !hydrationInfo || isInSkipHydrationBlock$1();\n  if (isNodeCreationMode && (tProjectionNode.flags & 32 /* TNodeFlags.isDetached */) !== 32 /* TNodeFlags.isDetached */) {\n    // re-distribution of projectable nodes is stored on a component's view level\n    applyProjection(tView, lView, tProjectionNode);\n  }\n}\n\n/**\n *\n * Update an interpolated property on an element with a lone bound value\n *\n * Used when the value passed to a property has 1 interpolated value in it, an no additional text\n * surrounds that interpolated value:\n *\n * ```html\n * <div title=\"{{v0}}\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate('title', v0);\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵpropertyInterpolate(propName, v0, sanitizer) {\n  ɵɵpropertyInterpolate1(propName, '', v0, '', sanitizer);\n  return ɵɵpropertyInterpolate;\n}\n/**\n *\n * Update an interpolated property on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate1('title', 'prefix', v0, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵpropertyInterpolate1(propName, prefix, v0, suffix, sanitizer) {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 1, prefix, suffix);\n  }\n  return ɵɵpropertyInterpolate1;\n}\n/**\n *\n * Update an interpolated property on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate2('title', 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵpropertyInterpolate2(propName, prefix, v0, i0, v1, suffix, sanitizer) {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 2, prefix, i0, suffix);\n  }\n  return ɵɵpropertyInterpolate2;\n}\n/**\n *\n * Update an interpolated property on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate3(\n * 'title', 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵpropertyInterpolate3(propName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer) {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 3, prefix, i0, i1, suffix);\n  }\n  return ɵɵpropertyInterpolate3;\n}\n/**\n *\n * Update an interpolated property on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate4(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵpropertyInterpolate4(propName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer) {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);\n  }\n  return ɵɵpropertyInterpolate4;\n}\n/**\n *\n * Update an interpolated property on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate5(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵpropertyInterpolate5(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer) {\n  const lView = getLView();\n  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);\n  }\n  return ɵɵpropertyInterpolate5;\n}\n/**\n *\n * Update an interpolated property on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate6(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵpropertyInterpolate6(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer) {\n  const lView = getLView();\n  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);\n  }\n  return ɵɵpropertyInterpolate6;\n}\n/**\n *\n * Update an interpolated property on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate7(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵpropertyInterpolate7(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer) {\n  const lView = getLView();\n  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5, suffix);\n  }\n  return ɵɵpropertyInterpolate7;\n}\n/**\n *\n * Update an interpolated property on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate8(\n *  'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵpropertyInterpolate8(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer) {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6, suffix);\n  }\n  return ɵɵpropertyInterpolate8;\n}\n/**\n * Update an interpolated property on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolateV(\n *  'title', ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update.\n * @param values The collection of values and the strings in between those values, beginning with a\n * string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵpropertyInterpolateV(propName, values, sanitizer) {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    if (ngDevMode) {\n      const interpolationInBetween = [values[0]]; // prefix\n      for (let i = 2; i < values.length; i += 2) {\n        interpolationInBetween.push(values[i]);\n      }\n      storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);\n    }\n  }\n  return ɵɵpropertyInterpolateV;\n}\nfunction toTStylingRange(prev, next) {\n  ngDevMode && assertNumberInRange(prev, 0, 32767 /* StylingRange.UNSIGNED_MASK */);\n  ngDevMode && assertNumberInRange(next, 0, 32767 /* StylingRange.UNSIGNED_MASK */);\n  return prev << 17 /* StylingRange.PREV_SHIFT */ | next << 2 /* StylingRange.NEXT_SHIFT */;\n}\n\nfunction getTStylingRangePrev(tStylingRange) {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return tStylingRange >> 17 /* StylingRange.PREV_SHIFT */ & 32767 /* StylingRange.UNSIGNED_MASK */;\n}\n\nfunction getTStylingRangePrevDuplicate(tStylingRange) {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return (tStylingRange & 2 /* StylingRange.PREV_DUPLICATE */) == 2 /* StylingRange.PREV_DUPLICATE */;\n}\n\nfunction setTStylingRangePrev(tStylingRange, previous) {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  ngDevMode && assertNumberInRange(previous, 0, 32767 /* StylingRange.UNSIGNED_MASK */);\n  return tStylingRange & ~4294836224 /* StylingRange.PREV_MASK */ | previous << 17 /* StylingRange.PREV_SHIFT */;\n}\n\nfunction setTStylingRangePrevDuplicate(tStylingRange) {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return tStylingRange | 2 /* StylingRange.PREV_DUPLICATE */;\n}\n\nfunction getTStylingRangeNext(tStylingRange) {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return (tStylingRange & 131068 /* StylingRange.NEXT_MASK */) >> 2 /* StylingRange.NEXT_SHIFT */;\n}\n\nfunction setTStylingRangeNext(tStylingRange, next) {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  ngDevMode && assertNumberInRange(next, 0, 32767 /* StylingRange.UNSIGNED_MASK */);\n  return tStylingRange & ~131068 /* StylingRange.NEXT_MASK */ |\n  //\n  next << 2 /* StylingRange.NEXT_SHIFT */;\n}\n\nfunction getTStylingRangeNextDuplicate(tStylingRange) {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return (tStylingRange & 1 /* StylingRange.NEXT_DUPLICATE */) === 1 /* StylingRange.NEXT_DUPLICATE */;\n}\n\nfunction setTStylingRangeNextDuplicate(tStylingRange) {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return tStylingRange | 1 /* StylingRange.NEXT_DUPLICATE */;\n}\n\nfunction getTStylingRangeTail(tStylingRange) {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  const next = getTStylingRangeNext(tStylingRange);\n  return next === 0 ? getTStylingRangePrev(tStylingRange) : next;\n}\n\n/**\n * NOTE: The word `styling` is used interchangeably as style or class styling.\n *\n * This file contains code to link styling instructions together so that they can be replayed in\n * priority order. The file exists because Ivy styling instruction execution order does not match\n * that of the priority order. The purpose of this code is to create a linked list so that the\n * instructions can be traversed in priority order when computing the styles.\n *\n * Assume we are dealing with the following code:\n * ```\n * @Component({\n *   template: `\n *     <my-cmp [style]=\" {color: '#001'} \"\n *             [style.color]=\" #002 \"\n *             dir-style-color-1\n *             dir-style-color-2> `\n * })\n * class ExampleComponent {\n *   static ngComp = ... {\n *     ...\n *     // Compiler ensures that `ɵɵstyleProp` is after `ɵɵstyleMap`\n *     ɵɵstyleMap({color: '#001'});\n *     ɵɵstyleProp('color', '#002');\n *     ...\n *   }\n * }\n *\n * @Directive({\n *   selector: `[dir-style-color-1]',\n * })\n * class Style1Directive {\n *   @HostBinding('style') style = {color: '#005'};\n *   @HostBinding('style.color') color = '#006';\n *\n *   static ngDir = ... {\n *     ...\n *     // Compiler ensures that `ɵɵstyleProp` is after `ɵɵstyleMap`\n *     ɵɵstyleMap({color: '#005'});\n *     ɵɵstyleProp('color', '#006');\n *     ...\n *   }\n * }\n *\n * @Directive({\n *   selector: `[dir-style-color-2]',\n * })\n * class Style2Directive {\n *   @HostBinding('style') style = {color: '#007'};\n *   @HostBinding('style.color') color = '#008';\n *\n *   static ngDir = ... {\n *     ...\n *     // Compiler ensures that `ɵɵstyleProp` is after `ɵɵstyleMap`\n *     ɵɵstyleMap({color: '#007'});\n *     ɵɵstyleProp('color', '#008');\n *     ...\n *   }\n * }\n *\n * @Directive({\n *   selector: `my-cmp',\n * })\n * class MyComponent {\n *   @HostBinding('style') style = {color: '#003'};\n *   @HostBinding('style.color') color = '#004';\n *\n *   static ngComp = ... {\n *     ...\n *     // Compiler ensures that `ɵɵstyleProp` is after `ɵɵstyleMap`\n *     ɵɵstyleMap({color: '#003'});\n *     ɵɵstyleProp('color', '#004');\n *     ...\n *   }\n * }\n * ```\n *\n * The Order of instruction execution is:\n *\n * NOTE: the comment binding location is for illustrative purposes only.\n *\n * ```\n * // Template: (ExampleComponent)\n *     ɵɵstyleMap({color: '#001'});   // Binding index: 10\n *     ɵɵstyleProp('color', '#002');  // Binding index: 12\n * // MyComponent\n *     ɵɵstyleMap({color: '#003'});   // Binding index: 20\n *     ɵɵstyleProp('color', '#004');  // Binding index: 22\n * // Style1Directive\n *     ɵɵstyleMap({color: '#005'});   // Binding index: 24\n *     ɵɵstyleProp('color', '#006');  // Binding index: 26\n * // Style2Directive\n *     ɵɵstyleMap({color: '#007'});   // Binding index: 28\n *     ɵɵstyleProp('color', '#008');  // Binding index: 30\n * ```\n *\n * The correct priority order of concatenation is:\n *\n * ```\n * // MyComponent\n *     ɵɵstyleMap({color: '#003'});   // Binding index: 20\n *     ɵɵstyleProp('color', '#004');  // Binding index: 22\n * // Style1Directive\n *     ɵɵstyleMap({color: '#005'});   // Binding index: 24\n *     ɵɵstyleProp('color', '#006');  // Binding index: 26\n * // Style2Directive\n *     ɵɵstyleMap({color: '#007'});   // Binding index: 28\n *     ɵɵstyleProp('color', '#008');  // Binding index: 30\n * // Template: (ExampleComponent)\n *     ɵɵstyleMap({color: '#001'});   // Binding index: 10\n *     ɵɵstyleProp('color', '#002');  // Binding index: 12\n * ```\n *\n * What color should be rendered?\n *\n * Once the items are correctly sorted in the list, the answer is simply the last item in the\n * concatenation list which is `#002`.\n *\n * To do so we keep a linked list of all of the bindings which pertain to this element.\n * Notice that the bindings are inserted in the order of execution, but the `TView.data` allows\n * us to traverse them in the order of priority.\n *\n * |Idx|`TView.data`|`LView`          | Notes\n * |---|------------|-----------------|--------------\n * |...|            |                 |\n * |10 |`null`      |`{color: '#001'}`| `ɵɵstyleMap('color', {color: '#001'})`\n * |11 |`30 | 12`   | ...             |\n * |12 |`color`     |`'#002'`         | `ɵɵstyleProp('color', '#002')`\n * |13 |`10 | 0`    | ...             |\n * |...|            |                 |\n * |20 |`null`      |`{color: '#003'}`| `ɵɵstyleMap('color', {color: '#003'})`\n * |21 |`0 | 22`    | ...             |\n * |22 |`color`     |`'#004'`         | `ɵɵstyleProp('color', '#004')`\n * |23 |`20 | 24`   | ...             |\n * |24 |`null`      |`{color: '#005'}`| `ɵɵstyleMap('color', {color: '#005'})`\n * |25 |`22 | 26`   | ...             |\n * |26 |`color`     |`'#006'`         | `ɵɵstyleProp('color', '#006')`\n * |27 |`24 | 28`   | ...             |\n * |28 |`null`      |`{color: '#007'}`| `ɵɵstyleMap('color', {color: '#007'})`\n * |29 |`26 | 30`   | ...             |\n * |30 |`color`     |`'#008'`         | `ɵɵstyleProp('color', '#008')`\n * |31 |`28 | 10`   | ...             |\n *\n * The above data structure allows us to re-concatenate the styling no matter which data binding\n * changes.\n *\n * NOTE: in addition to keeping track of next/previous index the `TView.data` also stores prev/next\n * duplicate bit. The duplicate bit if true says there either is a binding with the same name or\n * there is a map (which may contain the name). This information is useful in knowing if other\n * styles with higher priority need to be searched for overwrites.\n *\n * NOTE: See `should support example in 'tnode_linked_list.ts' documentation` in\n * `tnode_linked_list_spec.ts` for working example.\n */\nlet __unused_const_as_closure_does_not_like_standalone_comment_blocks__;\n/**\n * Insert new `tStyleValue` at `TData` and link existing style bindings such that we maintain linked\n * list of styles and compute the duplicate flag.\n *\n * Note: this function is executed during `firstUpdatePass` only to populate the `TView.data`.\n *\n * The function works by keeping track of `tStylingRange` which contains two pointers pointing to\n * the head/tail of the template portion of the styles.\n *  - if `isHost === false` (we are template) then insertion is at tail of `TStylingRange`\n *  - if `isHost === true` (we are host binding) then insertion is at head of `TStylingRange`\n *\n * @param tData The `TData` to insert into.\n * @param tNode `TNode` associated with the styling element.\n * @param tStylingKey See `TStylingKey`.\n * @param index location of where `tStyleValue` should be stored (and linked into list.)\n * @param isHostBinding `true` if the insertion is for a `hostBinding`. (insertion is in front of\n *               template.)\n * @param isClassBinding True if the associated `tStylingKey` as a `class` styling.\n *                       `tNode.classBindings` should be used (or `tNode.styleBindings` otherwise.)\n */\nfunction insertTStylingBinding(tData, tNode, tStylingKeyWithStatic, index, isHostBinding, isClassBinding) {\n  ngDevMode && assertFirstUpdatePass(getTView());\n  let tBindings = isClassBinding ? tNode.classBindings : tNode.styleBindings;\n  let tmplHead = getTStylingRangePrev(tBindings);\n  let tmplTail = getTStylingRangeNext(tBindings);\n  tData[index] = tStylingKeyWithStatic;\n  let isKeyDuplicateOfStatic = false;\n  let tStylingKey;\n  if (Array.isArray(tStylingKeyWithStatic)) {\n    // We are case when the `TStylingKey` contains static fields as well.\n    const staticKeyValueArray = tStylingKeyWithStatic;\n    tStylingKey = staticKeyValueArray[1]; // unwrap.\n    // We need to check if our key is present in the static so that we can mark it as duplicate.\n    if (tStylingKey === null || keyValueArrayIndexOf(staticKeyValueArray, tStylingKey) > 0) {\n      // tStylingKey is present in the statics, need to mark it as duplicate.\n      isKeyDuplicateOfStatic = true;\n    }\n  } else {\n    tStylingKey = tStylingKeyWithStatic;\n  }\n  if (isHostBinding) {\n    // We are inserting host bindings\n    // If we don't have template bindings then `tail` is 0.\n    const hasTemplateBindings = tmplTail !== 0;\n    // This is important to know because that means that the `head` can't point to the first\n    // template bindings (there are none.) Instead the head points to the tail of the template.\n    if (hasTemplateBindings) {\n      // template head's \"prev\" will point to last host binding or to 0 if no host bindings yet\n      const previousNode = getTStylingRangePrev(tData[tmplHead + 1]);\n      tData[index + 1] = toTStylingRange(previousNode, tmplHead);\n      // if a host binding has already been registered, we need to update the next of that host\n      // binding to point to this one\n      if (previousNode !== 0) {\n        // We need to update the template-tail value to point to us.\n        tData[previousNode + 1] = setTStylingRangeNext(tData[previousNode + 1], index);\n      }\n      // The \"previous\" of the template binding head should point to this host binding\n      tData[tmplHead + 1] = setTStylingRangePrev(tData[tmplHead + 1], index);\n    } else {\n      tData[index + 1] = toTStylingRange(tmplHead, 0);\n      // if a host binding has already been registered, we need to update the next of that host\n      // binding to point to this one\n      if (tmplHead !== 0) {\n        // We need to update the template-tail value to point to us.\n        tData[tmplHead + 1] = setTStylingRangeNext(tData[tmplHead + 1], index);\n      }\n      // if we don't have template, the head points to template-tail, and needs to be advanced.\n      tmplHead = index;\n    }\n  } else {\n    // We are inserting in template section.\n    // We need to set this binding's \"previous\" to the current template tail\n    tData[index + 1] = toTStylingRange(tmplTail, 0);\n    ngDevMode && assertEqual(tmplHead !== 0 && tmplTail === 0, false, 'Adding template bindings after hostBindings is not allowed.');\n    if (tmplHead === 0) {\n      tmplHead = index;\n    } else {\n      // We need to update the previous value \"next\" to point to this binding\n      tData[tmplTail + 1] = setTStylingRangeNext(tData[tmplTail + 1], index);\n    }\n    tmplTail = index;\n  }\n  // Now we need to update / compute the duplicates.\n  // Starting with our location search towards head (least priority)\n  if (isKeyDuplicateOfStatic) {\n    tData[index + 1] = setTStylingRangePrevDuplicate(tData[index + 1]);\n  }\n  markDuplicates(tData, tStylingKey, index, true, isClassBinding);\n  markDuplicates(tData, tStylingKey, index, false, isClassBinding);\n  markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding);\n  tBindings = toTStylingRange(tmplHead, tmplTail);\n  if (isClassBinding) {\n    tNode.classBindings = tBindings;\n  } else {\n    tNode.styleBindings = tBindings;\n  }\n}\n/**\n * Look into the residual styling to see if the current `tStylingKey` is duplicate of residual.\n *\n * @param tNode `TNode` where the residual is stored.\n * @param tStylingKey `TStylingKey` to store.\n * @param tData `TData` associated with the current `LView`.\n * @param index location of where `tStyleValue` should be stored (and linked into list.)\n * @param isClassBinding True if the associated `tStylingKey` as a `class` styling.\n *                       `tNode.classBindings` should be used (or `tNode.styleBindings` otherwise.)\n */\nfunction markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding) {\n  const residual = isClassBinding ? tNode.residualClasses : tNode.residualStyles;\n  if (residual != null /* or undefined */ && typeof tStylingKey == 'string' && keyValueArrayIndexOf(residual, tStylingKey) >= 0) {\n    // We have duplicate in the residual so mark ourselves as duplicate.\n    tData[index + 1] = setTStylingRangeNextDuplicate(tData[index + 1]);\n  }\n}\n/**\n * Marks `TStyleValue`s as duplicates if another style binding in the list has the same\n * `TStyleValue`.\n *\n * NOTE: this function is intended to be called twice once with `isPrevDir` set to `true` and once\n * with it set to `false` to search both the previous as well as next items in the list.\n *\n * No duplicate case\n * ```\n *   [style.color]\n *   [style.width.px] <<- index\n *   [style.height.px]\n * ```\n *\n * In the above case adding `[style.width.px]` to the existing `[style.color]` produces no\n * duplicates because `width` is not found in any other part of the linked list.\n *\n * Duplicate case\n * ```\n *   [style.color]\n *   [style.width.em]\n *   [style.width.px] <<- index\n * ```\n * In the above case adding `[style.width.px]` will produce a duplicate with `[style.width.em]`\n * because `width` is found in the chain.\n *\n * Map case 1\n * ```\n *   [style.width.px]\n *   [style.color]\n *   [style]  <<- index\n * ```\n * In the above case adding `[style]` will produce a duplicate with any other bindings because\n * `[style]` is a Map and as such is fully dynamic and could produce `color` or `width`.\n *\n * Map case 2\n * ```\n *   [style]\n *   [style.width.px]\n *   [style.color]  <<- index\n * ```\n * In the above case adding `[style.color]` will produce a duplicate because there is already a\n * `[style]` binding which is a Map and as such is fully dynamic and could produce `color` or\n * `width`.\n *\n * NOTE: Once `[style]` (Map) is added into the system all things are mapped as duplicates.\n * NOTE: We use `style` as example, but same logic is applied to `class`es as well.\n *\n * @param tData `TData` where the linked list is stored.\n * @param tStylingKey `TStylingKeyPrimitive` which contains the value to compare to other keys in\n *        the linked list.\n * @param index Starting location in the linked list to search from\n * @param isPrevDir Direction.\n *        - `true` for previous (lower priority);\n *        - `false` for next (higher priority).\n */\nfunction markDuplicates(tData, tStylingKey, index, isPrevDir, isClassBinding) {\n  const tStylingAtIndex = tData[index + 1];\n  const isMap = tStylingKey === null;\n  let cursor = isPrevDir ? getTStylingRangePrev(tStylingAtIndex) : getTStylingRangeNext(tStylingAtIndex);\n  let foundDuplicate = false;\n  // We keep iterating as long as we have a cursor\n  // AND either:\n  // - we found what we are looking for, OR\n  // - we are a map in which case we have to continue searching even after we find what we were\n  //   looking for since we are a wild card and everything needs to be flipped to duplicate.\n  while (cursor !== 0 && (foundDuplicate === false || isMap)) {\n    ngDevMode && assertIndexInRange(tData, cursor);\n    const tStylingValueAtCursor = tData[cursor];\n    const tStyleRangeAtCursor = tData[cursor + 1];\n    if (isStylingMatch(tStylingValueAtCursor, tStylingKey)) {\n      foundDuplicate = true;\n      tData[cursor + 1] = isPrevDir ? setTStylingRangeNextDuplicate(tStyleRangeAtCursor) : setTStylingRangePrevDuplicate(tStyleRangeAtCursor);\n    }\n    cursor = isPrevDir ? getTStylingRangePrev(tStyleRangeAtCursor) : getTStylingRangeNext(tStyleRangeAtCursor);\n  }\n  if (foundDuplicate) {\n    // if we found a duplicate, than mark ourselves.\n    tData[index + 1] = isPrevDir ? setTStylingRangePrevDuplicate(tStylingAtIndex) : setTStylingRangeNextDuplicate(tStylingAtIndex);\n  }\n}\n/**\n * Determines if two `TStylingKey`s are a match.\n *\n * When computing whether a binding contains a duplicate, we need to compare if the instruction\n * `TStylingKey` has a match.\n *\n * Here are examples of `TStylingKey`s which match given `tStylingKeyCursor` is:\n * - `color`\n *    - `color`    // Match another color\n *    - `null`     // That means that `tStylingKey` is a `classMap`/`styleMap` instruction\n *    - `['', 'color', 'other', true]` // wrapped `color` so match\n *    - `['', null, 'other', true]`       // wrapped `null` so match\n *    - `['', 'width', 'color', 'value']` // wrapped static value contains a match on `'color'`\n * - `null`       // `tStylingKeyCursor` always match as it is `classMap`/`styleMap` instruction\n *\n * @param tStylingKeyCursor\n * @param tStylingKey\n */\nfunction isStylingMatch(tStylingKeyCursor, tStylingKey) {\n  ngDevMode && assertNotEqual(Array.isArray(tStylingKey), true, 'Expected that \\'tStylingKey\\' has been unwrapped');\n  if (tStylingKeyCursor === null ||\n  // If the cursor is `null` it means that we have map at that\n  // location so we must assume that we have a match.\n  tStylingKey == null ||\n  // If `tStylingKey` is `null` then it is a map therefor assume that it\n  // contains a match.\n  (Array.isArray(tStylingKeyCursor) ? tStylingKeyCursor[1] : tStylingKeyCursor) === tStylingKey // If the keys match explicitly than we are a match.\n  ) {\n    return true;\n  } else if (Array.isArray(tStylingKeyCursor) && typeof tStylingKey === 'string') {\n    // if we did not find a match, but `tStylingKeyCursor` is `KeyValueArray` that means cursor has\n    // statics and we need to check those as well.\n    return keyValueArrayIndexOf(tStylingKeyCursor, tStylingKey) >= 0; // see if we are matching the key\n  }\n\n  return false;\n}\n\n// Global state of the parser. (This makes parser non-reentrant, but that is not an issue)\nconst parserState = {\n  textEnd: 0,\n  key: 0,\n  keyEnd: 0,\n  value: 0,\n  valueEnd: 0\n};\n/**\n * Retrieves the last parsed `key` of style.\n * @param text the text to substring the key from.\n */\nfunction getLastParsedKey(text) {\n  return text.substring(parserState.key, parserState.keyEnd);\n}\n/**\n * Retrieves the last parsed `value` of style.\n * @param text the text to substring the key from.\n */\nfunction getLastParsedValue(text) {\n  return text.substring(parserState.value, parserState.valueEnd);\n}\n/**\n * Initializes `className` string for parsing and parses the first token.\n *\n * This function is intended to be used in this format:\n * ```\n * for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {\n *   const key = getLastParsedKey();\n *   ...\n * }\n * ```\n * @param text `className` to parse\n * @returns index where the next invocation of `parseClassNameNext` should resume.\n */\nfunction parseClassName(text) {\n  resetParserState(text);\n  return parseClassNameNext(text, consumeWhitespace(text, 0, parserState.textEnd));\n}\n/**\n * Parses next `className` token.\n *\n * This function is intended to be used in this format:\n * ```\n * for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {\n *   const key = getLastParsedKey();\n *   ...\n * }\n * ```\n *\n * @param text `className` to parse\n * @param index where the parsing should resume.\n * @returns index where the next invocation of `parseClassNameNext` should resume.\n */\nfunction parseClassNameNext(text, index) {\n  const end = parserState.textEnd;\n  if (end === index) {\n    return -1;\n  }\n  index = parserState.keyEnd = consumeClassToken(text, parserState.key = index, end);\n  return consumeWhitespace(text, index, end);\n}\n/**\n * Initializes `cssText` string for parsing and parses the first key/values.\n *\n * This function is intended to be used in this format:\n * ```\n * for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i))) {\n *   const key = getLastParsedKey();\n *   const value = getLastParsedValue();\n *   ...\n * }\n * ```\n * @param text `cssText` to parse\n * @returns index where the next invocation of `parseStyleNext` should resume.\n */\nfunction parseStyle(text) {\n  resetParserState(text);\n  return parseStyleNext(text, consumeWhitespace(text, 0, parserState.textEnd));\n}\n/**\n * Parses the next `cssText` key/values.\n *\n * This function is intended to be used in this format:\n * ```\n * for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i))) {\n *   const key = getLastParsedKey();\n *   const value = getLastParsedValue();\n *   ...\n * }\n *\n * @param text `cssText` to parse\n * @param index where the parsing should resume.\n * @returns index where the next invocation of `parseStyleNext` should resume.\n */\nfunction parseStyleNext(text, startIndex) {\n  const end = parserState.textEnd;\n  let index = parserState.key = consumeWhitespace(text, startIndex, end);\n  if (end === index) {\n    // we reached an end so just quit\n    return -1;\n  }\n  index = parserState.keyEnd = consumeStyleKey(text, index, end);\n  index = consumeSeparator(text, index, end, 58 /* CharCode.COLON */);\n  index = parserState.value = consumeWhitespace(text, index, end);\n  index = parserState.valueEnd = consumeStyleValue(text, index, end);\n  return consumeSeparator(text, index, end, 59 /* CharCode.SEMI_COLON */);\n}\n/**\n * Reset the global state of the styling parser.\n * @param text The styling text to parse.\n */\nfunction resetParserState(text) {\n  parserState.key = 0;\n  parserState.keyEnd = 0;\n  parserState.value = 0;\n  parserState.valueEnd = 0;\n  parserState.textEnd = text.length;\n}\n/**\n * Returns index of next non-whitespace character.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index of next non-whitespace character (May be the same as `start` if no whitespace at\n *          that location.)\n */\nfunction consumeWhitespace(text, startIndex, endIndex) {\n  while (startIndex < endIndex && text.charCodeAt(startIndex) <= 32 /* CharCode.SPACE */) {\n    startIndex++;\n  }\n  return startIndex;\n}\n/**\n * Returns index of last char in class token.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after last char in class token.\n */\nfunction consumeClassToken(text, startIndex, endIndex) {\n  while (startIndex < endIndex && text.charCodeAt(startIndex) > 32 /* CharCode.SPACE */) {\n    startIndex++;\n  }\n  return startIndex;\n}\n/**\n * Consumes all of the characters belonging to style key and token.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after last style key character.\n */\nfunction consumeStyleKey(text, startIndex, endIndex) {\n  let ch;\n  while (startIndex < endIndex && ((ch = text.charCodeAt(startIndex)) === 45 /* CharCode.DASH */ || ch === 95 /* CharCode.UNDERSCORE */ || (ch & -33 /* CharCode.UPPER_CASE */) >= 65 /* CharCode.A */ && (ch & -33 /* CharCode.UPPER_CASE */) <= 90 /* CharCode.Z */ || ch >= 48 /* CharCode.ZERO */ && ch <= 57 /* CharCode.NINE */)) {\n    startIndex++;\n  }\n  return startIndex;\n}\n/**\n * Consumes all whitespace and the separator `:` after the style key.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after separator and surrounding whitespace.\n */\nfunction consumeSeparator(text, startIndex, endIndex, separator) {\n  startIndex = consumeWhitespace(text, startIndex, endIndex);\n  if (startIndex < endIndex) {\n    if (ngDevMode && text.charCodeAt(startIndex) !== separator) {\n      malformedStyleError(text, String.fromCharCode(separator), startIndex);\n    }\n    startIndex++;\n  }\n  return startIndex;\n}\n/**\n * Consumes style value honoring `url()` and `\"\"` text.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after last style value character.\n */\nfunction consumeStyleValue(text, startIndex, endIndex) {\n  let ch1 = -1; // 1st previous character\n  let ch2 = -1; // 2nd previous character\n  let ch3 = -1; // 3rd previous character\n  let i = startIndex;\n  let lastChIndex = i;\n  while (i < endIndex) {\n    const ch = text.charCodeAt(i++);\n    if (ch === 59 /* CharCode.SEMI_COLON */) {\n      return lastChIndex;\n    } else if (ch === 34 /* CharCode.DOUBLE_QUOTE */ || ch === 39 /* CharCode.SINGLE_QUOTE */) {\n      lastChIndex = i = consumeQuotedText(text, ch, i, endIndex);\n    } else if (startIndex === i - 4 &&\n    // We have seen only 4 characters so far \"URL(\" (Ignore \"foo_URL()\")\n    ch3 === 85 /* CharCode.U */ && ch2 === 82 /* CharCode.R */ && ch1 === 76 /* CharCode.L */ && ch === 40 /* CharCode.OPEN_PAREN */) {\n      lastChIndex = i = consumeQuotedText(text, 41 /* CharCode.CLOSE_PAREN */, i, endIndex);\n    } else if (ch > 32 /* CharCode.SPACE */) {\n      // if we have a non-whitespace character then capture its location\n      lastChIndex = i;\n    }\n    ch3 = ch2;\n    ch2 = ch1;\n    ch1 = ch & -33 /* CharCode.UPPER_CASE */;\n  }\n\n  return lastChIndex;\n}\n/**\n * Consumes all of the quoted characters.\n *\n * @param text Text to scan\n * @param quoteCharCode CharCode of either `\"` or `'` quote or `)` for `url(...)`.\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after quoted characters.\n */\nfunction consumeQuotedText(text, quoteCharCode, startIndex, endIndex) {\n  let ch1 = -1; // 1st previous character\n  let index = startIndex;\n  while (index < endIndex) {\n    const ch = text.charCodeAt(index++);\n    if (ch == quoteCharCode && ch1 !== 92 /* CharCode.BACK_SLASH */) {\n      return index;\n    }\n    if (ch == 92 /* CharCode.BACK_SLASH */ && ch1 === 92 /* CharCode.BACK_SLASH */) {\n      // two back slashes cancel each other out. For example `\"\\\\\"` should properly end the\n      // quotation. (It should not assume that the last `\"` is escaped.)\n      ch1 = 0;\n    } else {\n      ch1 = ch;\n    }\n  }\n  throw ngDevMode ? malformedStyleError(text, String.fromCharCode(quoteCharCode), endIndex) : new Error();\n}\nfunction malformedStyleError(text, expecting, index) {\n  ngDevMode && assertEqual(typeof text === 'string', true, 'String expected here');\n  throw throwError(`Malformed style at location ${index} in string '` + text.substring(0, index) + '[>>' + text.substring(index, index + 1) + '<<]' + text.slice(index + 1) + `'. Expecting '${expecting}'.`);\n}\n\n/**\n * Update a style binding on an element with the provided value.\n *\n * If the style value is falsy then it will be removed from the element\n * (or assigned a different value depending if there are any styles placed\n * on the element with `styleMap` or any static styles that are\n * present from when the element was created with `styling`).\n *\n * Note that the styling element is updated as part of `stylingApply`.\n *\n * @param prop A valid CSS property.\n * @param value New value to write (`null` or an empty string to remove).\n * @param suffix Optional suffix. Used with scalar values to add unit such as `px`.\n *\n * Note that this will apply the provided style value to the host element if this function is called\n * within a host binding function.\n *\n * @codeGenApi\n */\nfunction ɵɵstyleProp(prop, value, suffix) {\n  checkStylingProperty(prop, value, suffix, false);\n  return ɵɵstyleProp;\n}\n/**\n * Update a class binding on an element with the provided value.\n *\n * This instruction is meant to handle the `[class.foo]=\"exp\"` case and,\n * therefore, the class binding itself must already be allocated using\n * `styling` within the creation block.\n *\n * @param prop A valid CSS class (only one).\n * @param value A true/false value which will turn the class on or off.\n *\n * Note that this will apply the provided class value to the host element if this function\n * is called within a host binding function.\n *\n * @codeGenApi\n */\nfunction ɵɵclassProp(className, value) {\n  checkStylingProperty(className, value, null, true);\n  return ɵɵclassProp;\n}\n/**\n * Update style bindings using an object literal on an element.\n *\n * This instruction is meant to apply styling via the `[style]=\"exp\"` template bindings.\n * When styles are applied to the element they will then be updated with respect to\n * any styles/classes set via `styleProp`. If any styles are set to falsy\n * then they will be removed from the element.\n *\n * Note that the styling instruction will not be applied until `stylingApply` is called.\n *\n * @param styles A key/value style map of the styles that will be applied to the given element.\n *        Any missing styles (that have already been applied to the element beforehand) will be\n *        removed (unset) from the element's styling.\n *\n * Note that this will apply the provided styleMap value to the host element if this function\n * is called within a host binding.\n *\n * @codeGenApi\n */\nfunction ɵɵstyleMap(styles) {\n  checkStylingMap(styleKeyValueArraySet, styleStringParser, styles, false);\n}\n/**\n * Parse text as style and add values to KeyValueArray.\n *\n * This code is pulled out to a separate function so that it can be tree shaken away if it is not\n * needed. It is only referenced from `ɵɵstyleMap`.\n *\n * @param keyValueArray KeyValueArray to add parsed values to.\n * @param text text to parse.\n */\nfunction styleStringParser(keyValueArray, text) {\n  for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i)) {\n    styleKeyValueArraySet(keyValueArray, getLastParsedKey(text), getLastParsedValue(text));\n  }\n}\n/**\n * Update class bindings using an object literal or class-string on an element.\n *\n * This instruction is meant to apply styling via the `[class]=\"exp\"` template bindings.\n * When classes are applied to the element they will then be updated with\n * respect to any styles/classes set via `classProp`. If any\n * classes are set to falsy then they will be removed from the element.\n *\n * Note that the styling instruction will not be applied until `stylingApply` is called.\n * Note that this will the provided classMap value to the host element if this function is called\n * within a host binding.\n *\n * @param classes A key/value map or string of CSS classes that will be added to the\n *        given element. Any missing classes (that have already been applied to the element\n *        beforehand) will be removed (unset) from the element's list of CSS classes.\n *\n * @codeGenApi\n */\nfunction ɵɵclassMap(classes) {\n  checkStylingMap(classKeyValueArraySet, classStringParser, classes, true);\n}\n/**\n * Parse text as class and add values to KeyValueArray.\n *\n * This code is pulled out to a separate function so that it can be tree shaken away if it is not\n * needed. It is only referenced from `ɵɵclassMap`.\n *\n * @param keyValueArray KeyValueArray to add parsed values to.\n * @param text text to parse.\n */\nfunction classStringParser(keyValueArray, text) {\n  for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {\n    keyValueArraySet(keyValueArray, getLastParsedKey(text), true);\n  }\n}\n/**\n * Common code between `ɵɵclassProp` and `ɵɵstyleProp`.\n *\n * @param prop property name.\n * @param value binding value.\n * @param suffix suffix for the property (e.g. `em` or `px`)\n * @param isClassBased `true` if `class` change (`false` if `style`)\n */\nfunction checkStylingProperty(prop, value, suffix, isClassBased) {\n  const lView = getLView();\n  const tView = getTView();\n  // Styling instructions use 2 slots per binding.\n  // 1. one for the value / TStylingKey\n  // 2. one for the intermittent-value / TStylingRange\n  const bindingIndex = incrementBindingIndex(2);\n  if (tView.firstUpdatePass) {\n    stylingFirstUpdatePass(tView, prop, bindingIndex, isClassBased);\n  }\n  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {\n    const tNode = tView.data[getSelectedIndex()];\n    updateStyling(tView, tNode, lView, lView[RENDERER], prop, lView[bindingIndex + 1] = normalizeSuffix(value, suffix), isClassBased, bindingIndex);\n  }\n}\n/**\n * Common code between `ɵɵclassMap` and `ɵɵstyleMap`.\n *\n * @param keyValueArraySet (See `keyValueArraySet` in \"util/array_utils\") Gets passed in as a\n *        function so that `style` can be processed. This is done for tree shaking purposes.\n * @param stringParser Parser used to parse `value` if `string`. (Passed in as `style` and `class`\n *        have different parsers.)\n * @param value bound value from application\n * @param isClassBased `true` if `class` change (`false` if `style`)\n */\nfunction checkStylingMap(keyValueArraySet, stringParser, value, isClassBased) {\n  const tView = getTView();\n  const bindingIndex = incrementBindingIndex(2);\n  if (tView.firstUpdatePass) {\n    stylingFirstUpdatePass(tView, null, bindingIndex, isClassBased);\n  }\n  const lView = getLView();\n  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {\n    // `getSelectedIndex()` should be here (rather than in instruction) so that it is guarded by the\n    // if so as not to read unnecessarily.\n    const tNode = tView.data[getSelectedIndex()];\n    if (hasStylingInputShadow(tNode, isClassBased) && !isInHostBindings(tView, bindingIndex)) {\n      if (ngDevMode) {\n        // verify that if we are shadowing then `TData` is appropriately marked so that we skip\n        // processing this binding in styling resolution.\n        const tStylingKey = tView.data[bindingIndex];\n        assertEqual(Array.isArray(tStylingKey) ? tStylingKey[1] : tStylingKey, false, 'Styling linked list shadow input should be marked as \\'false\\'');\n      }\n      // VE does not concatenate the static portion like we are doing here.\n      // Instead VE just ignores the static completely if dynamic binding is present.\n      // Because of locality we have already set the static portion because we don't know if there\n      // is a dynamic portion until later. If we would ignore the static portion it would look like\n      // the binding has removed it. This would confuse `[ngStyle]`/`[ngClass]` to do the wrong\n      // thing as it would think that the static portion was removed. For this reason we\n      // concatenate it so that `[ngStyle]`/`[ngClass]`  can continue to work on changed.\n      let staticPrefix = isClassBased ? tNode.classesWithoutHost : tNode.stylesWithoutHost;\n      ngDevMode && isClassBased === false && staticPrefix !== null && assertEqual(staticPrefix.endsWith(';'), true, 'Expecting static portion to end with \\';\\'');\n      if (staticPrefix !== null) {\n        // We want to make sure that falsy values of `value` become empty strings.\n        value = concatStringsWithSpace(staticPrefix, value ? value : '');\n      }\n      // Given `<div [style] my-dir>` such that `my-dir` has `@Input('style')`.\n      // This takes over the `[style]` binding. (Same for `[class]`)\n      setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased);\n    } else {\n      updateStylingMap(tView, tNode, lView, lView[RENDERER], lView[bindingIndex + 1], lView[bindingIndex + 1] = toStylingKeyValueArray(keyValueArraySet, stringParser, value), isClassBased, bindingIndex);\n    }\n  }\n}\n/**\n * Determines when the binding is in `hostBindings` section\n *\n * @param tView Current `TView`\n * @param bindingIndex index of binding which we would like if it is in `hostBindings`\n */\nfunction isInHostBindings(tView, bindingIndex) {\n  // All host bindings are placed after the expando section.\n  return bindingIndex >= tView.expandoStartIndex;\n}\n/**\n * Collects the necessary information to insert the binding into a linked list of style bindings\n * using `insertTStylingBinding`.\n *\n * @param tView `TView` where the binding linked list will be stored.\n * @param tStylingKey Property/key of the binding.\n * @param bindingIndex Index of binding associated with the `prop`\n * @param isClassBased `true` if `class` change (`false` if `style`)\n */\nfunction stylingFirstUpdatePass(tView, tStylingKey, bindingIndex, isClassBased) {\n  ngDevMode && assertFirstUpdatePass(tView);\n  const tData = tView.data;\n  if (tData[bindingIndex + 1] === null) {\n    // The above check is necessary because we don't clear first update pass until first successful\n    // (no exception) template execution. This prevents the styling instruction from double adding\n    // itself to the list.\n    // `getSelectedIndex()` should be here (rather than in instruction) so that it is guarded by the\n    // if so as not to read unnecessarily.\n    const tNode = tData[getSelectedIndex()];\n    ngDevMode && assertDefined(tNode, 'TNode expected');\n    const isHostBindings = isInHostBindings(tView, bindingIndex);\n    if (hasStylingInputShadow(tNode, isClassBased) && tStylingKey === null && !isHostBindings) {\n      // `tStylingKey === null` implies that we are either `[style]` or `[class]` binding.\n      // If there is a directive which uses `@Input('style')` or `@Input('class')` than\n      // we need to neutralize this binding since that directive is shadowing it.\n      // We turn this into a noop by setting the key to `false`\n      tStylingKey = false;\n    }\n    tStylingKey = wrapInStaticStylingKey(tData, tNode, tStylingKey, isClassBased);\n    insertTStylingBinding(tData, tNode, tStylingKey, bindingIndex, isHostBindings, isClassBased);\n  }\n}\n/**\n * Adds static styling information to the binding if applicable.\n *\n * The linked list of styles not only stores the list and keys, but also stores static styling\n * information on some of the keys. This function determines if the key should contain the styling\n * information and computes it.\n *\n * See `TStylingStatic` for more details.\n *\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param stylingKey `TStylingKeyPrimitive` which may need to be wrapped into `TStylingKey`\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction wrapInStaticStylingKey(tData, tNode, stylingKey, isClassBased) {\n  const hostDirectiveDef = getCurrentDirectiveDef(tData);\n  let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;\n  if (hostDirectiveDef === null) {\n    // We are in template node.\n    // If template node already had styling instruction then it has already collected the static\n    // styling and there is no need to collect them again. We know that we are the first styling\n    // instruction because the `TNode.*Bindings` points to 0 (nothing has been inserted yet).\n    const isFirstStylingInstructionInTemplate = (isClassBased ? tNode.classBindings : tNode.styleBindings) === 0;\n    if (isFirstStylingInstructionInTemplate) {\n      // It would be nice to be able to get the statics from `mergeAttrs`, however, at this point\n      // they are already merged and it would not be possible to figure which property belongs where\n      // in the priority.\n      stylingKey = collectStylingFromDirectives(null, tData, tNode, stylingKey, isClassBased);\n      stylingKey = collectStylingFromTAttrs(stylingKey, tNode.attrs, isClassBased);\n      // We know that if we have styling binding in template we can't have residual.\n      residual = null;\n    }\n  } else {\n    // We are in host binding node and there was no binding instruction in template node.\n    // This means that we need to compute the residual.\n    const directiveStylingLast = tNode.directiveStylingLast;\n    const isFirstStylingInstructionInHostBinding = directiveStylingLast === -1 || tData[directiveStylingLast] !== hostDirectiveDef;\n    if (isFirstStylingInstructionInHostBinding) {\n      stylingKey = collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased);\n      if (residual === null) {\n        // - If `null` than either:\n        //    - Template styling instruction already ran and it has consumed the static\n        //      styling into its `TStylingKey` and so there is no need to update residual. Instead\n        //      we need to update the `TStylingKey` associated with the first template node\n        //      instruction. OR\n        //    - Some other styling instruction ran and determined that there are no residuals\n        let templateStylingKey = getTemplateHeadTStylingKey(tData, tNode, isClassBased);\n        if (templateStylingKey !== undefined && Array.isArray(templateStylingKey)) {\n          // Only recompute if `templateStylingKey` had static values. (If no static value found\n          // then there is nothing to do since this operation can only produce less static keys, not\n          // more.)\n          templateStylingKey = collectStylingFromDirectives(null, tData, tNode, templateStylingKey[1] /* unwrap previous statics */, isClassBased);\n          templateStylingKey = collectStylingFromTAttrs(templateStylingKey, tNode.attrs, isClassBased);\n          setTemplateHeadTStylingKey(tData, tNode, isClassBased, templateStylingKey);\n        }\n      } else {\n        // We only need to recompute residual if it is not `null`.\n        // - If existing residual (implies there was no template styling). This means that some of\n        //   the statics may have moved from the residual to the `stylingKey` and so we have to\n        //   recompute.\n        // - If `undefined` this is the first time we are running.\n        residual = collectResidual(tData, tNode, isClassBased);\n      }\n    }\n  }\n  if (residual !== undefined) {\n    isClassBased ? tNode.residualClasses = residual : tNode.residualStyles = residual;\n  }\n  return stylingKey;\n}\n/**\n * Retrieve the `TStylingKey` for the template styling instruction.\n *\n * This is needed since `hostBinding` styling instructions are inserted after the template\n * instruction. While the template instruction needs to update the residual in `TNode` the\n * `hostBinding` instructions need to update the `TStylingKey` of the template instruction because\n * the template instruction is downstream from the `hostBindings` instructions.\n *\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @return `TStylingKey` if found or `undefined` if not found.\n */\nfunction getTemplateHeadTStylingKey(tData, tNode, isClassBased) {\n  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;\n  if (getTStylingRangeNext(bindings) === 0) {\n    // There does not seem to be a styling instruction in the `template`.\n    return undefined;\n  }\n  return tData[getTStylingRangePrev(bindings)];\n}\n/**\n * Update the `TStylingKey` of the first template instruction in `TNode`.\n *\n * Logically `hostBindings` styling instructions are of lower priority than that of the template.\n * However, they execute after the template styling instructions. This means that they get inserted\n * in front of the template styling instructions.\n *\n * If we have a template styling instruction and a new `hostBindings` styling instruction is\n * executed it means that it may need to steal static fields from the template instruction. This\n * method allows us to update the first template instruction `TStylingKey` with a new value.\n *\n * Assume:\n * ```\n * <div my-dir style=\"color: red\" [style.color]=\"tmplExp\"></div>\n *\n * @Directive({\n *   host: {\n *     'style': 'width: 100px',\n *     '[style.color]': 'dirExp',\n *   }\n * })\n * class MyDir {}\n * ```\n *\n * when `[style.color]=\"tmplExp\"` executes it creates this data structure.\n * ```\n *  ['', 'color', 'color', 'red', 'width', '100px'],\n * ```\n *\n * The reason for this is that the template instruction does not know if there are styling\n * instructions and must assume that there are none and must collect all of the static styling.\n * (both\n * `color' and 'width`)\n *\n * When `'[style.color]': 'dirExp',` executes we need to insert a new data into the linked list.\n * ```\n *  ['', 'color', 'width', '100px'],  // newly inserted\n *  ['', 'color', 'color', 'red', 'width', '100px'], // this is wrong\n * ```\n *\n * Notice that the template statics is now wrong as it incorrectly contains `width` so we need to\n * update it like so:\n * ```\n *  ['', 'color', 'width', '100px'],\n *  ['', 'color', 'color', 'red'],    // UPDATE\n * ```\n *\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @param tStylingKey New `TStylingKey` which is replacing the old one.\n */\nfunction setTemplateHeadTStylingKey(tData, tNode, isClassBased, tStylingKey) {\n  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;\n  ngDevMode && assertNotEqual(getTStylingRangeNext(bindings), 0, 'Expecting to have at least one template styling binding.');\n  tData[getTStylingRangePrev(bindings)] = tStylingKey;\n}\n/**\n * Collect all static values after the current `TNode.directiveStylingLast` index.\n *\n * Collect the remaining styling information which has not yet been collected by an existing\n * styling instruction.\n *\n * @param tData `TData` where the `DirectiveDefs` are stored.\n * @param tNode `TNode` which contains the directive range.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction collectResidual(tData, tNode, isClassBased) {\n  let residual = undefined;\n  const directiveEnd = tNode.directiveEnd;\n  ngDevMode && assertNotEqual(tNode.directiveStylingLast, -1, 'By the time this function gets called at least one hostBindings-node styling instruction must have executed.');\n  // We add `1 + tNode.directiveStart` because we need to skip the current directive (as we are\n  // collecting things after the last `hostBindings` directive which had a styling instruction.)\n  for (let i = 1 + tNode.directiveStylingLast; i < directiveEnd; i++) {\n    const attrs = tData[i].hostAttrs;\n    residual = collectStylingFromTAttrs(residual, attrs, isClassBased);\n  }\n  return collectStylingFromTAttrs(residual, tNode.attrs, isClassBased);\n}\n/**\n * Collect the static styling information with lower priority than `hostDirectiveDef`.\n *\n * (This is opposite of residual styling.)\n *\n * @param hostDirectiveDef `DirectiveDef` for which we want to collect lower priority static\n *        styling. (Or `null` if template styling)\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param stylingKey Existing `TStylingKey` to update or wrap.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased) {\n  // We need to loop because there can be directives which have `hostAttrs` but don't have\n  // `hostBindings` so this loop catches up to the current directive..\n  let currentDirective = null;\n  const directiveEnd = tNode.directiveEnd;\n  let directiveStylingLast = tNode.directiveStylingLast;\n  if (directiveStylingLast === -1) {\n    directiveStylingLast = tNode.directiveStart;\n  } else {\n    directiveStylingLast++;\n  }\n  while (directiveStylingLast < directiveEnd) {\n    currentDirective = tData[directiveStylingLast];\n    ngDevMode && assertDefined(currentDirective, 'expected to be defined');\n    stylingKey = collectStylingFromTAttrs(stylingKey, currentDirective.hostAttrs, isClassBased);\n    if (currentDirective === hostDirectiveDef) break;\n    directiveStylingLast++;\n  }\n  if (hostDirectiveDef !== null) {\n    // we only advance the styling cursor if we are collecting data from host bindings.\n    // Template executes before host bindings and so if we would update the index,\n    // host bindings would not get their statics.\n    tNode.directiveStylingLast = directiveStylingLast;\n  }\n  return stylingKey;\n}\n/**\n * Convert `TAttrs` into `TStylingStatic`.\n *\n * @param stylingKey existing `TStylingKey` to update or wrap.\n * @param attrs `TAttributes` to process.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction collectStylingFromTAttrs(stylingKey, attrs, isClassBased) {\n  const desiredMarker = isClassBased ? 1 /* AttributeMarker.Classes */ : 2 /* AttributeMarker.Styles */;\n  let currentMarker = -1 /* AttributeMarker.ImplicitAttributes */;\n  if (attrs !== null) {\n    for (let i = 0; i < attrs.length; i++) {\n      const item = attrs[i];\n      if (typeof item === 'number') {\n        currentMarker = item;\n      } else {\n        if (currentMarker === desiredMarker) {\n          if (!Array.isArray(stylingKey)) {\n            stylingKey = stylingKey === undefined ? [] : ['', stylingKey];\n          }\n          keyValueArraySet(stylingKey, item, isClassBased ? true : attrs[++i]);\n        }\n      }\n    }\n  }\n  return stylingKey === undefined ? null : stylingKey;\n}\n/**\n * Convert user input to `KeyValueArray`.\n *\n * This function takes user input which could be `string`, Object literal, or iterable and converts\n * it into a consistent representation. The output of this is `KeyValueArray` (which is an array\n * where\n * even indexes contain keys and odd indexes contain values for those keys).\n *\n * The advantage of converting to `KeyValueArray` is that we can perform diff in an input\n * independent\n * way.\n * (ie we can compare `foo bar` to `['bar', 'baz'] and determine a set of changes which need to be\n * applied)\n *\n * The fact that `KeyValueArray` is sorted is very important because it allows us to compute the\n * difference in linear fashion without the need to allocate any additional data.\n *\n * For example if we kept this as a `Map` we would have to iterate over previous `Map` to determine\n * which values need to be deleted, over the new `Map` to determine additions, and we would have to\n * keep additional `Map` to keep track of duplicates or items which have not yet been visited.\n *\n * @param keyValueArraySet (See `keyValueArraySet` in \"util/array_utils\") Gets passed in as a\n *        function so that `style` can be processed. This is done\n *        for tree shaking purposes.\n * @param stringParser The parser is passed in so that it will be tree shakable. See\n *        `styleStringParser` and `classStringParser`\n * @param value The value to parse/convert to `KeyValueArray`\n */\nfunction toStylingKeyValueArray(keyValueArraySet, stringParser, value) {\n  if (value == null /*|| value === undefined */ || value === '') return EMPTY_ARRAY;\n  const styleKeyValueArray = [];\n  const unwrappedValue = unwrapSafeValue(value);\n  if (Array.isArray(unwrappedValue)) {\n    for (let i = 0; i < unwrappedValue.length; i++) {\n      keyValueArraySet(styleKeyValueArray, unwrappedValue[i], true);\n    }\n  } else if (typeof unwrappedValue === 'object') {\n    for (const key in unwrappedValue) {\n      if (unwrappedValue.hasOwnProperty(key)) {\n        keyValueArraySet(styleKeyValueArray, key, unwrappedValue[key]);\n      }\n    }\n  } else if (typeof unwrappedValue === 'string') {\n    stringParser(styleKeyValueArray, unwrappedValue);\n  } else {\n    ngDevMode && throwError('Unsupported styling type ' + typeof unwrappedValue + ': ' + unwrappedValue);\n  }\n  return styleKeyValueArray;\n}\n/**\n * Set a `value` for a `key`.\n *\n * See: `keyValueArraySet` for details\n *\n * @param keyValueArray KeyValueArray to add to.\n * @param key Style key to add.\n * @param value The value to set.\n */\nfunction styleKeyValueArraySet(keyValueArray, key, value) {\n  keyValueArraySet(keyValueArray, key, unwrapSafeValue(value));\n}\n/**\n * Class-binding-specific function for setting the `value` for a `key`.\n *\n * See: `keyValueArraySet` for details\n *\n * @param keyValueArray KeyValueArray to add to.\n * @param key Style key to add.\n * @param value The value to set.\n */\nfunction classKeyValueArraySet(keyValueArray, key, value) {\n  // We use `classList.add` to eventually add the CSS classes to the DOM node. Any value passed into\n  // `add` is stringified and added to the `class` attribute, e.g. even null, undefined or numbers\n  // will be added. Stringify the key here so that our internal data structure matches the value in\n  // the DOM. The only exceptions are empty strings and strings that contain spaces for which\n  // the browser throws an error. We ignore such values, because the error is somewhat cryptic.\n  const stringKey = String(key);\n  if (stringKey !== '' && !stringKey.includes(' ')) {\n    keyValueArraySet(keyValueArray, stringKey, value);\n  }\n}\n/**\n * Update map based styling.\n *\n * Map based styling could be anything which contains more than one binding. For example `string`,\n * or object literal. Dealing with all of these types would complicate the logic so\n * instead this function expects that the complex input is first converted into normalized\n * `KeyValueArray`. The advantage of normalization is that we get the values sorted, which makes it\n * very cheap to compute deltas between the previous and current value.\n *\n * @param tView Associated `TView.data` contains the linked list of binding priorities.\n * @param tNode `TNode` where the binding is located.\n * @param lView `LView` contains the values associated with other styling binding at this `TNode`.\n * @param renderer Renderer to use if any updates.\n * @param oldKeyValueArray Previous value represented as `KeyValueArray`\n * @param newKeyValueArray Current value represented as `KeyValueArray`\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @param bindingIndex Binding index of the binding.\n */\nfunction updateStylingMap(tView, tNode, lView, renderer, oldKeyValueArray, newKeyValueArray, isClassBased, bindingIndex) {\n  if (oldKeyValueArray === NO_CHANGE) {\n    // On first execution the oldKeyValueArray is NO_CHANGE => treat it as empty KeyValueArray.\n    oldKeyValueArray = EMPTY_ARRAY;\n  }\n  let oldIndex = 0;\n  let newIndex = 0;\n  let oldKey = 0 < oldKeyValueArray.length ? oldKeyValueArray[0] : null;\n  let newKey = 0 < newKeyValueArray.length ? newKeyValueArray[0] : null;\n  while (oldKey !== null || newKey !== null) {\n    ngDevMode && assertLessThan(oldIndex, 999, 'Are we stuck in infinite loop?');\n    ngDevMode && assertLessThan(newIndex, 999, 'Are we stuck in infinite loop?');\n    const oldValue = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex + 1] : undefined;\n    const newValue = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex + 1] : undefined;\n    let setKey = null;\n    let setValue = undefined;\n    if (oldKey === newKey) {\n      // UPDATE: Keys are equal => new value is overwriting old value.\n      oldIndex += 2;\n      newIndex += 2;\n      if (oldValue !== newValue) {\n        setKey = newKey;\n        setValue = newValue;\n      }\n    } else if (newKey === null || oldKey !== null && oldKey < newKey) {\n      // DELETE: oldKey key is missing or we did not find the oldKey in the newValue\n      // (because the keyValueArray is sorted and `newKey` is found later alphabetically).\n      // `\"background\" < \"color\"` so we need to delete `\"background\"` because it is not found in the\n      // new array.\n      oldIndex += 2;\n      setKey = oldKey;\n    } else {\n      // CREATE: newKey's is earlier alphabetically than oldKey's (or no oldKey) => we have new key.\n      // `\"color\" > \"background\"` so we need to add `color` because it is in new array but not in\n      // old array.\n      ngDevMode && assertDefined(newKey, 'Expecting to have a valid key');\n      newIndex += 2;\n      setKey = newKey;\n      setValue = newValue;\n    }\n    if (setKey !== null) {\n      updateStyling(tView, tNode, lView, renderer, setKey, setValue, isClassBased, bindingIndex);\n    }\n    oldKey = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex] : null;\n    newKey = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex] : null;\n  }\n}\n/**\n * Update a simple (property name) styling.\n *\n * This function takes `prop` and updates the DOM to that value. The function takes the binding\n * value as well as binding priority into consideration to determine which value should be written\n * to DOM. (For example it may be determined that there is a higher priority overwrite which blocks\n * the DOM write, or if the value goes to `undefined` a lower priority overwrite may be consulted.)\n *\n * @param tView Associated `TView.data` contains the linked list of binding priorities.\n * @param tNode `TNode` where the binding is located.\n * @param lView `LView` contains the values associated with other styling binding at this `TNode`.\n * @param renderer Renderer to use if any updates.\n * @param prop Either style property name or a class name.\n * @param value Either style value for `prop` or `true`/`false` if `prop` is class.\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @param bindingIndex Binding index of the binding.\n */\nfunction updateStyling(tView, tNode, lView, renderer, prop, value, isClassBased, bindingIndex) {\n  if (!(tNode.type & 3 /* TNodeType.AnyRNode */)) {\n    // It is possible to have styling on non-elements (such as ng-container).\n    // This is rare, but it does happen. In such a case, just ignore the binding.\n    return;\n  }\n  const tData = tView.data;\n  const tRange = tData[bindingIndex + 1];\n  const higherPriorityValue = getTStylingRangeNextDuplicate(tRange) ? findStylingValue(tData, tNode, lView, prop, getTStylingRangeNext(tRange), isClassBased) : undefined;\n  if (!isStylingValuePresent(higherPriorityValue)) {\n    // We don't have a next duplicate, or we did not find a duplicate value.\n    if (!isStylingValuePresent(value)) {\n      // We should delete current value or restore to lower priority value.\n      if (getTStylingRangePrevDuplicate(tRange)) {\n        // We have a possible prev duplicate, let's retrieve it.\n        value = findStylingValue(tData, null, lView, prop, bindingIndex, isClassBased);\n      }\n    }\n    const rNode = getNativeByIndex(getSelectedIndex(), lView);\n    applyStyling(renderer, isClassBased, rNode, prop, value);\n  }\n}\n/**\n * Search for styling value with higher priority which is overwriting current value, or a\n * value of lower priority to which we should fall back if the value is `undefined`.\n *\n * When value is being applied at a location, related values need to be consulted.\n * - If there is a higher priority binding, we should be using that one instead.\n *   For example `<div  [style]=\"{color:exp1}\" [style.color]=\"exp2\">` change to `exp1`\n *   requires that we check `exp2` to see if it is set to value other than `undefined`.\n * - If there is a lower priority binding and we are changing to `undefined`\n *   For example `<div  [style]=\"{color:exp1}\" [style.color]=\"exp2\">` change to `exp2` to\n *   `undefined` requires that we check `exp1` (and static values) and use that as new value.\n *\n * NOTE: The styling stores two values.\n * 1. The raw value which came from the application is stored at `index + 0` location. (This value\n *    is used for dirty checking).\n * 2. The normalized value is stored at `index + 1`.\n *\n * @param tData `TData` used for traversing the priority.\n * @param tNode `TNode` to use for resolving static styling. Also controls search direction.\n *   - `TNode` search next and quit as soon as `isStylingValuePresent(value)` is true.\n *      If no value found consult `tNode.residualStyle`/`tNode.residualClass` for default value.\n *   - `null` search prev and go all the way to end. Return last value where\n *     `isStylingValuePresent(value)` is true.\n * @param lView `LView` used for retrieving the actual values.\n * @param prop Property which we are interested in.\n * @param index Starting index in the linked list of styling bindings where the search should start.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction findStylingValue(tData, tNode, lView, prop, index, isClassBased) {\n  // `TNode` to use for resolving static styling. Also controls search direction.\n  //   - `TNode` search next and quit as soon as `isStylingValuePresent(value)` is true.\n  //      If no value found consult `tNode.residualStyle`/`tNode.residualClass` for default value.\n  //   - `null` search prev and go all the way to end. Return last value where\n  //     `isStylingValuePresent(value)` is true.\n  const isPrevDirection = tNode === null;\n  let value = undefined;\n  while (index > 0) {\n    const rawKey = tData[index];\n    const containsStatics = Array.isArray(rawKey);\n    // Unwrap the key if we contain static values.\n    const key = containsStatics ? rawKey[1] : rawKey;\n    const isStylingMap = key === null;\n    let valueAtLViewIndex = lView[index + 1];\n    if (valueAtLViewIndex === NO_CHANGE) {\n      // In firstUpdatePass the styling instructions create a linked list of styling.\n      // On subsequent passes it is possible for a styling instruction to try to read a binding\n      // which\n      // has not yet executed. In that case we will find `NO_CHANGE` and we should assume that\n      // we have `undefined` (or empty array in case of styling-map instruction) instead. This\n      // allows the resolution to apply the value (which may later be overwritten when the\n      // binding actually executes.)\n      valueAtLViewIndex = isStylingMap ? EMPTY_ARRAY : undefined;\n    }\n    let currentValue = isStylingMap ? keyValueArrayGet(valueAtLViewIndex, prop) : key === prop ? valueAtLViewIndex : undefined;\n    if (containsStatics && !isStylingValuePresent(currentValue)) {\n      currentValue = keyValueArrayGet(rawKey, prop);\n    }\n    if (isStylingValuePresent(currentValue)) {\n      value = currentValue;\n      if (isPrevDirection) {\n        return value;\n      }\n    }\n    const tRange = tData[index + 1];\n    index = isPrevDirection ? getTStylingRangePrev(tRange) : getTStylingRangeNext(tRange);\n  }\n  if (tNode !== null) {\n    // in case where we are going in next direction AND we did not find anything, we need to\n    // consult residual styling\n    let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;\n    if (residual != null /** OR residual !=== undefined */) {\n      value = keyValueArrayGet(residual, prop);\n    }\n  }\n  return value;\n}\n/**\n * Determines if the binding value should be used (or if the value is 'undefined' and hence priority\n * resolution should be used.)\n *\n * @param value Binding style value.\n */\nfunction isStylingValuePresent(value) {\n  // Currently only `undefined` value is considered non-binding. That is `undefined` says I don't\n  // have an opinion as to what this binding should be and you should consult other bindings by\n  // priority to determine the valid value.\n  // This is extracted into a single function so that we have a single place to control this.\n  return value !== undefined;\n}\n/**\n * Normalizes and/or adds a suffix to the value.\n *\n * If value is `null`/`undefined` no suffix is added\n * @param value\n * @param suffix\n */\nfunction normalizeSuffix(value, suffix) {\n  if (value == null || value === '') {\n    // do nothing\n    // Do not add the suffix if the value is going to be empty.\n    // As it produce invalid CSS, which the browsers will automatically omit but Domino will not.\n    // Example: `\"left\": \"px;\"` instead of `\"left\": \"\"`.\n  } else if (typeof suffix === 'string') {\n    value = value + suffix;\n  } else if (typeof value === 'object') {\n    value = stringify(unwrapSafeValue(value));\n  }\n  return value;\n}\n/**\n * Tests if the `TNode` has input shadow.\n *\n * An input shadow is when a directive steals (shadows) the input by using `@Input('style')` or\n * `@Input('class')` as input.\n *\n * @param tNode `TNode` which we would like to see if it has shadow.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction hasStylingInputShadow(tNode, isClassBased) {\n  return (tNode.flags & (isClassBased ? 8 /* TNodeFlags.hasClassInput */ : 16 /* TNodeFlags.hasStyleInput */)) !== 0;\n}\n\n/**\n * Create static text node\n *\n * @param index Index of the node in the data array\n * @param value Static string value to write.\n *\n * @codeGenApi\n */\nfunction ɵɵtext(index, value = '') {\n  const lView = getLView();\n  const tView = getTView();\n  const adjustedIndex = index + HEADER_OFFSET;\n  ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, 'text nodes should be created before any bindings');\n  ngDevMode && assertIndexInRange(lView, adjustedIndex);\n  const tNode = tView.firstCreatePass ? getOrCreateTNode(tView, adjustedIndex, 1 /* TNodeType.Text */, value, null) : tView.data[adjustedIndex];\n  const textNative = _locateOrCreateTextNode(tView, lView, tNode, value, index);\n  lView[adjustedIndex] = textNative;\n  if (wasLastNodeCreated()) {\n    appendChild(tView, lView, textNative, tNode);\n  }\n  // Text nodes are self closing.\n  setCurrentTNode(tNode, false);\n}\nlet _locateOrCreateTextNode = (tView, lView, tNode, value, index) => {\n  lastNodeWasCreated(true);\n  return createTextNode(lView[RENDERER], value);\n};\n/**\n * Enables hydration code path (to lookup existing elements in DOM)\n * in addition to the regular creation mode of text nodes.\n */\nfunction locateOrCreateTextNodeImpl(tView, lView, tNode, value, index) {\n  const hydrationInfo = lView[HYDRATION];\n  const isNodeCreationMode = !hydrationInfo || isInSkipHydrationBlock$1() || isDisconnectedNode(hydrationInfo, index);\n  lastNodeWasCreated(isNodeCreationMode);\n  // Regular creation mode.\n  if (isNodeCreationMode) {\n    return createTextNode(lView[RENDERER], value);\n  }\n  // Hydration mode, looking up an existing element in DOM.\n  const textNative = locateNextRNode(hydrationInfo, tView, lView, tNode);\n  ngDevMode && validateMatchingNode(textNative, Node.TEXT_NODE, null, lView, tNode);\n  ngDevMode && markRNodeAsClaimedByHydration(textNative);\n  return textNative;\n}\nfunction enableLocateOrCreateTextNodeImpl() {\n  _locateOrCreateTextNode = locateOrCreateTextNodeImpl;\n}\n\n/**\n *\n * Update text content with a lone bound value\n *\n * Used when a text node has 1 interpolated value in it, an no additional text\n * surrounds that interpolated value:\n *\n * ```html\n * <div>{{v0}}</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate(v0);\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction ɵɵtextInterpolate(v0) {\n  ɵɵtextInterpolate1('', v0, '');\n  return ɵɵtextInterpolate;\n}\n/**\n *\n * Update text content with single bound value surrounded by other text.\n *\n * Used when a text node has 1 interpolated value in it:\n *\n * ```html\n * <div>prefix{{v0}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate1('prefix', v0, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction ɵɵtextInterpolate1(prefix, v0, suffix) {\n  const lView = getLView();\n  const interpolated = interpolation1(lView, prefix, v0, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated);\n  }\n  return ɵɵtextInterpolate1;\n}\n/**\n *\n * Update text content with 2 bound values surrounded by other text.\n *\n * Used when a text node has 2 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate2('prefix', v0, '-', v1, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction ɵɵtextInterpolate2(prefix, v0, i0, v1, suffix) {\n  const lView = getLView();\n  const interpolated = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated);\n  }\n  return ɵɵtextInterpolate2;\n}\n/**\n *\n * Update text content with 3 bound values surrounded by other text.\n *\n * Used when a text node has 3 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate3(\n * 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction ɵɵtextInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {\n  const lView = getLView();\n  const interpolated = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated);\n  }\n  return ɵɵtextInterpolate3;\n}\n/**\n *\n * Update text content with 4 bound values surrounded by other text.\n *\n * Used when a text node has 4 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate4(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see ɵɵtextInterpolateV\n * @codeGenApi\n */\nfunction ɵɵtextInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {\n  const lView = getLView();\n  const interpolated = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated);\n  }\n  return ɵɵtextInterpolate4;\n}\n/**\n *\n * Update text content with 5 bound values surrounded by other text.\n *\n * Used when a text node has 5 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate5(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction ɵɵtextInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {\n  const lView = getLView();\n  const interpolated = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated);\n  }\n  return ɵɵtextInterpolate5;\n}\n/**\n *\n * Update text content with 6 bound values surrounded by other text.\n *\n * Used when a text node has 6 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate6(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change. @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction ɵɵtextInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {\n  const lView = getLView();\n  const interpolated = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated);\n  }\n  return ɵɵtextInterpolate6;\n}\n/**\n *\n * Update text content with 7 bound values surrounded by other text.\n *\n * Used when a text node has 7 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate7(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction ɵɵtextInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {\n  const lView = getLView();\n  const interpolated = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated);\n  }\n  return ɵɵtextInterpolate7;\n}\n/**\n *\n * Update text content with 8 bound values surrounded by other text.\n *\n * Used when a text node has 8 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate8(\n *  'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction ɵɵtextInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {\n  const lView = getLView();\n  const interpolated = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated);\n  }\n  return ɵɵtextInterpolate8;\n}\n/**\n * Update text content with 9 or more bound values other surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolateV(\n *  ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n *\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵtextInterpolateV(values) {\n  const lView = getLView();\n  const interpolated = interpolationV(lView, values);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated);\n  }\n  return ɵɵtextInterpolateV;\n}\n\n/**\n *\n * Update an interpolated class on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate1('prefix', v0, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵclassMapInterpolate1(prefix, v0, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate2('prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵclassMapInterpolate2(prefix, v0, i0, v1, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate3(\n * 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵclassMapInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate4(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵclassMapInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate5(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵclassMapInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate6(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵclassMapInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate7(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵclassMapInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate8(\n *  'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵclassMapInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n * Update an interpolated class on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolateV(\n *  ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @codeGenApi\n */\nfunction ɵɵclassMapInterpolateV(values) {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated style on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div style=\"key: {{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate1('key: ', v0, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵstyleMapInterpolate1(prefix, v0, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate2('key: ', v0, '; key1: ', v1, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵstyleMapInterpolate2(prefix, v0, i0, v1, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key2: {{v1}}; key2: {{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate3(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵstyleMapInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate4(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵstyleMapInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate5(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵstyleMapInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}};\n *             key5: {{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate6(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵstyleMapInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *             key6: {{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate7(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    '; key6: ', v6, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵstyleMapInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *             key6: {{v6}}; key7: {{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate8(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    '; key6: ', v6, '; key7: ', v7, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵstyleMapInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n/**\n * Update an interpolated style on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  class=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *         key6: {{v6}}; key7: {{v7}}; key8: {{v8}}; key9: {{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolateV(\n *    ['key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *     '; key6: ', v6, '; key7: ', v7, '; key8: ', v8, '; key9: ', v9, 'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '; key2: ', value1, '; key2: ', value2, ..., value99, 'suffix']`)\n * @codeGenApi\n */\nfunction ɵɵstyleMapInterpolateV(values) {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  ɵɵstyleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style property on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate1(0, 'prefix', v0, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵstylePropInterpolate1(prop, prefix, v0, suffix, valueSuffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate1;\n}\n/**\n *\n * Update an interpolated style property on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate2(0, 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵstylePropInterpolate2(prop, prefix, v0, i0, v1, suffix, valueSuffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate2;\n}\n/**\n *\n * Update an interpolated style property on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate3(0, 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵstylePropInterpolate3(prop, prefix, v0, i0, v1, i1, v2, suffix, valueSuffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate3;\n}\n/**\n *\n * Update an interpolated style property on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate4(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵstylePropInterpolate4(prop, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, valueSuffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate4;\n}\n/**\n *\n * Update an interpolated style property on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate5(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵstylePropInterpolate5(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, valueSuffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate5;\n}\n/**\n *\n * Update an interpolated style property on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate6(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵstylePropInterpolate6(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, valueSuffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate6;\n}\n/**\n *\n * Update an interpolated style property on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate7(\n *    0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵstylePropInterpolate7(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, valueSuffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate7;\n}\n/**\n *\n * Update an interpolated style property on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate8(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6,\n * '-', v7, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵstylePropInterpolate8(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, valueSuffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate8;\n}\n/**\n * Update an interpolated style property on an element with 9 or more bound values surrounded by\n * text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\">\n * </div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolateV(\n *  0, ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`..\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵstylePropInterpolateV(prop, values, valueSuffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolateV;\n}\n\n/**\n * Update a property on a host element. Only applies to native node properties, not inputs.\n *\n * Operates on the element selected by index via the {@link select} instruction.\n *\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n * @returns This function returns itself so that it may be chained\n * (e.g. `property('name', ctx.name)('title', ctx.title)`)\n *\n * @codeGenApi\n */\nfunction ɵɵhostProperty(propName, value, sanitizer) {\n  const lView = getLView();\n  const bindingIndex = nextBindingIndex();\n  if (bindingUpdated(lView, bindingIndex, value)) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, true);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);\n  }\n  return ɵɵhostProperty;\n}\n/**\n * Updates a synthetic host binding (e.g. `[@foo]`) on a component or directive.\n *\n * This instruction is for compatibility purposes and is designed to ensure that a\n * synthetic host binding (e.g. `@HostBinding('@foo')`) properly gets rendered in\n * the component's renderer. Normally all host bindings are evaluated with the parent\n * component's renderer, but, in the case of animation @triggers, they need to be\n * evaluated with the sub component's renderer (because that's where the animation\n * triggers are defined).\n *\n * Do not use this instruction as a replacement for `elementProperty`. This instruction\n * only exists to ensure compatibility with the ViewEngine's host binding behavior.\n *\n * @param index The index of the element to update in the data array\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n *\n * @codeGenApi\n */\nfunction ɵɵsyntheticHostProperty(propName, value, sanitizer) {\n  const lView = getLView();\n  const bindingIndex = nextBindingIndex();\n  if (bindingUpdated(lView, bindingIndex, value)) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    const currentDef = getCurrentDirectiveDef(tView.data);\n    const renderer = loadComponentRenderer(currentDef, tNode, lView);\n    elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, true);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);\n  }\n  return ɵɵsyntheticHostProperty;\n}\n\n/**\n * NOTE: changes to the `ngI18nClosureMode` name must be synced with `compiler-cli/src/tooling.ts`.\n */\nif (typeof ngI18nClosureMode === 'undefined') {\n  // These property accesses can be ignored because ngI18nClosureMode will be set to false\n  // when optimizing code and the whole if statement will be dropped.\n  // Make sure to refer to ngI18nClosureMode as ['ngI18nClosureMode'] for closure.\n  // NOTE: we need to have it in IIFE so that the tree-shaker is happy.\n  (function () {\n    // tslint:disable-next-line:no-toplevel-property-access\n    _global['ngI18nClosureMode'] =\n    // TODO(FW-1250): validate that this actually, you know, works.\n    // tslint:disable-next-line:no-toplevel-property-access\n    typeof goog !== 'undefined' && typeof goog.getMsg === 'function';\n  })();\n}\n\n// THIS CODE IS GENERATED - DO NOT MODIFY.\nconst u = undefined;\nfunction plural(val) {\n  const n = val,\n    i = Math.floor(Math.abs(val)),\n    v = val.toString().replace(/^[^.]*\\.?/, '').length;\n  if (i === 1 && v === 0) return 1;\n  return 5;\n}\nvar localeEn = [\"en\", [[\"a\", \"p\"], [\"AM\", \"PM\"], u], [[\"AM\", \"PM\"], u, u], [[\"S\", \"M\", \"T\", \"W\", \"T\", \"F\", \"S\"], [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"], [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"], [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\"]], u, [[\"J\", \"F\", \"M\", \"A\", \"M\", \"J\", \"J\", \"A\", \"S\", \"O\", \"N\", \"D\"], [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"], [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"]], u, [[\"B\", \"A\"], [\"BC\", \"AD\"], [\"Before Christ\", \"Anno Domini\"]], 0, [6, 0], [\"M/d/yy\", \"MMM d, y\", \"MMMM d, y\", \"EEEE, MMMM d, y\"], [\"h:mm a\", \"h:mm:ss a\", \"h:mm:ss a z\", \"h:mm:ss a zzzz\"], [\"{1}, {0}\", u, \"{1} 'at' {0}\", u], [\".\", \",\", \";\", \"%\", \"+\", \"-\", \"E\", \"×\", \"‰\", \"∞\", \"NaN\", \":\"], [\"#,##0.###\", \"#,##0%\", \"¤#,##0.00\", \"#E0\"], \"USD\", \"$\", \"US Dollar\", {}, \"ltr\", plural];\n\n/**\n * This const is used to store the locale data registered with `registerLocaleData`\n */\nlet LOCALE_DATA = {};\n/**\n * Register locale data to be used internally by Angular. See the\n * [\"I18n guide\"](guide/i18n-common-format-data-locale) to know how to import additional locale\n * data.\n *\n * The signature `registerLocaleData(data: any, extraData?: any)` is deprecated since v5.1\n */\nfunction registerLocaleData(data, localeId, extraData) {\n  if (typeof localeId !== 'string') {\n    extraData = localeId;\n    localeId = data[LocaleDataIndex.LocaleId];\n  }\n  localeId = localeId.toLowerCase().replace(/_/g, '-');\n  LOCALE_DATA[localeId] = data;\n  if (extraData) {\n    LOCALE_DATA[localeId][LocaleDataIndex.ExtraData] = extraData;\n  }\n}\n/**\n * Finds the locale data for a given locale.\n *\n * @param locale The locale code.\n * @returns The locale data.\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n-overview)\n */\nfunction findLocaleData(locale) {\n  const normalizedLocale = normalizeLocale(locale);\n  let match = getLocaleData(normalizedLocale);\n  if (match) {\n    return match;\n  }\n  // let's try to find a parent locale\n  const parentLocale = normalizedLocale.split('-')[0];\n  match = getLocaleData(parentLocale);\n  if (match) {\n    return match;\n  }\n  if (parentLocale === 'en') {\n    return localeEn;\n  }\n  throw new RuntimeError(701 /* RuntimeErrorCode.MISSING_LOCALE_DATA */, ngDevMode && `Missing locale data for the locale \"${locale}\".`);\n}\n/**\n * Retrieves the default currency code for the given locale.\n *\n * The default is defined as the first currency which is still in use.\n *\n * @param locale The code of the locale whose currency code we want.\n * @returns The code of the default currency for the given locale.\n *\n */\nfunction getLocaleCurrencyCode(locale) {\n  const data = findLocaleData(locale);\n  return data[LocaleDataIndex.CurrencyCode] || null;\n}\n/**\n * Retrieves the plural function used by ICU expressions to determine the plural case to use\n * for a given locale.\n * @param locale A locale code for the locale format rules to use.\n * @returns The plural function for the locale.\n * @see {@link NgPlural}\n * @see [Internationalization (i18n) Guide](/guide/i18n-overview)\n */\nfunction getLocalePluralCase(locale) {\n  const data = findLocaleData(locale);\n  return data[LocaleDataIndex.PluralCase];\n}\n/**\n * Helper function to get the given `normalizedLocale` from `LOCALE_DATA`\n * or from the global `ng.common.locale`.\n */\nfunction getLocaleData(normalizedLocale) {\n  if (!(normalizedLocale in LOCALE_DATA)) {\n    LOCALE_DATA[normalizedLocale] = _global.ng && _global.ng.common && _global.ng.common.locales && _global.ng.common.locales[normalizedLocale];\n  }\n  return LOCALE_DATA[normalizedLocale];\n}\n/**\n * Helper function to remove all the locale data from `LOCALE_DATA`.\n */\nfunction unregisterAllLocaleData() {\n  LOCALE_DATA = {};\n}\n/**\n * Index of each type of locale data from the locale data array\n */\nvar LocaleDataIndex;\n(function (LocaleDataIndex) {\n  LocaleDataIndex[LocaleDataIndex[\"LocaleId\"] = 0] = \"LocaleId\";\n  LocaleDataIndex[LocaleDataIndex[\"DayPeriodsFormat\"] = 1] = \"DayPeriodsFormat\";\n  LocaleDataIndex[LocaleDataIndex[\"DayPeriodsStandalone\"] = 2] = \"DayPeriodsStandalone\";\n  LocaleDataIndex[LocaleDataIndex[\"DaysFormat\"] = 3] = \"DaysFormat\";\n  LocaleDataIndex[LocaleDataIndex[\"DaysStandalone\"] = 4] = \"DaysStandalone\";\n  LocaleDataIndex[LocaleDataIndex[\"MonthsFormat\"] = 5] = \"MonthsFormat\";\n  LocaleDataIndex[LocaleDataIndex[\"MonthsStandalone\"] = 6] = \"MonthsStandalone\";\n  LocaleDataIndex[LocaleDataIndex[\"Eras\"] = 7] = \"Eras\";\n  LocaleDataIndex[LocaleDataIndex[\"FirstDayOfWeek\"] = 8] = \"FirstDayOfWeek\";\n  LocaleDataIndex[LocaleDataIndex[\"WeekendRange\"] = 9] = \"WeekendRange\";\n  LocaleDataIndex[LocaleDataIndex[\"DateFormat\"] = 10] = \"DateFormat\";\n  LocaleDataIndex[LocaleDataIndex[\"TimeFormat\"] = 11] = \"TimeFormat\";\n  LocaleDataIndex[LocaleDataIndex[\"DateTimeFormat\"] = 12] = \"DateTimeFormat\";\n  LocaleDataIndex[LocaleDataIndex[\"NumberSymbols\"] = 13] = \"NumberSymbols\";\n  LocaleDataIndex[LocaleDataIndex[\"NumberFormats\"] = 14] = \"NumberFormats\";\n  LocaleDataIndex[LocaleDataIndex[\"CurrencyCode\"] = 15] = \"CurrencyCode\";\n  LocaleDataIndex[LocaleDataIndex[\"CurrencySymbol\"] = 16] = \"CurrencySymbol\";\n  LocaleDataIndex[LocaleDataIndex[\"CurrencyName\"] = 17] = \"CurrencyName\";\n  LocaleDataIndex[LocaleDataIndex[\"Currencies\"] = 18] = \"Currencies\";\n  LocaleDataIndex[LocaleDataIndex[\"Directionality\"] = 19] = \"Directionality\";\n  LocaleDataIndex[LocaleDataIndex[\"PluralCase\"] = 20] = \"PluralCase\";\n  LocaleDataIndex[LocaleDataIndex[\"ExtraData\"] = 21] = \"ExtraData\";\n})(LocaleDataIndex || (LocaleDataIndex = {}));\n/**\n * Returns the canonical form of a locale name - lowercase with `_` replaced with `-`.\n */\nfunction normalizeLocale(locale) {\n  return locale.toLowerCase().replace(/_/g, '-');\n}\nconst pluralMapping = ['zero', 'one', 'two', 'few', 'many'];\n/**\n * Returns the plural case based on the locale\n */\nfunction getPluralCase(value, locale) {\n  const plural = getLocalePluralCase(locale)(parseInt(value, 10));\n  const result = pluralMapping[plural];\n  return result !== undefined ? result : 'other';\n}\n/**\n * The locale id that the application is using by default (for translations and ICU expressions).\n */\nconst DEFAULT_LOCALE_ID = 'en-US';\n/**\n * USD currency code that the application uses by default for CurrencyPipe when no\n * DEFAULT_CURRENCY_CODE is provided.\n */\nconst USD_CURRENCY_CODE = 'USD';\n\n/**\n * Marks that the next string is an element name.\n *\n * See `I18nMutateOpCodes` documentation.\n */\nconst ELEMENT_MARKER = {\n  marker: 'element'\n};\n/**\n * Marks that the next string is comment text need for ICU.\n *\n * See `I18nMutateOpCodes` documentation.\n */\nconst ICU_MARKER = {\n  marker: 'ICU'\n};\n/**\n * See `I18nCreateOpCodes`\n */\nvar I18nCreateOpCode;\n(function (I18nCreateOpCode) {\n  /**\n   * Number of bits to shift index so that it can be combined with the `APPEND_EAGERLY` and\n   * `COMMENT`.\n   */\n  I18nCreateOpCode[I18nCreateOpCode[\"SHIFT\"] = 2] = \"SHIFT\";\n  /**\n   * Should the node be appended to parent immediately after creation.\n   */\n  I18nCreateOpCode[I18nCreateOpCode[\"APPEND_EAGERLY\"] = 1] = \"APPEND_EAGERLY\";\n  /**\n   * If set the node should be comment (rather than a text) node.\n   */\n  I18nCreateOpCode[I18nCreateOpCode[\"COMMENT\"] = 2] = \"COMMENT\";\n})(I18nCreateOpCode || (I18nCreateOpCode = {}));\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd = 1;\n\n/**\n * The locale id that the application is currently using (for translations and ICU expressions).\n * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine\n * but is now defined as a global value.\n */\nlet LOCALE_ID = DEFAULT_LOCALE_ID;\n/**\n * Sets the locale id that will be used for translations and ICU expressions.\n * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine\n * but is now defined as a global value.\n *\n * @param localeId\n */\nfunction setLocaleId(localeId) {\n  assertDefined(localeId, `Expected localeId to be defined`);\n  if (typeof localeId === 'string') {\n    LOCALE_ID = localeId.toLowerCase().replace(/_/g, '-');\n  }\n}\n/**\n * Gets the locale id that will be used for translations and ICU expressions.\n * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine\n * but is now defined as a global value.\n */\nfunction getLocaleId() {\n  return LOCALE_ID;\n}\n\n/**\n * Find a node in front of which `currentTNode` should be inserted (takes i18n into account).\n *\n * This method determines the `RNode` in front of which we should insert the `currentRNode`. This\n * takes `TNode.insertBeforeIndex` into account.\n *\n * @param parentTNode parent `TNode`\n * @param currentTNode current `TNode` (The node which we would like to insert into the DOM)\n * @param lView current `LView`\n */\nfunction getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView) {\n  const tNodeInsertBeforeIndex = currentTNode.insertBeforeIndex;\n  const insertBeforeIndex = Array.isArray(tNodeInsertBeforeIndex) ? tNodeInsertBeforeIndex[0] : tNodeInsertBeforeIndex;\n  if (insertBeforeIndex === null) {\n    return getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView);\n  } else {\n    ngDevMode && assertIndexInRange(lView, insertBeforeIndex);\n    return unwrapRNode(lView[insertBeforeIndex]);\n  }\n}\n/**\n * Process `TNode.insertBeforeIndex` by adding i18n text nodes.\n *\n * See `TNode.insertBeforeIndex`\n */\nfunction processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRElement) {\n  const tNodeInsertBeforeIndex = childTNode.insertBeforeIndex;\n  if (Array.isArray(tNodeInsertBeforeIndex)) {\n    // An array indicates that there are i18n nodes that need to be added as children of this\n    // `childRNode`. These i18n nodes were created before this `childRNode` was available and so\n    // only now can be added. The first element of the array is the normal index where we should\n    // insert the `childRNode`. Additional elements are the extra nodes to be added as children of\n    // `childRNode`.\n    ngDevMode && assertDomNode(childRNode);\n    let i18nParent = childRNode;\n    let anchorRNode = null;\n    if (!(childTNode.type & 3 /* TNodeType.AnyRNode */)) {\n      anchorRNode = i18nParent;\n      i18nParent = parentRElement;\n    }\n    if (i18nParent !== null && childTNode.componentOffset === -1) {\n      for (let i = 1; i < tNodeInsertBeforeIndex.length; i++) {\n        // No need to `unwrapRNode` because all of the indexes point to i18n text nodes.\n        // see `assertDomNode` below.\n        const i18nChild = lView[tNodeInsertBeforeIndex[i]];\n        nativeInsertBefore(renderer, i18nParent, i18nChild, anchorRNode, false);\n      }\n    }\n  }\n}\n\n/**\n * Add `tNode` to `previousTNodes` list and update relevant `TNode`s in `previousTNodes` list\n * `tNode.insertBeforeIndex`.\n *\n * Things to keep in mind:\n * 1. All i18n text nodes are encoded as `TNodeType.Element` and are created eagerly by the\n *    `ɵɵi18nStart` instruction.\n * 2. All `TNodeType.Placeholder` `TNodes` are elements which will be created later by\n *    `ɵɵelementStart` instruction.\n * 3. `ɵɵelementStart` instruction will create `TNode`s in the ascending `TNode.index` order. (So a\n *    smaller index `TNode` is guaranteed to be created before a larger one)\n *\n * We use the above three invariants to determine `TNode.insertBeforeIndex`.\n *\n * In an ideal world `TNode.insertBeforeIndex` would always be `TNode.next.index`. However,\n * this will not work because `TNode.next.index` may be larger than `TNode.index` which means that\n * the next node is not yet created and therefore we can't insert in front of it.\n *\n * Rule1: `TNode.insertBeforeIndex = null` if `TNode.next === null` (Initial condition, as we don't\n *        know if there will be further `TNode`s inserted after.)\n * Rule2: If `previousTNode` is created after the `tNode` being inserted, then\n *        `previousTNode.insertBeforeNode = tNode.index` (So when a new `tNode` is added we check\n *        previous to see if we can update its `insertBeforeTNode`)\n *\n * See `TNode.insertBeforeIndex` for more context.\n *\n * @param previousTNodes A list of previous TNodes so that we can easily traverse `TNode`s in\n *     reverse order. (If `TNode` would have `previous` this would not be necessary.)\n * @param newTNode A TNode to add to the `previousTNodes` list.\n */\nfunction addTNodeAndUpdateInsertBeforeIndex(previousTNodes, newTNode) {\n  // Start with Rule1\n  ngDevMode && assertEqual(newTNode.insertBeforeIndex, null, 'We expect that insertBeforeIndex is not set');\n  previousTNodes.push(newTNode);\n  if (previousTNodes.length > 1) {\n    for (let i = previousTNodes.length - 2; i >= 0; i--) {\n      const existingTNode = previousTNodes[i];\n      // Text nodes are created eagerly and so they don't need their `indexBeforeIndex` updated.\n      // It is safe to ignore them.\n      if (!isI18nText(existingTNode)) {\n        if (isNewTNodeCreatedBefore(existingTNode, newTNode) && getInsertBeforeIndex(existingTNode) === null) {\n          // If it was created before us in time, (and it does not yet have `insertBeforeIndex`)\n          // then add the `insertBeforeIndex`.\n          setInsertBeforeIndex(existingTNode, newTNode.index);\n        }\n      }\n    }\n  }\n}\nfunction isI18nText(tNode) {\n  return !(tNode.type & 64 /* TNodeType.Placeholder */);\n}\n\nfunction isNewTNodeCreatedBefore(existingTNode, newTNode) {\n  return isI18nText(newTNode) || existingTNode.index > newTNode.index;\n}\nfunction getInsertBeforeIndex(tNode) {\n  const index = tNode.insertBeforeIndex;\n  return Array.isArray(index) ? index[0] : index;\n}\nfunction setInsertBeforeIndex(tNode, value) {\n  const index = tNode.insertBeforeIndex;\n  if (Array.isArray(index)) {\n    // Array is stored if we have to insert child nodes. See `TNode.insertBeforeIndex`\n    index[0] = value;\n  } else {\n    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);\n    tNode.insertBeforeIndex = value;\n  }\n}\n\n/**\n * Retrieve `TIcu` at a given `index`.\n *\n * The `TIcu` can be stored either directly (if it is nested ICU) OR\n * it is stored inside tho `TIcuContainer` if it is top level ICU.\n *\n * The reason for this is that the top level ICU need a `TNode` so that they are part of the render\n * tree, but nested ICU's have no TNode, because we don't know ahead of time if the nested ICU is\n * expressed (parent ICU may have selected a case which does not contain it.)\n *\n * @param tView Current `TView`.\n * @param index Index where the value should be read from.\n */\nfunction getTIcu(tView, index) {\n  const value = tView.data[index];\n  if (value === null || typeof value === 'string') return null;\n  if (ngDevMode && !(value.hasOwnProperty('tView') || value.hasOwnProperty('currentCaseLViewIndex'))) {\n    throwError('We expect to get \\'null\\'|\\'TIcu\\'|\\'TIcuContainer\\', but got: ' + value);\n  }\n  // Here the `value.hasOwnProperty('currentCaseLViewIndex')` is a polymorphic read as it can be\n  // either TIcu or TIcuContainerNode. This is not ideal, but we still think it is OK because it\n  // will be just two cases which fits into the browser inline cache (inline cache can take up to\n  // 4)\n  const tIcu = value.hasOwnProperty('currentCaseLViewIndex') ? value : value.value;\n  ngDevMode && assertTIcu(tIcu);\n  return tIcu;\n}\n/**\n * Store `TIcu` at a give `index`.\n *\n * The `TIcu` can be stored either directly (if it is nested ICU) OR\n * it is stored inside tho `TIcuContainer` if it is top level ICU.\n *\n * The reason for this is that the top level ICU need a `TNode` so that they are part of the render\n * tree, but nested ICU's have no TNode, because we don't know ahead of time if the nested ICU is\n * expressed (parent ICU may have selected a case which does not contain it.)\n *\n * @param tView Current `TView`.\n * @param index Index where the value should be stored at in `Tview.data`\n * @param tIcu The TIcu to store.\n */\nfunction setTIcu(tView, index, tIcu) {\n  const tNode = tView.data[index];\n  ngDevMode && assertEqual(tNode === null || tNode.hasOwnProperty('tView'), true, 'We expect to get \\'null\\'|\\'TIcuContainer\\'');\n  if (tNode === null) {\n    tView.data[index] = tIcu;\n  } else {\n    ngDevMode && assertTNodeType(tNode, 32 /* TNodeType.Icu */);\n    tNode.value = tIcu;\n  }\n}\n/**\n * Set `TNode.insertBeforeIndex` taking the `Array` into account.\n *\n * See `TNode.insertBeforeIndex`\n */\nfunction setTNodeInsertBeforeIndex(tNode, index) {\n  ngDevMode && assertTNode(tNode);\n  let insertBeforeIndex = tNode.insertBeforeIndex;\n  if (insertBeforeIndex === null) {\n    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);\n    insertBeforeIndex = tNode.insertBeforeIndex = [null /* may be updated to number later */, index];\n  } else {\n    assertEqual(Array.isArray(insertBeforeIndex), true, 'Expecting array here');\n    insertBeforeIndex.push(index);\n  }\n}\n/**\n * Create `TNode.type=TNodeType.Placeholder` node.\n *\n * See `TNodeType.Placeholder` for more information.\n */\nfunction createTNodePlaceholder(tView, previousTNodes, index) {\n  const tNode = createTNodeAtIndex(tView, index, 64 /* TNodeType.Placeholder */, null, null);\n  addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tNode);\n  return tNode;\n}\n/**\n * Returns current ICU case.\n *\n * ICU cases are stored as index into the `TIcu.cases`.\n * At times it is necessary to communicate that the ICU case just switched and that next ICU update\n * should update all bindings regardless of the mask. In such a case the we store negative numbers\n * for cases which have just been switched. This function removes the negative flag.\n */\nfunction getCurrentICUCaseIndex(tIcu, lView) {\n  const currentCase = lView[tIcu.currentCaseLViewIndex];\n  return currentCase === null ? currentCase : currentCase < 0 ? ~currentCase : currentCase;\n}\nfunction getParentFromIcuCreateOpCode(mergedCode) {\n  return mergedCode >>> 17 /* IcuCreateOpCode.SHIFT_PARENT */;\n}\n\nfunction getRefFromIcuCreateOpCode(mergedCode) {\n  return (mergedCode & 131070 /* IcuCreateOpCode.MASK_REF */) >>> 1 /* IcuCreateOpCode.SHIFT_REF */;\n}\n\nfunction getInstructionFromIcuCreateOpCode(mergedCode) {\n  return mergedCode & 1 /* IcuCreateOpCode.MASK_INSTRUCTION */;\n}\n\nfunction icuCreateOpCode(opCode, parentIdx, refIdx) {\n  ngDevMode && assertGreaterThanOrEqual(parentIdx, 0, 'Missing parent index');\n  ngDevMode && assertGreaterThan(refIdx, 0, 'Missing ref index');\n  return opCode | parentIdx << 17 /* IcuCreateOpCode.SHIFT_PARENT */ | refIdx << 1 /* IcuCreateOpCode.SHIFT_REF */;\n}\n\n/**\n * Keep track of which input bindings in `ɵɵi18nExp` have changed.\n *\n * This is used to efficiently update expressions in i18n only when the corresponding input has\n * changed.\n *\n * 1) Each bit represents which of the `ɵɵi18nExp` has changed.\n * 2) There are 32 bits allowed in JS.\n * 3) Bit 32 is special as it is shared for all changes past 32. (In other words if you have more\n * than 32 `ɵɵi18nExp` then all changes past 32nd `ɵɵi18nExp` will be mapped to same bit. This means\n * that we may end up changing more than we need to. But i18n expressions with 32 bindings is rare\n * so in practice it should not be an issue.)\n */\nlet changeMask = 0b0;\n/**\n * Keeps track of which bit needs to be updated in `changeMask`\n *\n * This value gets incremented on every call to `ɵɵi18nExp`\n */\nlet changeMaskCounter = 0;\n/**\n * Keep track of which input bindings in `ɵɵi18nExp` have changed.\n *\n * `setMaskBit` gets invoked by each call to `ɵɵi18nExp`.\n *\n * @param hasChange did `ɵɵi18nExp` detect a change.\n */\nfunction setMaskBit(hasChange) {\n  if (hasChange) {\n    changeMask = changeMask | 1 << Math.min(changeMaskCounter, 31);\n  }\n  changeMaskCounter++;\n}\nfunction applyI18n(tView, lView, index) {\n  if (changeMaskCounter > 0) {\n    ngDevMode && assertDefined(tView, `tView should be defined`);\n    const tI18n = tView.data[index];\n    // When `index` points to an `ɵɵi18nAttributes` then we have an array otherwise `TI18n`\n    const updateOpCodes = Array.isArray(tI18n) ? tI18n : tI18n.update;\n    const bindingsStartIndex = getBindingIndex() - changeMaskCounter - 1;\n    applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask);\n  }\n  // Reset changeMask & maskBit to default for the next update cycle\n  changeMask = 0b0;\n  changeMaskCounter = 0;\n}\n/**\n * Apply `I18nCreateOpCodes` op-codes as stored in `TI18n.create`.\n *\n * Creates text (and comment) nodes which are internationalized.\n *\n * @param lView Current lView\n * @param createOpCodes Set of op-codes to apply\n * @param parentRNode Parent node (so that direct children can be added eagerly) or `null` if it is\n *     a root node.\n * @param insertInFrontOf DOM node that should be used as an anchor.\n */\nfunction applyCreateOpCodes(lView, createOpCodes, parentRNode, insertInFrontOf) {\n  const renderer = lView[RENDERER];\n  for (let i = 0; i < createOpCodes.length; i++) {\n    const opCode = createOpCodes[i++];\n    const text = createOpCodes[i];\n    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;\n    const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;\n    const index = opCode >>> I18nCreateOpCode.SHIFT;\n    let rNode = lView[index];\n    if (rNode === null) {\n      // We only create new DOM nodes if they don't already exist: If ICU switches case back to a\n      // case which was already instantiated, no need to create new DOM nodes.\n      rNode = lView[index] = isComment ? renderer.createComment(text) : createTextNode(renderer, text);\n    }\n    if (appendNow && parentRNode !== null) {\n      nativeInsertBefore(renderer, parentRNode, rNode, insertInFrontOf, false);\n    }\n  }\n}\n/**\n * Apply `I18nMutateOpCodes` OpCodes.\n *\n * @param tView Current `TView`\n * @param mutableOpCodes Mutable OpCodes to process\n * @param lView Current `LView`\n * @param anchorRNode place where the i18n node should be inserted.\n */\nfunction applyMutableOpCodes(tView, mutableOpCodes, lView, anchorRNode) {\n  ngDevMode && assertDomNode(anchorRNode);\n  const renderer = lView[RENDERER];\n  // `rootIdx` represents the node into which all inserts happen.\n  let rootIdx = null;\n  // `rootRNode` represents the real node into which we insert. This can be different from\n  // `lView[rootIdx]` if we have projection.\n  //  - null we don't have a parent (as can be the case in when we are inserting into a root of\n  //    LView which has no parent.)\n  //  - `RElement` The element representing the root after taking projection into account.\n  let rootRNode;\n  for (let i = 0; i < mutableOpCodes.length; i++) {\n    const opCode = mutableOpCodes[i];\n    if (typeof opCode == 'string') {\n      const textNodeIndex = mutableOpCodes[++i];\n      if (lView[textNodeIndex] === null) {\n        ngDevMode && ngDevMode.rendererCreateTextNode++;\n        ngDevMode && assertIndexInRange(lView, textNodeIndex);\n        lView[textNodeIndex] = createTextNode(renderer, opCode);\n      }\n    } else if (typeof opCode == 'number') {\n      switch (opCode & 1 /* IcuCreateOpCode.MASK_INSTRUCTION */) {\n        case 0 /* IcuCreateOpCode.AppendChild */:\n          const parentIdx = getParentFromIcuCreateOpCode(opCode);\n          if (rootIdx === null) {\n            // The first operation should save the `rootIdx` because the first operation\n            // must insert into the root. (Only subsequent operations can insert into a dynamic\n            // parent)\n            rootIdx = parentIdx;\n            rootRNode = nativeParentNode(renderer, anchorRNode);\n          }\n          let insertInFrontOf;\n          let parentRNode;\n          if (parentIdx === rootIdx) {\n            insertInFrontOf = anchorRNode;\n            parentRNode = rootRNode;\n          } else {\n            insertInFrontOf = null;\n            parentRNode = unwrapRNode(lView[parentIdx]);\n          }\n          // FIXME(misko): Refactor with `processI18nText`\n          if (parentRNode !== null) {\n            // This can happen if the `LView` we are adding to is not attached to a parent `LView`.\n            // In such a case there is no \"root\" we can attach to. This is fine, as we still need to\n            // create the elements. When the `LView` gets later added to a parent these \"root\" nodes\n            // get picked up and added.\n            ngDevMode && assertDomNode(parentRNode);\n            const refIdx = getRefFromIcuCreateOpCode(opCode);\n            ngDevMode && assertGreaterThan(refIdx, HEADER_OFFSET, 'Missing ref');\n            // `unwrapRNode` is not needed here as all of these point to RNodes as part of the i18n\n            // which can't have components.\n            const child = lView[refIdx];\n            ngDevMode && assertDomNode(child);\n            nativeInsertBefore(renderer, parentRNode, child, insertInFrontOf, false);\n            const tIcu = getTIcu(tView, refIdx);\n            if (tIcu !== null && typeof tIcu === 'object') {\n              // If we just added a comment node which has ICU then that ICU may have already been\n              // rendered and therefore we need to re-add it here.\n              ngDevMode && assertTIcu(tIcu);\n              const caseIndex = getCurrentICUCaseIndex(tIcu, lView);\n              if (caseIndex !== null) {\n                applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, lView[tIcu.anchorIdx]);\n              }\n            }\n          }\n          break;\n        case 1 /* IcuCreateOpCode.Attr */:\n          const elementNodeIndex = opCode >>> 1 /* IcuCreateOpCode.SHIFT_REF */;\n          const attrName = mutableOpCodes[++i];\n          const attrValue = mutableOpCodes[++i];\n          // This code is used for ICU expressions only, since we don't support\n          // directives/components in ICUs, we don't need to worry about inputs here\n          setElementAttribute(renderer, getNativeByIndex(elementNodeIndex, lView), null, null, attrName, attrValue, null);\n          break;\n        default:\n          if (ngDevMode) {\n            throw new RuntimeError(700 /* RuntimeErrorCode.INVALID_I18N_STRUCTURE */, `Unable to determine the type of mutate operation for \"${opCode}\"`);\n          }\n      }\n    } else {\n      switch (opCode) {\n        case ICU_MARKER:\n          const commentValue = mutableOpCodes[++i];\n          const commentNodeIndex = mutableOpCodes[++i];\n          if (lView[commentNodeIndex] === null) {\n            ngDevMode && assertEqual(typeof commentValue, 'string', `Expected \"${commentValue}\" to be a comment node value`);\n            ngDevMode && ngDevMode.rendererCreateComment++;\n            ngDevMode && assertIndexInExpandoRange(lView, commentNodeIndex);\n            const commentRNode = lView[commentNodeIndex] = createCommentNode(renderer, commentValue);\n            // FIXME(misko): Attaching patch data is only needed for the root (Also add tests)\n            attachPatchData(commentRNode, lView);\n          }\n          break;\n        case ELEMENT_MARKER:\n          const tagName = mutableOpCodes[++i];\n          const elementNodeIndex = mutableOpCodes[++i];\n          if (lView[elementNodeIndex] === null) {\n            ngDevMode && assertEqual(typeof tagName, 'string', `Expected \"${tagName}\" to be an element node tag name`);\n            ngDevMode && ngDevMode.rendererCreateElement++;\n            ngDevMode && assertIndexInExpandoRange(lView, elementNodeIndex);\n            const elementRNode = lView[elementNodeIndex] = createElementNode(renderer, tagName, null);\n            // FIXME(misko): Attaching patch data is only needed for the root (Also add tests)\n            attachPatchData(elementRNode, lView);\n          }\n          break;\n        default:\n          ngDevMode && throwError(`Unable to determine the type of mutate operation for \"${opCode}\"`);\n      }\n    }\n  }\n}\n/**\n * Apply `I18nUpdateOpCodes` OpCodes\n *\n * @param tView Current `TView`\n * @param lView Current `LView`\n * @param updateOpCodes OpCodes to process\n * @param bindingsStartIndex Location of the first `ɵɵi18nApply`\n * @param changeMask Each bit corresponds to a `ɵɵi18nExp` (Counting backwards from\n *     `bindingsStartIndex`)\n */\nfunction applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask) {\n  for (let i = 0; i < updateOpCodes.length; i++) {\n    // bit code to check if we should apply the next update\n    const checkBit = updateOpCodes[i];\n    // Number of opCodes to skip until next set of update codes\n    const skipCodes = updateOpCodes[++i];\n    if (checkBit & changeMask) {\n      // The value has been updated since last checked\n      let value = '';\n      for (let j = i + 1; j <= i + skipCodes; j++) {\n        const opCode = updateOpCodes[j];\n        if (typeof opCode == 'string') {\n          value += opCode;\n        } else if (typeof opCode == 'number') {\n          if (opCode < 0) {\n            // Negative opCode represent `i18nExp` values offset.\n            value += renderStringify(lView[bindingsStartIndex - opCode]);\n          } else {\n            const nodeIndex = opCode >>> 2 /* I18nUpdateOpCode.SHIFT_REF */;\n            switch (opCode & 3 /* I18nUpdateOpCode.MASK_OPCODE */) {\n              case 1 /* I18nUpdateOpCode.Attr */:\n                const propName = updateOpCodes[++j];\n                const sanitizeFn = updateOpCodes[++j];\n                const tNodeOrTagName = tView.data[nodeIndex];\n                ngDevMode && assertDefined(tNodeOrTagName, 'Experting TNode or string');\n                if (typeof tNodeOrTagName === 'string') {\n                  // IF we don't have a `TNode`, then we are an element in ICU (as ICU content does\n                  // not have TNode), in which case we know that there are no directives, and hence\n                  // we use attribute setting.\n                  setElementAttribute(lView[RENDERER], lView[nodeIndex], null, tNodeOrTagName, propName, value, sanitizeFn);\n                } else {\n                  elementPropertyInternal(tView, tNodeOrTagName, lView, propName, value, lView[RENDERER], sanitizeFn, false);\n                }\n                break;\n              case 0 /* I18nUpdateOpCode.Text */:\n                const rText = lView[nodeIndex];\n                rText !== null && updateTextNode(lView[RENDERER], rText, value);\n                break;\n              case 2 /* I18nUpdateOpCode.IcuSwitch */:\n                applyIcuSwitchCase(tView, getTIcu(tView, nodeIndex), lView, value);\n                break;\n              case 3 /* I18nUpdateOpCode.IcuUpdate */:\n                applyIcuUpdateCase(tView, getTIcu(tView, nodeIndex), bindingsStartIndex, lView);\n                break;\n            }\n          }\n        }\n      }\n    } else {\n      const opCode = updateOpCodes[i + 1];\n      if (opCode > 0 && (opCode & 3 /* I18nUpdateOpCode.MASK_OPCODE */) === 3 /* I18nUpdateOpCode.IcuUpdate */) {\n        // Special case for the `icuUpdateCase`. It could be that the mask did not match, but\n        // we still need to execute `icuUpdateCase` because the case has changed recently due to\n        // previous `icuSwitchCase` instruction. (`icuSwitchCase` and `icuUpdateCase` always come in\n        // pairs.)\n        const nodeIndex = opCode >>> 2 /* I18nUpdateOpCode.SHIFT_REF */;\n        const tIcu = getTIcu(tView, nodeIndex);\n        const currentIndex = lView[tIcu.currentCaseLViewIndex];\n        if (currentIndex < 0) {\n          applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView);\n        }\n      }\n    }\n    i += skipCodes;\n  }\n}\n/**\n * Apply OpCodes associated with updating an existing ICU.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param bindingsStartIndex Location of the first `ɵɵi18nApply`\n * @param lView Current `LView`\n */\nfunction applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView) {\n  ngDevMode && assertIndexInRange(lView, tIcu.currentCaseLViewIndex);\n  let activeCaseIndex = lView[tIcu.currentCaseLViewIndex];\n  if (activeCaseIndex !== null) {\n    let mask = changeMask;\n    if (activeCaseIndex < 0) {\n      // Clear the flag.\n      // Negative number means that the ICU was freshly created and we need to force the update.\n      activeCaseIndex = lView[tIcu.currentCaseLViewIndex] = ~activeCaseIndex;\n      // -1 is same as all bits on, which simulates creation since it marks all bits dirty\n      mask = -1;\n    }\n    applyUpdateOpCodes(tView, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);\n  }\n}\n/**\n * Apply OpCodes associated with switching a case on ICU.\n *\n * This involves tearing down existing case and than building up a new case.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param lView Current `LView`\n * @param value Value of the case to update to.\n */\nfunction applyIcuSwitchCase(tView, tIcu, lView, value) {\n  // Rebuild a new case for this ICU\n  const caseIndex = getCaseIndex(tIcu, value);\n  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);\n  if (activeCaseIndex !== caseIndex) {\n    applyIcuSwitchCaseRemove(tView, tIcu, lView);\n    lView[tIcu.currentCaseLViewIndex] = caseIndex === null ? null : ~caseIndex;\n    if (caseIndex !== null) {\n      // Add the nodes for the new case\n      const anchorRNode = lView[tIcu.anchorIdx];\n      if (anchorRNode) {\n        ngDevMode && assertDomNode(anchorRNode);\n        applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, anchorRNode);\n      }\n    }\n  }\n}\n/**\n * Apply OpCodes associated with tearing ICU case.\n *\n * This involves tearing down existing case and than building up a new case.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param lView Current `LView`\n */\nfunction applyIcuSwitchCaseRemove(tView, tIcu, lView) {\n  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);\n  if (activeCaseIndex !== null) {\n    const removeCodes = tIcu.remove[activeCaseIndex];\n    for (let i = 0; i < removeCodes.length; i++) {\n      const nodeOrIcuIndex = removeCodes[i];\n      if (nodeOrIcuIndex > 0) {\n        // Positive numbers are `RNode`s.\n        const rNode = getNativeByIndex(nodeOrIcuIndex, lView);\n        rNode !== null && nativeRemoveNode(lView[RENDERER], rNode);\n      } else {\n        // Negative numbers are ICUs\n        applyIcuSwitchCaseRemove(tView, getTIcu(tView, ~nodeOrIcuIndex), lView);\n      }\n    }\n  }\n}\n/**\n * Returns the index of the current case of an ICU expression depending on the main binding value\n *\n * @param icuExpression\n * @param bindingValue The value of the main binding used by this ICU expression\n */\nfunction getCaseIndex(icuExpression, bindingValue) {\n  let index = icuExpression.cases.indexOf(bindingValue);\n  if (index === -1) {\n    switch (icuExpression.type) {\n      case 1 /* IcuType.plural */:\n        {\n          const resolvedCase = getPluralCase(bindingValue, getLocaleId());\n          index = icuExpression.cases.indexOf(resolvedCase);\n          if (index === -1 && resolvedCase !== 'other') {\n            index = icuExpression.cases.indexOf('other');\n          }\n          break;\n        }\n      case 0 /* IcuType.select */:\n        {\n          index = icuExpression.cases.indexOf('other');\n          break;\n        }\n    }\n  }\n  return index === -1 ? null : index;\n}\nfunction loadIcuContainerVisitor() {\n  const _stack = [];\n  let _index = -1;\n  let _lView;\n  let _removes;\n  /**\n   * Retrieves a set of root nodes from `TIcu.remove`. Used by `TNodeType.ICUContainer`\n   * to determine which root belong to the ICU.\n   *\n   * Example of usage.\n   * ```\n   * const nextRNode = icuContainerIteratorStart(tIcuContainerNode, lView);\n   * let rNode: RNode|null;\n   * while(rNode = nextRNode()) {\n   *   console.log(rNode);\n   * }\n   * ```\n   *\n   * @param tIcuContainerNode Current `TIcuContainerNode`\n   * @param lView `LView` where the `RNode`s should be looked up.\n   */\n  function icuContainerIteratorStart(tIcuContainerNode, lView) {\n    _lView = lView;\n    while (_stack.length) _stack.pop();\n    ngDevMode && assertTNodeForLView(tIcuContainerNode, lView);\n    enterIcu(tIcuContainerNode.value, lView);\n    return icuContainerIteratorNext;\n  }\n  function enterIcu(tIcu, lView) {\n    _index = 0;\n    const currentCase = getCurrentICUCaseIndex(tIcu, lView);\n    if (currentCase !== null) {\n      ngDevMode && assertNumberInRange(currentCase, 0, tIcu.cases.length - 1);\n      _removes = tIcu.remove[currentCase];\n    } else {\n      _removes = EMPTY_ARRAY;\n    }\n  }\n  function icuContainerIteratorNext() {\n    if (_index < _removes.length) {\n      const removeOpCode = _removes[_index++];\n      ngDevMode && assertNumber(removeOpCode, 'Expecting OpCode number');\n      if (removeOpCode > 0) {\n        const rNode = _lView[removeOpCode];\n        ngDevMode && assertDomNode(rNode);\n        return rNode;\n      } else {\n        _stack.push(_index, _removes);\n        // ICUs are represented by negative indices\n        const tIcuIndex = ~removeOpCode;\n        const tIcu = _lView[TVIEW].data[tIcuIndex];\n        ngDevMode && assertTIcu(tIcu);\n        enterIcu(tIcu, _lView);\n        return icuContainerIteratorNext();\n      }\n    } else {\n      if (_stack.length === 0) {\n        return null;\n      } else {\n        _removes = _stack.pop();\n        _index = _stack.pop();\n        return icuContainerIteratorNext();\n      }\n    }\n  }\n  return icuContainerIteratorStart;\n}\n\n/**\n * Converts `I18nCreateOpCodes` array into a human readable format.\n *\n * This function is attached to the `I18nCreateOpCodes.debug` property if `ngDevMode` is enabled.\n * This function provides a human readable view of the opcodes. This is useful when debugging the\n * application as well as writing more readable tests.\n *\n * @param this `I18nCreateOpCodes` if attached as a method.\n * @param opcodes `I18nCreateOpCodes` if invoked as a function.\n */\nfunction i18nCreateOpCodesToString(opcodes) {\n  const createOpCodes = opcodes || (Array.isArray(this) ? this : []);\n  let lines = [];\n  for (let i = 0; i < createOpCodes.length; i++) {\n    const opCode = createOpCodes[i++];\n    const text = createOpCodes[i];\n    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;\n    const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;\n    const index = opCode >>> I18nCreateOpCode.SHIFT;\n    lines.push(`lView[${index}] = document.${isComment ? 'createComment' : 'createText'}(${JSON.stringify(text)});`);\n    if (appendNow) {\n      lines.push(`parent.appendChild(lView[${index}]);`);\n    }\n  }\n  return lines;\n}\n/**\n * Converts `I18nUpdateOpCodes` array into a human readable format.\n *\n * This function is attached to the `I18nUpdateOpCodes.debug` property if `ngDevMode` is enabled.\n * This function provides a human readable view of the opcodes. This is useful when debugging the\n * application as well as writing more readable tests.\n *\n * @param this `I18nUpdateOpCodes` if attached as a method.\n * @param opcodes `I18nUpdateOpCodes` if invoked as a function.\n */\nfunction i18nUpdateOpCodesToString(opcodes) {\n  const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));\n  let lines = [];\n  function consumeOpCode(value) {\n    const ref = value >>> 2 /* I18nUpdateOpCode.SHIFT_REF */;\n    const opCode = value & 3 /* I18nUpdateOpCode.MASK_OPCODE */;\n    switch (opCode) {\n      case 0 /* I18nUpdateOpCode.Text */:\n        return `(lView[${ref}] as Text).textContent = $$$`;\n      case 1 /* I18nUpdateOpCode.Attr */:\n        const attrName = parser.consumeString();\n        const sanitizationFn = parser.consumeFunction();\n        const value = sanitizationFn ? `(${sanitizationFn})($$$)` : '$$$';\n        return `(lView[${ref}] as Element).setAttribute('${attrName}', ${value})`;\n      case 2 /* I18nUpdateOpCode.IcuSwitch */:\n        return `icuSwitchCase(${ref}, $$$)`;\n      case 3 /* I18nUpdateOpCode.IcuUpdate */:\n        return `icuUpdateCase(${ref})`;\n    }\n    throw new Error('unexpected OpCode');\n  }\n  while (parser.hasMore()) {\n    let mask = parser.consumeNumber();\n    let size = parser.consumeNumber();\n    const end = parser.i + size;\n    const statements = [];\n    let statement = '';\n    while (parser.i < end) {\n      let value = parser.consumeNumberOrString();\n      if (typeof value === 'string') {\n        statement += value;\n      } else if (value < 0) {\n        // Negative numbers are ref indexes\n        // Here `i` refers to current binding index. It is to signify that the value is relative,\n        // rather than absolute.\n        statement += '${lView[i' + value + ']}';\n      } else {\n        // Positive numbers are operations.\n        const opCodeText = consumeOpCode(value);\n        statements.push(opCodeText.replace('$$$', '`' + statement + '`') + ';');\n        statement = '';\n      }\n    }\n    lines.push(`if (mask & 0b${mask.toString(2)}) { ${statements.join(' ')} }`);\n  }\n  return lines;\n}\n/**\n * Converts `I18nCreateOpCodes` array into a human readable format.\n *\n * This function is attached to the `I18nCreateOpCodes.debug` if `ngDevMode` is enabled. This\n * function provides a human readable view of the opcodes. This is useful when debugging the\n * application as well as writing more readable tests.\n *\n * @param this `I18nCreateOpCodes` if attached as a method.\n * @param opcodes `I18nCreateOpCodes` if invoked as a function.\n */\nfunction icuCreateOpCodesToString(opcodes) {\n  const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));\n  let lines = [];\n  function consumeOpCode(opCode) {\n    const parent = getParentFromIcuCreateOpCode(opCode);\n    const ref = getRefFromIcuCreateOpCode(opCode);\n    switch (getInstructionFromIcuCreateOpCode(opCode)) {\n      case 0 /* IcuCreateOpCode.AppendChild */:\n        return `(lView[${parent}] as Element).appendChild(lView[${lastRef}])`;\n      case 1 /* IcuCreateOpCode.Attr */:\n        return `(lView[${ref}] as Element).setAttribute(\"${parser.consumeString()}\", \"${parser.consumeString()}\")`;\n    }\n    throw new Error('Unexpected OpCode: ' + getInstructionFromIcuCreateOpCode(opCode));\n  }\n  let lastRef = -1;\n  while (parser.hasMore()) {\n    let value = parser.consumeNumberStringOrMarker();\n    if (value === ICU_MARKER) {\n      const text = parser.consumeString();\n      lastRef = parser.consumeNumber();\n      lines.push(`lView[${lastRef}] = document.createComment(\"${text}\")`);\n    } else if (value === ELEMENT_MARKER) {\n      const text = parser.consumeString();\n      lastRef = parser.consumeNumber();\n      lines.push(`lView[${lastRef}] = document.createElement(\"${text}\")`);\n    } else if (typeof value === 'string') {\n      lastRef = parser.consumeNumber();\n      lines.push(`lView[${lastRef}] = document.createTextNode(\"${value}\")`);\n    } else if (typeof value === 'number') {\n      const line = consumeOpCode(value);\n      line && lines.push(line);\n    } else {\n      throw new Error('Unexpected value');\n    }\n  }\n  return lines;\n}\n/**\n * Converts `I18nRemoveOpCodes` array into a human readable format.\n *\n * This function is attached to the `I18nRemoveOpCodes.debug` if `ngDevMode` is enabled. This\n * function provides a human readable view of the opcodes. This is useful when debugging the\n * application as well as writing more readable tests.\n *\n * @param this `I18nRemoveOpCodes` if attached as a method.\n * @param opcodes `I18nRemoveOpCodes` if invoked as a function.\n */\nfunction i18nRemoveOpCodesToString(opcodes) {\n  const removeCodes = opcodes || (Array.isArray(this) ? this : []);\n  let lines = [];\n  for (let i = 0; i < removeCodes.length; i++) {\n    const nodeOrIcuIndex = removeCodes[i];\n    if (nodeOrIcuIndex > 0) {\n      // Positive numbers are `RNode`s.\n      lines.push(`remove(lView[${nodeOrIcuIndex}])`);\n    } else {\n      // Negative numbers are ICUs\n      lines.push(`removeNestedICU(${~nodeOrIcuIndex})`);\n    }\n  }\n  return lines;\n}\nclass OpCodeParser {\n  constructor(codes) {\n    this.i = 0;\n    this.codes = codes;\n  }\n  hasMore() {\n    return this.i < this.codes.length;\n  }\n  consumeNumber() {\n    let value = this.codes[this.i++];\n    assertNumber(value, 'expecting number in OpCode');\n    return value;\n  }\n  consumeString() {\n    let value = this.codes[this.i++];\n    assertString(value, 'expecting string in OpCode');\n    return value;\n  }\n  consumeFunction() {\n    let value = this.codes[this.i++];\n    if (value === null || typeof value === 'function') {\n      return value;\n    }\n    throw new Error('expecting function in OpCode');\n  }\n  consumeNumberOrString() {\n    let value = this.codes[this.i++];\n    if (typeof value === 'string') {\n      return value;\n    }\n    assertNumber(value, 'expecting number or string in OpCode');\n    return value;\n  }\n  consumeNumberStringOrMarker() {\n    let value = this.codes[this.i++];\n    if (typeof value === 'string' || typeof value === 'number' || value == ICU_MARKER || value == ELEMENT_MARKER) {\n      return value;\n    }\n    assertNumber(value, 'expecting number, string, ICU_MARKER or ELEMENT_MARKER in OpCode');\n    return value;\n  }\n}\nconst BINDING_REGEXP = /�(\\d+):?\\d*�/gi;\nconst ICU_REGEXP = /({\\s*�\\d+:?\\d*�\\s*,\\s*\\S{6}\\s*,[\\s\\S]*})/gi;\nconst NESTED_ICU = /�(\\d+)�/;\nconst ICU_BLOCK_REGEXP = /^\\s*(�\\d+:?\\d*�)\\s*,\\s*(select|plural)\\s*,/;\nconst MARKER = `�`;\nconst SUBTEMPLATE_REGEXP = /�\\/?\\*(\\d+:\\d+)�/gi;\nconst PH_REGEXP = /�(\\/?[#*]\\d+):?\\d*�/gi;\n/**\n * Angular uses the special entity &ngsp; as a placeholder for non-removable space.\n * It's replaced by the 0xE500 PUA (Private Use Areas) unicode character and later on replaced by a\n * space.\n * We are re-implementing the same idea since translations might contain this special character.\n */\nconst NGSP_UNICODE_REGEXP = /\\uE500/g;\nfunction replaceNgsp(value) {\n  return value.replace(NGSP_UNICODE_REGEXP, ' ');\n}\n/**\n * Patch a `debug` property getter on top of the existing object.\n *\n * NOTE: always call this method with `ngDevMode && attachDebugObject(...)`\n *\n * @param obj Object to patch\n * @param debugGetter Getter returning a value to patch\n */\nfunction attachDebugGetter(obj, debugGetter) {\n  if (ngDevMode) {\n    Object.defineProperty(obj, 'debug', {\n      get: debugGetter,\n      enumerable: false\n    });\n  } else {\n    throw new Error('This method should be guarded with `ngDevMode` so that it can be tree shaken in production!');\n  }\n}\n/**\n * Create dynamic nodes from i18n translation block.\n *\n * - Text nodes are created synchronously\n * - TNodes are linked into tree lazily\n *\n * @param tView Current `TView`\n * @parentTNodeIndex index to the parent TNode of this i18n block\n * @param lView Current `LView`\n * @param index Index of `ɵɵi18nStart` instruction.\n * @param message Message to translate.\n * @param subTemplateIndex Index into the sub template of message translation. (ie in case of\n *     `ngIf`) (-1 otherwise)\n */\nfunction i18nStartFirstCreatePass(tView, parentTNodeIndex, lView, index, message, subTemplateIndex) {\n  const rootTNode = getCurrentParentTNode();\n  const createOpCodes = [];\n  const updateOpCodes = [];\n  const existingTNodeStack = [[]];\n  if (ngDevMode) {\n    attachDebugGetter(createOpCodes, i18nCreateOpCodesToString);\n    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n  }\n  message = getTranslationForTemplate(message, subTemplateIndex);\n  const msgParts = replaceNgsp(message).split(PH_REGEXP);\n  for (let i = 0; i < msgParts.length; i++) {\n    let value = msgParts[i];\n    if ((i & 1) === 0) {\n      // Even indexes are text (including bindings & ICU expressions)\n      const parts = i18nParseTextIntoPartsAndICU(value);\n      for (let j = 0; j < parts.length; j++) {\n        let part = parts[j];\n        if ((j & 1) === 0) {\n          // `j` is odd therefore `part` is string\n          const text = part;\n          ngDevMode && assertString(text, 'Parsed ICU part should be string');\n          if (text !== '') {\n            i18nStartFirstCreatePassProcessTextNode(tView, rootTNode, existingTNodeStack[0], createOpCodes, updateOpCodes, lView, text);\n          }\n        } else {\n          // `j` is Even therefor `part` is an `ICUExpression`\n          const icuExpression = part;\n          // Verify that ICU expression has the right shape. Translations might contain invalid\n          // constructions (while original messages were correct), so ICU parsing at runtime may\n          // not succeed (thus `icuExpression` remains a string).\n          // Note: we intentionally retain the error here by not using `ngDevMode`, because\n          // the value can change based on the locale and users aren't guaranteed to hit\n          // an invalid string while they're developing.\n          if (typeof icuExpression !== 'object') {\n            throw new Error(`Unable to parse ICU expression in \"${message}\" message.`);\n          }\n          const icuContainerTNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodeStack[0], lView, createOpCodes, ngDevMode ? `ICU ${index}:${icuExpression.mainBinding}` : '', true);\n          const icuNodeIndex = icuContainerTNode.index;\n          ngDevMode && assertGreaterThanOrEqual(icuNodeIndex, HEADER_OFFSET, 'Index must be in absolute LView offset');\n          icuStart(tView, lView, updateOpCodes, parentTNodeIndex, icuExpression, icuNodeIndex);\n        }\n      }\n    } else {\n      // Odd indexes are placeholders (elements and sub-templates)\n      // At this point value is something like: '/#1:2' (originally coming from '�/#1:2�')\n      const isClosing = value.charCodeAt(0) === 47 /* CharCode.SLASH */;\n      const type = value.charCodeAt(isClosing ? 1 : 0);\n      ngDevMode && assertOneOf(type, 42 /* CharCode.STAR */, 35 /* CharCode.HASH */);\n      const index = HEADER_OFFSET + Number.parseInt(value.substring(isClosing ? 2 : 1));\n      if (isClosing) {\n        existingTNodeStack.shift();\n        setCurrentTNode(getCurrentParentTNode(), false);\n      } else {\n        const tNode = createTNodePlaceholder(tView, existingTNodeStack[0], index);\n        existingTNodeStack.unshift([]);\n        setCurrentTNode(tNode, true);\n      }\n    }\n  }\n  tView.data[index] = {\n    create: createOpCodes,\n    update: updateOpCodes\n  };\n}\n/**\n * Allocate space in i18n Range add create OpCode instruction to create a text or comment node.\n *\n * @param tView Current `TView` needed to allocate space in i18n range.\n * @param rootTNode Root `TNode` of the i18n block. This node determines if the new TNode will be\n *     added as part of the `i18nStart` instruction or as part of the `TNode.insertBeforeIndex`.\n * @param existingTNodes internal state for `addTNodeAndUpdateInsertBeforeIndex`.\n * @param lView Current `LView` needed to allocate space in i18n range.\n * @param createOpCodes Array storing `I18nCreateOpCodes` where new opCodes will be added.\n * @param text Text to be added when the `Text` or `Comment` node will be created.\n * @param isICU true if a `Comment` node for ICU (instead of `Text`) node should be created.\n */\nfunction createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, text, isICU) {\n  const i18nNodeIdx = allocExpando(tView, lView, 1, null);\n  let opCode = i18nNodeIdx << I18nCreateOpCode.SHIFT;\n  let parentTNode = getCurrentParentTNode();\n  if (rootTNode === parentTNode) {\n    // FIXME(misko): A null `parentTNode` should represent when we fall of the `LView` boundary.\n    // (there is no parent), but in some circumstances (because we are inconsistent about how we set\n    // `previousOrParentTNode`) it could point to `rootTNode` So this is a work around.\n    parentTNode = null;\n  }\n  if (parentTNode === null) {\n    // If we don't have a parent that means that we can eagerly add nodes.\n    // If we have a parent than these nodes can't be added now (as the parent has not been created\n    // yet) and instead the `parentTNode` is responsible for adding it. See\n    // `TNode.insertBeforeIndex`\n    opCode |= I18nCreateOpCode.APPEND_EAGERLY;\n  }\n  if (isICU) {\n    opCode |= I18nCreateOpCode.COMMENT;\n    ensureIcuContainerVisitorLoaded(loadIcuContainerVisitor);\n  }\n  createOpCodes.push(opCode, text === null ? '' : text);\n  // We store `{{?}}` so that when looking at debug `TNodeType.template` we can see where the\n  // bindings are.\n  const tNode = createTNodeAtIndex(tView, i18nNodeIdx, isICU ? 32 /* TNodeType.Icu */ : 1 /* TNodeType.Text */, text === null ? ngDevMode ? '{{?}}' : '' : text, null);\n  addTNodeAndUpdateInsertBeforeIndex(existingTNodes, tNode);\n  const tNodeIdx = tNode.index;\n  setCurrentTNode(tNode, false /* Text nodes are self closing */);\n  if (parentTNode !== null && rootTNode !== parentTNode) {\n    // We are a child of deeper node (rather than a direct child of `i18nStart` instruction.)\n    // We have to make sure to add ourselves to the parent.\n    setTNodeInsertBeforeIndex(parentTNode, tNodeIdx);\n  }\n  return tNode;\n}\n/**\n * Processes text node in i18n block.\n *\n * Text nodes can have:\n * - Create instruction in `createOpCodes` for creating the text node.\n * - Allocate spec for text node in i18n range of `LView`\n * - If contains binding:\n *    - bindings => allocate space in i18n range of `LView` to store the binding value.\n *    - populate `updateOpCodes` with update instructions.\n *\n * @param tView Current `TView`\n * @param rootTNode Root `TNode` of the i18n block. This node determines if the new TNode will\n *     be added as part of the `i18nStart` instruction or as part of the\n *     `TNode.insertBeforeIndex`.\n * @param existingTNodes internal state for `addTNodeAndUpdateInsertBeforeIndex`.\n * @param createOpCodes Location where the creation OpCodes will be stored.\n * @param lView Current `LView`\n * @param text The translated text (which may contain binding)\n */\nfunction i18nStartFirstCreatePassProcessTextNode(tView, rootTNode, existingTNodes, createOpCodes, updateOpCodes, lView, text) {\n  const hasBinding = text.match(BINDING_REGEXP);\n  const tNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, hasBinding ? null : text, false);\n  if (hasBinding) {\n    generateBindingUpdateOpCodes(updateOpCodes, text, tNode.index, null, 0, null);\n  }\n}\n/**\n * See `i18nAttributes` above.\n */\nfunction i18nAttributesFirstPass(tView, index, values) {\n  const previousElement = getCurrentTNode();\n  const previousElementIndex = previousElement.index;\n  const updateOpCodes = [];\n  if (ngDevMode) {\n    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n  }\n  if (tView.firstCreatePass && tView.data[index] === null) {\n    for (let i = 0; i < values.length; i += 2) {\n      const attrName = values[i];\n      const message = values[i + 1];\n      if (message !== '') {\n        // Check if attribute value contains an ICU and throw an error if that's the case.\n        // ICUs in element attributes are not supported.\n        // Note: we intentionally retain the error here by not using `ngDevMode`, because\n        // the `value` can change based on the locale and users aren't guaranteed to hit\n        // an invalid string while they're developing.\n        if (ICU_REGEXP.test(message)) {\n          throw new Error(`ICU expressions are not supported in attributes. Message: \"${message}\".`);\n        }\n        // i18n attributes that hit this code path are guaranteed to have bindings, because\n        // the compiler treats static i18n attributes as regular attribute bindings.\n        // Since this may not be the first i18n attribute on this element we need to pass in how\n        // many previous bindings there have already been.\n        generateBindingUpdateOpCodes(updateOpCodes, message, previousElementIndex, attrName, countBindings(updateOpCodes), null);\n      }\n    }\n    tView.data[index] = updateOpCodes;\n  }\n}\n/**\n * Generate the OpCodes to update the bindings of a string.\n *\n * @param updateOpCodes Place where the update opcodes will be stored.\n * @param str The string containing the bindings.\n * @param destinationNode Index of the destination node which will receive the binding.\n * @param attrName Name of the attribute, if the string belongs to an attribute.\n * @param sanitizeFn Sanitization function used to sanitize the string after update, if necessary.\n * @param bindingStart The lView index of the next expression that can be bound via an opCode.\n * @returns The mask value for these bindings\n */\nfunction generateBindingUpdateOpCodes(updateOpCodes, str, destinationNode, attrName, bindingStart, sanitizeFn) {\n  ngDevMode && assertGreaterThanOrEqual(destinationNode, HEADER_OFFSET, 'Index must be in absolute LView offset');\n  const maskIndex = updateOpCodes.length; // Location of mask\n  const sizeIndex = maskIndex + 1; // location of size for skipping\n  updateOpCodes.push(null, null); // Alloc space for mask and size\n  const startIndex = maskIndex + 2; // location of first allocation.\n  if (ngDevMode) {\n    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n  }\n  const textParts = str.split(BINDING_REGEXP);\n  let mask = 0;\n  for (let j = 0; j < textParts.length; j++) {\n    const textValue = textParts[j];\n    if (j & 1) {\n      // Odd indexes are bindings\n      const bindingIndex = bindingStart + parseInt(textValue, 10);\n      updateOpCodes.push(-1 - bindingIndex);\n      mask = mask | toMaskBit(bindingIndex);\n    } else if (textValue !== '') {\n      // Even indexes are text\n      updateOpCodes.push(textValue);\n    }\n  }\n  updateOpCodes.push(destinationNode << 2 /* I18nUpdateOpCode.SHIFT_REF */ | (attrName ? 1 /* I18nUpdateOpCode.Attr */ : 0 /* I18nUpdateOpCode.Text */));\n  if (attrName) {\n    updateOpCodes.push(attrName, sanitizeFn);\n  }\n  updateOpCodes[maskIndex] = mask;\n  updateOpCodes[sizeIndex] = updateOpCodes.length - startIndex;\n  return mask;\n}\n/**\n * Count the number of bindings in the given `opCodes`.\n *\n * It could be possible to speed this up, by passing the number of bindings found back from\n * `generateBindingUpdateOpCodes()` to `i18nAttributesFirstPass()` but this would then require more\n * complexity in the code and/or transient objects to be created.\n *\n * Since this function is only called once when the template is instantiated, is trivial in the\n * first instance (since `opCodes` will be an empty array), and it is not common for elements to\n * contain multiple i18n bound attributes, it seems like this is a reasonable compromise.\n */\nfunction countBindings(opCodes) {\n  let count = 0;\n  for (let i = 0; i < opCodes.length; i++) {\n    const opCode = opCodes[i];\n    // Bindings are negative numbers.\n    if (typeof opCode === 'number' && opCode < 0) {\n      count++;\n    }\n  }\n  return count;\n}\n/**\n * Convert binding index to mask bit.\n *\n * Each index represents a single bit on the bit-mask. Because bit-mask only has 32 bits, we make\n * the 32nd bit share all masks for all bindings higher than 32. Since it is extremely rare to\n * have more than 32 bindings this will be hit very rarely. The downside of hitting this corner\n * case is that we will execute binding code more often than necessary. (penalty of performance)\n */\nfunction toMaskBit(bindingIndex) {\n  return 1 << Math.min(bindingIndex, 31);\n}\nfunction isRootTemplateMessage(subTemplateIndex) {\n  return subTemplateIndex === -1;\n}\n/**\n * Removes everything inside the sub-templates of a message.\n */\nfunction removeInnerTemplateTranslation(message) {\n  let match;\n  let res = '';\n  let index = 0;\n  let inTemplate = false;\n  let tagMatched;\n  while ((match = SUBTEMPLATE_REGEXP.exec(message)) !== null) {\n    if (!inTemplate) {\n      res += message.substring(index, match.index + match[0].length);\n      tagMatched = match[1];\n      inTemplate = true;\n    } else {\n      if (match[0] === `${MARKER}/*${tagMatched}${MARKER}`) {\n        index = match.index;\n        inTemplate = false;\n      }\n    }\n  }\n  ngDevMode && assertEqual(inTemplate, false, `Tag mismatch: unable to find the end of the sub-template in the translation \"${message}\"`);\n  res += message.slice(index);\n  return res;\n}\n/**\n * Extracts a part of a message and removes the rest.\n *\n * This method is used for extracting a part of the message associated with a template. A\n * translated message can span multiple templates.\n *\n * Example:\n * ```\n * <div i18n>Translate <span *ngIf>me</span>!</div>\n * ```\n *\n * @param message The message to crop\n * @param subTemplateIndex Index of the sub-template to extract. If undefined it returns the\n * external template and removes all sub-templates.\n */\nfunction getTranslationForTemplate(message, subTemplateIndex) {\n  if (isRootTemplateMessage(subTemplateIndex)) {\n    // We want the root template message, ignore all sub-templates\n    return removeInnerTemplateTranslation(message);\n  } else {\n    // We want a specific sub-template\n    const start = message.indexOf(`:${subTemplateIndex}${MARKER}`) + 2 + subTemplateIndex.toString().length;\n    const end = message.search(new RegExp(`${MARKER}\\\\/\\\\*\\\\d+:${subTemplateIndex}${MARKER}`));\n    return removeInnerTemplateTranslation(message.substring(start, end));\n  }\n}\n/**\n * Generate the OpCodes for ICU expressions.\n *\n * @param icuExpression\n * @param index Index where the anchor is stored and an optional `TIcuContainerNode`\n *   - `lView[anchorIdx]` points to a `Comment` node representing the anchor for the ICU.\n *   - `tView.data[anchorIdx]` points to the `TIcuContainerNode` if ICU is root (`null` otherwise)\n */\nfunction icuStart(tView, lView, updateOpCodes, parentIdx, icuExpression, anchorIdx) {\n  ngDevMode && assertDefined(icuExpression, 'ICU expression must be defined');\n  let bindingMask = 0;\n  const tIcu = {\n    type: icuExpression.type,\n    currentCaseLViewIndex: allocExpando(tView, lView, 1, null),\n    anchorIdx,\n    cases: [],\n    create: [],\n    remove: [],\n    update: []\n  };\n  addUpdateIcuSwitch(updateOpCodes, icuExpression, anchorIdx);\n  setTIcu(tView, anchorIdx, tIcu);\n  const values = icuExpression.values;\n  for (let i = 0; i < values.length; i++) {\n    // Each value is an array of strings & other ICU expressions\n    const valueArr = values[i];\n    const nestedIcus = [];\n    for (let j = 0; j < valueArr.length; j++) {\n      const value = valueArr[j];\n      if (typeof value !== 'string') {\n        // It is an nested ICU expression\n        const icuIndex = nestedIcus.push(value) - 1;\n        // Replace nested ICU expression by a comment node\n        valueArr[j] = `<!--�${icuIndex}�-->`;\n      }\n    }\n    bindingMask = parseIcuCase(tView, tIcu, lView, updateOpCodes, parentIdx, icuExpression.cases[i], valueArr.join(''), nestedIcus) | bindingMask;\n  }\n  if (bindingMask) {\n    addUpdateIcuUpdate(updateOpCodes, bindingMask, anchorIdx);\n  }\n}\n/**\n * Parses text containing an ICU expression and produces a JSON object for it.\n * Original code from closure library, modified for Angular.\n *\n * @param pattern Text containing an ICU expression that needs to be parsed.\n *\n */\nfunction parseICUBlock(pattern) {\n  const cases = [];\n  const values = [];\n  let icuType = 1 /* IcuType.plural */;\n  let mainBinding = 0;\n  pattern = pattern.replace(ICU_BLOCK_REGEXP, function (str, binding, type) {\n    if (type === 'select') {\n      icuType = 0 /* IcuType.select */;\n    } else {\n      icuType = 1 /* IcuType.plural */;\n    }\n\n    mainBinding = parseInt(binding.slice(1), 10);\n    return '';\n  });\n  const parts = i18nParseTextIntoPartsAndICU(pattern);\n  // Looking for (key block)+ sequence. One of the keys has to be \"other\".\n  for (let pos = 0; pos < parts.length;) {\n    let key = parts[pos++].trim();\n    if (icuType === 1 /* IcuType.plural */) {\n      // Key can be \"=x\", we just want \"x\"\n      key = key.replace(/\\s*(?:=)?(\\w+)\\s*/, '$1');\n    }\n    if (key.length) {\n      cases.push(key);\n    }\n    const blocks = i18nParseTextIntoPartsAndICU(parts[pos++]);\n    if (cases.length > values.length) {\n      values.push(blocks);\n    }\n  }\n  // TODO(ocombe): support ICU expressions in attributes, see #21615\n  return {\n    type: icuType,\n    mainBinding: mainBinding,\n    cases,\n    values\n  };\n}\n/**\n * Breaks pattern into strings and top level {...} blocks.\n * Can be used to break a message into text and ICU expressions, or to break an ICU expression\n * into keys and cases. Original code from closure library, modified for Angular.\n *\n * @param pattern (sub)Pattern to be broken.\n * @returns An `Array<string|IcuExpression>` where:\n *   - odd positions: `string` => text between ICU expressions\n *   - even positions: `ICUExpression` => ICU expression parsed into `ICUExpression` record.\n */\nfunction i18nParseTextIntoPartsAndICU(pattern) {\n  if (!pattern) {\n    return [];\n  }\n  let prevPos = 0;\n  const braceStack = [];\n  const results = [];\n  const braces = /[{}]/g;\n  // lastIndex doesn't get set to 0 so we have to.\n  braces.lastIndex = 0;\n  let match;\n  while (match = braces.exec(pattern)) {\n    const pos = match.index;\n    if (match[0] == '}') {\n      braceStack.pop();\n      if (braceStack.length == 0) {\n        // End of the block.\n        const block = pattern.substring(prevPos, pos);\n        if (ICU_BLOCK_REGEXP.test(block)) {\n          results.push(parseICUBlock(block));\n        } else {\n          results.push(block);\n        }\n        prevPos = pos + 1;\n      }\n    } else {\n      if (braceStack.length == 0) {\n        const substring = pattern.substring(prevPos, pos);\n        results.push(substring);\n        prevPos = pos + 1;\n      }\n      braceStack.push('{');\n    }\n  }\n  const substring = pattern.substring(prevPos);\n  results.push(substring);\n  return results;\n}\n/**\n * Parses a node, its children and its siblings, and generates the mutate & update OpCodes.\n *\n */\nfunction parseIcuCase(tView, tIcu, lView, updateOpCodes, parentIdx, caseName, unsafeCaseHtml, nestedIcus) {\n  const create = [];\n  const remove = [];\n  const update = [];\n  if (ngDevMode) {\n    attachDebugGetter(create, icuCreateOpCodesToString);\n    attachDebugGetter(remove, i18nRemoveOpCodesToString);\n    attachDebugGetter(update, i18nUpdateOpCodesToString);\n  }\n  tIcu.cases.push(caseName);\n  tIcu.create.push(create);\n  tIcu.remove.push(remove);\n  tIcu.update.push(update);\n  const inertBodyHelper = getInertBodyHelper(getDocument());\n  const inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeCaseHtml);\n  ngDevMode && assertDefined(inertBodyElement, 'Unable to generate inert body element');\n  const inertRootNode = getTemplateContent(inertBodyElement) || inertBodyElement;\n  if (inertRootNode) {\n    return walkIcuTree(tView, tIcu, lView, updateOpCodes, create, remove, update, inertRootNode, parentIdx, nestedIcus, 0);\n  } else {\n    return 0;\n  }\n}\nfunction walkIcuTree(tView, tIcu, lView, sharedUpdateOpCodes, create, remove, update, parentNode, parentIdx, nestedIcus, depth) {\n  let bindingMask = 0;\n  let currentNode = parentNode.firstChild;\n  while (currentNode) {\n    const newIndex = allocExpando(tView, lView, 1, null);\n    switch (currentNode.nodeType) {\n      case Node.ELEMENT_NODE:\n        const element = currentNode;\n        const tagName = element.tagName.toLowerCase();\n        if (VALID_ELEMENTS.hasOwnProperty(tagName)) {\n          addCreateNodeAndAppend(create, ELEMENT_MARKER, tagName, parentIdx, newIndex);\n          tView.data[newIndex] = tagName;\n          const elAttrs = element.attributes;\n          for (let i = 0; i < elAttrs.length; i++) {\n            const attr = elAttrs.item(i);\n            const lowerAttrName = attr.name.toLowerCase();\n            const hasBinding = !!attr.value.match(BINDING_REGEXP);\n            // we assume the input string is safe, unless it's using a binding\n            if (hasBinding) {\n              if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {\n                if (URI_ATTRS[lowerAttrName]) {\n                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, _sanitizeUrl);\n                } else {\n                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, null);\n                }\n              } else {\n                ngDevMode && console.warn(`WARNING: ignoring unsafe attribute value ` + `${lowerAttrName} on element ${tagName} ` + `(see ${XSS_SECURITY_URL})`);\n              }\n            } else {\n              addCreateAttribute(create, newIndex, attr);\n            }\n          }\n          // Parse the children of this node (if any)\n          bindingMask = walkIcuTree(tView, tIcu, lView, sharedUpdateOpCodes, create, remove, update, currentNode, newIndex, nestedIcus, depth + 1) | bindingMask;\n          addRemoveNode(remove, newIndex, depth);\n        }\n        break;\n      case Node.TEXT_NODE:\n        const value = currentNode.textContent || '';\n        const hasBinding = value.match(BINDING_REGEXP);\n        addCreateNodeAndAppend(create, null, hasBinding ? '' : value, parentIdx, newIndex);\n        addRemoveNode(remove, newIndex, depth);\n        if (hasBinding) {\n          bindingMask = generateBindingUpdateOpCodes(update, value, newIndex, null, 0, null) | bindingMask;\n        }\n        break;\n      case Node.COMMENT_NODE:\n        // Check if the comment node is a placeholder for a nested ICU\n        const isNestedIcu = NESTED_ICU.exec(currentNode.textContent || '');\n        if (isNestedIcu) {\n          const nestedIcuIndex = parseInt(isNestedIcu[1], 10);\n          const icuExpression = nestedIcus[nestedIcuIndex];\n          // Create the comment node that will anchor the ICU expression\n          addCreateNodeAndAppend(create, ICU_MARKER, ngDevMode ? `nested ICU ${nestedIcuIndex}` : '', parentIdx, newIndex);\n          icuStart(tView, lView, sharedUpdateOpCodes, parentIdx, icuExpression, newIndex);\n          addRemoveNestedIcu(remove, newIndex, depth);\n        }\n        break;\n    }\n    currentNode = currentNode.nextSibling;\n  }\n  return bindingMask;\n}\nfunction addRemoveNode(remove, index, depth) {\n  if (depth === 0) {\n    remove.push(index);\n  }\n}\nfunction addRemoveNestedIcu(remove, index, depth) {\n  if (depth === 0) {\n    remove.push(~index); // remove ICU at `index`\n    remove.push(index); // remove ICU comment at `index`\n  }\n}\n\nfunction addUpdateIcuSwitch(update, icuExpression, index) {\n  update.push(toMaskBit(icuExpression.mainBinding), 2, -1 - icuExpression.mainBinding, index << 2 /* I18nUpdateOpCode.SHIFT_REF */ | 2 /* I18nUpdateOpCode.IcuSwitch */);\n}\n\nfunction addUpdateIcuUpdate(update, bindingMask, index) {\n  update.push(bindingMask, 1, index << 2 /* I18nUpdateOpCode.SHIFT_REF */ | 3 /* I18nUpdateOpCode.IcuUpdate */);\n}\n\nfunction addCreateNodeAndAppend(create, marker, text, appendToParentIdx, createAtIdx) {\n  if (marker !== null) {\n    create.push(marker);\n  }\n  create.push(text, createAtIdx, icuCreateOpCode(0 /* IcuCreateOpCode.AppendChild */, appendToParentIdx, createAtIdx));\n}\nfunction addCreateAttribute(create, newIndex, attr) {\n  create.push(newIndex << 1 /* IcuCreateOpCode.SHIFT_REF */ | 1 /* IcuCreateOpCode.Attr */, attr.name, attr.value);\n}\n\n// i18nPostprocess consts\nconst ROOT_TEMPLATE_ID = 0;\nconst PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\\[(�.+?�?)\\]/;\nconst PP_PLACEHOLDERS_REGEXP = /\\[(�.+?�?)\\]|(�\\/?\\*\\d+:\\d+�)/g;\nconst PP_ICU_VARS_REGEXP = /({\\s*)(VAR_(PLURAL|SELECT)(_\\d+)?)(\\s*,)/g;\nconst PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;\nconst PP_ICUS_REGEXP = /�I18N_EXP_(ICU(_\\d+)?)�/g;\nconst PP_CLOSE_TEMPLATE_REGEXP = /\\/\\*/;\nconst PP_TEMPLATE_ID_REGEXP = /\\d+\\:(\\d+)/;\n/**\n * Handles message string post-processing for internationalization.\n *\n * Handles message string post-processing by transforming it from intermediate\n * format (that might contain some markers that we need to replace) to the final\n * form, consumable by i18nStart instruction. Post processing steps include:\n *\n * 1. Resolve all multi-value cases (like [�*1:1��#2:1�|�#4:1�|�5�])\n * 2. Replace all ICU vars (like \"VAR_PLURAL\")\n * 3. Replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n * 4. Replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�)\n *    in case multiple ICUs have the same placeholder name\n *\n * @param message Raw translation string for post processing\n * @param replacements Set of replacements that should be applied\n *\n * @returns Transformed string that can be consumed by i18nStart instruction\n *\n * @codeGenApi\n */\nfunction i18nPostprocess(message, replacements = {}) {\n  /**\n   * Step 1: resolve all multi-value placeholders like [�#5�|�*1:1��#2:1�|�#4:1�]\n   *\n   * Note: due to the way we process nested templates (BFS), multi-value placeholders are typically\n   * grouped by templates, for example: [�#5�|�#6�|�#1:1�|�#3:2�] where �#5� and �#6� belong to root\n   * template, �#1:1� belong to nested template with index 1 and �#1:2� - nested template with index\n   * 3. However in real templates the order might be different: i.e. �#1:1� and/or �#3:2� may go in\n   * front of �#6�. The post processing step restores the right order by keeping track of the\n   * template id stack and looks for placeholders that belong to the currently active template.\n   */\n  let result = message;\n  if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)) {\n    const matches = {};\n    const templateIdsStack = [ROOT_TEMPLATE_ID];\n    result = result.replace(PP_PLACEHOLDERS_REGEXP, (m, phs, tmpl) => {\n      const content = phs || tmpl;\n      const placeholders = matches[content] || [];\n      if (!placeholders.length) {\n        content.split('|').forEach(placeholder => {\n          const match = placeholder.match(PP_TEMPLATE_ID_REGEXP);\n          const templateId = match ? parseInt(match[1], 10) : ROOT_TEMPLATE_ID;\n          const isCloseTemplateTag = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder);\n          placeholders.push([templateId, isCloseTemplateTag, placeholder]);\n        });\n        matches[content] = placeholders;\n      }\n      if (!placeholders.length) {\n        throw new Error(`i18n postprocess: unmatched placeholder - ${content}`);\n      }\n      const currentTemplateId = templateIdsStack[templateIdsStack.length - 1];\n      let idx = 0;\n      // find placeholder index that matches current template id\n      for (let i = 0; i < placeholders.length; i++) {\n        if (placeholders[i][0] === currentTemplateId) {\n          idx = i;\n          break;\n        }\n      }\n      // update template id stack based on the current tag extracted\n      const [templateId, isCloseTemplateTag, placeholder] = placeholders[idx];\n      if (isCloseTemplateTag) {\n        templateIdsStack.pop();\n      } else if (currentTemplateId !== templateId) {\n        templateIdsStack.push(templateId);\n      }\n      // remove processed tag from the list\n      placeholders.splice(idx, 1);\n      return placeholder;\n    });\n  }\n  // return current result if no replacements specified\n  if (!Object.keys(replacements).length) {\n    return result;\n  }\n  /**\n   * Step 2: replace all ICU vars (like \"VAR_PLURAL\")\n   */\n  result = result.replace(PP_ICU_VARS_REGEXP, (match, start, key, _type, _idx, end) => {\n    return replacements.hasOwnProperty(key) ? `${start}${replacements[key]}${end}` : match;\n  });\n  /**\n   * Step 3: replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n   */\n  result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP, (match, key) => {\n    return replacements.hasOwnProperty(key) ? replacements[key] : match;\n  });\n  /**\n   * Step 4: replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�) in case\n   * multiple ICUs have the same placeholder name\n   */\n  result = result.replace(PP_ICUS_REGEXP, (match, key) => {\n    if (replacements.hasOwnProperty(key)) {\n      const list = replacements[key];\n      if (!list.length) {\n        throw new Error(`i18n postprocess: unmatched ICU - ${match} with key: ${key}`);\n      }\n      return list.shift();\n    }\n    return match;\n  });\n  return result;\n}\n\n/**\n * Marks a block of text as translatable.\n *\n * The instructions `i18nStart` and `i18nEnd` mark the translation block in the template.\n * The translation `message` is the value which is locale specific. The translation string may\n * contain placeholders which associate inner elements and sub-templates within the translation.\n *\n * The translation `message` placeholders are:\n * - `�{index}(:{block})�`: *Binding Placeholder*: Marks a location where an expression will be\n *   interpolated into. The placeholder `index` points to the expression binding index. An optional\n *   `block` that matches the sub-template in which it was declared.\n * - `�#{index}(:{block})�`/`�/#{index}(:{block})�`: *Element Placeholder*:  Marks the beginning\n *   and end of DOM element that were embedded in the original translation block. The placeholder\n *   `index` points to the element index in the template instructions set. An optional `block` that\n *   matches the sub-template in which it was declared.\n * - `�*{index}:{block}�`/`�/*{index}:{block}�`: *Sub-template Placeholder*: Sub-templates must be\n *   split up and translated separately in each angular template function. The `index` points to the\n *   `template` instruction index. A `block` that matches the sub-template in which it was declared.\n *\n * @param index A unique index of the translation in the static block.\n * @param messageIndex An index of the translation message from the `def.consts` array.\n * @param subTemplateIndex Optional sub-template index in the `message`.\n *\n * @codeGenApi\n */\nfunction ɵɵi18nStart(index, messageIndex, subTemplateIndex = -1) {\n  const tView = getTView();\n  const lView = getLView();\n  const adjustedIndex = HEADER_OFFSET + index;\n  ngDevMode && assertDefined(tView, `tView should be defined`);\n  const message = getConstant(tView.consts, messageIndex);\n  const parentTNode = getCurrentParentTNode();\n  if (tView.firstCreatePass) {\n    i18nStartFirstCreatePass(tView, parentTNode === null ? 0 : parentTNode.index, lView, adjustedIndex, message, subTemplateIndex);\n  }\n  // Set a flag that this LView has i18n blocks.\n  // The flag is later used to determine whether this component should\n  // be hydrated (currently hydration is not supported for i18n blocks).\n  if (tView.type === 2 /* TViewType.Embedded */) {\n    // Annotate host component's LView (not embedded view's LView),\n    // since hydration can be skipped on per-component basis only.\n    const componentLView = lView[DECLARATION_COMPONENT_VIEW];\n    componentLView[FLAGS] |= 32 /* LViewFlags.HasI18n */;\n  } else {\n    lView[FLAGS] |= 32 /* LViewFlags.HasI18n */;\n  }\n\n  const tI18n = tView.data[adjustedIndex];\n  const sameViewParentTNode = parentTNode === lView[T_HOST] ? null : parentTNode;\n  const parentRNode = getClosestRElement(tView, sameViewParentTNode, lView);\n  // If `parentTNode` is an `ElementContainer` than it has `<!--ng-container--->`.\n  // When we do inserts we have to make sure to insert in front of `<!--ng-container--->`.\n  const insertInFrontOf = parentTNode && parentTNode.type & 8 /* TNodeType.ElementContainer */ ? lView[parentTNode.index] : null;\n  applyCreateOpCodes(lView, tI18n.create, parentRNode, insertInFrontOf);\n  setInI18nBlock(true);\n}\n/**\n * Translates a translation block marked by `i18nStart` and `i18nEnd`. It inserts the text/ICU nodes\n * into the render tree, moves the placeholder nodes and removes the deleted nodes.\n *\n * @codeGenApi\n */\nfunction ɵɵi18nEnd() {\n  setInI18nBlock(false);\n}\n/**\n *\n * Use this instruction to create a translation block that doesn't contain any placeholder.\n * It calls both {@link i18nStart} and {@link i18nEnd} in one instruction.\n *\n * The translation `message` is the value which is locale specific. The translation string may\n * contain placeholders which associate inner elements and sub-templates within the translation.\n *\n * The translation `message` placeholders are:\n * - `�{index}(:{block})�`: *Binding Placeholder*: Marks a location where an expression will be\n *   interpolated into. The placeholder `index` points to the expression binding index. An optional\n *   `block` that matches the sub-template in which it was declared.\n * - `�#{index}(:{block})�`/`�/#{index}(:{block})�`: *Element Placeholder*:  Marks the beginning\n *   and end of DOM element that were embedded in the original translation block. The placeholder\n *   `index` points to the element index in the template instructions set. An optional `block` that\n *   matches the sub-template in which it was declared.\n * - `�*{index}:{block}�`/`�/*{index}:{block}�`: *Sub-template Placeholder*: Sub-templates must be\n *   split up and translated separately in each angular template function. The `index` points to the\n *   `template` instruction index. A `block` that matches the sub-template in which it was declared.\n *\n * @param index A unique index of the translation in the static block.\n * @param messageIndex An index of the translation message from the `def.consts` array.\n * @param subTemplateIndex Optional sub-template index in the `message`.\n *\n * @codeGenApi\n */\nfunction ɵɵi18n(index, messageIndex, subTemplateIndex) {\n  ɵɵi18nStart(index, messageIndex, subTemplateIndex);\n  ɵɵi18nEnd();\n}\n/**\n * Marks a list of attributes as translatable.\n *\n * @param index A unique index in the static block\n * @param values\n *\n * @codeGenApi\n */\nfunction ɵɵi18nAttributes(index, attrsIndex) {\n  const tView = getTView();\n  ngDevMode && assertDefined(tView, `tView should be defined`);\n  const attrs = getConstant(tView.consts, attrsIndex);\n  i18nAttributesFirstPass(tView, index + HEADER_OFFSET, attrs);\n}\n/**\n * Stores the values of the bindings during each update cycle in order to determine if we need to\n * update the translated nodes.\n *\n * @param value The binding's value\n * @returns This function returns itself so that it may be chained\n * (e.g. `i18nExp(ctx.name)(ctx.title)`)\n *\n * @codeGenApi\n */\nfunction ɵɵi18nExp(value) {\n  const lView = getLView();\n  setMaskBit(bindingUpdated(lView, nextBindingIndex(), value));\n  return ɵɵi18nExp;\n}\n/**\n * Updates a translation block or an i18n attribute when the bindings have changed.\n *\n * @param index Index of either {@link i18nStart} (translation block) or {@link i18nAttributes}\n * (i18n attribute) on which it should update the content.\n *\n * @codeGenApi\n */\nfunction ɵɵi18nApply(index) {\n  applyI18n(getTView(), getLView(), index + HEADER_OFFSET);\n}\n/**\n * Handles message string post-processing for internationalization.\n *\n * Handles message string post-processing by transforming it from intermediate\n * format (that might contain some markers that we need to replace) to the final\n * form, consumable by i18nStart instruction. Post processing steps include:\n *\n * 1. Resolve all multi-value cases (like [�*1:1��#2:1�|�#4:1�|�5�])\n * 2. Replace all ICU vars (like \"VAR_PLURAL\")\n * 3. Replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n * 4. Replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�)\n *    in case multiple ICUs have the same placeholder name\n *\n * @param message Raw translation string for post processing\n * @param replacements Set of replacements that should be applied\n *\n * @returns Transformed string that can be consumed by i18nStart instruction\n *\n * @codeGenApi\n */\nfunction ɵɵi18nPostprocess(message, replacements = {}) {\n  return i18nPostprocess(message, replacements);\n}\n\n/**\n * Creates runtime data structures for `{#defer}` blocks.\n *\n * @param index The index of the defer block in the data array\n * @param deferredDepsFn Function that contains dependencies for this defer block\n *\n * @codeGenApi\n */\nfunction ɵɵdefer(index, deferredDepsFn) {\n  // TODO: implement runtime logic.\n}\n\n/*\n * This file re-exports all symbols contained in this directory.\n *\n * Why is this file not `index.ts`?\n *\n * There seems to be an inconsistent path resolution of an `index.ts` file\n * when only the parent directory is referenced. This could be due to the\n * node module resolution configuration differing from rollup and/or typescript.\n *\n * With commit\n * https://github.com/angular/angular/commit/d5e3f2c64bd13ce83e7c70788b7fc514ca4a9918\n * the `instructions.ts` file was moved to `instructions/instructions.ts` and an\n * `index.ts` file was used to re-export everything. Having had file names that were\n * importing from `instructions' directly (not the from the sub file or the `index.ts`\n * file) caused strange CI issues. `index.ts` had to be renamed to `all.ts` for this\n * to work.\n *\n * Jira Issue = FW-1184\n */\n\n/**\n * Resolves the providers which are defined in the DirectiveDef.\n *\n * When inserting the tokens and the factories in their respective arrays, we can assume that\n * this method is called first for the component (if any), and then for other directives on the same\n * node.\n * As a consequence,the providers are always processed in that order:\n * 1) The view providers of the component\n * 2) The providers of the component\n * 3) The providers of the other directives\n * This matches the structure of the injectables arrays of a view (for each node).\n * So the tokens and the factories can be pushed at the end of the arrays, except\n * in one case for multi providers.\n *\n * @param def the directive definition\n * @param providers: Array of `providers`.\n * @param viewProviders: Array of `viewProviders`.\n */\nfunction providersResolver(def, providers, viewProviders) {\n  const tView = getTView();\n  if (tView.firstCreatePass) {\n    const isComponent = isComponentDef(def);\n    // The list of view providers is processed first, and the flags are updated\n    resolveProvider(viewProviders, tView.data, tView.blueprint, isComponent, true);\n    // Then, the list of providers is processed, and the flags are updated\n    resolveProvider(providers, tView.data, tView.blueprint, isComponent, false);\n  }\n}\n/**\n * Resolves a provider and publishes it to the DI system.\n */\nfunction resolveProvider(provider, tInjectables, lInjectablesBlueprint, isComponent, isViewProvider) {\n  provider = resolveForwardRef(provider);\n  if (Array.isArray(provider)) {\n    // Recursively call `resolveProvider`\n    // Recursion is OK in this case because this code will not be in hot-path once we implement\n    // cloning of the initial state.\n    for (let i = 0; i < provider.length; i++) {\n      resolveProvider(provider[i], tInjectables, lInjectablesBlueprint, isComponent, isViewProvider);\n    }\n  } else {\n    const tView = getTView();\n    const lView = getLView();\n    const tNode = getCurrentTNode();\n    let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide);\n    const providerFactory = providerToFactory(provider);\n    if (ngDevMode) {\n      const injector = new NodeInjector(tNode, lView);\n      runInInjectorProfilerContext(injector, token, () => {\n        emitProviderConfiguredEvent(provider, isViewProvider);\n      });\n    }\n    const beginIndex = tNode.providerIndexes & 1048575 /* TNodeProviderIndexes.ProvidersStartIndexMask */;\n    const endIndex = tNode.directiveStart;\n    const cptViewProvidersCount = tNode.providerIndexes >> 20 /* TNodeProviderIndexes.CptViewProvidersCountShift */;\n    if (isTypeProvider(provider) || !provider.multi) {\n      // Single provider case: the factory is created and pushed immediately\n      const factory = new NodeInjectorFactory(providerFactory, isViewProvider, ɵɵdirectiveInject);\n      const existingFactoryIndex = indexOf(token, tInjectables, isViewProvider ? beginIndex : beginIndex + cptViewProvidersCount, endIndex);\n      if (existingFactoryIndex === -1) {\n        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);\n        registerDestroyHooksIfSupported(tView, provider, tInjectables.length);\n        tInjectables.push(token);\n        tNode.directiveStart++;\n        tNode.directiveEnd++;\n        if (isViewProvider) {\n          tNode.providerIndexes += 1048576 /* TNodeProviderIndexes.CptViewProvidersCountShifter */;\n        }\n\n        lInjectablesBlueprint.push(factory);\n        lView.push(factory);\n      } else {\n        lInjectablesBlueprint[existingFactoryIndex] = factory;\n        lView[existingFactoryIndex] = factory;\n      }\n    } else {\n      // Multi provider case:\n      // We create a multi factory which is going to aggregate all the values.\n      // Since the output of such a factory depends on content or view injection,\n      // we create two of them, which are linked together.\n      //\n      // The first one (for view providers) is always in the first block of the injectables array,\n      // and the second one (for providers) is always in the second block.\n      // This is important because view providers have higher priority. When a multi token\n      // is being looked up, the view providers should be found first.\n      // Note that it is not possible to have a multi factory in the third block (directive block).\n      //\n      // The algorithm to process multi providers is as follows:\n      // 1) If the multi provider comes from the `viewProviders` of the component:\n      //   a) If the special view providers factory doesn't exist, it is created and pushed.\n      //   b) Else, the multi provider is added to the existing multi factory.\n      // 2) If the multi provider comes from the `providers` of the component or of another\n      // directive:\n      //   a) If the multi factory doesn't exist, it is created and provider pushed into it.\n      //      It is also linked to the multi factory for view providers, if it exists.\n      //   b) Else, the multi provider is added to the existing multi factory.\n      const existingProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex + cptViewProvidersCount, endIndex);\n      const existingViewProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex, beginIndex + cptViewProvidersCount);\n      const doesProvidersFactoryExist = existingProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingProvidersFactoryIndex];\n      const doesViewProvidersFactoryExist = existingViewProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingViewProvidersFactoryIndex];\n      if (isViewProvider && !doesViewProvidersFactoryExist || !isViewProvider && !doesProvidersFactoryExist) {\n        // Cases 1.a and 2.a\n        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);\n        const factory = multiFactory(isViewProvider ? multiViewProvidersFactoryResolver : multiProvidersFactoryResolver, lInjectablesBlueprint.length, isViewProvider, isComponent, providerFactory);\n        if (!isViewProvider && doesViewProvidersFactoryExist) {\n          lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory = factory;\n        }\n        registerDestroyHooksIfSupported(tView, provider, tInjectables.length, 0);\n        tInjectables.push(token);\n        tNode.directiveStart++;\n        tNode.directiveEnd++;\n        if (isViewProvider) {\n          tNode.providerIndexes += 1048576 /* TNodeProviderIndexes.CptViewProvidersCountShifter */;\n        }\n\n        lInjectablesBlueprint.push(factory);\n        lView.push(factory);\n      } else {\n        // Cases 1.b and 2.b\n        const indexInFactory = multiFactoryAdd(lInjectablesBlueprint[isViewProvider ? existingViewProvidersFactoryIndex : existingProvidersFactoryIndex], providerFactory, !isViewProvider && isComponent);\n        registerDestroyHooksIfSupported(tView, provider, existingProvidersFactoryIndex > -1 ? existingProvidersFactoryIndex : existingViewProvidersFactoryIndex, indexInFactory);\n      }\n      if (!isViewProvider && isComponent && doesViewProvidersFactoryExist) {\n        lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders++;\n      }\n    }\n  }\n}\n/**\n * Registers the `ngOnDestroy` hook of a provider, if the provider supports destroy hooks.\n * @param tView `TView` in which to register the hook.\n * @param provider Provider whose hook should be registered.\n * @param contextIndex Index under which to find the context for the hook when it's being invoked.\n * @param indexInFactory Only required for `multi` providers. Index of the provider in the multi\n * provider factory.\n */\nfunction registerDestroyHooksIfSupported(tView, provider, contextIndex, indexInFactory) {\n  const providerIsTypeProvider = isTypeProvider(provider);\n  const providerIsClassProvider = isClassProvider(provider);\n  if (providerIsTypeProvider || providerIsClassProvider) {\n    // Resolve forward references as `useClass` can hold a forward reference.\n    const classToken = providerIsClassProvider ? resolveForwardRef(provider.useClass) : provider;\n    const prototype = classToken.prototype;\n    const ngOnDestroy = prototype.ngOnDestroy;\n    if (ngOnDestroy) {\n      const hooks = tView.destroyHooks || (tView.destroyHooks = []);\n      if (!providerIsTypeProvider && provider.multi) {\n        ngDevMode && assertDefined(indexInFactory, 'indexInFactory when registering multi factory destroy hook');\n        const existingCallbacksIndex = hooks.indexOf(contextIndex);\n        if (existingCallbacksIndex === -1) {\n          hooks.push(contextIndex, [indexInFactory, ngOnDestroy]);\n        } else {\n          hooks[existingCallbacksIndex + 1].push(indexInFactory, ngOnDestroy);\n        }\n      } else {\n        hooks.push(contextIndex, ngOnDestroy);\n      }\n    }\n  }\n}\n/**\n * Add a factory in a multi factory.\n * @returns Index at which the factory was inserted.\n */\nfunction multiFactoryAdd(multiFactory, factory, isComponentProvider) {\n  if (isComponentProvider) {\n    multiFactory.componentProviders++;\n  }\n  return multiFactory.multi.push(factory) - 1;\n}\n/**\n * Returns the index of item in the array, but only in the begin to end range.\n */\nfunction indexOf(item, arr, begin, end) {\n  for (let i = begin; i < end; i++) {\n    if (arr[i] === item) return i;\n  }\n  return -1;\n}\n/**\n * Use this with `multi` `providers`.\n */\nfunction multiProvidersFactoryResolver(_, tData, lData, tNode) {\n  return multiResolve(this.multi, []);\n}\n/**\n * Use this with `multi` `viewProviders`.\n *\n * This factory knows how to concatenate itself with the existing `multi` `providers`.\n */\nfunction multiViewProvidersFactoryResolver(_, tData, lView, tNode) {\n  const factories = this.multi;\n  let result;\n  if (this.providerFactory) {\n    const componentCount = this.providerFactory.componentProviders;\n    const multiProviders = getNodeInjectable(lView, lView[TVIEW], this.providerFactory.index, tNode);\n    // Copy the section of the array which contains `multi` `providers` from the component\n    result = multiProviders.slice(0, componentCount);\n    // Insert the `viewProvider` instances.\n    multiResolve(factories, result);\n    // Copy the section of the array which contains `multi` `providers` from other directives\n    for (let i = componentCount; i < multiProviders.length; i++) {\n      result.push(multiProviders[i]);\n    }\n  } else {\n    result = [];\n    // Insert the `viewProvider` instances.\n    multiResolve(factories, result);\n  }\n  return result;\n}\n/**\n * Maps an array of factories into an array of values.\n */\nfunction multiResolve(factories, result) {\n  for (let i = 0; i < factories.length; i++) {\n    const factory = factories[i];\n    result.push(factory());\n  }\n  return result;\n}\n/**\n * Creates a multi factory.\n */\nfunction multiFactory(factoryFn, index, isViewProvider, isComponent, f) {\n  const factory = new NodeInjectorFactory(factoryFn, isViewProvider, ɵɵdirectiveInject);\n  factory.multi = [];\n  factory.index = index;\n  factory.componentProviders = 0;\n  multiFactoryAdd(factory, f, isComponent && !isViewProvider);\n  return factory;\n}\n\n/**\n * This feature resolves the providers of a directive (or component),\n * and publish them into the DI system, making it visible to others for injection.\n *\n * For example:\n * ```ts\n * class ComponentWithProviders {\n *   constructor(private greeter: GreeterDE) {}\n *\n *   static ɵcmp = defineComponent({\n *     type: ComponentWithProviders,\n *     selectors: [['component-with-providers']],\n *    factory: () => new ComponentWithProviders(directiveInject(GreeterDE as any)),\n *    decls: 1,\n *    vars: 1,\n *    template: function(fs: RenderFlags, ctx: ComponentWithProviders) {\n *      if (fs & RenderFlags.Create) {\n *        ɵɵtext(0);\n *      }\n *      if (fs & RenderFlags.Update) {\n *        ɵɵtextInterpolate(ctx.greeter.greet());\n *      }\n *    },\n *    features: [ɵɵProvidersFeature([GreeterDE])]\n *  });\n * }\n * ```\n *\n * @param definition\n *\n * @codeGenApi\n */\nfunction ɵɵProvidersFeature(providers, viewProviders = []) {\n  return definition => {\n    definition.providersResolver = (def, processProvidersFn) => {\n      return providersResolver(def,\n      //\n      processProvidersFn ? processProvidersFn(providers) : providers,\n      //\n      viewProviders);\n    };\n  };\n}\n\n/**\n * Represents an instance of an `NgModule` created by an `NgModuleFactory`.\n * Provides access to the `NgModule` instance and related objects.\n *\n * @publicApi\n */\nclass NgModuleRef$1 {}\n/**\n * @publicApi\n *\n * @deprecated\n * This class was mostly used as a part of ViewEngine-based JIT API and is no longer needed in Ivy\n * JIT mode. See [JIT API changes due to ViewEngine deprecation](guide/deprecations#jit-api-changes)\n * for additional context. Angular provides APIs that accept NgModule classes directly (such as\n * [PlatformRef.bootstrapModule](api/core/PlatformRef#bootstrapModule) and\n * [createNgModule](api/core/createNgModule)), consider switching to those APIs instead of\n * using factory-based ones.\n */\nclass NgModuleFactory$1 {}\n\n/**\n * Returns a new NgModuleRef instance based on the NgModule class and parent injector provided.\n *\n * @param ngModule NgModule class.\n * @param parentInjector Optional injector instance to use as a parent for the module injector. If\n *     not provided, `NullInjector` will be used instead.\n * @returns NgModuleRef that represents an NgModule instance.\n *\n * @publicApi\n */\nfunction createNgModule(ngModule, parentInjector) {\n  return new NgModuleRef(ngModule, parentInjector ?? null, []);\n}\n/**\n * The `createNgModule` function alias for backwards-compatibility.\n * Please avoid using it directly and use `createNgModule` instead.\n *\n * @deprecated Use `createNgModule` instead.\n */\nconst createNgModuleRef = createNgModule;\nclass NgModuleRef extends NgModuleRef$1 {\n  constructor(ngModuleType, _parent, additionalProviders) {\n    super();\n    this._parent = _parent;\n    // tslint:disable-next-line:require-internal-with-underscore\n    this._bootstrapComponents = [];\n    this.destroyCbs = [];\n    // When bootstrapping a module we have a dependency graph that looks like this:\n    // ApplicationRef -> ComponentFactoryResolver -> NgModuleRef. The problem is that if the\n    // module being resolved tries to inject the ComponentFactoryResolver, it'll create a\n    // circular dependency which will result in a runtime error, because the injector doesn't\n    // exist yet. We work around the issue by creating the ComponentFactoryResolver ourselves\n    // and providing it, rather than letting the injector resolve it.\n    this.componentFactoryResolver = new ComponentFactoryResolver(this);\n    const ngModuleDef = getNgModuleDef(ngModuleType);\n    ngDevMode && assertDefined(ngModuleDef, `NgModule '${stringify(ngModuleType)}' is not a subtype of 'NgModuleType'.`);\n    this._bootstrapComponents = maybeUnwrapFn$1(ngModuleDef.bootstrap);\n    this._r3Injector = createInjectorWithoutInjectorInstances(ngModuleType, _parent, [{\n      provide: NgModuleRef$1,\n      useValue: this\n    }, {\n      provide: ComponentFactoryResolver$1,\n      useValue: this.componentFactoryResolver\n    }, ...additionalProviders], stringify(ngModuleType), new Set(['environment']));\n    // We need to resolve the injector types separately from the injector creation, because\n    // the module might be trying to use this ref in its constructor for DI which will cause a\n    // circular error that will eventually error out, because the injector isn't created yet.\n    this._r3Injector.resolveInjectorInitializers();\n    this.instance = this._r3Injector.get(ngModuleType);\n  }\n  get injector() {\n    return this._r3Injector;\n  }\n  destroy() {\n    ngDevMode && assertDefined(this.destroyCbs, 'NgModule already destroyed');\n    const injector = this._r3Injector;\n    !injector.destroyed && injector.destroy();\n    this.destroyCbs.forEach(fn => fn());\n    this.destroyCbs = null;\n  }\n  onDestroy(callback) {\n    ngDevMode && assertDefined(this.destroyCbs, 'NgModule already destroyed');\n    this.destroyCbs.push(callback);\n  }\n}\nclass NgModuleFactory extends NgModuleFactory$1 {\n  constructor(moduleType) {\n    super();\n    this.moduleType = moduleType;\n  }\n  create(parentInjector) {\n    return new NgModuleRef(this.moduleType, parentInjector, []);\n  }\n}\nfunction createNgModuleRefWithProviders(moduleType, parentInjector, additionalProviders) {\n  return new NgModuleRef(moduleType, parentInjector, additionalProviders);\n}\nclass EnvironmentNgModuleRefAdapter extends NgModuleRef$1 {\n  constructor(config) {\n    super();\n    this.componentFactoryResolver = new ComponentFactoryResolver(this);\n    this.instance = null;\n    const injector = new R3Injector([...config.providers, {\n      provide: NgModuleRef$1,\n      useValue: this\n    }, {\n      provide: ComponentFactoryResolver$1,\n      useValue: this.componentFactoryResolver\n    }], config.parent || getNullInjector(), config.debugName, new Set(['environment']));\n    this.injector = injector;\n    if (config.runEnvironmentInitializers) {\n      injector.resolveInjectorInitializers();\n    }\n  }\n  destroy() {\n    this.injector.destroy();\n  }\n  onDestroy(callback) {\n    this.injector.onDestroy(callback);\n  }\n}\n/**\n * Create a new environment injector.\n *\n * Learn more about environment injectors in\n * [this guide](guide/standalone-components#environment-injectors).\n *\n * @param providers An array of providers.\n * @param parent A parent environment injector.\n * @param debugName An optional name for this injector instance, which will be used in error\n *     messages.\n *\n * @publicApi\n */\nfunction createEnvironmentInjector(providers, parent, debugName = null) {\n  const adapter = new EnvironmentNgModuleRefAdapter({\n    providers,\n    parent,\n    debugName,\n    runEnvironmentInitializers: true\n  });\n  return adapter.injector;\n}\n\n/**\n * A service used by the framework to create instances of standalone injectors. Those injectors are\n * created on demand in case of dynamic component instantiation and contain ambient providers\n * collected from the imports graph rooted at a given standalone component.\n */\nclass StandaloneService {\n  constructor(_injector) {\n    this._injector = _injector;\n    this.cachedInjectors = new Map();\n  }\n  getOrCreateStandaloneInjector(componentDef) {\n    if (!componentDef.standalone) {\n      return null;\n    }\n    if (!this.cachedInjectors.has(componentDef)) {\n      const providers = internalImportProvidersFrom(false, componentDef.type);\n      const standaloneInjector = providers.length > 0 ? createEnvironmentInjector([providers], this._injector, `Standalone[${componentDef.type.name}]`) : null;\n      this.cachedInjectors.set(componentDef, standaloneInjector);\n    }\n    return this.cachedInjectors.get(componentDef);\n  }\n  ngOnDestroy() {\n    try {\n      for (const injector of this.cachedInjectors.values()) {\n        if (injector !== null) {\n          injector.destroy();\n        }\n      }\n    } finally {\n      this.cachedInjectors.clear();\n    }\n  }\n  /** @nocollapse */\n  static #_ = this.ɵprov = ɵɵdefineInjectable({\n    token: StandaloneService,\n    providedIn: 'environment',\n    factory: () => new StandaloneService(ɵɵinject(EnvironmentInjector))\n  });\n}\n/**\n * A feature that acts as a setup code for the {@link StandaloneService}.\n *\n * The most important responsibility of this feature is to expose the \"getStandaloneInjector\"\n * function (an entry points to a standalone injector creation) on a component definition object. We\n * go through the features infrastructure to make sure that the standalone injector creation logic\n * is tree-shakable and not included in applications that don't use standalone components.\n *\n * @codeGenApi\n */\nfunction ɵɵStandaloneFeature(definition) {\n  definition.getStandaloneInjector = parentInjector => {\n    return parentInjector.get(StandaloneService).getOrCreateStandaloneInjector(definition);\n  };\n}\n\n/**\n * Retrieves the component instance associated with a given DOM element.\n *\n * @usageNotes\n * Given the following DOM structure:\n *\n * ```html\n * <app-root>\n *   <div>\n *     <child-comp></child-comp>\n *   </div>\n * </app-root>\n * ```\n *\n * Calling `getComponent` on `<child-comp>` will return the instance of `ChildComponent`\n * associated with this DOM element.\n *\n * Calling the function on `<app-root>` will return the `MyApp` instance.\n *\n *\n * @param element DOM element from which the component should be retrieved.\n * @returns Component instance associated with the element or `null` if there\n *    is no component associated with it.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getComponent(element) {\n  ngDevMode && assertDomElement(element);\n  const context = getLContext(element);\n  if (context === null) return null;\n  if (context.component === undefined) {\n    const lView = context.lView;\n    if (lView === null) {\n      return null;\n    }\n    context.component = getComponentAtNodeIndex(context.nodeIndex, lView);\n  }\n  return context.component;\n}\n/**\n * If inside an embedded view (e.g. `*ngIf` or `*ngFor`), retrieves the context of the embedded\n * view that the element is part of. Otherwise retrieves the instance of the component whose view\n * owns the element (in this case, the result is the same as calling `getOwningComponent`).\n *\n * @param element Element for which to get the surrounding component instance.\n * @returns Instance of the component that is around the element or null if the element isn't\n *    inside any component.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getContext(element) {\n  assertDomElement(element);\n  const context = getLContext(element);\n  const lView = context ? context.lView : null;\n  return lView === null ? null : lView[CONTEXT];\n}\n/**\n * Retrieves the component instance whose view contains the DOM element.\n *\n * For example, if `<child-comp>` is used in the template of `<app-comp>`\n * (i.e. a `ViewChild` of `<app-comp>`), calling `getOwningComponent` on `<child-comp>`\n * would return `<app-comp>`.\n *\n * @param elementOrDir DOM element, component or directive instance\n *    for which to retrieve the root components.\n * @returns Component instance whose view owns the DOM element or null if the element is not\n *    part of a component view.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getOwningComponent(elementOrDir) {\n  const context = getLContext(elementOrDir);\n  let lView = context ? context.lView : null;\n  if (lView === null) return null;\n  let parent;\n  while (lView[TVIEW].type === 2 /* TViewType.Embedded */ && (parent = getLViewParent(lView))) {\n    lView = parent;\n  }\n  return lView[FLAGS] & 512 /* LViewFlags.IsRoot */ ? null : lView[CONTEXT];\n}\n/**\n * Retrieves all root components associated with a DOM element, directive or component instance.\n * Root components are those which have been bootstrapped by Angular.\n *\n * @param elementOrDir DOM element, component or directive instance\n *    for which to retrieve the root components.\n * @returns Root components associated with the target object.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getRootComponents(elementOrDir) {\n  const lView = readPatchedLView(elementOrDir);\n  return lView !== null ? [getRootContext(lView)] : [];\n}\n/**\n * Retrieves an `Injector` associated with an element, component or directive instance.\n *\n * @param elementOrDir DOM element, component or directive instance for which to\n *    retrieve the injector.\n * @returns Injector associated with the element, component or directive instance.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getInjector(elementOrDir) {\n  const context = getLContext(elementOrDir);\n  const lView = context ? context.lView : null;\n  if (lView === null) return Injector.NULL;\n  const tNode = lView[TVIEW].data[context.nodeIndex];\n  return new NodeInjector(tNode, lView);\n}\n/**\n * Retrieve a set of injection tokens at a given DOM node.\n *\n * @param element Element for which the injection tokens should be retrieved.\n */\nfunction getInjectionTokens(element) {\n  const context = getLContext(element);\n  const lView = context ? context.lView : null;\n  if (lView === null) return [];\n  const tView = lView[TVIEW];\n  const tNode = tView.data[context.nodeIndex];\n  const providerTokens = [];\n  const startIndex = tNode.providerIndexes & 1048575 /* TNodeProviderIndexes.ProvidersStartIndexMask */;\n  const endIndex = tNode.directiveEnd;\n  for (let i = startIndex; i < endIndex; i++) {\n    let value = tView.data[i];\n    if (isDirectiveDefHack(value)) {\n      // The fact that we sometimes store Type and sometimes DirectiveDef in this location is a\n      // design flaw.  We should always store same type so that we can be monomorphic. The issue\n      // is that for Components/Directives we store the def instead the type. The correct behavior\n      // is that we should always be storing injectable type in this location.\n      value = value.type;\n    }\n    providerTokens.push(value);\n  }\n  return providerTokens;\n}\n/**\n * Retrieves directive instances associated with a given DOM node. Does not include\n * component instances.\n *\n * @usageNotes\n * Given the following DOM structure:\n *\n * ```html\n * <app-root>\n *   <button my-button></button>\n *   <my-comp></my-comp>\n * </app-root>\n * ```\n *\n * Calling `getDirectives` on `<button>` will return an array with an instance of the `MyButton`\n * directive that is associated with the DOM node.\n *\n * Calling `getDirectives` on `<my-comp>` will return an empty array.\n *\n * @param node DOM node for which to get the directives.\n * @returns Array of directives associated with the node.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getDirectives(node) {\n  // Skip text nodes because we can't have directives associated with them.\n  if (node instanceof Text) {\n    return [];\n  }\n  const context = getLContext(node);\n  const lView = context ? context.lView : null;\n  if (lView === null) {\n    return [];\n  }\n  const tView = lView[TVIEW];\n  const nodeIndex = context.nodeIndex;\n  if (!tView?.data[nodeIndex]) {\n    return [];\n  }\n  if (context.directives === undefined) {\n    context.directives = getDirectivesAtNodeIndex(nodeIndex, lView);\n  }\n  // The `directives` in this case are a named array called `LComponentView`. Clone the\n  // result so we don't expose an internal data structure in the user's console.\n  return context.directives === null ? [] : [...context.directives];\n}\n/**\n * Returns the debug (partial) metadata for a particular directive or component instance.\n * The function accepts an instance of a directive or component and returns the corresponding\n * metadata.\n *\n * @param directiveOrComponentInstance Instance of a directive or component\n * @returns metadata of the passed directive or component\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getDirectiveMetadata(directiveOrComponentInstance) {\n  const {\n    constructor\n  } = directiveOrComponentInstance;\n  if (!constructor) {\n    throw new Error('Unable to find the instance constructor');\n  }\n  // In case a component inherits from a directive, we may have component and directive metadata\n  // To ensure we don't get the metadata of the directive, we want to call `getComponentDef` first.\n  const componentDef = getComponentDef$1(constructor);\n  if (componentDef) {\n    return {\n      inputs: componentDef.inputs,\n      outputs: componentDef.outputs,\n      encapsulation: componentDef.encapsulation,\n      changeDetection: componentDef.onPush ? ChangeDetectionStrategy.OnPush : ChangeDetectionStrategy.Default\n    };\n  }\n  const directiveDef = getDirectiveDef(constructor);\n  if (directiveDef) {\n    return {\n      inputs: directiveDef.inputs,\n      outputs: directiveDef.outputs\n    };\n  }\n  return null;\n}\n/**\n * Retrieve map of local references.\n *\n * The references are retrieved as a map of local reference name to element or directive instance.\n *\n * @param target DOM element, component or directive instance for which to retrieve\n *    the local references.\n */\nfunction getLocalRefs(target) {\n  const context = getLContext(target);\n  if (context === null) return {};\n  if (context.localRefs === undefined) {\n    const lView = context.lView;\n    if (lView === null) {\n      return {};\n    }\n    context.localRefs = discoverLocalRefs(lView, context.nodeIndex);\n  }\n  return context.localRefs || {};\n}\n/**\n * Retrieves the host element of a component or directive instance.\n * The host element is the DOM element that matched the selector of the directive.\n *\n * @param componentOrDirective Component or directive instance for which the host\n *     element should be retrieved.\n * @returns Host element of the target.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getHostElement(componentOrDirective) {\n  return getLContext(componentOrDirective).native;\n}\n/**\n * Retrieves the rendered text for a given component.\n *\n * This function retrieves the host element of a component and\n * and then returns the `textContent` for that element. This implies\n * that the text returned will include re-projected content of\n * the component as well.\n *\n * @param component The component to return the content text for.\n */\nfunction getRenderedText(component) {\n  const hostElement = getHostElement(component);\n  return hostElement.textContent || '';\n}\n/**\n * Retrieves a list of event listeners associated with a DOM element. The list does include host\n * listeners, but it does not include event listeners defined outside of the Angular context\n * (e.g. through `addEventListener`).\n *\n * @usageNotes\n * Given the following DOM structure:\n *\n * ```html\n * <app-root>\n *   <div (click)=\"doSomething()\"></div>\n * </app-root>\n * ```\n *\n * Calling `getListeners` on `<div>` will return an object that looks as follows:\n *\n * ```ts\n * {\n *   name: 'click',\n *   element: <div>,\n *   callback: () => doSomething(),\n *   useCapture: false\n * }\n * ```\n *\n * @param element Element for which the DOM listeners should be retrieved.\n * @returns Array of event listeners on the DOM element.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getListeners(element) {\n  ngDevMode && assertDomElement(element);\n  const lContext = getLContext(element);\n  const lView = lContext === null ? null : lContext.lView;\n  if (lView === null) return [];\n  const tView = lView[TVIEW];\n  const lCleanup = lView[CLEANUP];\n  const tCleanup = tView.cleanup;\n  const listeners = [];\n  if (tCleanup && lCleanup) {\n    for (let i = 0; i < tCleanup.length;) {\n      const firstParam = tCleanup[i++];\n      const secondParam = tCleanup[i++];\n      if (typeof firstParam === 'string') {\n        const name = firstParam;\n        const listenerElement = unwrapRNode(lView[secondParam]);\n        const callback = lCleanup[tCleanup[i++]];\n        const useCaptureOrIndx = tCleanup[i++];\n        // if useCaptureOrIndx is boolean then report it as is.\n        // if useCaptureOrIndx is positive number then it in unsubscribe method\n        // if useCaptureOrIndx is negative number then it is a Subscription\n        const type = typeof useCaptureOrIndx === 'boolean' || useCaptureOrIndx >= 0 ? 'dom' : 'output';\n        const useCapture = typeof useCaptureOrIndx === 'boolean' ? useCaptureOrIndx : false;\n        if (element == listenerElement) {\n          listeners.push({\n            element,\n            name,\n            callback,\n            useCapture,\n            type\n          });\n        }\n      }\n    }\n  }\n  listeners.sort(sortListeners);\n  return listeners;\n}\nfunction sortListeners(a, b) {\n  if (a.name == b.name) return 0;\n  return a.name < b.name ? -1 : 1;\n}\n/**\n * This function should not exist because it is megamorphic and only mostly correct.\n *\n * See call site for more info.\n */\nfunction isDirectiveDefHack(obj) {\n  return obj.type !== undefined && obj.declaredInputs !== undefined && obj.findHostDirectiveDefs !== undefined;\n}\n/**\n * Retrieve the component `LView` from component/element.\n *\n * NOTE: `LView` is a private and should not be leaked outside.\n *       Don't export this method to `ng.*` on window.\n *\n * @param target DOM element or component instance for which to retrieve the LView.\n */\nfunction getComponentLView(target) {\n  const lContext = getLContext(target);\n  const nodeIndx = lContext.nodeIndex;\n  const lView = lContext.lView;\n  ngDevMode && assertLView(lView);\n  const componentLView = lView[nodeIndx];\n  ngDevMode && assertLView(componentLView);\n  return componentLView;\n}\n/** Asserts that a value is a DOM Element. */\nfunction assertDomElement(value) {\n  if (typeof Element !== 'undefined' && !(value instanceof Element)) {\n    throw new Error('Expecting instance of DOM Element');\n  }\n}\n\n/**\n * Adds decorator, constructor, and property metadata to a given type via static metadata fields\n * on the type.\n *\n * These metadata fields can later be read with Angular's `ReflectionCapabilities` API.\n *\n * Calls to `setClassMetadata` can be guarded by ngDevMode, resulting in the metadata assignments\n * being tree-shaken away during production builds.\n */\nfunction setClassMetadata(type, decorators, ctorParameters, propDecorators) {\n  return noSideEffects(() => {\n    const clazz = type;\n    if (decorators !== null) {\n      if (clazz.hasOwnProperty('decorators') && clazz.decorators !== undefined) {\n        clazz.decorators.push(...decorators);\n      } else {\n        clazz.decorators = decorators;\n      }\n    }\n    if (ctorParameters !== null) {\n      // Rather than merging, clobber the existing parameters. If other projects exist which\n      // use tsickle-style annotations and reflect over them in the same way, this could\n      // cause issues, but that is vanishingly unlikely.\n      clazz.ctorParameters = ctorParameters;\n    }\n    if (propDecorators !== null) {\n      // The property decorator objects are merged as it is possible different fields have\n      // different decorator types. Decorators on individual fields are not merged, as it's\n      // also incredibly unlikely that a field will be decorated both with an Angular\n      // decorator and a non-Angular decorator that's also been downleveled.\n      if (clazz.hasOwnProperty('propDecorators') && clazz.propDecorators !== undefined) {\n        clazz.propDecorators = {\n          ...clazz.propDecorators,\n          ...propDecorators\n        };\n      } else {\n        clazz.propDecorators = propDecorators;\n      }\n    }\n  });\n}\n\n/**\n * Bindings for pure functions are stored after regular bindings.\n *\n * |-------decls------|---------vars---------|                 |----- hostVars (dir1) ------|\n * ------------------------------------------------------------------------------------------\n * | nodes/refs/pipes | bindings | fn slots  | injector | dir1 | host bindings | host slots |\n * ------------------------------------------------------------------------------------------\n *                    ^                      ^\n *      TView.bindingStartIndex      TView.expandoStartIndex\n *\n * Pure function instructions are given an offset from the binding root. Adding the offset to the\n * binding root gives the first index where the bindings are stored. In component views, the binding\n * root is the bindingStartIndex. In host bindings, the binding root is the expandoStartIndex +\n * any directive instances + any hostVars in directives evaluated before it.\n *\n * See VIEW_DATA.md for more information about host binding resolution.\n */\n/**\n * If the value hasn't been saved, calls the pure function to store and return the\n * value. If it has been saved, returns the saved value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn Function that returns a value\n * @param thisArg Optional calling context of pureFn\n * @returns value\n *\n * @codeGenApi\n */\nfunction ɵɵpureFunction0(slotOffset, pureFn, thisArg) {\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  return lView[bindingIndex] === NO_CHANGE ? updateBinding(lView, bindingIndex, thisArg ? pureFn.call(thisArg) : pureFn()) : getBinding(lView, bindingIndex);\n}\n/**\n * If the value of the provided exp has changed, calls the pure function to return\n * an updated value. Or if the value has not changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn Function that returns an updated value\n * @param exp Updated expression value\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction ɵɵpureFunction1(slotOffset, pureFn, exp, thisArg) {\n  return pureFunction1Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp, thisArg);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction ɵɵpureFunction2(slotOffset, pureFn, exp1, exp2, thisArg) {\n  return pureFunction2Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, thisArg);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction ɵɵpureFunction3(slotOffset, pureFn, exp1, exp2, exp3, thisArg) {\n  return pureFunction3Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, thisArg);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction ɵɵpureFunction4(slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {\n  return pureFunction4Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction ɵɵpureFunction5(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, thisArg) {\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n  return bindingUpdated(lView, bindingIndex + 4, exp5) || different ? updateBinding(lView, bindingIndex + 5, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5) : pureFn(exp1, exp2, exp3, exp4, exp5)) : getBinding(lView, bindingIndex + 5);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param exp6\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction ɵɵpureFunction6(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, thisArg) {\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n  return bindingUpdated2(lView, bindingIndex + 4, exp5, exp6) || different ? updateBinding(lView, bindingIndex + 6, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6)) : getBinding(lView, bindingIndex + 6);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param exp6\n * @param exp7\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction ɵɵpureFunction7(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, thisArg) {\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  let different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n  return bindingUpdated3(lView, bindingIndex + 4, exp5, exp6, exp7) || different ? updateBinding(lView, bindingIndex + 7, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7)) : getBinding(lView, bindingIndex + 7);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param exp6\n * @param exp7\n * @param exp8\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction ɵɵpureFunction8(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8, thisArg) {\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n  return bindingUpdated4(lView, bindingIndex + 4, exp5, exp6, exp7, exp8) || different ? updateBinding(lView, bindingIndex + 8, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8)) : getBinding(lView, bindingIndex + 8);\n}\n/**\n * pureFunction instruction that can support any number of bindings.\n *\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn A pure function that takes binding values and builds an object or array\n * containing those values.\n * @param exps An array of binding values\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction ɵɵpureFunctionV(slotOffset, pureFn, exps, thisArg) {\n  return pureFunctionVInternal(getLView(), getBindingRoot(), slotOffset, pureFn, exps, thisArg);\n}\n/**\n * Results of a pure function invocation are stored in LView in a dedicated slot that is initialized\n * to NO_CHANGE. In rare situations a pure pipe might throw an exception on the very first\n * invocation and not produce any valid results. In this case LView would keep holding the NO_CHANGE\n * value. The NO_CHANGE is not something that we can use in expressions / bindings thus we convert\n * it to `undefined`.\n */\nfunction getPureFunctionReturnValue(lView, returnValueIndex) {\n  ngDevMode && assertIndexInRange(lView, returnValueIndex);\n  const lastReturnValue = lView[returnValueIndex];\n  return lastReturnValue === NO_CHANGE ? undefined : lastReturnValue;\n}\n/**\n * If the value of the provided exp has changed, calls the pure function to return\n * an updated value. Or if the value has not changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn Function that returns an updated value\n * @param exp Updated expression value\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nfunction pureFunction1Internal(lView, bindingRoot, slotOffset, pureFn, exp, thisArg) {\n  const bindingIndex = bindingRoot + slotOffset;\n  return bindingUpdated(lView, bindingIndex, exp) ? updateBinding(lView, bindingIndex + 1, thisArg ? pureFn.call(thisArg, exp) : pureFn(exp)) : getPureFunctionReturnValue(lView, bindingIndex + 1);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nfunction pureFunction2Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, thisArg) {\n  const bindingIndex = bindingRoot + slotOffset;\n  return bindingUpdated2(lView, bindingIndex, exp1, exp2) ? updateBinding(lView, bindingIndex + 2, thisArg ? pureFn.call(thisArg, exp1, exp2) : pureFn(exp1, exp2)) : getPureFunctionReturnValue(lView, bindingIndex + 2);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nfunction pureFunction3Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, thisArg) {\n  const bindingIndex = bindingRoot + slotOffset;\n  return bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) ? updateBinding(lView, bindingIndex + 3, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3) : pureFn(exp1, exp2, exp3)) : getPureFunctionReturnValue(lView, bindingIndex + 3);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n */\nfunction pureFunction4Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {\n  const bindingIndex = bindingRoot + slotOffset;\n  return bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) ? updateBinding(lView, bindingIndex + 4, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4) : pureFn(exp1, exp2, exp3, exp4)) : getPureFunctionReturnValue(lView, bindingIndex + 4);\n}\n/**\n * pureFunction instruction that can support any number of bindings.\n *\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn A pure function that takes binding values and builds an object or array\n * containing those values.\n * @param exps An array of binding values\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nfunction pureFunctionVInternal(lView, bindingRoot, slotOffset, pureFn, exps, thisArg) {\n  let bindingIndex = bindingRoot + slotOffset;\n  let different = false;\n  for (let i = 0; i < exps.length; i++) {\n    bindingUpdated(lView, bindingIndex++, exps[i]) && (different = true);\n  }\n  return different ? updateBinding(lView, bindingIndex, pureFn.apply(thisArg, exps)) : getPureFunctionReturnValue(lView, bindingIndex);\n}\n\n/**\n * Create a pipe.\n *\n * @param index Pipe index where the pipe will be stored.\n * @param pipeName The name of the pipe\n * @returns T the instance of the pipe.\n *\n * @codeGenApi\n */\nfunction ɵɵpipe(index, pipeName) {\n  const tView = getTView();\n  let pipeDef;\n  const adjustedIndex = index + HEADER_OFFSET;\n  if (tView.firstCreatePass) {\n    // The `getPipeDef` throws if a pipe with a given name is not found\n    // (so we use non-null assertion below).\n    pipeDef = getPipeDef(pipeName, tView.pipeRegistry);\n    tView.data[adjustedIndex] = pipeDef;\n    if (pipeDef.onDestroy) {\n      (tView.destroyHooks ??= []).push(adjustedIndex, pipeDef.onDestroy);\n    }\n  } else {\n    pipeDef = tView.data[adjustedIndex];\n  }\n  const pipeFactory = pipeDef.factory || (pipeDef.factory = getFactoryDef(pipeDef.type, true));\n  let previousInjectorProfilerContext;\n  if (ngDevMode) {\n    previousInjectorProfilerContext = setInjectorProfilerContext({\n      injector: new NodeInjector(getCurrentTNode(), getLView()),\n      token: pipeDef.type\n    });\n  }\n  const previousInjectImplementation = setInjectImplementation(ɵɵdirectiveInject);\n  try {\n    // DI for pipes is supposed to behave like directives when placed on a component\n    // host node, which means that we have to disable access to `viewProviders`.\n    const previousIncludeViewProviders = setIncludeViewProviders(false);\n    const pipeInstance = pipeFactory();\n    setIncludeViewProviders(previousIncludeViewProviders);\n    store(tView, getLView(), adjustedIndex, pipeInstance);\n    return pipeInstance;\n  } finally {\n    // we have to restore the injector implementation in finally, just in case the creation of the\n    // pipe throws an error.\n    setInjectImplementation(previousInjectImplementation);\n    ngDevMode && setInjectorProfilerContext(previousInjectorProfilerContext);\n  }\n}\n/**\n * Searches the pipe registry for a pipe with the given name. If one is found,\n * returns the pipe. Otherwise, an error is thrown because the pipe cannot be resolved.\n *\n * @param name Name of pipe to resolve\n * @param registry Full list of available pipes\n * @returns Matching PipeDef\n */\nfunction getPipeDef(name, registry) {\n  if (registry) {\n    if (ngDevMode) {\n      const pipes = registry.filter(pipe => pipe.name === name);\n      // TODO: Throw an error in the next major\n      if (pipes.length > 1) {\n        console.warn(formatRuntimeError(313 /* RuntimeErrorCode.MULTIPLE_MATCHING_PIPES */, getMultipleMatchingPipesMessage(name)));\n      }\n    }\n    for (let i = registry.length - 1; i >= 0; i--) {\n      const pipeDef = registry[i];\n      if (name === pipeDef.name) {\n        return pipeDef;\n      }\n    }\n  }\n  if (ngDevMode) {\n    throw new RuntimeError(-302 /* RuntimeErrorCode.PIPE_NOT_FOUND */, getPipeNotFoundErrorMessage(name));\n  }\n}\n/**\n * Generates a helpful error message for the user when multiple pipes match the name.\n *\n * @param name Name of the pipe\n * @returns The error message\n */\nfunction getMultipleMatchingPipesMessage(name) {\n  const lView = getLView();\n  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];\n  const context = declarationLView[CONTEXT];\n  const hostIsStandalone = isHostComponentStandalone(lView);\n  const componentInfoMessage = context ? ` in the '${context.constructor.name}' component` : '';\n  const verifyMessage = `check ${hostIsStandalone ? '\\'@Component.imports\\' of this component' : 'the imports of this module'}`;\n  const errorMessage = `Multiple pipes match the name \\`${name}\\`${componentInfoMessage}. ${verifyMessage}`;\n  return errorMessage;\n}\n/**\n * Generates a helpful error message for the user when a pipe is not found.\n *\n * @param name Name of the missing pipe\n * @returns The error message\n */\nfunction getPipeNotFoundErrorMessage(name) {\n  const lView = getLView();\n  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];\n  const context = declarationLView[CONTEXT];\n  const hostIsStandalone = isHostComponentStandalone(lView);\n  const componentInfoMessage = context ? ` in the '${context.constructor.name}' component` : '';\n  const verifyMessage = `Verify that it is ${hostIsStandalone ? 'included in the \\'@Component.imports\\' of this component' : 'declared or imported in this module'}`;\n  const errorMessage = `The pipe '${name}' could not be found${componentInfoMessage}. ${verifyMessage}`;\n  return errorMessage;\n}\n/**\n * Invokes a pipe with 1 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\nfunction ɵɵpipeBind1(index, slotOffset, v1) {\n  const adjustedIndex = index + HEADER_OFFSET;\n  const lView = getLView();\n  const pipeInstance = load(lView, adjustedIndex);\n  return isPure(lView, adjustedIndex) ? pureFunction1Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, pipeInstance) : pipeInstance.transform(v1);\n}\n/**\n * Invokes a pipe with 2 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\nfunction ɵɵpipeBind2(index, slotOffset, v1, v2) {\n  const adjustedIndex = index + HEADER_OFFSET;\n  const lView = getLView();\n  const pipeInstance = load(lView, adjustedIndex);\n  return isPure(lView, adjustedIndex) ? pureFunction2Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, pipeInstance) : pipeInstance.transform(v1, v2);\n}\n/**\n * Invokes a pipe with 3 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n * @param v3 4rd argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\nfunction ɵɵpipeBind3(index, slotOffset, v1, v2, v3) {\n  const adjustedIndex = index + HEADER_OFFSET;\n  const lView = getLView();\n  const pipeInstance = load(lView, adjustedIndex);\n  return isPure(lView, adjustedIndex) ? pureFunction3Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, pipeInstance) : pipeInstance.transform(v1, v2, v3);\n}\n/**\n * Invokes a pipe with 4 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n * @param v3 3rd argument to {@link PipeTransform#transform}.\n * @param v4 4th argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\nfunction ɵɵpipeBind4(index, slotOffset, v1, v2, v3, v4) {\n  const adjustedIndex = index + HEADER_OFFSET;\n  const lView = getLView();\n  const pipeInstance = load(lView, adjustedIndex);\n  return isPure(lView, adjustedIndex) ? pureFunction4Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, v4, pipeInstance) : pipeInstance.transform(v1, v2, v3, v4);\n}\n/**\n * Invokes a pipe with variable number of arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param values Array of arguments to pass to {@link PipeTransform#transform} method.\n *\n * @codeGenApi\n */\nfunction ɵɵpipeBindV(index, slotOffset, values) {\n  const adjustedIndex = index + HEADER_OFFSET;\n  const lView = getLView();\n  const pipeInstance = load(lView, adjustedIndex);\n  return isPure(lView, adjustedIndex) ? pureFunctionVInternal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, values, pipeInstance) : pipeInstance.transform.apply(pipeInstance, values);\n}\nfunction isPure(lView, index) {\n  return lView[TVIEW].data[index].pure;\n}\nfunction symbolIterator() {\n  // @ts-expect-error accessing a private member\n  return this._results[Symbol.iterator]();\n}\n/**\n * An unmodifiable list of items that Angular keeps up to date when the state\n * of the application changes.\n *\n * The type of object that {@link ViewChildren}, {@link ContentChildren}, and {@link QueryList}\n * provide.\n *\n * Implements an iterable interface, therefore it can be used in both ES6\n * javascript `for (var i of items)` loops as well as in Angular templates with\n * `*ngFor=\"let i of myList\"`.\n *\n * Changes can be observed by subscribing to the changes `Observable`.\n *\n * NOTE: In the future this class will implement an `Observable` interface.\n *\n * @usageNotes\n * ### Example\n * ```typescript\n * @Component({...})\n * class Container {\n *   @ViewChildren(Item) items:QueryList<Item>;\n * }\n * ```\n *\n * @publicApi\n */\nclass QueryList {\n  static #_ = Symbol.iterator;\n  /**\n   * Returns `Observable` of `QueryList` notifying the subscriber of changes.\n   */\n  get changes() {\n    return this._changes || (this._changes = new EventEmitter());\n  }\n  /**\n   * @param emitDistinctChangesOnly Whether `QueryList.changes` should fire only when actual change\n   *     has occurred. Or if it should fire when query is recomputed. (recomputing could resolve in\n   *     the same result)\n   */\n  constructor(_emitDistinctChangesOnly = false) {\n    this._emitDistinctChangesOnly = _emitDistinctChangesOnly;\n    this.dirty = true;\n    this._results = [];\n    this._changesDetected = false;\n    this._changes = null;\n    this.length = 0;\n    this.first = undefined;\n    this.last = undefined;\n    // This function should be declared on the prototype, but doing so there will cause the class\n    // declaration to have side-effects and become not tree-shakable. For this reason we do it in\n    // the constructor.\n    // [Symbol.iterator](): Iterator<T> { ... }\n    const proto = QueryList.prototype;\n    if (!proto[Symbol.iterator]) proto[Symbol.iterator] = symbolIterator;\n  }\n  /**\n   * Returns the QueryList entry at `index`.\n   */\n  get(index) {\n    return this._results[index];\n  }\n  /**\n   * See\n   * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\n   */\n  map(fn) {\n    return this._results.map(fn);\n  }\n  filter(fn) {\n    return this._results.filter(fn);\n  }\n  /**\n   * See\n   * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)\n   */\n  find(fn) {\n    return this._results.find(fn);\n  }\n  /**\n   * See\n   * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)\n   */\n  reduce(fn, init) {\n    return this._results.reduce(fn, init);\n  }\n  /**\n   * See\n   * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)\n   */\n  forEach(fn) {\n    this._results.forEach(fn);\n  }\n  /**\n   * See\n   * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)\n   */\n  some(fn) {\n    return this._results.some(fn);\n  }\n  /**\n   * Returns a copy of the internal results list as an Array.\n   */\n  toArray() {\n    return this._results.slice();\n  }\n  toString() {\n    return this._results.toString();\n  }\n  /**\n   * Updates the stored data of the query list, and resets the `dirty` flag to `false`, so that\n   * on change detection, it will not notify of changes to the queries, unless a new change\n   * occurs.\n   *\n   * @param resultsTree The query results to store\n   * @param identityAccessor Optional function for extracting stable object identity from a value\n   *    in the array. This function is executed for each element of the query result list while\n   *    comparing current query list with the new one (provided as a first argument of the `reset`\n   *    function) to detect if the lists are different. If the function is not provided, elements\n   *    are compared as is (without any pre-processing).\n   */\n  reset(resultsTree, identityAccessor) {\n    // Cast to `QueryListInternal` so that we can mutate fields which are readonly for the usage of\n    // QueryList (but not for QueryList itself.)\n    const self = this;\n    self.dirty = false;\n    const newResultFlat = flatten$1(resultsTree);\n    if (this._changesDetected = !arrayEquals(self._results, newResultFlat, identityAccessor)) {\n      self._results = newResultFlat;\n      self.length = newResultFlat.length;\n      self.last = newResultFlat[this.length - 1];\n      self.first = newResultFlat[0];\n    }\n  }\n  /**\n   * Triggers a change event by emitting on the `changes` {@link EventEmitter}.\n   */\n  notifyOnChanges() {\n    if (this._changes && (this._changesDetected || !this._emitDistinctChangesOnly)) this._changes.emit(this);\n  }\n  /** internal */\n  setDirty() {\n    this.dirty = true;\n  }\n  /** internal */\n  destroy() {\n    this.changes.complete();\n    this.changes.unsubscribe();\n  }\n}\nfunction createAndRenderEmbeddedLView(declarationLView, templateTNode, context, options) {\n  const embeddedTView = templateTNode.tView;\n  ngDevMode && assertDefined(embeddedTView, 'TView must be defined for a template node.');\n  ngDevMode && assertTNodeForLView(templateTNode, declarationLView);\n  // Embedded views follow the change detection strategy of the view they're declared in.\n  const isSignalView = declarationLView[FLAGS] & 4096 /* LViewFlags.SignalView */;\n  const viewFlags = isSignalView ? 4096 /* LViewFlags.SignalView */ : 16 /* LViewFlags.CheckAlways */;\n  const embeddedLView = createLView(declarationLView, embeddedTView, context, viewFlags, null, templateTNode, null, null, null, options?.injector ?? null, options?.hydrationInfo ?? null);\n  const declarationLContainer = declarationLView[templateTNode.index];\n  ngDevMode && assertLContainer(declarationLContainer);\n  embeddedLView[DECLARATION_LCONTAINER] = declarationLContainer;\n  const declarationViewLQueries = declarationLView[QUERIES];\n  if (declarationViewLQueries !== null) {\n    embeddedLView[QUERIES] = declarationViewLQueries.createEmbeddedView(embeddedTView);\n  }\n  // execute creation mode of a view\n  renderView(embeddedTView, embeddedLView, context);\n  return embeddedLView;\n}\nfunction getLViewFromLContainer(lContainer, index) {\n  const adjustedIndex = CONTAINER_HEADER_OFFSET + index;\n  // avoid reading past the array boundaries\n  if (adjustedIndex < lContainer.length) {\n    const lView = lContainer[adjustedIndex];\n    ngDevMode && assertLView(lView);\n    return lView;\n  }\n  return undefined;\n}\nfunction addLViewToLContainer(lContainer, lView, index, addToDOM = true) {\n  const tView = lView[TVIEW];\n  // insert to the view tree so the new view can be change-detected\n  insertView(tView, lView, lContainer, index);\n  // insert to the view to the DOM tree\n  if (addToDOM) {\n    const beforeNode = getBeforeNodeForView(index, lContainer);\n    const renderer = lView[RENDERER];\n    const parentRNode = nativeParentNode(renderer, lContainer[NATIVE]);\n    if (parentRNode !== null) {\n      addViewToDOM(tView, lContainer[T_HOST], renderer, lView, parentRNode, beforeNode);\n    }\n  }\n}\nfunction removeLViewFromLContainer(lContainer, index) {\n  const lView = detachView(lContainer, index);\n  if (lView !== undefined) {\n    destroyLView(lView[TVIEW], lView);\n  }\n  return lView;\n}\n\n/**\n * Represents an embedded template that can be used to instantiate embedded views.\n * To instantiate embedded views based on a template, use the `ViewContainerRef`\n * method `createEmbeddedView()`.\n *\n * Access a `TemplateRef` instance by placing a directive on an `<ng-template>`\n * element (or directive prefixed with `*`). The `TemplateRef` for the embedded view\n * is injected into the constructor of the directive,\n * using the `TemplateRef` token.\n *\n * You can also use a `Query` to find a `TemplateRef` associated with\n * a component or a directive.\n *\n * @see {@link ViewContainerRef}\n * @see [Navigate the Component Tree with DI](guide/dependency-injection-navtree)\n *\n * @publicApi\n */\nclass TemplateRef {\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static #_ = this.__NG_ELEMENT_ID__ = injectTemplateRef;\n}\nconst ViewEngineTemplateRef = TemplateRef;\n// TODO(alxhub): combine interface and implementation. Currently this is challenging since something\n// in g3 depends on them being separate.\nconst R3TemplateRef = class TemplateRef extends ViewEngineTemplateRef {\n  constructor(_declarationLView, _declarationTContainer, elementRef) {\n    super();\n    this._declarationLView = _declarationLView;\n    this._declarationTContainer = _declarationTContainer;\n    this.elementRef = elementRef;\n  }\n  /**\n   * Returns an `ssrId` associated with a TView, which was used to\n   * create this instance of the `TemplateRef`.\n   *\n   * @internal\n   */\n  get ssrId() {\n    return this._declarationTContainer.tView?.ssrId || null;\n  }\n  createEmbeddedView(context, injector) {\n    return this.createEmbeddedViewImpl(context, injector);\n  }\n  /**\n   * @internal\n   */\n  createEmbeddedViewImpl(context, injector, hydrationInfo) {\n    const embeddedLView = createAndRenderEmbeddedLView(this._declarationLView, this._declarationTContainer, context, {\n      injector,\n      hydrationInfo\n    });\n    return new ViewRef(embeddedLView);\n  }\n};\n/**\n * Creates a TemplateRef given a node.\n *\n * @returns The TemplateRef instance to use\n */\nfunction injectTemplateRef() {\n  return createTemplateRef(getCurrentTNode(), getLView());\n}\n/**\n * Creates a TemplateRef and stores it on the injector.\n *\n * @param hostTNode The node on which a TemplateRef is requested\n * @param hostLView The `LView` to which the node belongs\n * @returns The TemplateRef instance or null if we can't create a TemplateRef on a given node type\n */\nfunction createTemplateRef(hostTNode, hostLView) {\n  if (hostTNode.type & 4 /* TNodeType.Container */) {\n    ngDevMode && assertDefined(hostTNode.tView, 'TView must be allocated');\n    return new R3TemplateRef(hostLView, hostTNode, createElementRef(hostTNode, hostLView));\n  }\n  return null;\n}\n\n/**\n * Removes all dehydrated views from a given LContainer:\n * both in internal data structure, as well as removing\n * corresponding DOM nodes that belong to that dehydrated view.\n */\nfunction removeDehydratedViews(lContainer) {\n  const views = lContainer[DEHYDRATED_VIEWS] ?? [];\n  const parentLView = lContainer[PARENT];\n  const renderer = parentLView[RENDERER];\n  for (const view of views) {\n    removeDehydratedView(view, renderer);\n    ngDevMode && ngDevMode.dehydratedViewsRemoved++;\n  }\n  // Reset the value to an empty array to indicate that no\n  // further processing of dehydrated views is needed for\n  // this view container (i.e. do not trigger the lookup process\n  // once again in case a `ViewContainerRef` is created later).\n  lContainer[DEHYDRATED_VIEWS] = EMPTY_ARRAY;\n}\n/**\n * Helper function to remove all nodes from a dehydrated view.\n */\nfunction removeDehydratedView(dehydratedView, renderer) {\n  let nodesRemoved = 0;\n  let currentRNode = dehydratedView.firstChild;\n  if (currentRNode) {\n    const numNodes = dehydratedView.data[NUM_ROOT_NODES];\n    while (nodesRemoved < numNodes) {\n      ngDevMode && validateSiblingNodeExists(currentRNode);\n      const nextSibling = currentRNode.nextSibling;\n      nativeRemoveNode(renderer, currentRNode, false);\n      currentRNode = nextSibling;\n      nodesRemoved++;\n    }\n  }\n}\n/**\n * Walks over all views within this LContainer invokes dehydrated views\n * cleanup function for each one.\n */\nfunction cleanupLContainer(lContainer) {\n  removeDehydratedViews(lContainer);\n  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n    cleanupLView(lContainer[i]);\n  }\n}\n/**\n * Walks over `LContainer`s and components registered within\n * this LView and invokes dehydrated views cleanup function for each one.\n */\nfunction cleanupLView(lView) {\n  const tView = lView[TVIEW];\n  for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {\n    if (isLContainer(lView[i])) {\n      const lContainer = lView[i];\n      cleanupLContainer(lContainer);\n    } else if (Array.isArray(lView[i])) {\n      // This is a component, enter the `cleanupLView` recursively.\n      cleanupLView(lView[i]);\n    }\n  }\n}\n/**\n * Walks over all views registered within the ApplicationRef and removes\n * all dehydrated views from all `LContainer`s along the way.\n */\nfunction cleanupDehydratedViews(appRef) {\n  const viewRefs = appRef._views;\n  for (const viewRef of viewRefs) {\n    const lNode = getLNodeForHydration(viewRef);\n    // An `lView` might be `null` if a `ViewRef` represents\n    // an embedded view (not a component view).\n    if (lNode !== null && lNode[HOST] !== null) {\n      if (isLView(lNode)) {\n        cleanupLView(lNode);\n      } else {\n        // Cleanup in the root component view\n        const componentLView = lNode[HOST];\n        cleanupLView(componentLView);\n        // Cleanup in all views within this view container\n        cleanupLContainer(lNode);\n      }\n      ngDevMode && ngDevMode.dehydratedViewsCleanupRuns++;\n    }\n  }\n}\n\n/**\n * Given a current DOM node and a serialized information about the views\n * in a container, walks over the DOM structure, collecting the list of\n * dehydrated views.\n */\nfunction locateDehydratedViewsInContainer(currentRNode, serializedViews) {\n  const dehydratedViews = [];\n  for (const serializedView of serializedViews) {\n    // Repeats a view multiple times as needed, based on the serialized information\n    // (for example, for *ngFor-produced views).\n    for (let i = 0; i < (serializedView[MULTIPLIER] ?? 1); i++) {\n      const view = {\n        data: serializedView,\n        firstChild: null\n      };\n      if (serializedView[NUM_ROOT_NODES] > 0) {\n        // Keep reference to the first node in this view,\n        // so it can be accessed while invoking template instructions.\n        view.firstChild = currentRNode;\n        // Move over to the next node after this view, which can\n        // either be a first node of the next view or an anchor comment\n        // node after the last view in a container.\n        currentRNode = siblingAfter(serializedView[NUM_ROOT_NODES], currentRNode);\n      }\n      dehydratedViews.push(view);\n    }\n  }\n  return [currentRNode, dehydratedViews];\n}\n/**\n * Reference to a function that searches for a matching dehydrated views\n * stored on a given lContainer.\n * Returns `null` by default, when hydration is not enabled.\n */\nlet _findMatchingDehydratedViewImpl = (lContainer, template) => null;\n/**\n * Retrieves the next dehydrated view from the LContainer and verifies that\n * it matches a given template id (from the TView that was used to create this\n * instance of a view). If the id doesn't match, that means that we are in an\n * unexpected state and can not complete the reconciliation process. Thus,\n * all dehydrated views from this LContainer are removed (including corresponding\n * DOM nodes) and the rendering is performed as if there were no dehydrated views\n * in this container.\n */\nfunction findMatchingDehydratedViewImpl(lContainer, template) {\n  const views = lContainer[DEHYDRATED_VIEWS] ?? [];\n  if (!template || views.length === 0) {\n    return null;\n  }\n  const view = views[0];\n  // Verify whether the first dehydrated view in the container matches\n  // the template id passed to this function (that originated from a TView\n  // that was used to create an instance of an embedded or component views.\n  if (view.data[TEMPLATE_ID] === template) {\n    // If the template id matches - extract the first view and return it.\n    return views.shift();\n  } else {\n    // Otherwise, we are at the state when reconciliation can not be completed,\n    // thus we remove all dehydrated views within this container (remove them\n    // from internal data structures as well as delete associated elements from\n    // the DOM tree).\n    removeDehydratedViews(lContainer);\n    return null;\n  }\n}\nfunction enableFindMatchingDehydratedViewImpl() {\n  _findMatchingDehydratedViewImpl = findMatchingDehydratedViewImpl;\n}\nfunction findMatchingDehydratedView(lContainer, template) {\n  return _findMatchingDehydratedViewImpl(lContainer, template);\n}\n\n/**\n * Represents a container where one or more views can be attached to a component.\n *\n * Can contain *host views* (created by instantiating a\n * component with the `createComponent()` method), and *embedded views*\n * (created by instantiating a `TemplateRef` with the `createEmbeddedView()` method).\n *\n * A view container instance can contain other view containers,\n * creating a [view hierarchy](guide/glossary#view-hierarchy).\n *\n * @usageNotes\n *\n * The example below demonstrates how the `createComponent` function can be used\n * to create an instance of a ComponentRef dynamically and attach it to an ApplicationRef,\n * so that it gets included into change detection cycles.\n *\n * Note: the example uses standalone components, but the function can also be used for\n * non-standalone components (declared in an NgModule) as well.\n *\n * ```typescript\n * @Component({\n *   standalone: true,\n *   selector: 'dynamic',\n *   template: `<span>This is a content of a dynamic component.</span>`,\n * })\n * class DynamicComponent {\n *   vcr = inject(ViewContainerRef);\n * }\n *\n * @Component({\n *   standalone: true,\n *   selector: 'app',\n *   template: `<main>Hi! This is the main content.</main>`,\n * })\n * class AppComponent {\n *   vcr = inject(ViewContainerRef);\n *\n *   ngAfterViewInit() {\n *     const compRef = this.vcr.createComponent(DynamicComponent);\n *     compRef.changeDetectorRef.detectChanges();\n *   }\n * }\n * ```\n *\n * @see {@link ComponentRef}\n * @see {@link EmbeddedViewRef}\n *\n * @publicApi\n */\nclass ViewContainerRef {\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static #_ = this.__NG_ELEMENT_ID__ = injectViewContainerRef;\n}\n/**\n * Creates a ViewContainerRef and stores it on the injector. Or, if the ViewContainerRef\n * already exists, retrieves the existing ViewContainerRef.\n *\n * @returns The ViewContainerRef instance to use\n */\nfunction injectViewContainerRef() {\n  const previousTNode = getCurrentTNode();\n  return createContainerRef(previousTNode, getLView());\n}\nconst VE_ViewContainerRef = ViewContainerRef;\n// TODO(alxhub): cleaning up this indirection triggers a subtle bug in Closure in g3. Once the fix\n// for that lands, this can be cleaned up.\nconst R3ViewContainerRef = class ViewContainerRef extends VE_ViewContainerRef {\n  constructor(_lContainer, _hostTNode, _hostLView) {\n    super();\n    this._lContainer = _lContainer;\n    this._hostTNode = _hostTNode;\n    this._hostLView = _hostLView;\n  }\n  get element() {\n    return createElementRef(this._hostTNode, this._hostLView);\n  }\n  get injector() {\n    return new NodeInjector(this._hostTNode, this._hostLView);\n  }\n  /** @deprecated No replacement */\n  get parentInjector() {\n    const parentLocation = getParentInjectorLocation(this._hostTNode, this._hostLView);\n    if (hasParentInjector(parentLocation)) {\n      const parentView = getParentInjectorView(parentLocation, this._hostLView);\n      const injectorIndex = getParentInjectorIndex(parentLocation);\n      ngDevMode && assertNodeInjector(parentView, injectorIndex);\n      const parentTNode = parentView[TVIEW].data[injectorIndex + 8 /* NodeInjectorOffset.TNODE */];\n      return new NodeInjector(parentTNode, parentView);\n    } else {\n      return new NodeInjector(null, this._hostLView);\n    }\n  }\n  clear() {\n    while (this.length > 0) {\n      this.remove(this.length - 1);\n    }\n  }\n  get(index) {\n    const viewRefs = getViewRefs(this._lContainer);\n    return viewRefs !== null && viewRefs[index] || null;\n  }\n  get length() {\n    return this._lContainer.length - CONTAINER_HEADER_OFFSET;\n  }\n  createEmbeddedView(templateRef, context, indexOrOptions) {\n    let index;\n    let injector;\n    if (typeof indexOrOptions === 'number') {\n      index = indexOrOptions;\n    } else if (indexOrOptions != null) {\n      index = indexOrOptions.index;\n      injector = indexOrOptions.injector;\n    }\n    const hydrationInfo = findMatchingDehydratedView(this._lContainer, templateRef.ssrId);\n    const viewRef = templateRef.createEmbeddedViewImpl(context || {}, injector, hydrationInfo);\n    // If there is a matching dehydrated view, but the host TNode is located in the skip\n    // hydration block, this means that the content was detached (as a part of the skip\n    // hydration logic) and it needs to be appended into the DOM.\n    const skipDomInsertion = !!hydrationInfo && !hasInSkipHydrationBlockFlag(this._hostTNode);\n    this.insertImpl(viewRef, index, skipDomInsertion);\n    return viewRef;\n  }\n  createComponent(componentFactoryOrType, indexOrOptions, injector, projectableNodes, environmentInjector) {\n    const isComponentFactory = componentFactoryOrType && !isType(componentFactoryOrType);\n    let index;\n    // This function supports 2 signatures and we need to handle options correctly for both:\n    //   1. When first argument is a Component type. This signature also requires extra\n    //      options to be provided as object (more ergonomic option).\n    //   2. First argument is a Component factory. In this case extra options are represented as\n    //      positional arguments. This signature is less ergonomic and will be deprecated.\n    if (isComponentFactory) {\n      if (ngDevMode) {\n        assertEqual(typeof indexOrOptions !== 'object', true, 'It looks like Component factory was provided as the first argument ' + 'and an options object as the second argument. This combination of arguments ' + 'is incompatible. You can either change the first argument to provide Component ' + 'type or change the second argument to be a number (representing an index at ' + 'which to insert the new component\\'s host view into this container)');\n      }\n      index = indexOrOptions;\n    } else {\n      if (ngDevMode) {\n        assertDefined(getComponentDef$1(componentFactoryOrType), `Provided Component class doesn't contain Component definition. ` + `Please check whether provided class has @Component decorator.`);\n        assertEqual(typeof indexOrOptions !== 'number', true, 'It looks like Component type was provided as the first argument ' + 'and a number (representing an index at which to insert the new component\\'s ' + 'host view into this container as the second argument. This combination of arguments ' + 'is incompatible. Please use an object as the second argument instead.');\n      }\n      const options = indexOrOptions || {};\n      if (ngDevMode && options.environmentInjector && options.ngModuleRef) {\n        throwError(`Cannot pass both environmentInjector and ngModuleRef options to createComponent().`);\n      }\n      index = options.index;\n      injector = options.injector;\n      projectableNodes = options.projectableNodes;\n      environmentInjector = options.environmentInjector || options.ngModuleRef;\n    }\n    const componentFactory = isComponentFactory ? componentFactoryOrType : new ComponentFactory(getComponentDef$1(componentFactoryOrType));\n    const contextInjector = injector || this.parentInjector;\n    // If an `NgModuleRef` is not provided explicitly, try retrieving it from the DI tree.\n    if (!environmentInjector && componentFactory.ngModule == null) {\n      // For the `ComponentFactory` case, entering this logic is very unlikely, since we expect that\n      // an instance of a `ComponentFactory`, resolved via `ComponentFactoryResolver` would have an\n      // `ngModule` field. This is possible in some test scenarios and potentially in some JIT-based\n      // use-cases. For the `ComponentFactory` case we preserve backwards-compatibility and try\n      // using a provided injector first, then fall back to the parent injector of this\n      // `ViewContainerRef` instance.\n      //\n      // For the factory-less case, it's critical to establish a connection with the module\n      // injector tree (by retrieving an instance of an `NgModuleRef` and accessing its injector),\n      // so that a component can use DI tokens provided in MgModules. For this reason, we can not\n      // rely on the provided injector, since it might be detached from the DI tree (for example, if\n      // it was created via `Injector.create` without specifying a parent injector, or if an\n      // injector is retrieved from an `NgModuleRef` created via `createNgModule` using an\n      // NgModule outside of a module tree). Instead, we always use `ViewContainerRef`'s parent\n      // injector, which is normally connected to the DI tree, which includes module injector\n      // subtree.\n      const _injector = isComponentFactory ? contextInjector : this.parentInjector;\n      // DO NOT REFACTOR. The code here used to have a `injector.get(NgModuleRef, null) ||\n      // undefined` expression which seems to cause internal google apps to fail. This is documented\n      // in the following internal bug issue: go/b/142967802\n      const result = _injector.get(EnvironmentInjector, null);\n      if (result) {\n        environmentInjector = result;\n      }\n    }\n    const componentDef = getComponentDef$1(componentFactory.componentType ?? {});\n    const dehydratedView = findMatchingDehydratedView(this._lContainer, componentDef?.id ?? null);\n    const rNode = dehydratedView?.firstChild ?? null;\n    const componentRef = componentFactory.create(contextInjector, projectableNodes, rNode, environmentInjector);\n    // If there is a matching dehydrated view, but the host TNode is located in the skip\n    // hydration block, this means that the content was detached (as a part of the skip\n    // hydration logic) and it needs to be appended into the DOM.\n    const skipDomInsertion = !!dehydratedView && !hasInSkipHydrationBlockFlag(this._hostTNode);\n    this.insertImpl(componentRef.hostView, index, skipDomInsertion);\n    return componentRef;\n  }\n  insert(viewRef, index) {\n    return this.insertImpl(viewRef, index, false);\n  }\n  insertImpl(viewRef, index, skipDomInsertion) {\n    const lView = viewRef._lView;\n    const tView = lView[TVIEW];\n    if (ngDevMode && viewRef.destroyed) {\n      throw new Error('Cannot insert a destroyed View in a ViewContainer!');\n    }\n    if (viewAttachedToContainer(lView)) {\n      // If view is already attached, detach it first so we clean up references appropriately.\n      const prevIdx = this.indexOf(viewRef);\n      // A view might be attached either to this or a different container. The `prevIdx` for\n      // those cases will be:\n      // equal to -1 for views attached to this ViewContainerRef\n      // >= 0 for views attached to a different ViewContainerRef\n      if (prevIdx !== -1) {\n        this.detach(prevIdx);\n      } else {\n        const prevLContainer = lView[PARENT];\n        ngDevMode && assertEqual(isLContainer(prevLContainer), true, 'An attached view should have its PARENT point to a container.');\n        // We need to re-create a R3ViewContainerRef instance since those are not stored on\n        // LView (nor anywhere else).\n        const prevVCRef = new R3ViewContainerRef(prevLContainer, prevLContainer[T_HOST], prevLContainer[PARENT]);\n        prevVCRef.detach(prevVCRef.indexOf(viewRef));\n      }\n    }\n    // Logical operation of adding `LView` to `LContainer`\n    const adjustedIdx = this._adjustIndex(index);\n    const lContainer = this._lContainer;\n    addLViewToLContainer(lContainer, lView, adjustedIdx, !skipDomInsertion);\n    viewRef.attachToViewContainerRef();\n    addToArray(getOrCreateViewRefs(lContainer), adjustedIdx, viewRef);\n    return viewRef;\n  }\n  move(viewRef, newIndex) {\n    if (ngDevMode && viewRef.destroyed) {\n      throw new Error('Cannot move a destroyed View in a ViewContainer!');\n    }\n    return this.insert(viewRef, newIndex);\n  }\n  indexOf(viewRef) {\n    const viewRefsArr = getViewRefs(this._lContainer);\n    return viewRefsArr !== null ? viewRefsArr.indexOf(viewRef) : -1;\n  }\n  remove(index) {\n    const adjustedIdx = this._adjustIndex(index, -1);\n    const detachedView = detachView(this._lContainer, adjustedIdx);\n    if (detachedView) {\n      // Before destroying the view, remove it from the container's array of `ViewRef`s.\n      // This ensures the view container length is updated before calling\n      // `destroyLView`, which could recursively call view container methods that\n      // rely on an accurate container length.\n      // (e.g. a method on this view container being called by a child directive's OnDestroy\n      // lifecycle hook)\n      removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx);\n      destroyLView(detachedView[TVIEW], detachedView);\n    }\n  }\n  detach(index) {\n    const adjustedIdx = this._adjustIndex(index, -1);\n    const view = detachView(this._lContainer, adjustedIdx);\n    const wasDetached = view && removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx) != null;\n    return wasDetached ? new ViewRef(view) : null;\n  }\n  _adjustIndex(index, shift = 0) {\n    if (index == null) {\n      return this.length + shift;\n    }\n    if (ngDevMode) {\n      assertGreaterThan(index, -1, `ViewRef index must be positive, got ${index}`);\n      // +1 because it's legal to insert at the end.\n      assertLessThan(index, this.length + 1 + shift, 'index');\n    }\n    return index;\n  }\n};\nfunction getViewRefs(lContainer) {\n  return lContainer[VIEW_REFS];\n}\nfunction getOrCreateViewRefs(lContainer) {\n  return lContainer[VIEW_REFS] || (lContainer[VIEW_REFS] = []);\n}\n/**\n * Creates a ViewContainerRef and stores it on the injector.\n *\n * @param hostTNode The node that is requesting a ViewContainerRef\n * @param hostLView The view to which the node belongs\n * @returns The ViewContainerRef instance to use\n */\nfunction createContainerRef(hostTNode, hostLView) {\n  ngDevMode && assertTNodeType(hostTNode, 12 /* TNodeType.AnyContainer */ | 3 /* TNodeType.AnyRNode */);\n  let lContainer;\n  const slotValue = hostLView[hostTNode.index];\n  if (isLContainer(slotValue)) {\n    // If the host is a container, we don't need to create a new LContainer\n    lContainer = slotValue;\n  } else {\n    // An LContainer anchor can not be `null`, but we set it here temporarily\n    // and update to the actual value later in this function (see\n    // `_locateOrCreateAnchorNode`).\n    lContainer = createLContainer(slotValue, hostLView, null, hostTNode);\n    hostLView[hostTNode.index] = lContainer;\n    addToViewTree(hostLView, lContainer);\n  }\n  _locateOrCreateAnchorNode(lContainer, hostLView, hostTNode, slotValue);\n  return new R3ViewContainerRef(lContainer, hostTNode, hostLView);\n}\n/**\n * Creates and inserts a comment node that acts as an anchor for a view container.\n *\n * If the host is a regular element, we have to insert a comment node manually which will\n * be used as an anchor when inserting elements. In this specific case we use low-level DOM\n * manipulation to insert it.\n */\nfunction insertAnchorNode(hostLView, hostTNode) {\n  const renderer = hostLView[RENDERER];\n  ngDevMode && ngDevMode.rendererCreateComment++;\n  const commentNode = renderer.createComment(ngDevMode ? 'container' : '');\n  const hostNative = getNativeByTNode(hostTNode, hostLView);\n  const parentOfHostNative = nativeParentNode(renderer, hostNative);\n  nativeInsertBefore(renderer, parentOfHostNative, commentNode, nativeNextSibling(renderer, hostNative), false);\n  return commentNode;\n}\nlet _locateOrCreateAnchorNode = createAnchorNode;\n/**\n * Regular creation mode: an anchor is created and\n * assigned to the `lContainer[NATIVE]` slot.\n */\nfunction createAnchorNode(lContainer, hostLView, hostTNode, slotValue) {\n  // We already have a native element (anchor) set, return.\n  if (lContainer[NATIVE]) return;\n  let commentNode;\n  // If the host is an element container, the native host element is guaranteed to be a\n  // comment and we can reuse that comment as anchor element for the new LContainer.\n  // The comment node in question is already part of the DOM structure so we don't need to append\n  // it again.\n  if (hostTNode.type & 8 /* TNodeType.ElementContainer */) {\n    commentNode = unwrapRNode(slotValue);\n  } else {\n    commentNode = insertAnchorNode(hostLView, hostTNode);\n  }\n  lContainer[NATIVE] = commentNode;\n}\n/**\n * Hydration logic that looks up:\n *  - an anchor node in the DOM and stores the node in `lContainer[NATIVE]`\n *  - all dehydrated views in this container and puts them into `lContainer[DEHYDRATED_VIEWS]`\n */\nfunction locateOrCreateAnchorNode(lContainer, hostLView, hostTNode, slotValue) {\n  // We already have a native element (anchor) set and the process\n  // of finding dehydrated views happened (so the `lContainer[DEHYDRATED_VIEWS]`\n  // is not null), exit early.\n  if (lContainer[NATIVE] && lContainer[DEHYDRATED_VIEWS]) return;\n  const hydrationInfo = hostLView[HYDRATION];\n  const noOffsetIndex = hostTNode.index - HEADER_OFFSET;\n  // TODO(akushnir): this should really be a single condition, refactor the code\n  // to use `hasInSkipHydrationBlockFlag` logic inside `isInSkipHydrationBlock`.\n  const skipHydration = isInSkipHydrationBlock(hostTNode) || hasInSkipHydrationBlockFlag(hostTNode);\n  const isNodeCreationMode = !hydrationInfo || skipHydration || isDisconnectedNode(hydrationInfo, noOffsetIndex);\n  // Regular creation mode.\n  if (isNodeCreationMode) {\n    return createAnchorNode(lContainer, hostLView, hostTNode, slotValue);\n  }\n  // Hydration mode, looking up an anchor node and dehydrated views in DOM.\n  const currentRNode = getSegmentHead(hydrationInfo, noOffsetIndex);\n  const serializedViews = hydrationInfo.data[CONTAINERS]?.[noOffsetIndex];\n  ngDevMode && assertDefined(serializedViews, 'Unexpected state: no hydration info available for a given TNode, ' + 'which represents a view container.');\n  const [commentNode, dehydratedViews] = locateDehydratedViewsInContainer(currentRNode, serializedViews);\n  if (ngDevMode) {\n    validateMatchingNode(commentNode, Node.COMMENT_NODE, null, hostLView, hostTNode, true);\n    // Do not throw in case this node is already claimed (thus `false` as a second\n    // argument). If this container is created based on an `<ng-template>`, the comment\n    // node would be already claimed from the `template` instruction. If an element acts\n    // as an anchor (e.g. <div #vcRef>), a separate comment node would be created/located,\n    // so we need to claim it here.\n    markRNodeAsClaimedByHydration(commentNode, false);\n  }\n  lContainer[NATIVE] = commentNode;\n  lContainer[DEHYDRATED_VIEWS] = dehydratedViews;\n}\nfunction enableLocateOrCreateContainerRefImpl() {\n  _locateOrCreateAnchorNode = locateOrCreateAnchorNode;\n}\nclass LQuery_ {\n  constructor(queryList) {\n    this.queryList = queryList;\n    this.matches = null;\n  }\n  clone() {\n    return new LQuery_(this.queryList);\n  }\n  setDirty() {\n    this.queryList.setDirty();\n  }\n}\nclass LQueries_ {\n  constructor(queries = []) {\n    this.queries = queries;\n  }\n  createEmbeddedView(tView) {\n    const tQueries = tView.queries;\n    if (tQueries !== null) {\n      const noOfInheritedQueries = tView.contentQueries !== null ? tView.contentQueries[0] : tQueries.length;\n      const viewLQueries = [];\n      // An embedded view has queries propagated from a declaration view at the beginning of the\n      // TQueries collection and up until a first content query declared in the embedded view. Only\n      // propagated LQueries are created at this point (LQuery corresponding to declared content\n      // queries will be instantiated from the content query instructions for each directive).\n      for (let i = 0; i < noOfInheritedQueries; i++) {\n        const tQuery = tQueries.getByIndex(i);\n        const parentLQuery = this.queries[tQuery.indexInDeclarationView];\n        viewLQueries.push(parentLQuery.clone());\n      }\n      return new LQueries_(viewLQueries);\n    }\n    return null;\n  }\n  insertView(tView) {\n    this.dirtyQueriesWithMatches(tView);\n  }\n  detachView(tView) {\n    this.dirtyQueriesWithMatches(tView);\n  }\n  dirtyQueriesWithMatches(tView) {\n    for (let i = 0; i < this.queries.length; i++) {\n      if (getTQuery(tView, i).matches !== null) {\n        this.queries[i].setDirty();\n      }\n    }\n  }\n}\nclass TQueryMetadata_ {\n  constructor(predicate, flags, read = null) {\n    this.predicate = predicate;\n    this.flags = flags;\n    this.read = read;\n  }\n}\nclass TQueries_ {\n  constructor(queries = []) {\n    this.queries = queries;\n  }\n  elementStart(tView, tNode) {\n    ngDevMode && assertFirstCreatePass(tView, 'Queries should collect results on the first template pass only');\n    for (let i = 0; i < this.queries.length; i++) {\n      this.queries[i].elementStart(tView, tNode);\n    }\n  }\n  elementEnd(tNode) {\n    for (let i = 0; i < this.queries.length; i++) {\n      this.queries[i].elementEnd(tNode);\n    }\n  }\n  embeddedTView(tNode) {\n    let queriesForTemplateRef = null;\n    for (let i = 0; i < this.length; i++) {\n      const childQueryIndex = queriesForTemplateRef !== null ? queriesForTemplateRef.length : 0;\n      const tqueryClone = this.getByIndex(i).embeddedTView(tNode, childQueryIndex);\n      if (tqueryClone) {\n        tqueryClone.indexInDeclarationView = i;\n        if (queriesForTemplateRef !== null) {\n          queriesForTemplateRef.push(tqueryClone);\n        } else {\n          queriesForTemplateRef = [tqueryClone];\n        }\n      }\n    }\n    return queriesForTemplateRef !== null ? new TQueries_(queriesForTemplateRef) : null;\n  }\n  template(tView, tNode) {\n    ngDevMode && assertFirstCreatePass(tView, 'Queries should collect results on the first template pass only');\n    for (let i = 0; i < this.queries.length; i++) {\n      this.queries[i].template(tView, tNode);\n    }\n  }\n  getByIndex(index) {\n    ngDevMode && assertIndexInRange(this.queries, index);\n    return this.queries[index];\n  }\n  get length() {\n    return this.queries.length;\n  }\n  track(tquery) {\n    this.queries.push(tquery);\n  }\n}\nclass TQuery_ {\n  constructor(metadata, nodeIndex = -1) {\n    this.metadata = metadata;\n    this.matches = null;\n    this.indexInDeclarationView = -1;\n    this.crossesNgTemplate = false;\n    /**\n     * A flag indicating if a given query still applies to nodes it is crossing. We use this flag\n     * (alongside with _declarationNodeIndex) to know when to stop applying content queries to\n     * elements in a template.\n     */\n    this._appliesToNextNode = true;\n    this._declarationNodeIndex = nodeIndex;\n  }\n  elementStart(tView, tNode) {\n    if (this.isApplyingToNode(tNode)) {\n      this.matchTNode(tView, tNode);\n    }\n  }\n  elementEnd(tNode) {\n    if (this._declarationNodeIndex === tNode.index) {\n      this._appliesToNextNode = false;\n    }\n  }\n  template(tView, tNode) {\n    this.elementStart(tView, tNode);\n  }\n  embeddedTView(tNode, childQueryIndex) {\n    if (this.isApplyingToNode(tNode)) {\n      this.crossesNgTemplate = true;\n      // A marker indicating a `<ng-template>` element (a placeholder for query results from\n      // embedded views created based on this `<ng-template>`).\n      this.addMatch(-tNode.index, childQueryIndex);\n      return new TQuery_(this.metadata);\n    }\n    return null;\n  }\n  isApplyingToNode(tNode) {\n    if (this._appliesToNextNode && (this.metadata.flags & 1 /* QueryFlags.descendants */) !== 1 /* QueryFlags.descendants */) {\n      const declarationNodeIdx = this._declarationNodeIndex;\n      let parent = tNode.parent;\n      // Determine if a given TNode is a \"direct\" child of a node on which a content query was\n      // declared (only direct children of query's host node can match with the descendants: false\n      // option). There are 3 main use-case / conditions to consider here:\n      // - <needs-target><i #target></i></needs-target>: here <i #target> parent node is a query\n      // host node;\n      // - <needs-target><ng-template [ngIf]=\"true\"><i #target></i></ng-template></needs-target>:\n      // here <i #target> parent node is null;\n      // - <needs-target><ng-container><i #target></i></ng-container></needs-target>: here we need\n      // to go past `<ng-container>` to determine <i #target> parent node (but we shouldn't traverse\n      // up past the query's host node!).\n      while (parent !== null && parent.type & 8 /* TNodeType.ElementContainer */ && parent.index !== declarationNodeIdx) {\n        parent = parent.parent;\n      }\n      return declarationNodeIdx === (parent !== null ? parent.index : -1);\n    }\n    return this._appliesToNextNode;\n  }\n  matchTNode(tView, tNode) {\n    const predicate = this.metadata.predicate;\n    if (Array.isArray(predicate)) {\n      for (let i = 0; i < predicate.length; i++) {\n        const name = predicate[i];\n        this.matchTNodeWithReadOption(tView, tNode, getIdxOfMatchingSelector(tNode, name));\n        // Also try matching the name to a provider since strings can be used as DI tokens too.\n        this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, name, false, false));\n      }\n    } else {\n      if (predicate === TemplateRef) {\n        if (tNode.type & 4 /* TNodeType.Container */) {\n          this.matchTNodeWithReadOption(tView, tNode, -1);\n        }\n      } else {\n        this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, predicate, false, false));\n      }\n    }\n  }\n  matchTNodeWithReadOption(tView, tNode, nodeMatchIdx) {\n    if (nodeMatchIdx !== null) {\n      const read = this.metadata.read;\n      if (read !== null) {\n        if (read === ElementRef || read === ViewContainerRef || read === TemplateRef && tNode.type & 4 /* TNodeType.Container */) {\n          this.addMatch(tNode.index, -2);\n        } else {\n          const directiveOrProviderIdx = locateDirectiveOrProvider(tNode, tView, read, false, false);\n          if (directiveOrProviderIdx !== null) {\n            this.addMatch(tNode.index, directiveOrProviderIdx);\n          }\n        }\n      } else {\n        this.addMatch(tNode.index, nodeMatchIdx);\n      }\n    }\n  }\n  addMatch(tNodeIdx, matchIdx) {\n    if (this.matches === null) {\n      this.matches = [tNodeIdx, matchIdx];\n    } else {\n      this.matches.push(tNodeIdx, matchIdx);\n    }\n  }\n}\n/**\n * Iterates over local names for a given node and returns directive index\n * (or -1 if a local name points to an element).\n *\n * @param tNode static data of a node to check\n * @param selector selector to match\n * @returns directive index, -1 or null if a selector didn't match any of the local names\n */\nfunction getIdxOfMatchingSelector(tNode, selector) {\n  const localNames = tNode.localNames;\n  if (localNames !== null) {\n    for (let i = 0; i < localNames.length; i += 2) {\n      if (localNames[i] === selector) {\n        return localNames[i + 1];\n      }\n    }\n  }\n  return null;\n}\nfunction createResultByTNodeType(tNode, currentView) {\n  if (tNode.type & (3 /* TNodeType.AnyRNode */ | 8 /* TNodeType.ElementContainer */)) {\n    return createElementRef(tNode, currentView);\n  } else if (tNode.type & 4 /* TNodeType.Container */) {\n    return createTemplateRef(tNode, currentView);\n  }\n  return null;\n}\nfunction createResultForNode(lView, tNode, matchingIdx, read) {\n  if (matchingIdx === -1) {\n    // if read token and / or strategy is not specified, detect it using appropriate tNode type\n    return createResultByTNodeType(tNode, lView);\n  } else if (matchingIdx === -2) {\n    // read a special token from a node injector\n    return createSpecialToken(lView, tNode, read);\n  } else {\n    // read a token\n    return getNodeInjectable(lView, lView[TVIEW], matchingIdx, tNode);\n  }\n}\nfunction createSpecialToken(lView, tNode, read) {\n  if (read === ElementRef) {\n    return createElementRef(tNode, lView);\n  } else if (read === TemplateRef) {\n    return createTemplateRef(tNode, lView);\n  } else if (read === ViewContainerRef) {\n    ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 12 /* TNodeType.AnyContainer */);\n    return createContainerRef(tNode, lView);\n  } else {\n    ngDevMode && throwError(`Special token to read should be one of ElementRef, TemplateRef or ViewContainerRef but got ${stringify(read)}.`);\n  }\n}\n/**\n * A helper function that creates query results for a given view. This function is meant to do the\n * processing once and only once for a given view instance (a set of results for a given view\n * doesn't change).\n */\nfunction materializeViewResults(tView, lView, tQuery, queryIndex) {\n  const lQuery = lView[QUERIES].queries[queryIndex];\n  if (lQuery.matches === null) {\n    const tViewData = tView.data;\n    const tQueryMatches = tQuery.matches;\n    const result = [];\n    for (let i = 0; i < tQueryMatches.length; i += 2) {\n      const matchedNodeIdx = tQueryMatches[i];\n      if (matchedNodeIdx < 0) {\n        // we at the <ng-template> marker which might have results in views created based on this\n        // <ng-template> - those results will be in separate views though, so here we just leave\n        // null as a placeholder\n        result.push(null);\n      } else {\n        ngDevMode && assertIndexInRange(tViewData, matchedNodeIdx);\n        const tNode = tViewData[matchedNodeIdx];\n        result.push(createResultForNode(lView, tNode, tQueryMatches[i + 1], tQuery.metadata.read));\n      }\n    }\n    lQuery.matches = result;\n  }\n  return lQuery.matches;\n}\n/**\n * A helper function that collects (already materialized) query results from a tree of views,\n * starting with a provided LView.\n */\nfunction collectQueryResults(tView, lView, queryIndex, result) {\n  const tQuery = tView.queries.getByIndex(queryIndex);\n  const tQueryMatches = tQuery.matches;\n  if (tQueryMatches !== null) {\n    const lViewResults = materializeViewResults(tView, lView, tQuery, queryIndex);\n    for (let i = 0; i < tQueryMatches.length; i += 2) {\n      const tNodeIdx = tQueryMatches[i];\n      if (tNodeIdx > 0) {\n        result.push(lViewResults[i / 2]);\n      } else {\n        const childQueryIndex = tQueryMatches[i + 1];\n        const declarationLContainer = lView[-tNodeIdx];\n        ngDevMode && assertLContainer(declarationLContainer);\n        // collect matches for views inserted in this container\n        for (let i = CONTAINER_HEADER_OFFSET; i < declarationLContainer.length; i++) {\n          const embeddedLView = declarationLContainer[i];\n          if (embeddedLView[DECLARATION_LCONTAINER] === embeddedLView[PARENT]) {\n            collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);\n          }\n        }\n        // collect matches for views created from this declaration container and inserted into\n        // different containers\n        if (declarationLContainer[MOVED_VIEWS] !== null) {\n          const embeddedLViews = declarationLContainer[MOVED_VIEWS];\n          for (let i = 0; i < embeddedLViews.length; i++) {\n            const embeddedLView = embeddedLViews[i];\n            collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);\n          }\n        }\n      }\n    }\n  }\n  return result;\n}\n/**\n * Refreshes a query by combining matches from all active views and removing matches from deleted\n * views.\n *\n * @returns `true` if a query got dirty during change detection or if this is a static query\n * resolving in creation mode, `false` otherwise.\n *\n * @codeGenApi\n */\nfunction ɵɵqueryRefresh(queryList) {\n  const lView = getLView();\n  const tView = getTView();\n  const queryIndex = getCurrentQueryIndex();\n  setCurrentQueryIndex(queryIndex + 1);\n  const tQuery = getTQuery(tView, queryIndex);\n  if (queryList.dirty && isCreationMode(lView) === ((tQuery.metadata.flags & 2 /* QueryFlags.isStatic */) === 2 /* QueryFlags.isStatic */)) {\n    if (tQuery.matches === null) {\n      queryList.reset([]);\n    } else {\n      const result = tQuery.crossesNgTemplate ? collectQueryResults(tView, lView, queryIndex, []) : materializeViewResults(tView, lView, tQuery, queryIndex);\n      queryList.reset(result, unwrapElementRef);\n      queryList.notifyOnChanges();\n    }\n    return true;\n  }\n  return false;\n}\n/**\n * Creates new QueryList, stores the reference in LView and returns QueryList.\n *\n * @param predicate The type for which the query will search\n * @param flags Flags associated with the query\n * @param read What to save in the query\n *\n * @codeGenApi\n */\nfunction ɵɵviewQuery(predicate, flags, read) {\n  ngDevMode && assertNumber(flags, 'Expecting flags');\n  const tView = getTView();\n  if (tView.firstCreatePass) {\n    createTQuery(tView, new TQueryMetadata_(predicate, flags, read), -1);\n    if ((flags & 2 /* QueryFlags.isStatic */) === 2 /* QueryFlags.isStatic */) {\n      tView.staticViewQueries = true;\n    }\n  }\n  createLQuery(tView, getLView(), flags);\n}\n/**\n * Registers a QueryList, associated with a content query, for later refresh (part of a view\n * refresh).\n *\n * @param directiveIndex Current directive index\n * @param predicate The type for which the query will search\n * @param flags Flags associated with the query\n * @param read What to save in the query\n * @returns QueryList<T>\n *\n * @codeGenApi\n */\nfunction ɵɵcontentQuery(directiveIndex, predicate, flags, read) {\n  ngDevMode && assertNumber(flags, 'Expecting flags');\n  const tView = getTView();\n  if (tView.firstCreatePass) {\n    const tNode = getCurrentTNode();\n    createTQuery(tView, new TQueryMetadata_(predicate, flags, read), tNode.index);\n    saveContentQueryAndDirectiveIndex(tView, directiveIndex);\n    if ((flags & 2 /* QueryFlags.isStatic */) === 2 /* QueryFlags.isStatic */) {\n      tView.staticContentQueries = true;\n    }\n  }\n  createLQuery(tView, getLView(), flags);\n}\n/**\n * Loads a QueryList corresponding to the current view or content query.\n *\n * @codeGenApi\n */\nfunction ɵɵloadQuery() {\n  return loadQueryInternal(getLView(), getCurrentQueryIndex());\n}\nfunction loadQueryInternal(lView, queryIndex) {\n  ngDevMode && assertDefined(lView[QUERIES], 'LQueries should be defined when trying to load a query');\n  ngDevMode && assertIndexInRange(lView[QUERIES].queries, queryIndex);\n  return lView[QUERIES].queries[queryIndex].queryList;\n}\nfunction createLQuery(tView, lView, flags) {\n  const queryList = new QueryList((flags & 4 /* QueryFlags.emitDistinctChangesOnly */) === 4 /* QueryFlags.emitDistinctChangesOnly */);\n  storeCleanupWithContext(tView, lView, queryList, queryList.destroy);\n  if (lView[QUERIES] === null) lView[QUERIES] = new LQueries_();\n  lView[QUERIES].queries.push(new LQuery_(queryList));\n}\nfunction createTQuery(tView, metadata, nodeIndex) {\n  if (tView.queries === null) tView.queries = new TQueries_();\n  tView.queries.track(new TQuery_(metadata, nodeIndex));\n}\nfunction saveContentQueryAndDirectiveIndex(tView, directiveIndex) {\n  const tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);\n  const lastSavedDirectiveIndex = tViewContentQueries.length ? tViewContentQueries[tViewContentQueries.length - 1] : -1;\n  if (directiveIndex !== lastSavedDirectiveIndex) {\n    tViewContentQueries.push(tView.queries.length - 1, directiveIndex);\n  }\n}\nfunction getTQuery(tView, index) {\n  ngDevMode && assertDefined(tView.queries, 'TQueries must be defined to retrieve a TQuery');\n  return tView.queries.getByIndex(index);\n}\n\n/**\n * Retrieves `TemplateRef` instance from `Injector` when a local reference is placed on the\n * `<ng-template>` element.\n *\n * @codeGenApi\n */\nfunction ɵɵtemplateRefExtractor(tNode, lView) {\n  return createTemplateRef(tNode, lView);\n}\n\n/**\n * A mapping of the @angular/core API surface used in generated expressions to the actual symbols.\n *\n * This should be kept up to date with the public exports of @angular/core.\n */\nconst angularCoreEnv = (() => ({\n  'ɵɵattribute': ɵɵattribute,\n  'ɵɵattributeInterpolate1': ɵɵattributeInterpolate1,\n  'ɵɵattributeInterpolate2': ɵɵattributeInterpolate2,\n  'ɵɵattributeInterpolate3': ɵɵattributeInterpolate3,\n  'ɵɵattributeInterpolate4': ɵɵattributeInterpolate4,\n  'ɵɵattributeInterpolate5': ɵɵattributeInterpolate5,\n  'ɵɵattributeInterpolate6': ɵɵattributeInterpolate6,\n  'ɵɵattributeInterpolate7': ɵɵattributeInterpolate7,\n  'ɵɵattributeInterpolate8': ɵɵattributeInterpolate8,\n  'ɵɵattributeInterpolateV': ɵɵattributeInterpolateV,\n  'ɵɵdefineComponent': ɵɵdefineComponent,\n  'ɵɵdefineDirective': ɵɵdefineDirective,\n  'ɵɵdefineInjectable': ɵɵdefineInjectable,\n  'ɵɵdefineInjector': ɵɵdefineInjector,\n  'ɵɵdefineNgModule': ɵɵdefineNgModule,\n  'ɵɵdefinePipe': ɵɵdefinePipe,\n  'ɵɵdirectiveInject': ɵɵdirectiveInject,\n  'ɵɵgetInheritedFactory': ɵɵgetInheritedFactory,\n  'ɵɵinject': ɵɵinject,\n  'ɵɵinjectAttribute': ɵɵinjectAttribute,\n  'ɵɵinvalidFactory': ɵɵinvalidFactory,\n  'ɵɵinvalidFactoryDep': ɵɵinvalidFactoryDep,\n  'ɵɵtemplateRefExtractor': ɵɵtemplateRefExtractor,\n  'ɵɵresetView': ɵɵresetView,\n  'ɵɵHostDirectivesFeature': ɵɵHostDirectivesFeature,\n  'ɵɵNgOnChangesFeature': ɵɵNgOnChangesFeature,\n  'ɵɵProvidersFeature': ɵɵProvidersFeature,\n  'ɵɵCopyDefinitionFeature': ɵɵCopyDefinitionFeature,\n  'ɵɵInheritDefinitionFeature': ɵɵInheritDefinitionFeature,\n  'ɵɵInputTransformsFeature': ɵɵInputTransformsFeature,\n  'ɵɵStandaloneFeature': ɵɵStandaloneFeature,\n  'ɵɵnextContext': ɵɵnextContext,\n  'ɵɵnamespaceHTML': ɵɵnamespaceHTML,\n  'ɵɵnamespaceMathML': ɵɵnamespaceMathML,\n  'ɵɵnamespaceSVG': ɵɵnamespaceSVG,\n  'ɵɵenableBindings': ɵɵenableBindings,\n  'ɵɵdisableBindings': ɵɵdisableBindings,\n  'ɵɵelementStart': ɵɵelementStart,\n  'ɵɵelementEnd': ɵɵelementEnd,\n  'ɵɵelement': ɵɵelement,\n  'ɵɵelementContainerStart': ɵɵelementContainerStart,\n  'ɵɵelementContainerEnd': ɵɵelementContainerEnd,\n  'ɵɵelementContainer': ɵɵelementContainer,\n  'ɵɵpureFunction0': ɵɵpureFunction0,\n  'ɵɵpureFunction1': ɵɵpureFunction1,\n  'ɵɵpureFunction2': ɵɵpureFunction2,\n  'ɵɵpureFunction3': ɵɵpureFunction3,\n  'ɵɵpureFunction4': ɵɵpureFunction4,\n  'ɵɵpureFunction5': ɵɵpureFunction5,\n  'ɵɵpureFunction6': ɵɵpureFunction6,\n  'ɵɵpureFunction7': ɵɵpureFunction7,\n  'ɵɵpureFunction8': ɵɵpureFunction8,\n  'ɵɵpureFunctionV': ɵɵpureFunctionV,\n  'ɵɵgetCurrentView': ɵɵgetCurrentView,\n  'ɵɵrestoreView': ɵɵrestoreView,\n  'ɵɵlistener': ɵɵlistener,\n  'ɵɵprojection': ɵɵprojection,\n  'ɵɵsyntheticHostProperty': ɵɵsyntheticHostProperty,\n  'ɵɵsyntheticHostListener': ɵɵsyntheticHostListener,\n  'ɵɵpipeBind1': ɵɵpipeBind1,\n  'ɵɵpipeBind2': ɵɵpipeBind2,\n  'ɵɵpipeBind3': ɵɵpipeBind3,\n  'ɵɵpipeBind4': ɵɵpipeBind4,\n  'ɵɵpipeBindV': ɵɵpipeBindV,\n  'ɵɵprojectionDef': ɵɵprojectionDef,\n  'ɵɵhostProperty': ɵɵhostProperty,\n  'ɵɵproperty': ɵɵproperty,\n  'ɵɵpropertyInterpolate': ɵɵpropertyInterpolate,\n  'ɵɵpropertyInterpolate1': ɵɵpropertyInterpolate1,\n  'ɵɵpropertyInterpolate2': ɵɵpropertyInterpolate2,\n  'ɵɵpropertyInterpolate3': ɵɵpropertyInterpolate3,\n  'ɵɵpropertyInterpolate4': ɵɵpropertyInterpolate4,\n  'ɵɵpropertyInterpolate5': ɵɵpropertyInterpolate5,\n  'ɵɵpropertyInterpolate6': ɵɵpropertyInterpolate6,\n  'ɵɵpropertyInterpolate7': ɵɵpropertyInterpolate7,\n  'ɵɵpropertyInterpolate8': ɵɵpropertyInterpolate8,\n  'ɵɵpropertyInterpolateV': ɵɵpropertyInterpolateV,\n  'ɵɵpipe': ɵɵpipe,\n  'ɵɵqueryRefresh': ɵɵqueryRefresh,\n  'ɵɵviewQuery': ɵɵviewQuery,\n  'ɵɵloadQuery': ɵɵloadQuery,\n  'ɵɵcontentQuery': ɵɵcontentQuery,\n  'ɵɵreference': ɵɵreference,\n  'ɵɵclassMap': ɵɵclassMap,\n  'ɵɵclassMapInterpolate1': ɵɵclassMapInterpolate1,\n  'ɵɵclassMapInterpolate2': ɵɵclassMapInterpolate2,\n  'ɵɵclassMapInterpolate3': ɵɵclassMapInterpolate3,\n  'ɵɵclassMapInterpolate4': ɵɵclassMapInterpolate4,\n  'ɵɵclassMapInterpolate5': ɵɵclassMapInterpolate5,\n  'ɵɵclassMapInterpolate6': ɵɵclassMapInterpolate6,\n  'ɵɵclassMapInterpolate7': ɵɵclassMapInterpolate7,\n  'ɵɵclassMapInterpolate8': ɵɵclassMapInterpolate8,\n  'ɵɵclassMapInterpolateV': ɵɵclassMapInterpolateV,\n  'ɵɵstyleMap': ɵɵstyleMap,\n  'ɵɵstyleMapInterpolate1': ɵɵstyleMapInterpolate1,\n  'ɵɵstyleMapInterpolate2': ɵɵstyleMapInterpolate2,\n  'ɵɵstyleMapInterpolate3': ɵɵstyleMapInterpolate3,\n  'ɵɵstyleMapInterpolate4': ɵɵstyleMapInterpolate4,\n  'ɵɵstyleMapInterpolate5': ɵɵstyleMapInterpolate5,\n  'ɵɵstyleMapInterpolate6': ɵɵstyleMapInterpolate6,\n  'ɵɵstyleMapInterpolate7': ɵɵstyleMapInterpolate7,\n  'ɵɵstyleMapInterpolate8': ɵɵstyleMapInterpolate8,\n  'ɵɵstyleMapInterpolateV': ɵɵstyleMapInterpolateV,\n  'ɵɵstyleProp': ɵɵstyleProp,\n  'ɵɵstylePropInterpolate1': ɵɵstylePropInterpolate1,\n  'ɵɵstylePropInterpolate2': ɵɵstylePropInterpolate2,\n  'ɵɵstylePropInterpolate3': ɵɵstylePropInterpolate3,\n  'ɵɵstylePropInterpolate4': ɵɵstylePropInterpolate4,\n  'ɵɵstylePropInterpolate5': ɵɵstylePropInterpolate5,\n  'ɵɵstylePropInterpolate6': ɵɵstylePropInterpolate6,\n  'ɵɵstylePropInterpolate7': ɵɵstylePropInterpolate7,\n  'ɵɵstylePropInterpolate8': ɵɵstylePropInterpolate8,\n  'ɵɵstylePropInterpolateV': ɵɵstylePropInterpolateV,\n  'ɵɵclassProp': ɵɵclassProp,\n  'ɵɵadvance': ɵɵadvance,\n  'ɵɵtemplate': ɵɵtemplate,\n  'ɵɵdefer': ɵɵdefer,\n  'ɵɵtext': ɵɵtext,\n  'ɵɵtextInterpolate': ɵɵtextInterpolate,\n  'ɵɵtextInterpolate1': ɵɵtextInterpolate1,\n  'ɵɵtextInterpolate2': ɵɵtextInterpolate2,\n  'ɵɵtextInterpolate3': ɵɵtextInterpolate3,\n  'ɵɵtextInterpolate4': ɵɵtextInterpolate4,\n  'ɵɵtextInterpolate5': ɵɵtextInterpolate5,\n  'ɵɵtextInterpolate6': ɵɵtextInterpolate6,\n  'ɵɵtextInterpolate7': ɵɵtextInterpolate7,\n  'ɵɵtextInterpolate8': ɵɵtextInterpolate8,\n  'ɵɵtextInterpolateV': ɵɵtextInterpolateV,\n  'ɵɵi18n': ɵɵi18n,\n  'ɵɵi18nAttributes': ɵɵi18nAttributes,\n  'ɵɵi18nExp': ɵɵi18nExp,\n  'ɵɵi18nStart': ɵɵi18nStart,\n  'ɵɵi18nEnd': ɵɵi18nEnd,\n  'ɵɵi18nApply': ɵɵi18nApply,\n  'ɵɵi18nPostprocess': ɵɵi18nPostprocess,\n  'ɵɵresolveWindow': ɵɵresolveWindow,\n  'ɵɵresolveDocument': ɵɵresolveDocument,\n  'ɵɵresolveBody': ɵɵresolveBody,\n  'ɵɵsetComponentScope': ɵɵsetComponentScope,\n  'ɵɵsetNgModuleScope': ɵɵsetNgModuleScope,\n  'ɵɵregisterNgModuleType': registerNgModuleType,\n  'ɵɵsanitizeHtml': ɵɵsanitizeHtml,\n  'ɵɵsanitizeStyle': ɵɵsanitizeStyle,\n  'ɵɵsanitizeResourceUrl': ɵɵsanitizeResourceUrl,\n  'ɵɵsanitizeScript': ɵɵsanitizeScript,\n  'ɵɵsanitizeUrl': ɵɵsanitizeUrl,\n  'ɵɵsanitizeUrlOrResourceUrl': ɵɵsanitizeUrlOrResourceUrl,\n  'ɵɵtrustConstantHtml': ɵɵtrustConstantHtml,\n  'ɵɵtrustConstantResourceUrl': ɵɵtrustConstantResourceUrl,\n  'ɵɵvalidateIframeAttribute': ɵɵvalidateIframeAttribute,\n  'forwardRef': forwardRef,\n  'resolveForwardRef': resolveForwardRef\n}))();\nfunction patchModuleCompilation() {\n  // Does nothing, but exists as a target for patching.\n}\nfunction isModuleWithProviders$1(value) {\n  return value.ngModule !== undefined;\n}\nfunction isNgModule$1(value) {\n  return !!getNgModuleDef(value);\n}\nfunction isPipe(value) {\n  return !!getPipeDef$1(value);\n}\nfunction isDirective(value) {\n  return !!getDirectiveDef(value);\n}\nfunction isComponent(value) {\n  return !!getComponentDef$1(value);\n}\nconst moduleQueue = [];\n/**\n * Enqueues moduleDef to be checked later to see if scope can be set on its\n * component declarations.\n */\nfunction enqueueModuleForDelayedScoping(moduleType, ngModule) {\n  moduleQueue.push({\n    moduleType,\n    ngModule\n  });\n}\nlet flushingModuleQueue = false;\n/**\n * Loops over queued module definitions, if a given module definition has all of its\n * declarations resolved, it dequeues that module definition and sets the scope on\n * its declarations.\n */\nfunction flushModuleScopingQueueAsMuchAsPossible() {\n  if (!flushingModuleQueue) {\n    flushingModuleQueue = true;\n    try {\n      for (let i = moduleQueue.length - 1; i >= 0; i--) {\n        const {\n          moduleType,\n          ngModule\n        } = moduleQueue[i];\n        if (ngModule.declarations && ngModule.declarations.every(isResolvedDeclaration)) {\n          // dequeue\n          moduleQueue.splice(i, 1);\n          setScopeOnDeclaredComponents(moduleType, ngModule);\n        }\n      }\n    } finally {\n      flushingModuleQueue = false;\n    }\n  }\n}\n/**\n * Returns truthy if a declaration has resolved. If the declaration happens to be\n * an array of declarations, it will recurse to check each declaration in that array\n * (which may also be arrays).\n */\nfunction isResolvedDeclaration(declaration) {\n  if (Array.isArray(declaration)) {\n    return declaration.every(isResolvedDeclaration);\n  }\n  return !!resolveForwardRef(declaration);\n}\n/**\n * Compiles a module in JIT mode.\n *\n * This function automatically gets called when a class has a `@NgModule` decorator.\n */\nfunction compileNgModule(moduleType, ngModule = {}) {\n  patchModuleCompilation();\n  compileNgModuleDefs(moduleType, ngModule);\n  if (ngModule.id !== undefined) {\n    registerNgModuleType(moduleType, ngModule.id);\n  }\n  // Because we don't know if all declarations have resolved yet at the moment the\n  // NgModule decorator is executing, we're enqueueing the setting of module scope\n  // on its declarations to be run at a later time when all declarations for the module,\n  // including forward refs, have resolved.\n  enqueueModuleForDelayedScoping(moduleType, ngModule);\n}\n/**\n * Compiles and adds the `ɵmod`, `ɵfac` and `ɵinj` properties to the module class.\n *\n * It's possible to compile a module via this API which will allow duplicate declarations in its\n * root.\n */\nfunction compileNgModuleDefs(moduleType, ngModule, allowDuplicateDeclarationsInRoot = false) {\n  ngDevMode && assertDefined(moduleType, 'Required value moduleType');\n  ngDevMode && assertDefined(ngModule, 'Required value ngModule');\n  const declarations = flatten$1(ngModule.declarations || EMPTY_ARRAY);\n  let ngModuleDef = null;\n  Object.defineProperty(moduleType, NG_MOD_DEF, {\n    configurable: true,\n    get: () => {\n      if (ngModuleDef === null) {\n        if (ngDevMode && ngModule.imports && ngModule.imports.indexOf(moduleType) > -1) {\n          // We need to assert this immediately, because allowing it to continue will cause it to\n          // go into an infinite loop before we've reached the point where we throw all the errors.\n          throw new Error(`'${stringifyForError(moduleType)}' module can't import itself`);\n        }\n        const compiler = getCompilerFacade({\n          usage: 0 /* JitCompilerUsage.Decorator */,\n          kind: 'NgModule',\n          type: moduleType\n        });\n        ngModuleDef = compiler.compileNgModule(angularCoreEnv, `ng:///${moduleType.name}/ɵmod.js`, {\n          type: moduleType,\n          bootstrap: flatten$1(ngModule.bootstrap || EMPTY_ARRAY).map(resolveForwardRef),\n          declarations: declarations.map(resolveForwardRef),\n          imports: flatten$1(ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),\n          exports: flatten$1(ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),\n          schemas: ngModule.schemas ? flatten$1(ngModule.schemas) : null,\n          id: ngModule.id || null\n        });\n        // Set `schemas` on ngModuleDef to an empty array in JIT mode to indicate that runtime\n        // should verify that there are no unknown elements in a template. In AOT mode, that check\n        // happens at compile time and `schemas` information is not present on Component and Module\n        // defs after compilation (so the check doesn't happen the second time at runtime).\n        if (!ngModuleDef.schemas) {\n          ngModuleDef.schemas = [];\n        }\n      }\n      return ngModuleDef;\n    }\n  });\n  let ngFactoryDef = null;\n  Object.defineProperty(moduleType, NG_FACTORY_DEF, {\n    get: () => {\n      if (ngFactoryDef === null) {\n        const compiler = getCompilerFacade({\n          usage: 0 /* JitCompilerUsage.Decorator */,\n          kind: 'NgModule',\n          type: moduleType\n        });\n        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${moduleType.name}/ɵfac.js`, {\n          name: moduleType.name,\n          type: moduleType,\n          deps: reflectDependencies(moduleType),\n          target: compiler.FactoryTarget.NgModule,\n          typeArgumentCount: 0\n        });\n      }\n      return ngFactoryDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode\n  });\n  let ngInjectorDef = null;\n  Object.defineProperty(moduleType, NG_INJ_DEF, {\n    get: () => {\n      if (ngInjectorDef === null) {\n        ngDevMode && verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot);\n        const meta = {\n          name: moduleType.name,\n          type: moduleType,\n          providers: ngModule.providers || EMPTY_ARRAY,\n          imports: [(ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef), (ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef)]\n        };\n        const compiler = getCompilerFacade({\n          usage: 0 /* JitCompilerUsage.Decorator */,\n          kind: 'NgModule',\n          type: moduleType\n        });\n        ngInjectorDef = compiler.compileInjector(angularCoreEnv, `ng:///${moduleType.name}/ɵinj.js`, meta);\n      }\n      return ngInjectorDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode\n  });\n}\nfunction generateStandaloneInDeclarationsError(type, location) {\n  const prefix = `Unexpected \"${stringifyForError(type)}\" found in the \"declarations\" array of the`;\n  const suffix = `\"${stringifyForError(type)}\" is marked as standalone and can't be declared ` + 'in any NgModule - did you intend to import it instead (by adding it to the \"imports\" array)?';\n  return `${prefix} ${location}, ${suffix}`;\n}\nfunction verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot, importingModule) {\n  if (verifiedNgModule.get(moduleType)) return;\n  // skip verifications of standalone components, directives, and pipes\n  if (isStandalone(moduleType)) return;\n  verifiedNgModule.set(moduleType, true);\n  moduleType = resolveForwardRef(moduleType);\n  let ngModuleDef;\n  if (importingModule) {\n    ngModuleDef = getNgModuleDef(moduleType);\n    if (!ngModuleDef) {\n      throw new Error(`Unexpected value '${moduleType.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);\n    }\n  } else {\n    ngModuleDef = getNgModuleDef(moduleType, true);\n  }\n  const errors = [];\n  const declarations = maybeUnwrapFn$1(ngModuleDef.declarations);\n  const imports = maybeUnwrapFn$1(ngModuleDef.imports);\n  flatten$1(imports).map(unwrapModuleWithProvidersImports).forEach(modOrStandaloneCmpt => {\n    verifySemanticsOfNgModuleImport(modOrStandaloneCmpt, moduleType);\n    verifySemanticsOfNgModuleDef(modOrStandaloneCmpt, false, moduleType);\n  });\n  const exports = maybeUnwrapFn$1(ngModuleDef.exports);\n  declarations.forEach(verifyDeclarationsHaveDefinitions);\n  declarations.forEach(verifyDirectivesHaveSelector);\n  declarations.forEach(declarationType => verifyNotStandalone(declarationType, moduleType));\n  const combinedDeclarations = [...declarations.map(resolveForwardRef), ...flatten$1(imports.map(computeCombinedExports)).map(resolveForwardRef)];\n  exports.forEach(verifyExportsAreDeclaredOrReExported);\n  declarations.forEach(decl => verifyDeclarationIsUnique(decl, allowDuplicateDeclarationsInRoot));\n  const ngModule = getAnnotation(moduleType, 'NgModule');\n  if (ngModule) {\n    ngModule.imports && flatten$1(ngModule.imports).map(unwrapModuleWithProvidersImports).forEach(mod => {\n      verifySemanticsOfNgModuleImport(mod, moduleType);\n      verifySemanticsOfNgModuleDef(mod, false, moduleType);\n    });\n    ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyCorrectBootstrapType);\n    ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyComponentIsPartOfNgModule);\n  }\n  // Throw Error if any errors were detected.\n  if (errors.length) {\n    throw new Error(errors.join('\\n'));\n  }\n  ////////////////////////////////////////////////////////////////////////////////////////////////\n  function verifyDeclarationsHaveDefinitions(type) {\n    type = resolveForwardRef(type);\n    const def = getComponentDef$1(type) || getDirectiveDef(type) || getPipeDef$1(type);\n    if (!def) {\n      errors.push(`Unexpected value '${stringifyForError(type)}' declared by the module '${stringifyForError(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`);\n    }\n  }\n  function verifyDirectivesHaveSelector(type) {\n    type = resolveForwardRef(type);\n    const def = getDirectiveDef(type);\n    if (!getComponentDef$1(type) && def && def.selectors.length == 0) {\n      errors.push(`Directive ${stringifyForError(type)} has no selector, please add it!`);\n    }\n  }\n  function verifyNotStandalone(type, moduleType) {\n    type = resolveForwardRef(type);\n    const def = getComponentDef$1(type) || getDirectiveDef(type) || getPipeDef$1(type);\n    if (def?.standalone) {\n      const location = `\"${stringifyForError(moduleType)}\" NgModule`;\n      errors.push(generateStandaloneInDeclarationsError(type, location));\n    }\n  }\n  function verifyExportsAreDeclaredOrReExported(type) {\n    type = resolveForwardRef(type);\n    const kind = getComponentDef$1(type) && 'component' || getDirectiveDef(type) && 'directive' || getPipeDef$1(type) && 'pipe';\n    if (kind) {\n      // only checked if we are declared as Component, Directive, or Pipe\n      // Modules don't need to be declared or imported.\n      if (combinedDeclarations.lastIndexOf(type) === -1) {\n        // We are exporting something which we don't explicitly declare or import.\n        errors.push(`Can't export ${kind} ${stringifyForError(type)} from ${stringifyForError(moduleType)} as it was neither declared nor imported!`);\n      }\n    }\n  }\n  function verifyDeclarationIsUnique(type, suppressErrors) {\n    type = resolveForwardRef(type);\n    const existingModule = ownerNgModule.get(type);\n    if (existingModule && existingModule !== moduleType) {\n      if (!suppressErrors) {\n        const modules = [existingModule, moduleType].map(stringifyForError).sort();\n        errors.push(`Type ${stringifyForError(type)} is part of the declarations of 2 modules: ${modules[0]} and ${modules[1]}! ` + `Please consider moving ${stringifyForError(type)} to a higher module that imports ${modules[0]} and ${modules[1]}. ` + `You can also create a new NgModule that exports and includes ${stringifyForError(type)} then import that NgModule in ${modules[0]} and ${modules[1]}.`);\n      }\n    } else {\n      // Mark type as having owner.\n      ownerNgModule.set(type, moduleType);\n    }\n  }\n  function verifyComponentIsPartOfNgModule(type) {\n    type = resolveForwardRef(type);\n    const existingModule = ownerNgModule.get(type);\n    if (!existingModule && !isStandalone(type)) {\n      errors.push(`Component ${stringifyForError(type)} is not part of any NgModule or the module has not been imported into your module.`);\n    }\n  }\n  function verifyCorrectBootstrapType(type) {\n    type = resolveForwardRef(type);\n    if (!getComponentDef$1(type)) {\n      errors.push(`${stringifyForError(type)} cannot be used as an entry component.`);\n    }\n    if (isStandalone(type)) {\n      // Note: this error should be the same as the\n      // `NGMODULE_BOOTSTRAP_IS_STANDALONE` one in AOT compiler.\n      errors.push(`The \\`${stringifyForError(type)}\\` class is a standalone component, which can ` + `not be used in the \\`@NgModule.bootstrap\\` array. Use the \\`bootstrapApplication\\` ` + `function for bootstrap instead.`);\n    }\n  }\n  function verifySemanticsOfNgModuleImport(type, importingModule) {\n    type = resolveForwardRef(type);\n    const directiveDef = getComponentDef$1(type) || getDirectiveDef(type);\n    if (directiveDef !== null && !directiveDef.standalone) {\n      throw new Error(`Unexpected directive '${type.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);\n    }\n    const pipeDef = getPipeDef$1(type);\n    if (pipeDef !== null && !pipeDef.standalone) {\n      throw new Error(`Unexpected pipe '${type.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);\n    }\n  }\n}\nfunction unwrapModuleWithProvidersImports(typeOrWithProviders) {\n  typeOrWithProviders = resolveForwardRef(typeOrWithProviders);\n  return typeOrWithProviders.ngModule || typeOrWithProviders;\n}\nfunction getAnnotation(type, name) {\n  let annotation = null;\n  collect(type.__annotations__);\n  collect(type.decorators);\n  return annotation;\n  function collect(annotations) {\n    if (annotations) {\n      annotations.forEach(readAnnotation);\n    }\n  }\n  function readAnnotation(decorator) {\n    if (!annotation) {\n      const proto = Object.getPrototypeOf(decorator);\n      if (proto.ngMetadataName == name) {\n        annotation = decorator;\n      } else if (decorator.type) {\n        const proto = Object.getPrototypeOf(decorator.type);\n        if (proto.ngMetadataName == name) {\n          annotation = decorator.args[0];\n        }\n      }\n    }\n  }\n}\n/**\n * Keep track of compiled components. This is needed because in tests we often want to compile the\n * same component with more than one NgModule. This would cause an error unless we reset which\n * NgModule the component belongs to. We keep the list of compiled components here so that the\n * TestBed can reset it later.\n */\nlet ownerNgModule = new WeakMap();\nlet verifiedNgModule = new WeakMap();\nfunction resetCompiledComponents() {\n  ownerNgModule = new WeakMap();\n  verifiedNgModule = new WeakMap();\n  moduleQueue.length = 0;\n  GENERATED_COMP_IDS.clear();\n}\n/**\n * Computes the combined declarations of explicit declarations, as well as declarations inherited by\n * traversing the exports of imported modules.\n * @param type\n */\nfunction computeCombinedExports(type) {\n  type = resolveForwardRef(type);\n  const ngModuleDef = getNgModuleDef(type);\n  // a standalone component, directive or pipe\n  if (ngModuleDef === null) {\n    return [type];\n  }\n  return flatten$1(maybeUnwrapFn$1(ngModuleDef.exports).map(type => {\n    const ngModuleDef = getNgModuleDef(type);\n    if (ngModuleDef) {\n      verifySemanticsOfNgModuleDef(type, false);\n      return computeCombinedExports(type);\n    } else {\n      return type;\n    }\n  }));\n}\n/**\n * Some declared components may be compiled asynchronously, and thus may not have their\n * ɵcmp set yet. If this is the case, then a reference to the module is written into\n * the `ngSelectorScope` property of the declared type.\n */\nfunction setScopeOnDeclaredComponents(moduleType, ngModule) {\n  const declarations = flatten$1(ngModule.declarations || EMPTY_ARRAY);\n  const transitiveScopes = transitiveScopesFor(moduleType);\n  declarations.forEach(declaration => {\n    declaration = resolveForwardRef(declaration);\n    if (declaration.hasOwnProperty(NG_COMP_DEF)) {\n      // A `ɵcmp` field exists - go ahead and patch the component directly.\n      const component = declaration;\n      const componentDef = getComponentDef$1(component);\n      patchComponentDefWithScope(componentDef, transitiveScopes);\n    } else if (!declaration.hasOwnProperty(NG_DIR_DEF) && !declaration.hasOwnProperty(NG_PIPE_DEF)) {\n      // Set `ngSelectorScope` for future reference when the component compilation finishes.\n      declaration.ngSelectorScope = moduleType;\n    }\n  });\n}\n/**\n * Patch the definition of a component with directives and pipes from the compilation scope of\n * a given module.\n */\nfunction patchComponentDefWithScope(componentDef, transitiveScopes) {\n  componentDef.directiveDefs = () => Array.from(transitiveScopes.compilation.directives).map(dir => dir.hasOwnProperty(NG_COMP_DEF) ? getComponentDef$1(dir) : getDirectiveDef(dir)).filter(def => !!def);\n  componentDef.pipeDefs = () => Array.from(transitiveScopes.compilation.pipes).map(pipe => getPipeDef$1(pipe));\n  componentDef.schemas = transitiveScopes.schemas;\n  // Since we avoid Components/Directives/Pipes recompiling in case there are no overrides, we\n  // may face a problem where previously compiled defs available to a given Component/Directive\n  // are cached in TView and may become stale (in case any of these defs gets recompiled). In\n  // order to avoid this problem, we force fresh TView to be created.\n  componentDef.tView = null;\n}\n/**\n * Compute the pair of transitive scopes (compilation scope and exported scope) for a given type\n * (either a NgModule or a standalone component / directive / pipe).\n */\nfunction transitiveScopesFor(type) {\n  if (isNgModule$1(type)) {\n    return transitiveScopesForNgModule(type);\n  } else if (isStandalone(type)) {\n    const directiveDef = getComponentDef$1(type) || getDirectiveDef(type);\n    if (directiveDef !== null) {\n      return {\n        schemas: null,\n        compilation: {\n          directives: new Set(),\n          pipes: new Set()\n        },\n        exported: {\n          directives: new Set([type]),\n          pipes: new Set()\n        }\n      };\n    }\n    const pipeDef = getPipeDef$1(type);\n    if (pipeDef !== null) {\n      return {\n        schemas: null,\n        compilation: {\n          directives: new Set(),\n          pipes: new Set()\n        },\n        exported: {\n          directives: new Set(),\n          pipes: new Set([type])\n        }\n      };\n    }\n  }\n  // TODO: change the error message to be more user-facing and take standalone into account\n  throw new Error(`${type.name} does not have a module def (ɵmod property)`);\n}\n/**\n * Compute the pair of transitive scopes (compilation scope and exported scope) for a given module.\n *\n * This operation is memoized and the result is cached on the module's definition. This function can\n * be called on modules with components that have not fully compiled yet, but the result should not\n * be used until they have.\n *\n * @param moduleType module that transitive scope should be calculated for.\n */\nfunction transitiveScopesForNgModule(moduleType) {\n  const def = getNgModuleDef(moduleType, true);\n  if (def.transitiveCompileScopes !== null) {\n    return def.transitiveCompileScopes;\n  }\n  const scopes = {\n    schemas: def.schemas || null,\n    compilation: {\n      directives: new Set(),\n      pipes: new Set()\n    },\n    exported: {\n      directives: new Set(),\n      pipes: new Set()\n    }\n  };\n  maybeUnwrapFn$1(def.imports).forEach(imported => {\n    // When this module imports another, the imported module's exported directives and pipes are\n    // added to the compilation scope of this module.\n    const importedScope = transitiveScopesFor(imported);\n    importedScope.exported.directives.forEach(entry => scopes.compilation.directives.add(entry));\n    importedScope.exported.pipes.forEach(entry => scopes.compilation.pipes.add(entry));\n  });\n  maybeUnwrapFn$1(def.declarations).forEach(declared => {\n    const declaredWithDefs = declared;\n    if (getPipeDef$1(declaredWithDefs)) {\n      scopes.compilation.pipes.add(declared);\n    } else {\n      // Either declared has a ɵcmp or ɵdir, or it's a component which hasn't\n      // had its template compiled yet. In either case, it gets added to the compilation's\n      // directives.\n      scopes.compilation.directives.add(declared);\n    }\n  });\n  maybeUnwrapFn$1(def.exports).forEach(exported => {\n    const exportedType = exported;\n    // Either the type is a module, a pipe, or a component/directive (which may not have a\n    // ɵcmp as it might be compiled asynchronously).\n    if (isNgModule$1(exportedType)) {\n      // When this module exports another, the exported module's exported directives and pipes are\n      // added to both the compilation and exported scopes of this module.\n      const exportedScope = transitiveScopesFor(exportedType);\n      exportedScope.exported.directives.forEach(entry => {\n        scopes.compilation.directives.add(entry);\n        scopes.exported.directives.add(entry);\n      });\n      exportedScope.exported.pipes.forEach(entry => {\n        scopes.compilation.pipes.add(entry);\n        scopes.exported.pipes.add(entry);\n      });\n    } else if (getPipeDef$1(exportedType)) {\n      scopes.exported.pipes.add(exportedType);\n    } else {\n      scopes.exported.directives.add(exportedType);\n    }\n  });\n  def.transitiveCompileScopes = scopes;\n  return scopes;\n}\nfunction expandModuleWithProviders(value) {\n  if (isModuleWithProviders$1(value)) {\n    return value.ngModule;\n  }\n  return value;\n}\nlet _nextReferenceId = 0;\nclass MetadataOverrider {\n  constructor() {\n    this._references = new Map();\n  }\n  /**\n   * Creates a new instance for the given metadata class\n   * based on an old instance and overrides.\n   */\n  overrideMetadata(metadataClass, oldMetadata, override) {\n    const props = {};\n    if (oldMetadata) {\n      _valueProps(oldMetadata).forEach(prop => props[prop] = oldMetadata[prop]);\n    }\n    if (override.set) {\n      if (override.remove || override.add) {\n        throw new Error(`Cannot set and add/remove ${ɵstringify(metadataClass)} at the same time!`);\n      }\n      setMetadata(props, override.set);\n    }\n    if (override.remove) {\n      removeMetadata(props, override.remove, this._references);\n    }\n    if (override.add) {\n      addMetadata(props, override.add);\n    }\n    return new metadataClass(props);\n  }\n}\nfunction removeMetadata(metadata, remove, references) {\n  const removeObjects = new Set();\n  for (const prop in remove) {\n    const removeValue = remove[prop];\n    if (Array.isArray(removeValue)) {\n      removeValue.forEach(value => {\n        removeObjects.add(_propHashKey(prop, value, references));\n      });\n    } else {\n      removeObjects.add(_propHashKey(prop, removeValue, references));\n    }\n  }\n  for (const prop in metadata) {\n    const propValue = metadata[prop];\n    if (Array.isArray(propValue)) {\n      metadata[prop] = propValue.filter(value => !removeObjects.has(_propHashKey(prop, value, references)));\n    } else {\n      if (removeObjects.has(_propHashKey(prop, propValue, references))) {\n        metadata[prop] = undefined;\n      }\n    }\n  }\n}\nfunction addMetadata(metadata, add) {\n  for (const prop in add) {\n    const addValue = add[prop];\n    const propValue = metadata[prop];\n    if (propValue != null && Array.isArray(propValue)) {\n      metadata[prop] = propValue.concat(addValue);\n    } else {\n      metadata[prop] = addValue;\n    }\n  }\n}\nfunction setMetadata(metadata, set) {\n  for (const prop in set) {\n    metadata[prop] = set[prop];\n  }\n}\nfunction _propHashKey(propName, propValue, references) {\n  let nextObjectId = 0;\n  const objectIds = new Map();\n  const replacer = (key, value) => {\n    if (value !== null && typeof value === 'object') {\n      if (objectIds.has(value)) {\n        return objectIds.get(value);\n      }\n      // Record an id for this object such that any later references use the object's id instead\n      // of the object itself, in order to break cyclic pointers in objects.\n      objectIds.set(value, `ɵobj#${nextObjectId++}`);\n      // The first time an object is seen the object itself is serialized.\n      return value;\n    } else if (typeof value === 'function') {\n      value = _serializeReference(value, references);\n    }\n    return value;\n  };\n  return `${propName}:${JSON.stringify(propValue, replacer)}`;\n}\nfunction _serializeReference(ref, references) {\n  let id = references.get(ref);\n  if (!id) {\n    id = `${ɵstringify(ref)}${_nextReferenceId++}`;\n    references.set(ref, id);\n  }\n  return id;\n}\nfunction _valueProps(obj) {\n  const props = [];\n  // regular public props\n  Object.keys(obj).forEach(prop => {\n    if (!prop.startsWith('_')) {\n      props.push(prop);\n    }\n  });\n  // getters\n  let proto = obj;\n  while (proto = Object.getPrototypeOf(proto)) {\n    Object.keys(proto).forEach(protoProp => {\n      const desc = Object.getOwnPropertyDescriptor(proto, protoProp);\n      if (!protoProp.startsWith('_') && desc && 'get' in desc) {\n        props.push(protoProp);\n      }\n    });\n  }\n  return props;\n}\nconst reflection = new ɵReflectionCapabilities();\n/**\n * Allows to override ivy metadata for tests (via the `TestBed`).\n */\nclass OverrideResolver {\n  constructor() {\n    this.overrides = new Map();\n    this.resolved = new Map();\n  }\n  addOverride(type, override) {\n    const overrides = this.overrides.get(type) || [];\n    overrides.push(override);\n    this.overrides.set(type, overrides);\n    this.resolved.delete(type);\n  }\n  setOverrides(overrides) {\n    this.overrides.clear();\n    overrides.forEach(([type, override]) => {\n      this.addOverride(type, override);\n    });\n  }\n  getAnnotation(type) {\n    const annotations = reflection.annotations(type);\n    // Try to find the nearest known Type annotation and make sure that this annotation is an\n    // instance of the type we are looking for, so we can use it for resolution. Note: there might\n    // be multiple known annotations found due to the fact that Components can extend Directives (so\n    // both Directive and Component annotations would be present), so we always check if the known\n    // annotation has the right type.\n    for (let i = annotations.length - 1; i >= 0; i--) {\n      const annotation = annotations[i];\n      const isKnownType = annotation instanceof Directive || annotation instanceof Component || annotation instanceof Pipe || annotation instanceof NgModule;\n      if (isKnownType) {\n        return annotation instanceof this.type ? annotation : null;\n      }\n    }\n    return null;\n  }\n  resolve(type) {\n    let resolved = this.resolved.get(type) || null;\n    if (!resolved) {\n      resolved = this.getAnnotation(type);\n      if (resolved) {\n        const overrides = this.overrides.get(type);\n        if (overrides) {\n          const overrider = new MetadataOverrider();\n          overrides.forEach(override => {\n            resolved = overrider.overrideMetadata(this.type, resolved, override);\n          });\n        }\n      }\n      this.resolved.set(type, resolved);\n    }\n    return resolved;\n  }\n}\nclass DirectiveResolver extends OverrideResolver {\n  get type() {\n    return Directive;\n  }\n}\nclass ComponentResolver extends OverrideResolver {\n  get type() {\n    return Component;\n  }\n}\nclass PipeResolver extends OverrideResolver {\n  get type() {\n    return Pipe;\n  }\n}\nclass NgModuleResolver extends OverrideResolver {\n  get type() {\n    return NgModule;\n  }\n}\nvar TestingModuleOverride;\n(function (TestingModuleOverride) {\n  TestingModuleOverride[TestingModuleOverride[\"DECLARATION\"] = 0] = \"DECLARATION\";\n  TestingModuleOverride[TestingModuleOverride[\"OVERRIDE_TEMPLATE\"] = 1] = \"OVERRIDE_TEMPLATE\";\n})(TestingModuleOverride || (TestingModuleOverride = {}));\nfunction isTestingModuleOverride(value) {\n  return value === TestingModuleOverride.DECLARATION || value === TestingModuleOverride.OVERRIDE_TEMPLATE;\n}\nfunction assertNoStandaloneComponents(types, resolver, location) {\n  types.forEach(type => {\n    const component = resolver.resolve(type);\n    if (component && component.standalone) {\n      throw new Error(generateStandaloneInDeclarationsError(type, location));\n    }\n  });\n}\nclass TestBedCompiler {\n  constructor(platform, additionalModuleTypes) {\n    this.platform = platform;\n    this.additionalModuleTypes = additionalModuleTypes;\n    this.originalComponentResolutionQueue = null;\n    // Testing module configuration\n    this.declarations = [];\n    this.imports = [];\n    this.providers = [];\n    this.schemas = [];\n    // Queues of components/directives/pipes that should be recompiled.\n    this.pendingComponents = new Set();\n    this.pendingDirectives = new Set();\n    this.pendingPipes = new Set();\n    // Keep track of all components and directives, so we can patch Providers onto defs later.\n    this.seenComponents = new Set();\n    this.seenDirectives = new Set();\n    // Keep track of overridden modules, so that we can collect all affected ones in the module tree.\n    this.overriddenModules = new Set();\n    // Store resolved styles for Components that have template overrides present and `styleUrls`\n    // defined at the same time.\n    this.existingComponentStyles = new Map();\n    this.resolvers = initResolvers();\n    this.componentToModuleScope = new Map();\n    // Map that keeps initial version of component/directive/pipe defs in case\n    // we compile a Type again, thus overriding respective static fields. This is\n    // required to make sure we restore defs to their initial states between test runs.\n    // Note: one class may have multiple defs (for example: ɵmod and ɵinj in case of an\n    // NgModule), store all of them in a map.\n    this.initialNgDefs = new Map();\n    // Array that keeps cleanup operations for initial versions of component/directive/pipe/module\n    // defs in case TestBed makes changes to the originals.\n    this.defCleanupOps = [];\n    this._injector = null;\n    this.compilerProviders = null;\n    this.providerOverrides = [];\n    this.rootProviderOverrides = [];\n    // Overrides for injectables with `{providedIn: SomeModule}` need to be tracked and added to that\n    // module's provider list.\n    this.providerOverridesByModule = new Map();\n    this.providerOverridesByToken = new Map();\n    this.scopesWithOverriddenProviders = new Set();\n    this.testModuleRef = null;\n    class DynamicTestModule {}\n    this.testModuleType = DynamicTestModule;\n  }\n  setCompilerProviders(providers) {\n    this.compilerProviders = providers;\n    this._injector = null;\n  }\n  configureTestingModule(moduleDef) {\n    // Enqueue any compilation tasks for the directly declared component.\n    if (moduleDef.declarations !== undefined) {\n      // Verify that there are no standalone components\n      assertNoStandaloneComponents(moduleDef.declarations, this.resolvers.component, '\"TestBed.configureTestingModule\" call');\n      this.queueTypeArray(moduleDef.declarations, TestingModuleOverride.DECLARATION);\n      this.declarations.push(...moduleDef.declarations);\n    }\n    // Enqueue any compilation tasks for imported modules.\n    if (moduleDef.imports !== undefined) {\n      this.queueTypesFromModulesArray(moduleDef.imports);\n      this.imports.push(...moduleDef.imports);\n    }\n    if (moduleDef.providers !== undefined) {\n      this.providers.push(...moduleDef.providers);\n    }\n    if (moduleDef.schemas !== undefined) {\n      this.schemas.push(...moduleDef.schemas);\n    }\n  }\n  overrideModule(ngModule, override) {\n    this.overriddenModules.add(ngModule);\n    // Compile the module right away.\n    this.resolvers.module.addOverride(ngModule, override);\n    const metadata = this.resolvers.module.resolve(ngModule);\n    if (metadata === null) {\n      throw invalidTypeError(ngModule.name, 'NgModule');\n    }\n    this.recompileNgModule(ngModule, metadata);\n    // At this point, the module has a valid module def (ɵmod), but the override may have introduced\n    // new declarations or imported modules. Ingest any possible new types and add them to the\n    // current queue.\n    this.queueTypesFromModulesArray([ngModule]);\n  }\n  overrideComponent(component, override) {\n    this.verifyNoStandaloneFlagOverrides(component, override);\n    this.resolvers.component.addOverride(component, override);\n    this.pendingComponents.add(component);\n  }\n  overrideDirective(directive, override) {\n    this.verifyNoStandaloneFlagOverrides(directive, override);\n    this.resolvers.directive.addOverride(directive, override);\n    this.pendingDirectives.add(directive);\n  }\n  overridePipe(pipe, override) {\n    this.verifyNoStandaloneFlagOverrides(pipe, override);\n    this.resolvers.pipe.addOverride(pipe, override);\n    this.pendingPipes.add(pipe);\n  }\n  verifyNoStandaloneFlagOverrides(type, override) {\n    if (override.add?.hasOwnProperty('standalone') || override.set?.hasOwnProperty('standalone') || override.remove?.hasOwnProperty('standalone')) {\n      throw new Error(`An override for the ${type.name} class has the \\`standalone\\` flag. ` + `Changing the \\`standalone\\` flag via TestBed overrides is not supported.`);\n    }\n  }\n  overrideProvider(token, provider) {\n    let providerDef;\n    if (provider.useFactory !== undefined) {\n      providerDef = {\n        provide: token,\n        useFactory: provider.useFactory,\n        deps: provider.deps || [],\n        multi: provider.multi\n      };\n    } else if (provider.useValue !== undefined) {\n      providerDef = {\n        provide: token,\n        useValue: provider.useValue,\n        multi: provider.multi\n      };\n    } else {\n      providerDef = {\n        provide: token\n      };\n    }\n    const injectableDef = typeof token !== 'string' ? ɵgetInjectableDef(token) : null;\n    const providedIn = injectableDef === null ? null : resolveForwardRef$1(injectableDef.providedIn);\n    const overridesBucket = providedIn === 'root' ? this.rootProviderOverrides : this.providerOverrides;\n    overridesBucket.push(providerDef);\n    // Keep overrides grouped by token as well for fast lookups using token\n    this.providerOverridesByToken.set(token, providerDef);\n    if (injectableDef !== null && providedIn !== null && typeof providedIn !== 'string') {\n      const existingOverrides = this.providerOverridesByModule.get(providedIn);\n      if (existingOverrides !== undefined) {\n        existingOverrides.push(providerDef);\n      } else {\n        this.providerOverridesByModule.set(providedIn, [providerDef]);\n      }\n    }\n  }\n  overrideTemplateUsingTestingModule(type, template) {\n    const def = type[ɵNG_COMP_DEF];\n    const hasStyleUrls = () => {\n      const metadata = this.resolvers.component.resolve(type);\n      return !!metadata.styleUrls && metadata.styleUrls.length > 0;\n    };\n    const overrideStyleUrls = !!def && !isComponentDefPendingResolution(type) && hasStyleUrls();\n    // In Ivy, compiling a component does not require knowing the module providing the\n    // component's scope, so overrideTemplateUsingTestingModule can be implemented purely via\n    // overrideComponent. Important: overriding template requires full Component re-compilation,\n    // which may fail in case styleUrls are also present (thus Component is considered as required\n    // resolution). In order to avoid this, we preemptively set styleUrls to an empty array,\n    // preserve current styles available on Component def and restore styles back once compilation\n    // is complete.\n    const override = overrideStyleUrls ? {\n      template,\n      styles: [],\n      styleUrls: []\n    } : {\n      template\n    };\n    this.overrideComponent(type, {\n      set: override\n    });\n    if (overrideStyleUrls && def.styles && def.styles.length > 0) {\n      this.existingComponentStyles.set(type, def.styles);\n    }\n    // Set the component's scope to be the testing module.\n    this.componentToModuleScope.set(type, TestingModuleOverride.OVERRIDE_TEMPLATE);\n  }\n  compileComponents() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.clearComponentResolutionQueue();\n      // Run compilers for all queued types.\n      let needsAsyncResources = _this.compileTypesSync();\n      // compileComponents() should not be async unless it needs to be.\n      if (needsAsyncResources) {\n        let resourceLoader;\n        let resolver = url => {\n          if (!resourceLoader) {\n            resourceLoader = _this.injector.get(ResourceLoader);\n          }\n          return Promise.resolve(resourceLoader.get(url));\n        };\n        yield resolveComponentResources(resolver);\n      }\n    })();\n  }\n  finalize() {\n    // One last compile\n    this.compileTypesSync();\n    // Create the testing module itself.\n    this.compileTestModule();\n    this.applyTransitiveScopes();\n    this.applyProviderOverrides();\n    // Patch previously stored `styles` Component values (taken from ɵcmp), in case these\n    // Components have `styleUrls` fields defined and template override was requested.\n    this.patchComponentsWithExistingStyles();\n    // Clear the componentToModuleScope map, so that future compilations don't reset the scope of\n    // every component.\n    this.componentToModuleScope.clear();\n    const parentInjector = this.platform.injector;\n    this.testModuleRef = new ɵRender3NgModuleRef(this.testModuleType, parentInjector, []);\n    // ApplicationInitStatus.runInitializers() is marked @internal to core.\n    // Cast it to any before accessing it.\n    this.testModuleRef.injector.get(ApplicationInitStatus).runInitializers();\n    // Set locale ID after running app initializers, since locale information might be updated while\n    // running initializers. This is also consistent with the execution order while bootstrapping an\n    // app (see `packages/core/src/application_ref.ts` file).\n    const localeId = this.testModuleRef.injector.get(LOCALE_ID$1, ɵDEFAULT_LOCALE_ID);\n    ɵsetLocaleId(localeId);\n    return this.testModuleRef;\n  }\n  /**\n   * @internal\n   */\n  _compileNgModuleSync(moduleType) {\n    this.queueTypesFromModulesArray([moduleType]);\n    this.compileTypesSync();\n    this.applyProviderOverrides();\n    this.applyProviderOverridesInScope(moduleType);\n    this.applyTransitiveScopes();\n  }\n  /**\n   * @internal\n   */\n  _compileNgModuleAsync(moduleType) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.queueTypesFromModulesArray([moduleType]);\n      yield _this2.compileComponents();\n      _this2.applyProviderOverrides();\n      _this2.applyProviderOverridesInScope(moduleType);\n      _this2.applyTransitiveScopes();\n    })();\n  }\n  /**\n   * @internal\n   */\n  _getModuleResolver() {\n    return this.resolvers.module;\n  }\n  /**\n   * @internal\n   */\n  _getComponentFactories(moduleType) {\n    return maybeUnwrapFn(moduleType.ɵmod.declarations).reduce((factories, declaration) => {\n      const componentDef = declaration.ɵcmp;\n      componentDef && factories.push(new ɵRender3ComponentFactory(componentDef, this.testModuleRef));\n      return factories;\n    }, []);\n  }\n  compileTypesSync() {\n    // Compile all queued components, directives, pipes.\n    let needsAsyncResources = false;\n    this.pendingComponents.forEach(declaration => {\n      needsAsyncResources = needsAsyncResources || isComponentDefPendingResolution(declaration);\n      const metadata = this.resolvers.component.resolve(declaration);\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Component');\n      }\n      this.maybeStoreNgDef(ɵNG_COMP_DEF, declaration);\n      ɵcompileComponent(declaration, metadata);\n    });\n    this.pendingComponents.clear();\n    this.pendingDirectives.forEach(declaration => {\n      const metadata = this.resolvers.directive.resolve(declaration);\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Directive');\n      }\n      this.maybeStoreNgDef(ɵNG_DIR_DEF, declaration);\n      ɵcompileDirective(declaration, metadata);\n    });\n    this.pendingDirectives.clear();\n    this.pendingPipes.forEach(declaration => {\n      const metadata = this.resolvers.pipe.resolve(declaration);\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Pipe');\n      }\n      this.maybeStoreNgDef(ɵNG_PIPE_DEF, declaration);\n      ɵcompilePipe(declaration, metadata);\n    });\n    this.pendingPipes.clear();\n    return needsAsyncResources;\n  }\n  applyTransitiveScopes() {\n    if (this.overriddenModules.size > 0) {\n      // Module overrides (via `TestBed.overrideModule`) might affect scopes that were previously\n      // calculated and stored in `transitiveCompileScopes`. If module overrides are present,\n      // collect all affected modules and reset scopes to force their re-calculation.\n      const testingModuleDef = this.testModuleType[ɵNG_MOD_DEF];\n      const affectedModules = this.collectModulesAffectedByOverrides(testingModuleDef.imports);\n      if (affectedModules.size > 0) {\n        affectedModules.forEach(moduleType => {\n          this.storeFieldOfDefOnType(moduleType, ɵNG_MOD_DEF, 'transitiveCompileScopes');\n          moduleType[ɵNG_MOD_DEF].transitiveCompileScopes = null;\n        });\n      }\n    }\n    const moduleToScope = new Map();\n    const getScopeOfModule = moduleType => {\n      if (!moduleToScope.has(moduleType)) {\n        const isTestingModule = isTestingModuleOverride(moduleType);\n        const realType = isTestingModule ? this.testModuleType : moduleType;\n        moduleToScope.set(moduleType, ɵtransitiveScopesFor(realType));\n      }\n      return moduleToScope.get(moduleType);\n    };\n    this.componentToModuleScope.forEach((moduleType, componentType) => {\n      const moduleScope = getScopeOfModule(moduleType);\n      this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'directiveDefs');\n      this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'pipeDefs');\n      // `tView` that is stored on component def contains information about directives and pipes\n      // that are in the scope of this component. Patching component scope will cause `tView` to be\n      // changed. Store original `tView` before patching scope, so the `tView` (including scope\n      // information) is restored back to its previous/original state before running next test.\n      this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'tView');\n      ɵpatchComponentDefWithScope(componentType.ɵcmp, moduleScope);\n    });\n    this.componentToModuleScope.clear();\n  }\n  applyProviderOverrides() {\n    const maybeApplyOverrides = field => type => {\n      const resolver = field === ɵNG_COMP_DEF ? this.resolvers.component : this.resolvers.directive;\n      const metadata = resolver.resolve(type);\n      if (this.hasProviderOverrides(metadata.providers)) {\n        this.patchDefWithProviderOverrides(type, field);\n      }\n    };\n    this.seenComponents.forEach(maybeApplyOverrides(ɵNG_COMP_DEF));\n    this.seenDirectives.forEach(maybeApplyOverrides(ɵNG_DIR_DEF));\n    this.seenComponents.clear();\n    this.seenDirectives.clear();\n  }\n  /**\n   * Applies provider overrides to a given type (either an NgModule or a standalone component)\n   * and all imported NgModules and standalone components recursively.\n   */\n  applyProviderOverridesInScope(type) {\n    const hasScope = isStandaloneComponent(type) || isNgModule(type);\n    // The function can be re-entered recursively while inspecting dependencies\n    // of an NgModule or a standalone component. Exit early if we come across a\n    // type that can not have a scope (directive or pipe) or the type is already\n    // processed earlier.\n    if (!hasScope || this.scopesWithOverriddenProviders.has(type)) {\n      return;\n    }\n    this.scopesWithOverriddenProviders.add(type);\n    // NOTE: the line below triggers JIT compilation of the module injector,\n    // which also invokes verification of the NgModule semantics, which produces\n    // detailed error messages. The fact that the code relies on this line being\n    // present here is suspicious and should be refactored in a way that the line\n    // below can be moved (for ex. after an early exit check below).\n    const injectorDef = type[ɵNG_INJ_DEF];\n    // No provider overrides, exit early.\n    if (this.providerOverridesByToken.size === 0) return;\n    if (isStandaloneComponent(type)) {\n      // Visit all component dependencies and override providers there.\n      const def = getComponentDef(type);\n      const dependencies = maybeUnwrapFn(def.dependencies ?? []);\n      for (const dependency of dependencies) {\n        this.applyProviderOverridesInScope(dependency);\n      }\n    } else {\n      const providers = [...injectorDef.providers, ...(this.providerOverridesByModule.get(type) || [])];\n      if (this.hasProviderOverrides(providers)) {\n        this.maybeStoreNgDef(ɵNG_INJ_DEF, type);\n        this.storeFieldOfDefOnType(type, ɵNG_INJ_DEF, 'providers');\n        injectorDef.providers = this.getOverriddenProviders(providers);\n      }\n      // Apply provider overrides to imported modules recursively\n      const moduleDef = type[ɵNG_MOD_DEF];\n      const imports = maybeUnwrapFn(moduleDef.imports);\n      for (const importedModule of imports) {\n        this.applyProviderOverridesInScope(importedModule);\n      }\n      // Also override the providers on any ModuleWithProviders imports since those don't appear in\n      // the moduleDef.\n      for (const importedModule of flatten(injectorDef.imports)) {\n        if (isModuleWithProviders(importedModule)) {\n          this.defCleanupOps.push({\n            object: importedModule,\n            fieldName: 'providers',\n            originalValue: importedModule.providers\n          });\n          importedModule.providers = this.getOverriddenProviders(importedModule.providers);\n        }\n      }\n    }\n  }\n  patchComponentsWithExistingStyles() {\n    this.existingComponentStyles.forEach((styles, type) => type[ɵNG_COMP_DEF].styles = styles);\n    this.existingComponentStyles.clear();\n  }\n  queueTypeArray(arr, moduleType) {\n    for (const value of arr) {\n      if (Array.isArray(value)) {\n        this.queueTypeArray(value, moduleType);\n      } else {\n        this.queueType(value, moduleType);\n      }\n    }\n  }\n  recompileNgModule(ngModule, metadata) {\n    // Cache the initial ngModuleDef as it will be overwritten.\n    this.maybeStoreNgDef(ɵNG_MOD_DEF, ngModule);\n    this.maybeStoreNgDef(ɵNG_INJ_DEF, ngModule);\n    ɵcompileNgModuleDefs(ngModule, metadata);\n  }\n  queueType(type, moduleType) {\n    const component = this.resolvers.component.resolve(type);\n    if (component) {\n      // Check whether a give Type has respective NG def (ɵcmp) and compile if def is\n      // missing. That might happen in case a class without any Angular decorators extends another\n      // class where Component/Directive/Pipe decorator is defined.\n      if (isComponentDefPendingResolution(type) || !type.hasOwnProperty(ɵNG_COMP_DEF)) {\n        this.pendingComponents.add(type);\n      }\n      this.seenComponents.add(type);\n      // Keep track of the module which declares this component, so later the component's scope\n      // can be set correctly. If the component has already been recorded here, then one of several\n      // cases is true:\n      // * the module containing the component was imported multiple times (common).\n      // * the component is declared in multiple modules (which is an error).\n      // * the component was in 'declarations' of the testing module, and also in an imported module\n      //   in which case the module scope will be TestingModuleOverride.DECLARATION.\n      // * overrideTemplateUsingTestingModule was called for the component in which case the module\n      //   scope will be TestingModuleOverride.OVERRIDE_TEMPLATE.\n      //\n      // If the component was previously in the testing module's 'declarations' (meaning the\n      // current value is TestingModuleOverride.DECLARATION), then `moduleType` is the component's\n      // real module, which was imported. This pattern is understood to mean that the component\n      // should use its original scope, but that the testing module should also contain the\n      // component in its scope.\n      //\n      // Note: standalone components have no associated NgModule, so the `moduleType` can be `null`.\n      if (moduleType !== null && (!this.componentToModuleScope.has(type) || this.componentToModuleScope.get(type) === TestingModuleOverride.DECLARATION)) {\n        this.componentToModuleScope.set(type, moduleType);\n      }\n      return;\n    }\n    const directive = this.resolvers.directive.resolve(type);\n    if (directive) {\n      if (!type.hasOwnProperty(ɵNG_DIR_DEF)) {\n        this.pendingDirectives.add(type);\n      }\n      this.seenDirectives.add(type);\n      return;\n    }\n    const pipe = this.resolvers.pipe.resolve(type);\n    if (pipe && !type.hasOwnProperty(ɵNG_PIPE_DEF)) {\n      this.pendingPipes.add(type);\n      return;\n    }\n  }\n  queueTypesFromModulesArray(arr) {\n    // Because we may encounter the same NgModule or a standalone Component while processing\n    // the dependencies of an NgModule or a standalone Component, we cache them in this set so we\n    // can skip ones that have already been seen encountered. In some test setups, this caching\n    // resulted in 10X runtime improvement.\n    const processedDefs = new Set();\n    const queueTypesFromModulesArrayRecur = arr => {\n      for (const value of arr) {\n        if (Array.isArray(value)) {\n          queueTypesFromModulesArrayRecur(value);\n        } else if (hasNgModuleDef(value)) {\n          const def = value.ɵmod;\n          if (processedDefs.has(def)) {\n            continue;\n          }\n          processedDefs.add(def);\n          // Look through declarations, imports, and exports, and queue\n          // everything found there.\n          this.queueTypeArray(maybeUnwrapFn(def.declarations), value);\n          queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.imports));\n          queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.exports));\n        } else if (isModuleWithProviders(value)) {\n          queueTypesFromModulesArrayRecur([value.ngModule]);\n        } else if (isStandaloneComponent(value)) {\n          this.queueType(value, null);\n          const def = getComponentDef(value);\n          if (processedDefs.has(def)) {\n            continue;\n          }\n          processedDefs.add(def);\n          const dependencies = maybeUnwrapFn(def.dependencies ?? []);\n          dependencies.forEach(dependency => {\n            // Note: in AOT, the `dependencies` might also contain regular\n            // (NgModule-based) Component, Directive and Pipes, so we handle\n            // them separately and proceed with recursive process for standalone\n            // Components and NgModules only.\n            if (isStandaloneComponent(dependency) || hasNgModuleDef(dependency)) {\n              queueTypesFromModulesArrayRecur([dependency]);\n            } else {\n              this.queueType(dependency, null);\n            }\n          });\n        }\n      }\n    };\n    queueTypesFromModulesArrayRecur(arr);\n  }\n  // When module overrides (via `TestBed.overrideModule`) are present, it might affect all modules\n  // that import (even transitively) an overridden one. For all affected modules we need to\n  // recalculate their scopes for a given test run and restore original scopes at the end. The goal\n  // of this function is to collect all affected modules in a set for further processing. Example:\n  // if we have the following module hierarchy: A -> B -> C (where `->` means `imports`) and module\n  // `C` is overridden, we consider `A` and `B` as affected, since their scopes might become\n  // invalidated with the override.\n  collectModulesAffectedByOverrides(arr) {\n    const seenModules = new Set();\n    const affectedModules = new Set();\n    const calcAffectedModulesRecur = (arr, path) => {\n      for (const value of arr) {\n        if (Array.isArray(value)) {\n          // If the value is an array, just flatten it (by invoking this function recursively),\n          // keeping \"path\" the same.\n          calcAffectedModulesRecur(value, path);\n        } else if (hasNgModuleDef(value)) {\n          if (seenModules.has(value)) {\n            // If we've seen this module before and it's included into \"affected modules\" list, mark\n            // the whole path that leads to that module as affected, but do not descend into its\n            // imports, since we already examined them before.\n            if (affectedModules.has(value)) {\n              path.forEach(item => affectedModules.add(item));\n            }\n            continue;\n          }\n          seenModules.add(value);\n          if (this.overriddenModules.has(value)) {\n            path.forEach(item => affectedModules.add(item));\n          }\n          // Examine module imports recursively to look for overridden modules.\n          const moduleDef = value[ɵNG_MOD_DEF];\n          calcAffectedModulesRecur(maybeUnwrapFn(moduleDef.imports), path.concat(value));\n        }\n      }\n    };\n    calcAffectedModulesRecur(arr, []);\n    return affectedModules;\n  }\n  /**\n   * Preserve an original def (such as ɵmod, ɵinj, etc) before applying an override.\n   * Note: one class may have multiple defs (for example: ɵmod and ɵinj in case of\n   * an NgModule). If there is a def in a set already, don't override it, since\n   * an original one should be restored at the end of a test.\n   */\n  maybeStoreNgDef(prop, type) {\n    if (!this.initialNgDefs.has(type)) {\n      this.initialNgDefs.set(type, new Map());\n    }\n    const currentDefs = this.initialNgDefs.get(type);\n    if (!currentDefs.has(prop)) {\n      const currentDef = Object.getOwnPropertyDescriptor(type, prop);\n      currentDefs.set(prop, currentDef);\n    }\n  }\n  storeFieldOfDefOnType(type, defField, fieldName) {\n    const def = type[defField];\n    const originalValue = def[fieldName];\n    this.defCleanupOps.push({\n      object: def,\n      fieldName,\n      originalValue\n    });\n  }\n  /**\n   * Clears current components resolution queue, but stores the state of the queue, so we can\n   * restore it later. Clearing the queue is required before we try to compile components (via\n   * `TestBed.compileComponents`), so that component defs are in sync with the resolution queue.\n   */\n  clearComponentResolutionQueue() {\n    if (this.originalComponentResolutionQueue === null) {\n      this.originalComponentResolutionQueue = new Map();\n    }\n    clearResolutionOfComponentResourcesQueue().forEach((value, key) => this.originalComponentResolutionQueue.set(key, value));\n  }\n  /*\n   * Restores component resolution queue to the previously saved state. This operation is performed\n   * as a part of restoring the state after completion of the current set of tests (that might\n   * potentially mutate the state).\n   */\n  restoreComponentResolutionQueue() {\n    if (this.originalComponentResolutionQueue !== null) {\n      restoreComponentResolutionQueue(this.originalComponentResolutionQueue);\n      this.originalComponentResolutionQueue = null;\n    }\n  }\n  restoreOriginalState() {\n    // Process cleanup ops in reverse order so the field's original value is restored correctly (in\n    // case there were multiple overrides for the same field).\n    forEachRight(this.defCleanupOps, op => {\n      op.object[op.fieldName] = op.originalValue;\n    });\n    // Restore initial component/directive/pipe defs\n    this.initialNgDefs.forEach((defs, type) => {\n      defs.forEach((descriptor, prop) => {\n        if (!descriptor) {\n          // Delete operations are generally undesirable since they have performance\n          // implications on objects they were applied to. In this particular case, situations\n          // where this code is invoked should be quite rare to cause any noticeable impact,\n          // since it's applied only to some test cases (for example when class with no\n          // annotations extends some @Component) when we need to clear 'ɵcmp' field on a given\n          // class to restore its original state (before applying overrides and running tests).\n          delete type[prop];\n        } else {\n          Object.defineProperty(type, prop, descriptor);\n        }\n      });\n    });\n    this.initialNgDefs.clear();\n    this.scopesWithOverriddenProviders.clear();\n    this.restoreComponentResolutionQueue();\n    // Restore the locale ID to the default value, this shouldn't be necessary but we never know\n    ɵsetLocaleId(ɵDEFAULT_LOCALE_ID);\n  }\n  compileTestModule() {\n    class RootScopeModule {}\n    ɵcompileNgModuleDefs(RootScopeModule, {\n      providers: [...this.rootProviderOverrides]\n    });\n    const providers = [provideZoneChangeDetection(), {\n      provide: Compiler,\n      useFactory: () => new R3TestCompiler(this)\n    }, ...this.providers, ...this.providerOverrides];\n    const imports = [RootScopeModule, this.additionalModuleTypes, this.imports || []];\n    // clang-format off\n    ɵcompileNgModuleDefs(this.testModuleType, {\n      declarations: this.declarations,\n      imports,\n      schemas: this.schemas,\n      providers\n    }, /* allowDuplicateDeclarationsInRoot */true);\n    // clang-format on\n    this.applyProviderOverridesInScope(this.testModuleType);\n  }\n  get injector() {\n    if (this._injector !== null) {\n      return this._injector;\n    }\n    const providers = [];\n    const compilerOptions = this.platform.injector.get(COMPILER_OPTIONS);\n    compilerOptions.forEach(opts => {\n      if (opts.providers) {\n        providers.push(opts.providers);\n      }\n    });\n    if (this.compilerProviders !== null) {\n      providers.push(...this.compilerProviders);\n    }\n    this._injector = Injector$1.create({\n      providers,\n      parent: this.platform.injector\n    });\n    return this._injector;\n  }\n  // get overrides for a specific provider (if any)\n  getSingleProviderOverrides(provider) {\n    const token = getProviderToken(provider);\n    return this.providerOverridesByToken.get(token) || null;\n  }\n  getProviderOverrides(providers) {\n    if (!providers || !providers.length || this.providerOverridesByToken.size === 0) return [];\n    // There are two flattening operations here. The inner flattenProviders() operates on the\n    // metadata's providers and applies a mapping function which retrieves overrides for each\n    // incoming provider. The outer flatten() then flattens the produced overrides array. If this is\n    // not done, the array can contain other empty arrays (e.g. `[[], []]`) which leak into the\n    // providers array and contaminate any error messages that might be generated.\n    return flatten(flattenProviders(providers, provider => this.getSingleProviderOverrides(provider) || []));\n  }\n  getOverriddenProviders(providers) {\n    if (!providers || !providers.length || this.providerOverridesByToken.size === 0) return [];\n    const flattenedProviders = flattenProviders(providers);\n    const overrides = this.getProviderOverrides(flattenedProviders);\n    const overriddenProviders = [...flattenedProviders, ...overrides];\n    const final = [];\n    const seenOverriddenProviders = new Set();\n    // We iterate through the list of providers in reverse order to make sure provider overrides\n    // take precedence over the values defined in provider list. We also filter out all providers\n    // that have overrides, keeping overridden values only. This is needed, since presence of a\n    // provider with `ngOnDestroy` hook will cause this hook to be registered and invoked later.\n    forEachRight(overriddenProviders, provider => {\n      const token = getProviderToken(provider);\n      if (this.providerOverridesByToken.has(token)) {\n        if (!seenOverriddenProviders.has(token)) {\n          seenOverriddenProviders.add(token);\n          // Treat all overridden providers as `{multi: false}` (even if it's a multi-provider) to\n          // make sure that provided override takes highest precedence and is not combined with\n          // other instances of the same multi provider.\n          final.unshift({\n            ...provider,\n            multi: false\n          });\n        }\n      } else {\n        final.unshift(provider);\n      }\n    });\n    return final;\n  }\n  hasProviderOverrides(providers) {\n    return this.getProviderOverrides(providers).length > 0;\n  }\n  patchDefWithProviderOverrides(declaration, field) {\n    const def = declaration[field];\n    if (def && def.providersResolver) {\n      this.maybeStoreNgDef(field, declaration);\n      const resolver = def.providersResolver;\n      const processProvidersFn = providers => this.getOverriddenProviders(providers);\n      this.storeFieldOfDefOnType(declaration, field, 'providersResolver');\n      def.providersResolver = ngDef => resolver(ngDef, processProvidersFn);\n    }\n  }\n}\nfunction initResolvers() {\n  return {\n    module: new NgModuleResolver(),\n    component: new ComponentResolver(),\n    directive: new DirectiveResolver(),\n    pipe: new PipeResolver()\n  };\n}\nfunction isStandaloneComponent(value) {\n  const def = getComponentDef(value);\n  return !!def?.standalone;\n}\nfunction getComponentDef(value) {\n  return value.ɵcmp ?? null;\n}\nfunction hasNgModuleDef(value) {\n  return value.hasOwnProperty('ɵmod');\n}\nfunction isNgModule(value) {\n  return hasNgModuleDef(value);\n}\nfunction maybeUnwrapFn(maybeFn) {\n  return maybeFn instanceof Function ? maybeFn() : maybeFn;\n}\nfunction flatten(values) {\n  const out = [];\n  values.forEach(value => {\n    if (Array.isArray(value)) {\n      out.push(...flatten(value));\n    } else {\n      out.push(value);\n    }\n  });\n  return out;\n}\nfunction identityFn(value) {\n  return value;\n}\nfunction flattenProviders(providers, mapFn = identityFn) {\n  const out = [];\n  for (let provider of providers) {\n    if (ɵisEnvironmentProviders(provider)) {\n      provider = provider.ɵproviders;\n    }\n    if (Array.isArray(provider)) {\n      out.push(...flattenProviders(provider, mapFn));\n    } else {\n      out.push(mapFn(provider));\n    }\n  }\n  return out;\n}\nfunction getProviderField(provider, field) {\n  return provider && typeof provider === 'object' && provider[field];\n}\nfunction getProviderToken(provider) {\n  return getProviderField(provider, 'provide') || provider;\n}\nfunction isModuleWithProviders(value) {\n  return value.hasOwnProperty('ngModule');\n}\nfunction forEachRight(values, fn) {\n  for (let idx = values.length - 1; idx >= 0; idx--) {\n    fn(values[idx], idx);\n  }\n}\nfunction invalidTypeError(name, expectedType) {\n  return new Error(`${name} class doesn't have @${expectedType} decorator or is missing metadata.`);\n}\nclass R3TestCompiler {\n  constructor(testBed) {\n    this.testBed = testBed;\n  }\n  compileModuleSync(moduleType) {\n    this.testBed._compileNgModuleSync(moduleType);\n    return new ɵNgModuleFactory(moduleType);\n  }\n  compileModuleAsync(moduleType) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      yield _this3.testBed._compileNgModuleAsync(moduleType);\n      return new ɵNgModuleFactory(moduleType);\n    })();\n  }\n  compileModuleAndAllComponentsSync(moduleType) {\n    const ngModuleFactory = this.compileModuleSync(moduleType);\n    const componentFactories = this.testBed._getComponentFactories(moduleType);\n    return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n  }\n  compileModuleAndAllComponentsAsync(moduleType) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const ngModuleFactory = yield _this4.compileModuleAsync(moduleType);\n      const componentFactories = _this4.testBed._getComponentFactories(moduleType);\n      return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n    })();\n  }\n  clearCache() {}\n  clearCacheFor(type) {}\n  getModuleId(moduleType) {\n    const meta = this.testBed._getModuleResolver().resolve(moduleType);\n    return meta && meta.id || undefined;\n  }\n}\n\n// The formatter and CI disagree on how this import statement should be formatted. Both try to keep\nlet _nextRootElementId = 0;\n/**\n * Returns a singleton of the `TestBed` class.\n *\n * @publicApi\n */\nfunction getTestBed() {\n  return TestBedImpl.INSTANCE;\n}\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * TestBed is the primary api for writing unit tests for Angular applications and libraries.\n */\nclass TestBedImpl {\n  constructor() {\n    // Properties\n    this.platform = null;\n    this.ngModule = null;\n    this._compiler = null;\n    this._testModuleRef = null;\n    this._activeFixtures = [];\n    /**\n     * Internal-only flag to indicate whether a module\n     * scoping queue has been checked and flushed already.\n     * @nodoc\n     */\n    this.globalCompilationChecked = false;\n  }\n  static #_ = this._INSTANCE = null;\n  static get INSTANCE() {\n    return TestBedImpl._INSTANCE = TestBedImpl._INSTANCE || new TestBedImpl();\n  }\n  /**\n   * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n   * angular module. These are common to every test in the suite.\n   *\n   * This may only be called once, to set up the common providers for the current test\n   * suite on the current platform. If you absolutely need to change the providers,\n   * first use `resetTestEnvironment`.\n   *\n   * Test modules and platforms for individual platforms are available from\n   * '@angular/<platform_name>/testing'.\n   *\n   * @publicApi\n   */\n  static initTestEnvironment(ngModule, platform, options) {\n    const testBed = TestBedImpl.INSTANCE;\n    testBed.initTestEnvironment(ngModule, platform, options);\n    return testBed;\n  }\n  /**\n   * Reset the providers for the test injector.\n   *\n   * @publicApi\n   */\n  static resetTestEnvironment() {\n    TestBedImpl.INSTANCE.resetTestEnvironment();\n  }\n  static configureCompiler(config) {\n    return TestBedImpl.INSTANCE.configureCompiler(config);\n  }\n  /**\n   * Allows overriding default providers, directives, pipes, modules of the test injector,\n   * which are defined in test_injector.js\n   */\n  static configureTestingModule(moduleDef) {\n    return TestBedImpl.INSTANCE.configureTestingModule(moduleDef);\n  }\n  /**\n   * Compile components with a `templateUrl` for the test's NgModule.\n   * It is necessary to call this function\n   * as fetching urls is asynchronous.\n   */\n  static compileComponents() {\n    return TestBedImpl.INSTANCE.compileComponents();\n  }\n  static overrideModule(ngModule, override) {\n    return TestBedImpl.INSTANCE.overrideModule(ngModule, override);\n  }\n  static overrideComponent(component, override) {\n    return TestBedImpl.INSTANCE.overrideComponent(component, override);\n  }\n  static overrideDirective(directive, override) {\n    return TestBedImpl.INSTANCE.overrideDirective(directive, override);\n  }\n  static overridePipe(pipe, override) {\n    return TestBedImpl.INSTANCE.overridePipe(pipe, override);\n  }\n  static overrideTemplate(component, template) {\n    return TestBedImpl.INSTANCE.overrideTemplate(component, template);\n  }\n  /**\n   * Overrides the template of the given component, compiling the template\n   * in the context of the TestingModule.\n   *\n   * Note: This works for JIT and AOTed components as well.\n   */\n  static overrideTemplateUsingTestingModule(component, template) {\n    return TestBedImpl.INSTANCE.overrideTemplateUsingTestingModule(component, template);\n  }\n  static overrideProvider(token, provider) {\n    return TestBedImpl.INSTANCE.overrideProvider(token, provider);\n  }\n  static inject(token, notFoundValue, flags) {\n    return TestBedImpl.INSTANCE.inject(token, notFoundValue, ɵconvertToBitFlags(flags));\n  }\n  /** @deprecated from v9.0.0 use TestBed.inject */\n  static get(token, notFoundValue = Injector$1.THROW_IF_NOT_FOUND, flags = InjectFlags$1.Default) {\n    return TestBedImpl.INSTANCE.inject(token, notFoundValue, flags);\n  }\n  /**\n   * Runs the given function in the `EnvironmentInjector` context of `TestBed`.\n   *\n   * @see {@link EnvironmentInjector#runInContext}\n   */\n  static runInInjectionContext(fn) {\n    return TestBedImpl.INSTANCE.runInInjectionContext(fn);\n  }\n  static createComponent(component) {\n    return TestBedImpl.INSTANCE.createComponent(component);\n  }\n  static resetTestingModule() {\n    return TestBedImpl.INSTANCE.resetTestingModule();\n  }\n  static execute(tokens, fn, context) {\n    return TestBedImpl.INSTANCE.execute(tokens, fn, context);\n  }\n  static get platform() {\n    return TestBedImpl.INSTANCE.platform;\n  }\n  static get ngModule() {\n    return TestBedImpl.INSTANCE.ngModule;\n  }\n  /**\n   * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n   * angular module. These are common to every test in the suite.\n   *\n   * This may only be called once, to set up the common providers for the current test\n   * suite on the current platform. If you absolutely need to change the providers,\n   * first use `resetTestEnvironment`.\n   *\n   * Test modules and platforms for individual platforms are available from\n   * '@angular/<platform_name>/testing'.\n   *\n   * @publicApi\n   */\n  initTestEnvironment(ngModule, platform, options) {\n    if (this.platform || this.ngModule) {\n      throw new Error('Cannot set base providers because it has already been called');\n    }\n    TestBedImpl._environmentTeardownOptions = options?.teardown;\n    TestBedImpl._environmentErrorOnUnknownElementsOption = options?.errorOnUnknownElements;\n    TestBedImpl._environmentErrorOnUnknownPropertiesOption = options?.errorOnUnknownProperties;\n    this.platform = platform;\n    this.ngModule = ngModule;\n    this._compiler = new TestBedCompiler(this.platform, this.ngModule);\n    // TestBed does not have an API which can reliably detect the start of a test, and thus could be\n    // used to track the state of the NgModule registry and reset it correctly. Instead, when we\n    // know we're in a testing scenario, we disable the check for duplicate NgModule registration\n    // completely.\n    ɵsetAllowDuplicateNgModuleIdsForTest(true);\n  }\n  /**\n   * Reset the providers for the test injector.\n   *\n   * @publicApi\n   */\n  resetTestEnvironment() {\n    this.resetTestingModule();\n    this._compiler = null;\n    this.platform = null;\n    this.ngModule = null;\n    TestBedImpl._environmentTeardownOptions = undefined;\n    ɵsetAllowDuplicateNgModuleIdsForTest(false);\n  }\n  resetTestingModule() {\n    this.checkGlobalCompilationFinished();\n    ɵresetCompiledComponents();\n    if (this._compiler !== null) {\n      this.compiler.restoreOriginalState();\n    }\n    this._compiler = new TestBedCompiler(this.platform, this.ngModule);\n    // Restore the previous value of the \"error on unknown elements\" option\n    ɵsetUnknownElementStrictMode$1(this._previousErrorOnUnknownElementsOption ?? THROW_ON_UNKNOWN_ELEMENTS_DEFAULT);\n    // Restore the previous value of the \"error on unknown properties\" option\n    ɵsetUnknownPropertyStrictMode$1(this._previousErrorOnUnknownPropertiesOption ?? THROW_ON_UNKNOWN_PROPERTIES_DEFAULT);\n    // We have to chain a couple of try/finally blocks, because each step can\n    // throw errors and we don't want it to interrupt the next step and we also\n    // want an error to be thrown at the end.\n    try {\n      this.destroyActiveFixtures();\n    } finally {\n      try {\n        if (this.shouldTearDownTestingModule()) {\n          this.tearDownTestingModule();\n        }\n      } finally {\n        this._testModuleRef = null;\n        this._instanceTeardownOptions = undefined;\n        this._instanceErrorOnUnknownElementsOption = undefined;\n        this._instanceErrorOnUnknownPropertiesOption = undefined;\n      }\n    }\n    return this;\n  }\n  configureCompiler(config) {\n    if (config.useJit != null) {\n      throw new Error('JIT compiler is not configurable via TestBed APIs.');\n    }\n    if (config.providers !== undefined) {\n      this.compiler.setCompilerProviders(config.providers);\n    }\n    return this;\n  }\n  configureTestingModule(moduleDef) {\n    this.assertNotInstantiated('TestBed.configureTestingModule', 'configure the test module');\n    // Trigger module scoping queue flush before executing other TestBed operations in a test.\n    // This is needed for the first test invocation to ensure that globally declared modules have\n    // their components scoped properly. See the `checkGlobalCompilationFinished` function\n    // description for additional info.\n    this.checkGlobalCompilationFinished();\n    // Always re-assign the options, even if they're undefined.\n    // This ensures that we don't carry them between tests.\n    this._instanceTeardownOptions = moduleDef.teardown;\n    this._instanceErrorOnUnknownElementsOption = moduleDef.errorOnUnknownElements;\n    this._instanceErrorOnUnknownPropertiesOption = moduleDef.errorOnUnknownProperties;\n    // Store the current value of the strict mode option,\n    // so we can restore it later\n    this._previousErrorOnUnknownElementsOption = ɵgetUnknownElementStrictMode$1();\n    ɵsetUnknownElementStrictMode$1(this.shouldThrowErrorOnUnknownElements());\n    this._previousErrorOnUnknownPropertiesOption = ɵgetUnknownPropertyStrictMode$1();\n    ɵsetUnknownPropertyStrictMode$1(this.shouldThrowErrorOnUnknownProperties());\n    this.compiler.configureTestingModule(moduleDef);\n    return this;\n  }\n  compileComponents() {\n    return this.compiler.compileComponents();\n  }\n  inject(token, notFoundValue, flags) {\n    if (token === TestBed) {\n      return this;\n    }\n    const UNDEFINED = {};\n    const result = this.testModuleRef.injector.get(token, UNDEFINED, ɵconvertToBitFlags(flags));\n    return result === UNDEFINED ? this.compiler.injector.get(token, notFoundValue, flags) : result;\n  }\n  /** @deprecated from v9.0.0 use TestBed.inject */\n  get(token, notFoundValue = Injector$1.THROW_IF_NOT_FOUND, flags = InjectFlags$1.Default) {\n    return this.inject(token, notFoundValue, flags);\n  }\n  runInInjectionContext(fn) {\n    return this.inject(EnvironmentInjector$1).runInContext(fn);\n  }\n  execute(tokens, fn, context) {\n    const params = tokens.map(t => this.inject(t));\n    return fn.apply(context, params);\n  }\n  overrideModule(ngModule, override) {\n    this.assertNotInstantiated('overrideModule', 'override module metadata');\n    this.compiler.overrideModule(ngModule, override);\n    return this;\n  }\n  overrideComponent(component, override) {\n    this.assertNotInstantiated('overrideComponent', 'override component metadata');\n    this.compiler.overrideComponent(component, override);\n    return this;\n  }\n  overrideTemplateUsingTestingModule(component, template) {\n    this.assertNotInstantiated('TestBed.overrideTemplateUsingTestingModule', 'Cannot override template when the test module has already been instantiated');\n    this.compiler.overrideTemplateUsingTestingModule(component, template);\n    return this;\n  }\n  overrideDirective(directive, override) {\n    this.assertNotInstantiated('overrideDirective', 'override directive metadata');\n    this.compiler.overrideDirective(directive, override);\n    return this;\n  }\n  overridePipe(pipe, override) {\n    this.assertNotInstantiated('overridePipe', 'override pipe metadata');\n    this.compiler.overridePipe(pipe, override);\n    return this;\n  }\n  /**\n   * Overwrites all providers for the given token with the given provider definition.\n   */\n  overrideProvider(token, provider) {\n    this.assertNotInstantiated('overrideProvider', 'override provider');\n    this.compiler.overrideProvider(token, provider);\n    return this;\n  }\n  overrideTemplate(component, template) {\n    return this.overrideComponent(component, {\n      set: {\n        template,\n        templateUrl: null\n      }\n    });\n  }\n  createComponent(type) {\n    const testComponentRenderer = this.inject(TestComponentRenderer);\n    const rootElId = `root${_nextRootElementId++}`;\n    testComponentRenderer.insertRootElement(rootElId);\n    const componentDef = type.ɵcmp;\n    if (!componentDef) {\n      throw new Error(`It looks like '${ɵstringify(type)}' has not been compiled.`);\n    }\n    const noNgZone = this.inject(ComponentFixtureNoNgZone, false);\n    const autoDetect = this.inject(ComponentFixtureAutoDetect, false);\n    const ngZone = noNgZone ? null : this.inject(NgZone$1, null);\n    const componentFactory = new ɵRender3ComponentFactory(componentDef);\n    const initComponent = () => {\n      const componentRef = componentFactory.create(Injector$1.NULL, [], `#${rootElId}`, this.testModuleRef);\n      return new ComponentFixture(componentRef, ngZone, autoDetect);\n    };\n    const fixture = ngZone ? ngZone.run(initComponent) : initComponent();\n    this._activeFixtures.push(fixture);\n    return fixture;\n  }\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n  get compiler() {\n    if (this._compiler === null) {\n      throw new Error(`Need to call TestBed.initTestEnvironment() first`);\n    }\n    return this._compiler;\n  }\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n  get testModuleRef() {\n    if (this._testModuleRef === null) {\n      this._testModuleRef = this.compiler.finalize();\n    }\n    return this._testModuleRef;\n  }\n  assertNotInstantiated(methodName, methodDescription) {\n    if (this._testModuleRef !== null) {\n      throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. ` + `Make sure you are not using \\`inject\\` before \\`${methodName}\\`.`);\n    }\n  }\n  /**\n   * Check whether the module scoping queue should be flushed, and flush it if needed.\n   *\n   * When the TestBed is reset, it clears the JIT module compilation queue, cancelling any\n   * in-progress module compilation. This creates a potential hazard - the very first time the\n   * TestBed is initialized (or if it's reset without being initialized), there may be pending\n   * compilations of modules declared in global scope. These compilations should be finished.\n   *\n   * To ensure that globally declared modules have their components scoped properly, this function\n   * is called whenever TestBed is initialized or reset. The _first_ time that this happens, prior\n   * to any other operations, the scoping queue is flushed.\n   */\n  checkGlobalCompilationFinished() {\n    // Checking _testNgModuleRef is null should not be necessary, but is left in as an additional\n    // guard that compilations queued in tests (after instantiation) are never flushed accidentally.\n    if (!this.globalCompilationChecked && this._testModuleRef === null) {\n      ɵflushModuleScopingQueueAsMuchAsPossible();\n    }\n    this.globalCompilationChecked = true;\n  }\n  destroyActiveFixtures() {\n    let errorCount = 0;\n    this._activeFixtures.forEach(fixture => {\n      try {\n        fixture.destroy();\n      } catch (e) {\n        errorCount++;\n        console.error('Error during cleanup of component', {\n          component: fixture.componentInstance,\n          stacktrace: e\n        });\n      }\n    });\n    this._activeFixtures = [];\n    if (errorCount > 0 && this.shouldRethrowTeardownErrors()) {\n      throw Error(`${errorCount} ${errorCount === 1 ? 'component' : 'components'} ` + `threw errors during cleanup`);\n    }\n  }\n  shouldRethrowTeardownErrors() {\n    const instanceOptions = this._instanceTeardownOptions;\n    const environmentOptions = TestBedImpl._environmentTeardownOptions;\n    // If the new teardown behavior hasn't been configured, preserve the old behavior.\n    if (!instanceOptions && !environmentOptions) {\n      return TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n    }\n    // Otherwise use the configured behavior or default to rethrowing.\n    return instanceOptions?.rethrowErrors ?? environmentOptions?.rethrowErrors ?? this.shouldTearDownTestingModule();\n  }\n  shouldThrowErrorOnUnknownElements() {\n    // Check if a configuration has been provided to throw when an unknown element is found\n    return this._instanceErrorOnUnknownElementsOption ?? TestBedImpl._environmentErrorOnUnknownElementsOption ?? THROW_ON_UNKNOWN_ELEMENTS_DEFAULT;\n  }\n  shouldThrowErrorOnUnknownProperties() {\n    // Check if a configuration has been provided to throw when an unknown property is found\n    return this._instanceErrorOnUnknownPropertiesOption ?? TestBedImpl._environmentErrorOnUnknownPropertiesOption ?? THROW_ON_UNKNOWN_PROPERTIES_DEFAULT;\n  }\n  shouldTearDownTestingModule() {\n    return this._instanceTeardownOptions?.destroyAfterEach ?? TestBedImpl._environmentTeardownOptions?.destroyAfterEach ?? TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n  }\n  tearDownTestingModule() {\n    // If the module ref has already been destroyed, we won't be able to get a test renderer.\n    if (this._testModuleRef === null) {\n      return;\n    }\n    // Resolve the renderer ahead of time, because we want to remove the root elements as the very\n    // last step, but the injector will be destroyed as a part of the module ref destruction.\n    const testRenderer = this.inject(TestComponentRenderer);\n    try {\n      this._testModuleRef.destroy();\n    } catch (e) {\n      if (this.shouldRethrowTeardownErrors()) {\n        throw e;\n      } else {\n        console.error('Error during cleanup of a testing module', {\n          component: this._testModuleRef.instance,\n          stacktrace: e\n        });\n      }\n    } finally {\n      testRenderer.removeAllRootElements?.();\n    }\n  }\n}\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * @publicApi\n */\nconst TestBed = TestBedImpl;\n/**\n * Allows injecting dependencies in `beforeEach()` and `it()`. Note: this function\n * (imported from the `@angular/core/testing` package) can **only** be used to inject dependencies\n * in tests. To inject dependencies in your application code, use the [`inject`](api/core/inject)\n * function from the `@angular/core` package instead.\n *\n * Example:\n *\n * ```\n * beforeEach(inject([Dependency, AClass], (dep, object) => {\n *   // some code that uses `dep` and `object`\n *   // ...\n * }));\n *\n * it('...', inject([AClass], (object) => {\n *   object.doSomething();\n *   expect(...);\n * })\n * ```\n *\n * @publicApi\n */\nfunction inject(tokens, fn) {\n  const testBed = TestBedImpl.INSTANCE;\n  // Not using an arrow function to preserve context passed from call site\n  return function () {\n    return testBed.execute(tokens, fn, this);\n  };\n}\n/**\n * @publicApi\n */\nclass InjectSetupWrapper {\n  constructor(_moduleDef) {\n    this._moduleDef = _moduleDef;\n  }\n  _addModule() {\n    const moduleDef = this._moduleDef();\n    if (moduleDef) {\n      TestBedImpl.configureTestingModule(moduleDef);\n    }\n  }\n  inject(tokens, fn) {\n    const self = this;\n    // Not using an arrow function to preserve context passed from call site\n    return function () {\n      self._addModule();\n      return inject(tokens, fn).call(this);\n    };\n  }\n}\nfunction withModule(moduleDef, fn) {\n  if (fn) {\n    // Not using an arrow function to preserve context passed from call site\n    return function () {\n      const testBed = TestBedImpl.INSTANCE;\n      if (moduleDef) {\n        testBed.configureTestingModule(moduleDef);\n      }\n      return fn.apply(this);\n    };\n  }\n  return new InjectSetupWrapper(() => moduleDef);\n}\n\n/**\n * Public Test Library for unit testing Angular applications. Assumes that you are running\n * with Jasmine, Mocha, or a similar framework which exports a beforeEach function and\n * allows tests to be asynchronous by either returning a promise or using a 'done' parameter.\n */\n// Reset the test providers and the fake async zone before each test.\n// We keep a guard because somehow this file can make it into a bundle and be executed\n// beforeEach is only defined when executing the tests\nglobalThis.beforeEach?.(getCleanupHook(false));\n// We provide both a `beforeEach` and `afterEach`, because the updated behavior for\n// tearing down the module is supposed to run after the test so that we can associate\n// teardown errors with the correct test.\n// We keep a guard because somehow this file can make it into a bundle and be executed\n// afterEach is only defined when executing the tests\nglobalThis.afterEach?.(getCleanupHook(true));\nfunction getCleanupHook(expectedTeardownValue) {\n  return () => {\n    const testBed = TestBedImpl.INSTANCE;\n    if (testBed.shouldTearDownTestingModule() === expectedTeardownValue) {\n      testBed.resetTestingModule();\n      resetFakeAsyncZone();\n    }\n  };\n}\n/**\n * This API should be removed. But doing so seems to break `google3` and so it requires a bit of\n * investigation.\n *\n * A work around is to mark it as `@codeGenApi` for now and investigate later.\n *\n * @codeGenApi\n */\n// TODO(iminar): Remove this code in a safe way.\nconst __core_private_testing_placeholder__ = '';\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of the core/testing package.\n */\n\n/// <reference types=\"jasmine\" />\n// This file only reexports content of the `src` folder. Keep it that way.\n\n// This file is not used to build this module. It is only used during editing\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ComponentFixture, ComponentFixtureAutoDetect, ComponentFixtureNoNgZone, InjectSetupWrapper, TestBed, TestComponentRenderer, __core_private_testing_placeholder__, async, discardPeriodicTasks, fakeAsync, flush, flushMicrotasks, getTestBed, inject, resetFakeAsyncZone, tick, waitForAsync, withModule, MetadataOverrider as ɵMetadataOverrider };","map":{"version":3,"names":["getDebugNode","RendererFactory2","RendererFactory2$1","InjectionToken","InjectionToken$1","ɵstringify","ɵReflectionCapabilities","Directive","Component","Pipe","NgModule","ɵgetInjectableDef","resolveForwardRef","resolveForwardRef$1","ɵNG_COMP_DEF","ɵRender3NgModuleRef","ApplicationInitStatus","LOCALE_ID","LOCALE_ID$1","ɵDEFAULT_LOCALE_ID","ɵsetLocaleId","ɵRender3ComponentFactory","ɵcompileComponent","ɵNG_DIR_DEF","ɵcompileDirective","ɵNG_PIPE_DEF","ɵcompilePipe","ɵNG_MOD_DEF","ɵtransitiveScopesFor","ɵpatchComponentDefWithScope","ɵNG_INJ_DEF","ɵcompileNgModuleDefs","provideZoneChangeDetection","Compiler","COMPILER_OPTIONS","Injector","Injector$1","ɵisEnvironmentProviders","ɵNgModuleFactory","ModuleWithComponentFactories","ɵconvertToBitFlags","InjectFlags","InjectFlags$1","ɵsetAllowDuplicateNgModuleIdsForTest","ɵresetCompiledComponents","ɵsetUnknownElementStrictMode","ɵsetUnknownElementStrictMode$1","ɵsetUnknownPropertyStrictMode","ɵsetUnknownPropertyStrictMode$1","ɵgetUnknownElementStrictMode","ɵgetUnknownElementStrictMode$1","ɵgetUnknownPropertyStrictMode","ɵgetUnknownPropertyStrictMode$1","EnvironmentInjector","EnvironmentInjector$1","NgZone","NgZone$1","ɵflushModuleScopingQueueAsMuchAsPossible","ResourceLoader","Subject","Subscription","Observable","merge","merge$1","share","waitForAsync","fn","_Zone","Zone","Promise","reject","asyncTest","__symbol__","async","ComponentFixture","constructor","componentRef","ngZone","_autoDetect","_isStable","_isDestroyed","_resolve","_promise","_onUnstableSubscription","_onStableSubscription","_onMicrotaskEmptySubscription","_onErrorSubscription","changeDetectorRef","elementRef","location","debugElement","nativeElement","componentInstance","instance","runOutsideAngular","onUnstable","subscribe","next","onMicrotaskEmpty","detectChanges","onStable","queueMicrotask","hasPendingMacrotasks","onError","error","_tick","checkNoChanges","run","autoDetectChanges","autoDetect","Error","isStable","whenStable","resolve","res","_getRenderer","_renderer","undefined","injector","get","whenRenderingDone","renderer","destroy","unsubscribe","fakeAsyncTestModule","fakeAsyncTestModuleNotLoadedErrorMessage","resetFakeAsyncZone","fakeAsync","tick","millis","tickOptions","processNewMacroTasksSynchronously","flush","maxTurns","discardPeriodicTasks","flushMicrotasks","TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT","THROW_ON_UNKNOWN_ELEMENTS_DEFAULT","THROW_ON_UNKNOWN_PROPERTIES_DEFAULT","TestComponentRenderer","insertRootElement","rootElementId","removeAllRootElements","ComponentFixtureAutoDetect","ComponentFixtureNoNgZone","resolveComponentResources","resourceResolver","componentResolved","urlMap","Map","cachedResourceResolve","url","promise","resp","set","then","unwrapResponse","componentResourceResolutionQueue","forEach","component","type","promises","templateUrl","push","template","styleUrls","styles","styleOffset","length","styleUrl","index","style","splice","indexOf","fullyResolved","all","componentDefResolved","clearResolutionOfComponentResourcesQueue","componentDefPendingResolution","Set","maybeQueueResolutionOfComponentResources","metadata","componentNeedsResolution","add","isComponentDefPendingResolution","has","hasOwnProperty","old","restoreComponentResolutionQueue","queue","clear","_","isComponentResourceResolutionQueueEmpty","size","response","text","delete","_global","globalThis","FactoryTarget","R3TemplateDependencyKind","ViewEncapsulation$1","ViewEncapsulation","getCompilerFacade","request","globalNg","ɵcompilerFacade","ngDevMode","console","kind","message","name","usage","getClosureSafeProperty","objWithPropertyToExtract","key","fillProperties","target","source","stringify","token","Array","isArray","map","join","overriddenName","toString","newLineIndex","substring","concatStringsWithSpace","before","after","__forward_ref__","forwardRef","forwardRefFn","isForwardRef","ɵɵdefineInjectable","opts","providedIn","factory","value","defineInjectable","ɵɵdefineInjector","options","providers","imports","getInjectableDef","getOwnDefinition","NG_PROV_DEF","NG_INJECTABLE_DEF","isInjectable","field","getInheritedInjectableDef","def","warn","getInjectorDef","NG_INJ_DEF","NG_INJECTOR_DEF","ɵprov","ɵinj","ngInjectableDef","ngInjectorDef","ERROR_DETAILS_PAGE_BASE_URL","XSS_SECURITY_URL","RuntimeError","code","formatRuntimeError","fullCode","Math","abs","errorMessage","addPeriodSeparator","match","separator","Type","Function","isType","v","assertNumber","actual","msg","throwError","assertNumberInRange","minInclusive","maxInclusive","assertLessThanOrEqual","assertGreaterThanOrEqual","assertString","assertFunction","assertEqual","expected","assertNotEqual","assertSame","assertNotSame","assertLessThan","assertGreaterThan","assertNotDefined","assertDefined","comparison","assertDomNode","node","Node","assertIndexInRange","arr","maxLen","assertOneOf","validValues","JSON","arrayEquals","a","b","identityAccessor","i","valueA","valueB","flatten$1","list","flat","Number","POSITIVE_INFINITY","deepForEach","input","addToArray","removeFromArray","pop","newArray","arraySplice","array","count","arrayInsert","end","previousEnd","arrayInsert2","value1","value2","arrayIndexOfSorted","_arrayIndexOfSorted","keyValueArraySet","keyValueArray","keyValueArrayIndexOf","keyValueArrayGet","keyValueArrayDelete","shift","start","middle","current","noSideEffects","ANNOTATIONS","PARAMETERS","PROP_METADATA","makeDecorator","props","parentClass","additionalProcessing","typeFn","metaCtor","makeMetadataCtor","DecoratorFactory","args","call","annotationInstance","TypeDecorator","cls","annotations","Object","defineProperty","prototype","create","ngMetadataName","annotationCls","ctor","values","propName","makeParamDecorator","ParamDecoratorFactory","apply","ParamDecorator","annotation","unusedKey","parameters","makePropDecorator","PropDecoratorFactory","decoratorInstance","PropDecorator","meta","unshift","ES5_DELEGATE_CTOR","ES2015_INHERITED_CLASS","ES2015_INHERITED_CLASS_WITH_CTOR","ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR","isDelegateCtor","typeStr","test","ReflectionCapabilities","reflect","_reflect","t","_zipTypesAndAnnotations","paramTypes","paramAnnotations","result","concat","_ownParameters","parentCtor","tsickleCtorParams","ctorParameters","ctorParam","convertTsickleDecoratorIntoMetadata","decorators","getOwnMetadata","getParentCtor","_ownAnnotations","typeOrFunc","ownAnnotations","parentAnnotations","_ownPropMetadata","propMetadata","propDecorators","keys","prop","parentPropMetadata","ownPropMetadata","hasLifecycleHook","lcProperty","decoratorInvocations","decoratorInvocation","decoratorType","annotationArgs","parentProto","getPrototypeOf","ngDevModeResetPerfCounters","locationString","newCounters","namedConstructors","firstCreatePass","tNode","tView","rendererCreateTextNode","rendererSetText","rendererCreateElement","rendererAddEventListener","rendererSetAttribute","rendererRemoveAttribute","rendererSetProperty","rendererSetClassName","rendererAddClass","rendererRemoveClass","rendererSetStyle","rendererRemoveStyle","rendererDestroy","rendererDestroyNode","rendererMoveNode","rendererRemoveNode","rendererAppendChild","rendererInsertBefore","rendererCreateComment","hydratedNodes","hydratedComponents","dehydratedViewsRemoved","dehydratedViewsCleanupRuns","componentsSkippedHydration","allowNgDevModeTrue","initNgDevMode","_injectorProfilerContext","getInjectorProfilerContext","setInjectorProfilerContext","context","previous","injectorProfilerCallback","setInjectorProfiler","injectorProfiler","event","emitProviderConfiguredEvent","provider","isViewProvider","providerRecord","provide","emitInstanceCreatedByInjectorEvent","emitInjectEvent","flags","service","runInInjectorProfilerContext","callback","prevInjectContext","isEnvironmentProviders","ɵproviders","renderStringify","String","stringifyForError","throwCyclicDependencyError","path","depPath","throwMixedMultiProviderError","throwInvalidProviderError","ngModuleType","providerDetail","ɵfromNgModule","throwProviderNotFoundError","injectorName","injectorDetails","_injectImplementation","getInjectImplementation","setInjectImplementation","impl","injectRootLimpMode","notFoundValue","injectableDef","Optional","assertInjectImplementationNotEqual","_THROW_IF_NOT_FOUND","THROW_IF_NOT_FOUND","DI_DECORATOR_FLAG","NG_TEMP_TOKEN_PATH","NG_TOKEN_PATH","NEW_LINE","NO_NEW_LINE","SOURCE","_currentInjector","getCurrentInjector","setCurrentInjector","former","injectInjectorOnly","Default","ɵɵinject","ɵɵinvalidFactoryDep","inject$1","convertToBitFlags","optional","host","self","skipSelf","injectArgs","types","arg","j","flag","getInjectFlag","attachInjectFlag","decorator","catchInjectorError","e","injectorErrorName","tokenPath","formatError","obj","charAt","slice","parts","replace","Inject","Self","SkipSelf","Host","ChangeDetectionStrategy","EMPTY_OBJ","EMPTY_ARRAY","freeze","NG_COMP_DEF","ɵcmp","NG_DIR_DEF","ɵdir","NG_PIPE_DEF","ɵpipe","NG_MOD_DEF","ɵmod","NG_FACTORY_DEF","ɵfac","NG_ELEMENT_ID","__NG_ELEMENT_ID__","NG_ENV_ID","__NG_ENV_ID__","classIndexOf","className","classToSearch","startingIndex","foundIndex","charCodeAt","setUpAttributes","native","attrs","namespaceURI","attrName","attrVal","setAttribute","isAnimationProp","setProperty","isNameOnlyAttributeMarker","marker","mergeHostAttrs","dst","src","srcMarker","item","mergeHostAttribute","key1","key2","markerInsertPosition","dstValue","NG_TEMPLATE_SELECTOR","isCssClassMatching","cssClassToMatch","isProjectionMode","toLowerCase","isImplicitAttrsSection","isInlineTemplate","hasTagAndTypeMatch","currentSelector","tagNameToCompare","isNodeMatchingSelector","selector","mode","nodeAttrs","nameOnlyMarkerIdx","getNameOnlyMarkerIndex","skipToNextSelector","isPositive","selectorAttrValue","attrIndexInNode","findAttrIndexInNode","nodeAttrValue","compareAgainstClassName","bindingsMode","maybeAttrName","matchTemplateAttribute","isNodeMatchingSelectorList","getProjectAsAttrValue","ngProjectAsAttrIdx","nodeAttr","attr","isSelectorInSelectorList","selectorListLoop","currentSelectorInList","maybeWrapInNotSelector","isNegativeMode","chunk","trim","stringifyCSSSelector","currentChunk","valueOrMarker","attrValue","stringifyCSSSelectorList","selectorList","extractAttrsAndClassesFromSelector","classes","ɵɵdefineComponent","componentDefinition","baseDef","getNgDirectiveDef","decls","vars","consts","ngContentSelectors","onPush","changeDetection","OnPush","directiveDefs","pipeDefs","dependencies","standalone","getStandaloneInjector","signals","data","encapsulation","Emulated","schemas","id","initFeatures","extractDefListOrFactory","getComponentId","ɵɵsetComponentScope","directives","pipes","extractDirectiveDef","getComponentDef$1","getDirectiveDef","nonNull","ɵɵdefineNgModule","bootstrap","declarations","exports","transitiveCompileScopes","ɵɵsetNgModuleScope","scope","ngModuleDef","getNgModuleDef","invertObject","secondary","newLookup","minifiedKey","publicName","declaredName","ɵɵdefineDirective","directiveDefinition","ɵɵdefinePipe","pipeDef","pure","onDestroy","ngOnDestroy","getPipeDef$1","isStandalone","throwNotFound","declaredInputs","providersResolver","hostBindings","hostVars","hostAttrs","contentQueries","inputTransforms","inputConfig","inputs","exportAs","selectors","viewQuery","features","setInput","findHostDirectiveDefs","hostDirectives","outputs","definition","defExtractor","dep","filter","GENERATED_COMP_IDS","componentDef","hash","hashSelectors","getOwnPropertyNames","char","imul","compId","previousCompDefType","HOST","TVIEW","FLAGS","PARENT","NEXT","DESCENDANT_VIEWS_TO_REFRESH","T_HOST","CLEANUP","CONTEXT","INJECTOR$1","ENVIRONMENT","RENDERER","CHILD_HEAD","CHILD_TAIL","DECLARATION_VIEW","DECLARATION_COMPONENT_VIEW","DECLARATION_LCONTAINER","PREORDER_HOOK_FLAGS","QUERIES","ID","EMBEDDED_VIEW_INJECTOR","ON_DESTROY_HOOKS","HYDRATION","REACTIVE_TEMPLATE_CONSUMER","REACTIVE_HOST_BINDING_CONSUMER","HEADER_OFFSET","unusedValueExportToPlacateAjd$4","TYPE","HAS_TRANSPLANTED_VIEWS","NATIVE","VIEW_REFS","MOVED_VIEWS","DEHYDRATED_VIEWS","CONTAINER_HEADER_OFFSET","unusedValueExportToPlacateAjd$3","isLView","isLContainer","isContentQueryHost","isComponentHost","componentOffset","isDirectiveHost","isComponentDef","isRootView","isProjectionTNode","hasI18n","lView","assertTNodeForLView","assertTNodeForTView","assertTNode","tData","assertTIcu","tIcu","currentCaseLViewIndex","assertComponentType","assertNgModuleType","assertCurrentTNodeIsParent","isParent","assertHasParent","parent","assertLContainer","assertLViewOrUndefined","assertLView","assertFirstCreatePass","errMessage","assertFirstUpdatePass","firstUpdatePass","assertDirectiveDef","assertIndexInDeclRange","assertBetween","bindingStartIndex","assertIndexInExpandoRange","expandoStartIndex","lower","upper","assertProjectionSlots","projection","assertParentView","assertNodeInjector","injectorIndex","getFactoryDef","hasFactoryDef","SIGNAL","Symbol","isSignal","defaultEquals","is","activeConsumer","inNotificationPhase","setActiveConsumer","consumer","prev","REACTIVE_NODE","version","dirty","producerNode","producerLastReadVersion","producerIndexOfThis","nextProducerIndex","liveConsumerNode","liveConsumerIndexOfThis","consumerAllowSignalWrites","consumerIsAlwaysLive","producerMustRecompute","producerRecomputeValue","consumerMarkedDirty","producerAccessed","idx","assertConsumerNode","consumerIsLive","staleProducer","producerRemoveLiveConsumerAtIndex","producerAddLiveConsumer","producerUpdateValueVersion","consumerPollProducersForChange","producerNotifyConsumers","consumerMarkDirty","producerUpdatesAllowed","consumerBeforeComputation","consumerAfterComputation","prevConsumer","producer","seenVersion","consumerDestroy","indexOfThis","assertProducerNode","lastIdx","idxProducer","computed","computation","COMPUTED_NODE","equal","ERRORED","UNSET","COMPUTING","oldValue","newValue","err","defaultThrowError","throwInvalidWriteToSignalErrorFn","throwInvalidWriteToSignalError","setThrowInvalidWriteToSignalError","postSignalSetFn","signal","initialValue","SIGNAL_NODE","signalFn","signalSetFn","update","signalUpdateFn","mutate","signalMutateFn","asReadonly","signalAsReadonlyFn","setPostSignalSetFn","readonlyFn","signalValueChanged","updater","mutator","untracked","nonReactiveReadsFn","watch","schedule","allowSignalWrites","WATCH_NODE","registerOnCleanup","cleanupFn","hasRun","NOOP_CLEANUP_FN","ref","notify","cleanup","setAlternateWeakRefImpl","SimpleChange","previousValue","currentValue","firstChange","isFirstChange","ɵɵNgOnChangesFeature","NgOnChangesFeatureImpl","ngOnChanges","ngOnChangesSetInput","rememberChangeHistoryAndInvokeOnChangesHook","ngInherit","simpleChangesStore","getSimpleChangesStore","privateName","setSimpleChangesStore","previousChange","SIMPLE_CHANGES_STORE","store","profilerCallback","setProfiler","profiler","hookOrListener","SVG_NAMESPACE","MATH_ML_NAMESPACE","unwrapRNode","unwrapLView","getNativeByIndex","getNativeByTNode","getNativeByTNodeOrNull","getTNode","load","view","getComponentLViewByIndex","nodeIndex","hostView","slotValue","isCreationMode","viewAttachedToChangeDetector","viewAttachedToContainer","getConstant","resetPreOrderHookFlags","markViewForRefresh","updateViewsToRefresh","clearViewRefreshFlag","amount","viewOrContainer","storeLViewOnDestroy","onDestroyCallback","removeLViewOnDestroy","destroyCBIdx","instructionState","lFrame","createLFrame","bindingsEnabled","skipHydrationRootTNode","_isInCheckNoChangesMode","specOnlyIsInstructionStateEmpty","getElementDepthCount","elementDepthCount","increaseElementDepthCount","decreaseElementDepthCount","getBindingsEnabled","isInSkipHydrationBlock$1","isSkipHydrationRootTNode","ɵɵenableBindings","enterSkipHydrationBlock","ɵɵdisableBindings","leaveSkipHydrationBlock","getLView","getTView","ɵɵrestoreView","viewToRestore","contextLView","ɵɵresetView","getCurrentTNode","currentTNode","getCurrentTNodePlaceholderOk","getCurrentParentTNode","setCurrentTNode","isCurrentTNodeParent","setCurrentTNodeAsNotParent","getContextLView","isInCheckNoChangesMode","setIsInCheckNoChangesMode","getBindingRoot","bindingRootIndex","getBindingIndex","bindingIndex","setBindingIndex","nextBindingIndex","incrementBindingIndex","isInI18nBlock","inI18n","setInI18nBlock","setBindingRootForHostBindings","currentDirectiveIndex","setCurrentDirectiveIndex","getCurrentDirectiveIndex","getCurrentDirectiveDef","getCurrentQueryIndex","currentQueryIndex","setCurrentQueryIndex","getDeclarationTNode","declTNode","enterDI","parentTNode","parentLView","allocLFrame","enterView","newView","newLFrame","selectedIndex","currentNamespace","firstChild","currentLFrame","childLFrame","child","leaveViewLight","oldLFrame","leaveDI","leaveView","nextContextImpl","level","walkUpViews","nestingLevel","currentView","getSelectedIndex","setSelectedIndex","getSelectedTNode","ɵɵnamespaceSVG","ɵɵnamespaceMathML","ɵɵnamespaceHTML","namespaceHTMLInternal","getNamespace$1","_wasLastNodeCreated","wasLastNodeCreated","lastNodeWasCreated","registerPreOrderHooks","directiveIndex","directiveDef","ngOnInit","ngDoCheck","wrappedOnChanges","preOrderHooks","preOrderCheckHooks","registerPostOrderHooks","directiveStart","directiveEnd","lifecycleHooks","ngAfterContentInit","ngAfterContentChecked","ngAfterViewInit","ngAfterViewChecked","contentHooks","contentCheckHooks","viewHooks","viewCheckHooks","destroyHooks","executeCheckHooks","hooks","callHooks","executeInitAndCheckHooks","initPhase","incrementInitPhaseFlags","currentNodeIndex","startIndex","nodeIndexLimit","max","lastNodeIndexFound","hook","isInitHook","callHook","callHookInternal","directive","indexWithintInitPhase","NO_PARENT_INJECTOR","NodeInjectorFactory","injectImplementation","resolving","canSeeViewProviders","injectImpl","isFactory","unusedValueExportToPlacateAjd$2","toTNodeTypeAsString","tNodeType","unusedValueExportToPlacateAjd$1","hasClassInput","hasStyleInput","assertTNodeType","expectedTypes","assertPureTNodeType","hasParentInjector","parentLocation","getParentInjectorIndex","parentInjectorIndex","getParentInjectorViewOffset","getParentInjectorView","startView","viewOffset","parentView","includeViewProviders","setIncludeViewProviders","BLOOM_SIZE","BLOOM_MASK","BLOOM_BUCKET_BITS","nextNgElementId","NOT_FOUND","bloomAdd","bloomHash","mask","getOrCreateNodeInjectorForNode","existingInjectorIndex","getInjectorIndex","insertBloom","blueprint","parentLoc","getParentInjectorLocation","parentIndex","parentData","footer","declarationViewOffset","lViewCursor","getTNodeFromLView","diPublicInInjector","injectAttributeImpl","attrNameToInject","attrsLength","notFoundValueOrThrow","lookupTokenUsingModuleInjector","moduleInjector","previousInjectImplementation","getOrCreateInjectable","embeddedInjectorValue","lookupTokenUsingEmbeddedInjector","lookupTokenUsingNodeInjector","bloomHashBitOrFactory","NodeInjector","previousTView","hostTElementNode","shouldSearchParent","bloomHasToken","searchTokensOnInjector","currentTView","canAccessViewProviders","isHostSpecialCase","injectableIdx","locateDirectiveOrProvider","getNodeInjectable","nodeProviderIndexes","providerIndexes","tInjectables","injectablesStart","directivesStart","cptViewProvidersCount","endIndex","providerTokenOrDef","dirDef","previousIncludeViewProviders","success","tokenId","createNodeInjector","injectorView","isFirstHostTNode","getNodeInjectorLView","nodeInjector","_lView","getNodeInjectorTNode","_tNode","ɵɵgetInheritedFactory","ownConstructor","ownFactory","getFactoryOf","objectPrototype","currentLView","nodeInjectorValue","embeddedViewInjector","embeddedViewInjectorValue","tViewType","ɵɵinjectAttribute","Attribute","attributeName","getReflect","reflectDependencies","convertDependencies","deps","reflectDependency","attribute","param","proto","modules","checkForDuplicateNgModules","assertSameOrNotExisting","incoming","registerNgModuleType","existing","clearModulesForTest","getRegisteredNgModuleType","setAllowDuplicateNgModuleIdsForTest","allowDuplicates","_desc","multi","DOCUMENT","setDocument","document","getDocument","APP_ID","DEFAULT_APP_ID","PLATFORM_INITIALIZER","PLATFORM_ID","PACKAGE_ROOT_URL","ANIMATION_MODULE_TYPE","CSP_NONCE","body","querySelector","getAttribute","ENABLED_SSR_FEATURES","ENVIRONMENT_INITIALIZER","INJECTOR","INJECTOR_DEF_TYPES","NullInjector","makeEnvironmentProviders","importProvidersFrom","sources","internalImportProvidersFrom","checkForStandaloneCmp","providersOut","dedup","injectorTypesWithProviders","collectProviders","cmpDef","internalSource","walkProviderTree","processInjectorTypesWithProviders","typesWithProviders","visitor","ngModule","deepForEachProvider","validateProvider","container","parents","defType","injDef","defName","isDuplicate","importTypesWithProviders","imported","useFactory","useValue","defProviders","injectorType","containerType","isTypeProvider","isValueProvider","isFactoryProvider","isExistingProvider","classRef","useClass","USE_VALUE$1","useExisting","isClassProvider","INJECTOR_SCOPE","NOT_YET","CIRCULAR","NULL_INJECTOR","getNullInjector","R3Injector","destroyed","_destroyed","scopes","records","_ngOnDestroyHooks","_onDestroyHooks","forEachSingleProvider","processProvider","makeRecord","record","injectorDefTypes","assertNotDestroyed","onDestroyHooks","removeOnDestroy","runInContext","previousInjector","couldBeInjectableType","injectableDefInScope","injectableDefOrInjectorDefFactory","hydrate","nextInjector","resolveInjectorInitializers","initializers","initializer","tokens","providerToRecord","multiRecord","hasOnDestroy","getUndecoratedInjectableFactory","paramLength","inheritedInjectableDef","providerToFactory","unwrappedProvider","hasDeps","runInInjectionContext","prevInjectorProfilerContext","prevInjector","assertInInjectionContext","debugFn","angularCoreDiEnv","compileInjectable","ngFactoryDef","compiler","getInjectableMetadata","compileFactory","typeArgumentCount","Injectable","configurable","USE_VALUE","isUseClassProvider","isUseValueProvider","isUseFactoryProvider","isUseExistingProvider","srcMeta","compilerMeta","createInjector","additionalProviders","createInjectorWithoutInjectorInstances","_2","NULL","_3","_4","ɵɵresolveWindow","element","ownerDocument","defaultView","ɵɵresolveDocument","ɵɵresolveBody","INTERPOLATION_DELIMITER","maybeUnwrapFn$1","isPlatformBrowser","CUSTOM_ELEMENTS_SCHEMA","NO_ERRORS_SCHEMA","shouldThrowErrorOnUnknownElement","shouldThrow","shouldThrowErrorOnUnknownProperty","validateElementIsKnown","tagName","hasDirectives","isUnknown","HTMLUnknownElement","customElements","matchingSchemas","isHostStandalone","isHostComponentStandalone","templateLocation","getTemplateLocationDetails","isPropertyValid","handleUnknownPropertyError","nodeType","importLocation","KNOWN_CONTROL_FLOW_DIRECTIVES","correspondingImport","reportUnknownPropertyError","getDeclarationComponentDef","declarationLView","hostComponentDef","componentClassName","schema","SKIP_HYDRATION_ATTR_NAME","hasSkipHydrationAttrOnTNode","SKIP_HYDRATION_ATTR_NAME_LOWER_CASE","mergedAttrs","hasSkipHydrationAttrOnRElement","rNode","hasAttribute","hasInSkipHydrationBlockFlag","isInSkipHydrationBlock","RendererStyleFlags2","COMMENT_DISALLOWED","COMMENT_DELIMITER","COMMENT_DELIMITER_ESCAPED","escapeCommentText","TRACKED_LVIEWS","uniqueIdCounter","getUniqueLViewId","registerLView","getLViewById","unregisterLView","LContext","lViewId","getLContext","mpValue","readPatchedData","isComponentInstance","findViaComponent","isDirectiveInstance","findViaDirective","getDirectivesAtNodeIndex","findViaNativeElement","existingCtx","createLContext","attachPatchData","rElement","parentNode","parentContext","getComponentViewByInstance","patchedData","MONKEY_PATCH_KEY_NAME","readPatchedLView","traverseNextElement","componentIndices","components","elementComponentIndex","componentView","rootComponentView","rootComponent","directiveInstance","directiveIndexStart","directiveIndexEnd","results","getComponentAtNodeIndex","discoverLocalRefs","localNames","localIndex","_icuContainerIterate","icuContainerIterate","tIcuContainerNode","ensureIcuContainerVisitorLoaded","loader","getLViewParent","getRootView","componentOrLView","getRootContext","viewOrComponent","rootView","getFirstLContainer","getNearestLContainer","getNextLContainer","applyToElementOrContainer","action","lNodeToHandle","beforeNode","lContainer","isComponent","nativeAppendChild","nativeInsertBefore","nativeRemoveNode","destroyNode","applyContainer","createTextNode","createText","updateTextNode","setValue","createCommentNode","createComment","createElementNode","namespace","createElement","removeViewFromDOM","applyView","addViewToDOM","parentNativeNode","detachViewFromDOM","destroyViewTree","lViewOrLContainer","cleanUpView","firstView","insertView","indexInContainer","containerLength","declarationLContainer","trackMovedView","lQueries","declarationContainer","movedViews","insertedLContainer","insertedComponentLView","declaredComponentLView","detachMovedView","declarationViewIndex","insertionLContainer","detachView","removeIndex","viewToDetach","removedLView","destroyLView","executeOnDestroys","processCleanups","tCleanup","lCleanup","targetIdx","destroyHooksFn","toCall","callContext","getParentRElement","getClosestRElement","None","isMove","insertBefore","appendChild","nativeAppendOrInsertBefore","nativeRemoveChild","isHostElement","removeChild","isTemplateNode","content","nativeParentNode","nativeNextSibling","nextSibling","getInsertInFrontOfRNode","_getInsertInFrontOfRNodeWithI18n","getInsertInFrontOfRNodeWithNoI18n","_processI18nInsertBefore","setI18nHandling","getInsertInFrontOfRNodeWithI18n","processI18nInsertBefore","childRNode","childTNode","parentRNode","anchorNode","getFirstNativeNode","getBeforeNodeForView","elIcuContainerChild","rNodeOrLContainer","nextRNode","projectionNodes","getProjectionNodes","componentHost","slotIdx","viewIndexInContainer","nextViewIndex","firstTNodeOfView","nativeParent","clearElementContents","textContent","applyNodes","parentRElement","isProjection","rawSlotValue","applyProjectionRecursive","projectionNext","applyProjection","tProjectionNode","componentLView","componentNode","nodeToProjectOrRNodes","nodeToProject","projectedComponentLView","anchor","applyStyling","isClassBased","removeClass","addClass","DashCase","removeStyle","isImportant","endsWith","Important","setStyle","writeDirectStyle","writeDirectClass","removeAttribute","setupStaticAttributes","policy$1","getPolicy$1","trustedTypes","createPolicy","createHTML","s","createScript","createScriptURL","trustedHTMLFromString","html","trustedScriptFromString","script","trustedScriptURLFromString","newTrustedFunctionForDev","fnArgs","fnBody","bind","ɵɵvalidateIframeAttribute","iframe","srcdoc","policy","getPolicy","trustedHTMLFromStringBypass","trustedScriptFromStringBypass","trustedScriptURLFromStringBypass","SafeValueImpl","changingThisBreaksApplicationSecurity","SafeHtmlImpl","getTypeName","SafeStyleImpl","SafeScriptImpl","SafeUrlImpl","SafeResourceUrlImpl","unwrapSafeValue","allowSanitizationBypassAndThrow","actualType","getSanitizationBypassType","bypassSanitizationTrustHtml","trustedHtml","bypassSanitizationTrustStyle","trustedStyle","bypassSanitizationTrustScript","trustedScript","bypassSanitizationTrustUrl","trustedUrl","bypassSanitizationTrustResourceUrl","trustedResourceUrl","getInertBodyHelper","defaultDoc","inertDocumentHelper","InertDocumentHelper","isDOMParserAvailable","DOMParserHelper","getInertBodyElement","window","DOMParser","parseFromString","inertDocument","implementation","createHTMLDocument","templateEl","innerHTML","SAFE_URL_PATTERN","_sanitizeUrl","tagSet","tags","split","sets","VOID_ELEMENTS","OPTIONAL_END_TAG_BLOCK_ELEMENTS","OPTIONAL_END_TAG_INLINE_ELEMENTS","OPTIONAL_END_TAG_ELEMENTS","BLOCK_ELEMENTS","INLINE_ELEMENTS","VALID_ELEMENTS","URI_ATTRS","HTML_ATTRS","ARIA_ATTRS","VALID_ATTRS","SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS","SanitizingHtmlSerializer","sanitizedSomething","buf","sanitizeChildren","el","traverseContent","ELEMENT_NODE","startElement","TEXT_NODE","chars","nodeValue","endElement","checkClobberedElement","nodeName","elAttrs","attributes","elAttr","encodeEntities","nextNode","compareDocumentPosition","DOCUMENT_POSITION_CONTAINED_BY","outerHTML","SURROGATE_PAIR_REGEXP","NON_ALPHANUMERIC_REGEXP","hi","low","inertBodyHelper","_sanitizeHtml","unsafeHtmlInput","inertBodyElement","unsafeHtml","mXSSAttempts","parsedHtml","sanitizer","safeHtml","getTemplateContent","isTemplateElement","SecurityContext","ɵɵsanitizeHtml","getSanitizer","sanitize","HTML","ɵɵsanitizeStyle","unsafeStyle","STYLE","ɵɵsanitizeUrl","unsafeUrl","URL","ɵɵsanitizeResourceUrl","unsafeResourceUrl","RESOURCE_URL","ɵɵsanitizeScript","unsafeScript","SCRIPT","ɵɵtrustConstantHtml","raw","ɵɵtrustConstantResourceUrl","getUrlSanitizer","tag","ɵɵsanitizeUrlOrResourceUrl","validateAgainstEventProperties","startsWith","validateAgainstEventAttributes","makeStateKey","initTransferState","transferState","TransferState","retrieveTransferredState","onSerializeCallbacks","defaultValue","remove","hasKey","isEmpty","onSerialize","toJson","doc","appId","getElementById","parse","REFERENCE_NODE_HOST","REFERENCE_NODE_BODY","NodeNavigationStep","ELEMENT_CONTAINERS","TEMPLATES","CONTAINERS","MULTIPLIER","NUM_ROOT_NODES","TEMPLATE_ID","NODES","DISCONNECTED_NODES","TRANSFER_STATE_TOKEN_ID","NGH_DATA_KEY","NGH_ATTR_NAME","SSR_CONTENT_INTEGRITY_MARKER","_retrieveHydrationInfoImpl","retrieveHydrationInfoImpl","nghAttrValue","componentViewNgh","rootViewNgh","remainingNgh","nghData","dehydratedView","setSegmentHead","markRNodeAsClaimedByHydration","enableRetrieveHydrationInfoImpl","retrieveHydrationInfo","getLNodeForHydration","viewRef","getTextNodeContent","processTextNodeMarkersBeforeHydration","commentNodesIterator","createNodeIterator","NodeFilter","SHOW_COMMENT","acceptNode","isTextNodeMarker","FILTER_ACCEPT","FILTER_REJECT","currentNode","nodes","replaceWith","checkIfAlreadyClaimed","isRNodeClaimedForHydration","__claimed","hydrationInfo","segmentHeads","getSegmentHead","getNgContainerSize","calcSerializedContainerSize","getSerializedContainerViews","views","numNodes","isDisconnectedNode","disconnectedNodes","nodeIds","ComponentRef$1","ComponentFactory$1","noComponentFactoryError","ERROR_COMPONENT","getComponent$1","_NullComponentFactoryResolver","resolveComponentFactory","ComponentFactoryResolver$1","injectElementRef","createElementRef","ElementRef","unwrapElementRef","Renderer2","injectRenderer2","nodeAtIndex","Sanitizer","Version","full","major","minor","patch","VERSION","NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR","ERROR_ORIGINAL_ERROR","wrappedError","originalError","getOriginalError","ErrorHandler","_console","handleError","_findOriginalError","DestroyRef","injectDestroyRef","NodeInjectorDestroyRef","EventEmitter_","isAsync","__isAsync","emit","observerOrNext","complete","nextFn","errorFn","completeFn","observer","_wrapInTimeout","sink","setTimeout","EventEmitter","noop","getNativeRequestAnimationFrame","isBrowser","nativeRequestAnimationFrame","nativeCancelAnimationFrame","unpatchedRequestAnimationFrame","unpatchedCancelAnimationFrame","AsyncStackTaggingZoneSpec","namePrefix","consoleAsyncStackTaggingImpl","createTask","onScheduleTask","delegate","_current","task","consoleTask","scheduleTask","onInvokeTask","_currentZone","targetZone","applyThis","applyArgs","ret","invokeTask","enableLongStackTrace","shouldCoalesceEventChangeDetection","shouldCoalesceRunChangeDetection","hasPendingMicrotasks","assertZonePatched","_nesting","_outer","_inner","fork","lastRequestAnimationFrameId","forkInnerZoneWithAngularBehavior","isInAngularZone","assertInAngularZone","assertNotInAngularZone","runTask","zone","scheduleEventTask","EMPTY_PAYLOAD","cancelTask","runGuarded","checkStable","delayChangeDetectionForEvents","isCheckStableRunning","fakeTopEventTask","root","updateMicroTaskStatus","invoke","delayChangeDetectionForEventsDelegate","properties","shouldBeIgnoredByZone","onEnter","onLeave","onInvoke","onHasTask","hasTaskState","hasTask","change","_hasPendingMicrotasks","microTask","macroTask","onHandleError","NoopNgZone","ZONE_IS_STABLE_OBSERVABLE","isStableFactory","_stable","isCurrentlyStable","stableSub","unstableSub","pipe","afterRender","unregisterFn","afterRenderEventManager","AfterRenderEventManager","callbackHandler","handler","AfterRenderCallbackHandlerImpl","errorHandler","AfterRenderCallback","unregister","register","afterNextRender","callbackFn","executingCallbacks","callbacks","deferredCallbacks","validateBegin","execute","renderDepth","begin","markViewDirty","IS_HYDRATION_DOM_REUSE_ENABLED","PRESERVE_HOST_CONTENT_DEFAULT","PRESERVE_HOST_CONTENT","normalizeDebugBindingName","camelCaseToDashCase","CAMEL_CASE_REGEXP","m","normalizeDebugBindingValue","VALUE_STRING_LENGTH_LIMIT","assertStandaloneComponentType","assertComponentDef","throwMultipleComponentError","first","second","throwErrorIfNoChangesMode","creationMode","currValue","formatValue","strValue","constructDetailsForInterpolation","rootIndex","expressionIndex","changedValue","prefix","chunks","getExpressionChangedErrorDetails","matches","RegExp","currentConsumer","setLViewForConsumer","getReactiveLViewConsumer","slot","getOrCreateCurrentLViewConsumer","commitLViewConsumerIfHasProducers","createLViewConsumer","REACTIVE_LVIEW_CONSUMER_NODE","NO_CHANGE","__brand__","ɵɵadvance","delta","selectIndexInternal","checkNoChangesMode","hooksInitPhaseCompleted","ɵɵdirectiveInject","ɵɵinvalidFactory","processHostBindingOpCodes","hostBindingOpCodes","opCode","directiveIdx","bindingRootIndx","hostBindingFn","createLView","tHostNode","environment","getOrCreateTNode","createTNodeAtIndex","createTNode","allocExpando","numSlotsToAlloc","allocIdx","executeTemplate","templateFn","rf","prevSelectedIndex","isUpdatePhase","preHookType","effectiveConsumer","postHookType","executeContentQueries","createDirectivesInstances","instantiateAllDirectives","invokeDirectivesHostBindings","saveResolvedLocalsInData","viewData","localRefExtractor","getOrCreateComponentTView","incompleteFirstPass","createTView","constsOrFactory","ssrId","initialViewLength","createViewBlueprint","queries","fill","staticViewQueries","staticContentQueries","directiveRegistry","pipeRegistry","seal","locateHostElement","elementOrSelector","preserveHostContent","preserveContent","ShadowDom","rootElement","selectRootElement","applyRootElementTransform","_applyRootElementTransformImpl","applyRootElementTransformImpl","enableApplyRootElementTransformImpl","storeCleanupWithContext","getOrCreateLViewCleanup","getOrCreateTViewCleanup","tParent","insertBeforeIndex","directiveStylingLast","propertyBindings","initialInputs","stylesWithoutHost","residualStyles","classesWithoutHost","residualClasses","classBindings","styleBindings","generatePropertyAliases","aliasMap","propertyAliases","hostDirectiveAliasMap","internalName","addPropertyAlias","initializeInputAndOutputAliases","hostDirectiveDefinitionMap","tViewData","tNodeAttrs","inputsFromAttrs","inputsStore","outputsStore","aliasData","aliasedInputs","aliasedOutputs","generateInitialInputs","mapPropName","elementPropertyInternal","nativeOnly","inputData","dataValue","setInputsForProperty","markDirtyIfOnPush","setNgReflectProperties","viewIndex","childComponentLView","setNgReflectProperty","debugValue","resolveDirectives","localRefs","exportsMap","matchResult","findDirectiveDefMatches","hostDirectiveDefs","initializeDirectives","cacheMatchingLocalNames","initTNodeFlags","preOrderHooksFound","preOrderCheckHooksFound","configureViewWithDirective","saveNameToExportMap","lifeCycleHooks","registerHostBindingOpCodes","directiveVarsIdx","elementIndx","lastSelectedElementIdx","addComponentLogic","setInputsFromAttrs","elementIndex","dirIndex","invokeHostBindingsInCreationMode","registry","find","hostDirectiveMatches","markAsComponentHost","hostTNode","numberOfDirectives","directiveFactory","nodeInjectorFactory","rendererFactory","lViewFlags","addToViewTree","createRenderer","elementAttributeInternal","setElementAttribute","initialInputData","writeToDirectiveInput","inputsToStore","createLContainer","hostNative","refreshContentQueries","queryStartIdx","directiveDefIdx","executeViewQueryFn","viewQueryFn","storePropertyBindingMetadata","propertyName","interpolationParts","propBindingIdxs","bindingMetadata","loadComponentRenderer","currentDef","textBindingInternal","renderComponent","hostLView","componentHostIdx","componentTView","syncViewWithBlueprint","hostRNode","renderView","renderChildComponents","EffectManager","effectFn","destroyRef","w","unregisterOnDestroy","isQueueEmpty","effect","effectManager","manualCleanup","computeStaticStyling","writeToHost","styleValue","collectNativeNodes","lNode","collectNativeNodesInLContainer","nodesInSlot","lViewInAContainer","lViewFirstChildTNode","detectChangesInternal","notifyErrorHandler","refreshView","checkNoChangesInternal","isInCheckNoChangesPass","markTransplantedViewsForRefresh","detectChangesInEmbeddedViews","detectChangesInChildComponents","embeddedLView","detectChangesInView","movedLView","detectChangesInComponent","ViewRef","rootNodes","_cdRefInjectingView","_appRef","_attachedToViewContainer","viewRefs","markForCheck","detach","reattach","attachToViewContainerRef","detachFromAppRef","attachToAppRef","appRef","RootViewRef","_view","ComponentFactoryResolver","ComponentFactory","toRefArray","nonMinified","minified","templateName","getNamespace","elementName","ChainedInjector","parentInjector","refArray","transform","componentType","isBoundToModule","projectableNodes","rootSelectorOrNode","environmentInjector","realEnvironmentInjector","rootViewInjector","hostRenderer","signalFlags","nonSignalFlags","rootFlags","rootTView","rootLView","tElementNode","rootComponentDef","rootDirectives","createRootComponentTNode","createRootComponentView","setRootNodeAttributes","projectNodes","createRootComponent","LifecycleHooksFeature","ComponentRef","_rootLView","previousInputValues","cmpNameForError","applyRootComponentStyling","viewRenderer","hostFeatures","rootTNode","feature","nodesforSlot","from","getSuperType","ɵɵInheritDefinitionFeature","superType","shouldInheritFields","inheritanceChain","superDef","writeableDef","maybeUnwrapEmpty","superHostBindings","inheritHostBindings","superViewQuery","superContentQueries","inheritViewQuery","inheritContentQueries","animation","defData","mergeHostAttrsAcrossInheritance","prevViewQuery","ctx","prevContentQueries","prevHostBindings","COPY_DIRECTIVE_FIELDS","COPY_COMPONENT_FIELDS","ɵɵCopyDefinitionFeature","defAny","ɵɵHostDirectivesFeature","rawHostDirectives","dir","bindingArrayToMap","matchedDefs","hostDirectiveConfig","hostDirectiveDef","validateHostDirective","patchDeclaredInputs","bindings","exposedInputs","remappedPublicName","validateMappings","bindingType","hostDirectiveBindings","ɵɵInputTransformsFeature","isIterable","iterator","isListLikeIterable","isJsObject","areIterablesEqual","comparator","iterator1","iterator2","item1","item2","done","iterateListLike","o","devModeEqual","isListLikeIterableA","isListLikeIterableB","isAObject","isBObject","updateBinding","getBinding","bindingUpdated","oldValueToCompare","details","bindingUpdated2","exp1","exp2","different","bindingUpdated3","exp3","bindingUpdated4","exp4","ɵɵattribute","interpolationV","isBindingUpdated","interpolation1","v0","suffix","interpolation2","i0","v1","interpolation3","i1","v2","interpolation4","i2","v3","interpolation5","i3","v4","interpolation6","i4","v5","interpolation7","i5","v6","interpolation8","i6","v7","ɵɵattributeInterpolate1","interpolatedValue","ɵɵattributeInterpolate2","ɵɵattributeInterpolate3","ɵɵattributeInterpolate4","ɵɵattributeInterpolate5","ɵɵattributeInterpolate6","ɵɵattributeInterpolate7","ɵɵattributeInterpolate8","ɵɵattributeInterpolateV","interpolated","interpolationInBetween","AT_THIS_LOCATION","getFriendlyStringFromTNodeType","validateMatchingNode","isViewContainerAnchor","expectedNode","shortRNodeDescription","header","describeExpectedDom","actualNode","describeDomFromNode","getHydrationErrorFooter","getHydrationAttributeNote","validateSiblingNodeExists","validateNodeExists","nodeNotFoundError","nodeNotFoundAtPathError","describeRNode","unsupportedProjectionOfDomNodes","invalidSkipHydrationHost","stringifyTNodeAttrs","shorten","internalAttrs","stringifyRNodeAttrs","describeTNode","innerContent","typeAsString","COMMENT_NODE","spacer","previousSibling","componentInfo","stripNewlines","maxLength","REF_EXTRACTOR_REGEXP","compressNodeLocation","referenceNode","segment","decompressNodeLocation","refNodeId","refNodeName","rest","parseInt","steps","step","matchAll","repeat","isFirstElementInNgContainer","getNoOffsetIndex","locateNextRNode","noOffsetIndex","locateRNodeByPath","previousTNodeParent","previousTNode","noOffsetParentIndex","previousRElement","noOffsetPrevSiblingIndex","segmentHead","numRootNodesToSkip","nodesToSkip","siblingAfter","skip","stringifyNavigationInstructions","instructions","r","FirstChild","navigateToNode","NextSibling","navigationInstructions","parentElementId","navigateBetween","finish","parentElement","navigateBetweenSiblings","parentPath","childPath","nav","calcPathBetween","to","fromNodeName","calcPathForNode","referenceNodeName","firstRNode","templateFirstCreatePass","attrsIndex","localRefsIndex","tViewConsts","embeddedTView","ɵɵtemplate","adjustedIndex","comment","_locateOrCreateContainerAnchor","createContainerAnchorImpl","locateOrCreateContainerAnchorImpl","isNodeCreationMode","currentRNode","viewContainerSize","enableLocateOrCreateContainerAnchorImpl","ɵɵreference","ɵɵproperty","setDirectiveInputsWhichShadowsStyling","property","elementStartFirstCreatePass","elementStart","ɵɵelementStart","_locateOrCreateElementNode","ɵɵelementEnd","elementEnd","ɵɵelement","locateOrCreateElementNodeImpl","enableLocateOrCreateElementNodeImpl","elementContainerStartFirstCreatePass","ɵɵelementContainerStart","_locateOrCreateElementContainerNode","ɵɵelementContainerEnd","ɵɵelementContainer","locateOrCreateElementContainerNode","ngContainerSize","enableLocateOrCreateElementContainerNodeImpl","ɵɵgetCurrentView","isPromise","isSubscribable","ɵɵlistener","eventName","listenerFn","useCapture","eventTargetResolver","listenerInternal","ɵɵsyntheticHostListener","findExistingListener","tNodeIdx","cleanupEventName","listenerIdxInLCleanup","isTNodeDirectiveHost","processOutputs","lCleanupIndex","idxOrTargetGetter","existingListener","lastListenerFn","__ngLastListenerFn__","__ngNextListenerFn__","wrapListener","listen","propsLength","minifiedName","output","subscription","executeListenerWithErrorHandling","wrapWithPreventDefault","wrapListenerIn_markDirtyAndPreventDefault","nextListenerFn","preventDefault","ɵɵnextContext","matchingProjectionSlotIndex","projectionSlots","wildcardNgContentIndex","ngProjectAsAttrVal","ɵɵprojectionDef","numProjectionSlots","projectionHeads","tails","componentChild","slotIndex","ɵɵprojection","selectorIndex","ɵɵpropertyInterpolate","ɵɵpropertyInterpolate1","ɵɵpropertyInterpolate2","ɵɵpropertyInterpolate3","ɵɵpropertyInterpolate4","ɵɵpropertyInterpolate5","ɵɵpropertyInterpolate6","ɵɵpropertyInterpolate7","ɵɵpropertyInterpolate8","ɵɵpropertyInterpolateV","toTStylingRange","getTStylingRangePrev","tStylingRange","getTStylingRangePrevDuplicate","setTStylingRangePrev","setTStylingRangePrevDuplicate","getTStylingRangeNext","setTStylingRangeNext","getTStylingRangeNextDuplicate","setTStylingRangeNextDuplicate","getTStylingRangeTail","__unused_const_as_closure_does_not_like_standalone_comment_blocks__","insertTStylingBinding","tStylingKeyWithStatic","isHostBinding","isClassBinding","tBindings","tmplHead","tmplTail","isKeyDuplicateOfStatic","tStylingKey","staticKeyValueArray","hasTemplateBindings","previousNode","markDuplicates","markDuplicateOfResidualStyling","residual","isPrevDir","tStylingAtIndex","isMap","cursor","foundDuplicate","tStylingValueAtCursor","tStyleRangeAtCursor","isStylingMatch","tStylingKeyCursor","parserState","textEnd","keyEnd","valueEnd","getLastParsedKey","getLastParsedValue","parseClassName","resetParserState","parseClassNameNext","consumeWhitespace","consumeClassToken","parseStyle","parseStyleNext","consumeStyleKey","consumeSeparator","consumeStyleValue","ch","malformedStyleError","fromCharCode","ch1","ch2","ch3","lastChIndex","consumeQuotedText","quoteCharCode","expecting","ɵɵstyleProp","checkStylingProperty","ɵɵclassProp","ɵɵstyleMap","checkStylingMap","styleKeyValueArraySet","styleStringParser","ɵɵclassMap","classKeyValueArraySet","classStringParser","stylingFirstUpdatePass","updateStyling","normalizeSuffix","stringParser","hasStylingInputShadow","isInHostBindings","staticPrefix","updateStylingMap","toStylingKeyValueArray","isHostBindings","wrapInStaticStylingKey","stylingKey","isFirstStylingInstructionInTemplate","collectStylingFromDirectives","collectStylingFromTAttrs","isFirstStylingInstructionInHostBinding","templateStylingKey","getTemplateHeadTStylingKey","setTemplateHeadTStylingKey","collectResidual","currentDirective","desiredMarker","currentMarker","styleKeyValueArray","unwrappedValue","stringKey","includes","oldKeyValueArray","newKeyValueArray","oldIndex","newIndex","oldKey","newKey","setKey","tRange","higherPriorityValue","findStylingValue","isStylingValuePresent","isPrevDirection","rawKey","containsStatics","isStylingMap","valueAtLViewIndex","ɵɵtext","textNative","_locateOrCreateTextNode","locateOrCreateTextNodeImpl","enableLocateOrCreateTextNodeImpl","ɵɵtextInterpolate","ɵɵtextInterpolate1","ɵɵtextInterpolate2","ɵɵtextInterpolate3","ɵɵtextInterpolate4","ɵɵtextInterpolate5","ɵɵtextInterpolate6","ɵɵtextInterpolate7","ɵɵtextInterpolate8","ɵɵtextInterpolateV","ɵɵclassMapInterpolate1","ɵɵclassMapInterpolate2","ɵɵclassMapInterpolate3","ɵɵclassMapInterpolate4","ɵɵclassMapInterpolate5","ɵɵclassMapInterpolate6","ɵɵclassMapInterpolate7","ɵɵclassMapInterpolate8","ɵɵclassMapInterpolateV","ɵɵstyleMapInterpolate1","ɵɵstyleMapInterpolate2","ɵɵstyleMapInterpolate3","ɵɵstyleMapInterpolate4","ɵɵstyleMapInterpolate5","ɵɵstyleMapInterpolate6","ɵɵstyleMapInterpolate7","ɵɵstyleMapInterpolate8","ɵɵstyleMapInterpolateV","ɵɵstylePropInterpolate1","valueSuffix","ɵɵstylePropInterpolate2","ɵɵstylePropInterpolate3","ɵɵstylePropInterpolate4","ɵɵstylePropInterpolate5","ɵɵstylePropInterpolate6","ɵɵstylePropInterpolate7","ɵɵstylePropInterpolate8","ɵɵstylePropInterpolateV","ɵɵhostProperty","ɵɵsyntheticHostProperty","ngI18nClosureMode","goog","getMsg","u","plural","val","n","floor","localeEn","LOCALE_DATA","registerLocaleData","localeId","extraData","LocaleDataIndex","LocaleId","ExtraData","findLocaleData","locale","normalizedLocale","normalizeLocale","getLocaleData","parentLocale","getLocaleCurrencyCode","CurrencyCode","getLocalePluralCase","PluralCase","ng","common","locales","unregisterAllLocaleData","pluralMapping","getPluralCase","DEFAULT_LOCALE_ID","USD_CURRENCY_CODE","ELEMENT_MARKER","ICU_MARKER","I18nCreateOpCode","unusedValueExportToPlacateAjd","setLocaleId","getLocaleId","tNodeInsertBeforeIndex","i18nParent","anchorRNode","i18nChild","addTNodeAndUpdateInsertBeforeIndex","previousTNodes","newTNode","existingTNode","isI18nText","isNewTNodeCreatedBefore","getInsertBeforeIndex","setInsertBeforeIndex","getTIcu","setTIcu","setTNodeInsertBeforeIndex","createTNodePlaceholder","getCurrentICUCaseIndex","currentCase","getParentFromIcuCreateOpCode","mergedCode","getRefFromIcuCreateOpCode","getInstructionFromIcuCreateOpCode","icuCreateOpCode","parentIdx","refIdx","changeMask","changeMaskCounter","setMaskBit","hasChange","min","applyI18n","tI18n","updateOpCodes","bindingsStartIndex","applyUpdateOpCodes","applyCreateOpCodes","createOpCodes","insertInFrontOf","isComment","COMMENT","appendNow","APPEND_EAGERLY","SHIFT","applyMutableOpCodes","mutableOpCodes","rootIdx","rootRNode","textNodeIndex","caseIndex","anchorIdx","elementNodeIndex","commentValue","commentNodeIndex","commentRNode","elementRNode","checkBit","skipCodes","sanitizeFn","tNodeOrTagName","rText","applyIcuSwitchCase","applyIcuUpdateCase","currentIndex","activeCaseIndex","getCaseIndex","applyIcuSwitchCaseRemove","removeCodes","nodeOrIcuIndex","icuExpression","bindingValue","cases","resolvedCase","loadIcuContainerVisitor","_stack","_index","_removes","icuContainerIteratorStart","enterIcu","icuContainerIteratorNext","removeOpCode","tIcuIndex","i18nCreateOpCodesToString","opcodes","lines","i18nUpdateOpCodesToString","parser","OpCodeParser","consumeOpCode","consumeString","sanitizationFn","consumeFunction","hasMore","consumeNumber","statements","statement","consumeNumberOrString","opCodeText","icuCreateOpCodesToString","lastRef","consumeNumberStringOrMarker","line","i18nRemoveOpCodesToString","codes","BINDING_REGEXP","ICU_REGEXP","NESTED_ICU","ICU_BLOCK_REGEXP","MARKER","SUBTEMPLATE_REGEXP","PH_REGEXP","NGSP_UNICODE_REGEXP","replaceNgsp","attachDebugGetter","debugGetter","enumerable","i18nStartFirstCreatePass","parentTNodeIndex","subTemplateIndex","existingTNodeStack","getTranslationForTemplate","msgParts","i18nParseTextIntoPartsAndICU","part","i18nStartFirstCreatePassProcessTextNode","icuContainerTNode","createTNodeAndAddOpCode","mainBinding","icuNodeIndex","icuStart","isClosing","existingTNodes","isICU","i18nNodeIdx","hasBinding","generateBindingUpdateOpCodes","i18nAttributesFirstPass","previousElement","previousElementIndex","countBindings","str","destinationNode","bindingStart","maskIndex","sizeIndex","textParts","textValue","toMaskBit","opCodes","isRootTemplateMessage","removeInnerTemplateTranslation","inTemplate","tagMatched","exec","search","bindingMask","addUpdateIcuSwitch","valueArr","nestedIcus","icuIndex","parseIcuCase","addUpdateIcuUpdate","parseICUBlock","pattern","icuType","binding","pos","blocks","prevPos","braceStack","braces","lastIndex","block","caseName","unsafeCaseHtml","inertRootNode","walkIcuTree","sharedUpdateOpCodes","depth","addCreateNodeAndAppend","lowerAttrName","addCreateAttribute","addRemoveNode","isNestedIcu","nestedIcuIndex","addRemoveNestedIcu","appendToParentIdx","createAtIdx","ROOT_TEMPLATE_ID","PP_MULTI_VALUE_PLACEHOLDERS_REGEXP","PP_PLACEHOLDERS_REGEXP","PP_ICU_VARS_REGEXP","PP_ICU_PLACEHOLDERS_REGEXP","PP_ICUS_REGEXP","PP_CLOSE_TEMPLATE_REGEXP","PP_TEMPLATE_ID_REGEXP","i18nPostprocess","replacements","templateIdsStack","phs","tmpl","placeholders","placeholder","templateId","isCloseTemplateTag","currentTemplateId","_type","_idx","ɵɵi18nStart","messageIndex","sameViewParentTNode","ɵɵi18nEnd","ɵɵi18n","ɵɵi18nAttributes","ɵɵi18nExp","ɵɵi18nApply","ɵɵi18nPostprocess","ɵɵdefer","deferredDepsFn","viewProviders","resolveProvider","lInjectablesBlueprint","providerFactory","beginIndex","existingFactoryIndex","registerDestroyHooksIfSupported","existingProvidersFactoryIndex","existingViewProvidersFactoryIndex","doesProvidersFactoryExist","doesViewProvidersFactoryExist","multiFactory","multiViewProvidersFactoryResolver","multiProvidersFactoryResolver","indexInFactory","multiFactoryAdd","componentProviders","contextIndex","providerIsTypeProvider","providerIsClassProvider","classToken","existingCallbacksIndex","isComponentProvider","lData","multiResolve","factories","componentCount","multiProviders","factoryFn","f","ɵɵProvidersFeature","processProvidersFn","NgModuleRef$1","NgModuleFactory$1","createNgModule","NgModuleRef","createNgModuleRef","_parent","_bootstrapComponents","destroyCbs","componentFactoryResolver","_r3Injector","NgModuleFactory","moduleType","createNgModuleRefWithProviders","EnvironmentNgModuleRefAdapter","config","debugName","runEnvironmentInitializers","createEnvironmentInjector","adapter","StandaloneService","_injector","cachedInjectors","getOrCreateStandaloneInjector","standaloneInjector","ɵɵStandaloneFeature","getComponent","assertDomElement","getContext","getOwningComponent","elementOrDir","getRootComponents","getInjector","getInjectionTokens","providerTokens","isDirectiveDefHack","getDirectives","Text","getDirectiveMetadata","directiveOrComponentInstance","getLocalRefs","getHostElement","componentOrDirective","getRenderedText","hostElement","getListeners","lContext","listeners","firstParam","secondParam","listenerElement","useCaptureOrIndx","sort","sortListeners","getComponentLView","nodeIndx","Element","setClassMetadata","clazz","ɵɵpureFunction0","slotOffset","pureFn","thisArg","ɵɵpureFunction1","exp","pureFunction1Internal","ɵɵpureFunction2","pureFunction2Internal","ɵɵpureFunction3","pureFunction3Internal","ɵɵpureFunction4","pureFunction4Internal","ɵɵpureFunction5","exp5","ɵɵpureFunction6","exp6","ɵɵpureFunction7","exp7","ɵɵpureFunction8","exp8","ɵɵpureFunctionV","exps","pureFunctionVInternal","getPureFunctionReturnValue","returnValueIndex","lastReturnValue","bindingRoot","ɵɵpipe","pipeName","getPipeDef","pipeFactory","previousInjectorProfilerContext","pipeInstance","getMultipleMatchingPipesMessage","getPipeNotFoundErrorMessage","hostIsStandalone","componentInfoMessage","verifyMessage","ɵɵpipeBind1","isPure","ɵɵpipeBind2","ɵɵpipeBind3","ɵɵpipeBind4","ɵɵpipeBindV","symbolIterator","_results","QueryList","changes","_changes","_emitDistinctChangesOnly","_changesDetected","last","reduce","init","some","toArray","reset","resultsTree","newResultFlat","notifyOnChanges","setDirty","createAndRenderEmbeddedLView","templateTNode","isSignalView","viewFlags","declarationViewLQueries","createEmbeddedView","getLViewFromLContainer","addLViewToLContainer","addToDOM","removeLViewFromLContainer","TemplateRef","injectTemplateRef","ViewEngineTemplateRef","R3TemplateRef","_declarationLView","_declarationTContainer","createEmbeddedViewImpl","createTemplateRef","removeDehydratedViews","removeDehydratedView","nodesRemoved","cleanupLContainer","cleanupLView","cleanupDehydratedViews","_views","locateDehydratedViewsInContainer","serializedViews","dehydratedViews","serializedView","_findMatchingDehydratedViewImpl","findMatchingDehydratedViewImpl","enableFindMatchingDehydratedViewImpl","findMatchingDehydratedView","ViewContainerRef","injectViewContainerRef","createContainerRef","VE_ViewContainerRef","R3ViewContainerRef","_lContainer","_hostTNode","_hostLView","getViewRefs","templateRef","indexOrOptions","skipDomInsertion","insertImpl","createComponent","componentFactoryOrType","isComponentFactory","ngModuleRef","componentFactory","contextInjector","insert","prevIdx","prevLContainer","prevVCRef","adjustedIdx","_adjustIndex","getOrCreateViewRefs","move","viewRefsArr","detachedView","wasDetached","_locateOrCreateAnchorNode","insertAnchorNode","commentNode","parentOfHostNative","createAnchorNode","locateOrCreateAnchorNode","skipHydration","enableLocateOrCreateContainerRefImpl","LQuery_","queryList","clone","LQueries_","tQueries","noOfInheritedQueries","viewLQueries","tQuery","getByIndex","parentLQuery","indexInDeclarationView","dirtyQueriesWithMatches","getTQuery","TQueryMetadata_","predicate","read","TQueries_","queriesForTemplateRef","childQueryIndex","tqueryClone","track","tquery","TQuery_","crossesNgTemplate","_appliesToNextNode","_declarationNodeIndex","isApplyingToNode","matchTNode","addMatch","declarationNodeIdx","matchTNodeWithReadOption","getIdxOfMatchingSelector","nodeMatchIdx","directiveOrProviderIdx","matchIdx","createResultByTNodeType","createResultForNode","matchingIdx","createSpecialToken","materializeViewResults","queryIndex","lQuery","tQueryMatches","matchedNodeIdx","collectQueryResults","lViewResults","embeddedLViews","ɵɵqueryRefresh","ɵɵviewQuery","createTQuery","createLQuery","ɵɵcontentQuery","saveContentQueryAndDirectiveIndex","ɵɵloadQuery","loadQueryInternal","tViewContentQueries","lastSavedDirectiveIndex","ɵɵtemplateRefExtractor","angularCoreEnv","patchModuleCompilation","isModuleWithProviders$1","isNgModule$1","isPipe","isDirective","moduleQueue","enqueueModuleForDelayedScoping","flushingModuleQueue","flushModuleScopingQueueAsMuchAsPossible","every","isResolvedDeclaration","setScopeOnDeclaredComponents","declaration","compileNgModule","compileNgModuleDefs","allowDuplicateDeclarationsInRoot","expandModuleWithProviders","verifySemanticsOfNgModuleDef","compileInjector","generateStandaloneInDeclarationsError","importingModule","verifiedNgModule","errors","unwrapModuleWithProvidersImports","modOrStandaloneCmpt","verifySemanticsOfNgModuleImport","verifyDeclarationsHaveDefinitions","verifyDirectivesHaveSelector","declarationType","verifyNotStandalone","combinedDeclarations","computeCombinedExports","verifyExportsAreDeclaredOrReExported","decl","verifyDeclarationIsUnique","getAnnotation","mod","verifyCorrectBootstrapType","verifyComponentIsPartOfNgModule","lastIndexOf","suppressErrors","existingModule","ownerNgModule","typeOrWithProviders","collect","__annotations__","readAnnotation","WeakMap","resetCompiledComponents","transitiveScopes","transitiveScopesFor","patchComponentDefWithScope","ngSelectorScope","compilation","transitiveScopesForNgModule","exported","importedScope","entry","declared","declaredWithDefs","exportedType","exportedScope","_nextReferenceId","MetadataOverrider","_references","overrideMetadata","metadataClass","oldMetadata","override","_valueProps","setMetadata","removeMetadata","addMetadata","references","removeObjects","removeValue","_propHashKey","propValue","addValue","nextObjectId","objectIds","replacer","_serializeReference","protoProp","desc","getOwnPropertyDescriptor","reflection","OverrideResolver","overrides","resolved","addOverride","setOverrides","isKnownType","overrider","DirectiveResolver","ComponentResolver","PipeResolver","NgModuleResolver","TestingModuleOverride","isTestingModuleOverride","DECLARATION","OVERRIDE_TEMPLATE","assertNoStandaloneComponents","resolver","TestBedCompiler","platform","additionalModuleTypes","originalComponentResolutionQueue","pendingComponents","pendingDirectives","pendingPipes","seenComponents","seenDirectives","overriddenModules","existingComponentStyles","resolvers","initResolvers","componentToModuleScope","initialNgDefs","defCleanupOps","compilerProviders","providerOverrides","rootProviderOverrides","providerOverridesByModule","providerOverridesByToken","scopesWithOverriddenProviders","testModuleRef","DynamicTestModule","testModuleType","setCompilerProviders","configureTestingModule","moduleDef","queueTypeArray","queueTypesFromModulesArray","overrideModule","module","invalidTypeError","recompileNgModule","overrideComponent","verifyNoStandaloneFlagOverrides","overrideDirective","overridePipe","overrideProvider","providerDef","overridesBucket","existingOverrides","overrideTemplateUsingTestingModule","hasStyleUrls","overrideStyleUrls","compileComponents","_this","_asyncToGenerator","clearComponentResolutionQueue","needsAsyncResources","compileTypesSync","resourceLoader","finalize","compileTestModule","applyTransitiveScopes","applyProviderOverrides","patchComponentsWithExistingStyles","runInitializers","_compileNgModuleSync","applyProviderOverridesInScope","_compileNgModuleAsync","_this2","_getModuleResolver","_getComponentFactories","maybeUnwrapFn","maybeStoreNgDef","testingModuleDef","affectedModules","collectModulesAffectedByOverrides","storeFieldOfDefOnType","moduleToScope","getScopeOfModule","isTestingModule","realType","moduleScope","maybeApplyOverrides","hasProviderOverrides","patchDefWithProviderOverrides","hasScope","isStandaloneComponent","isNgModule","injectorDef","getComponentDef","dependency","getOverriddenProviders","importedModule","flatten","isModuleWithProviders","object","fieldName","originalValue","queueType","processedDefs","queueTypesFromModulesArrayRecur","hasNgModuleDef","seenModules","calcAffectedModulesRecur","currentDefs","defField","restoreOriginalState","forEachRight","op","defs","descriptor","RootScopeModule","R3TestCompiler","compilerOptions","getSingleProviderOverrides","getProviderToken","getProviderOverrides","flattenProviders","flattenedProviders","overriddenProviders","final","seenOverriddenProviders","ngDef","maybeFn","out","identityFn","mapFn","getProviderField","expectedType","testBed","compileModuleSync","compileModuleAsync","_this3","compileModuleAndAllComponentsSync","ngModuleFactory","componentFactories","compileModuleAndAllComponentsAsync","_this4","clearCache","clearCacheFor","getModuleId","_nextRootElementId","getTestBed","TestBedImpl","INSTANCE","_compiler","_testModuleRef","_activeFixtures","globalCompilationChecked","_INSTANCE","initTestEnvironment","resetTestEnvironment","configureCompiler","overrideTemplate","inject","resetTestingModule","_environmentTeardownOptions","teardown","_environmentErrorOnUnknownElementsOption","errorOnUnknownElements","_environmentErrorOnUnknownPropertiesOption","errorOnUnknownProperties","checkGlobalCompilationFinished","_previousErrorOnUnknownElementsOption","_previousErrorOnUnknownPropertiesOption","destroyActiveFixtures","shouldTearDownTestingModule","tearDownTestingModule","_instanceTeardownOptions","_instanceErrorOnUnknownElementsOption","_instanceErrorOnUnknownPropertiesOption","useJit","assertNotInstantiated","shouldThrowErrorOnUnknownElements","shouldThrowErrorOnUnknownProperties","TestBed","UNDEFINED","params","testComponentRenderer","rootElId","noNgZone","initComponent","fixture","methodName","methodDescription","errorCount","stacktrace","shouldRethrowTeardownErrors","instanceOptions","environmentOptions","rethrowErrors","destroyAfterEach","testRenderer","InjectSetupWrapper","_moduleDef","_addModule","withModule","beforeEach","getCleanupHook","afterEach","expectedTeardownValue","__core_private_testing_placeholder__","ɵMetadataOverrider"],"sources":["/Users/frazerlinscott/Desktop/Software Frameworks/Assignments/Assignment1_SoftwareFrames_s2930588/node_modules/@angular/core/fesm2022/testing.mjs"],"sourcesContent":["/**\n * @license Angular v16.2.6\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { getDebugNode, RendererFactory2 as RendererFactory2$1, InjectionToken as InjectionToken$1, ɵstringify, ɵReflectionCapabilities, Directive, Component, Pipe, NgModule, ɵgetInjectableDef, resolveForwardRef as resolveForwardRef$1, ɵNG_COMP_DEF, ɵRender3NgModuleRef, ApplicationInitStatus, LOCALE_ID as LOCALE_ID$1, ɵDEFAULT_LOCALE_ID, ɵsetLocaleId, ɵRender3ComponentFactory, ɵcompileComponent, ɵNG_DIR_DEF, ɵcompileDirective, ɵNG_PIPE_DEF, ɵcompilePipe, ɵNG_MOD_DEF, ɵtransitiveScopesFor, ɵpatchComponentDefWithScope, ɵNG_INJ_DEF, ɵcompileNgModuleDefs, provideZoneChangeDetection, Compiler, COMPILER_OPTIONS, Injector as Injector$1, ɵisEnvironmentProviders, ɵNgModuleFactory, ModuleWithComponentFactories, ɵconvertToBitFlags, InjectFlags as InjectFlags$1, ɵsetAllowDuplicateNgModuleIdsForTest, ɵresetCompiledComponents, ɵsetUnknownElementStrictMode as ɵsetUnknownElementStrictMode$1, ɵsetUnknownPropertyStrictMode as ɵsetUnknownPropertyStrictMode$1, ɵgetUnknownElementStrictMode as ɵgetUnknownElementStrictMode$1, ɵgetUnknownPropertyStrictMode as ɵgetUnknownPropertyStrictMode$1, EnvironmentInjector as EnvironmentInjector$1, NgZone as NgZone$1, ɵflushModuleScopingQueueAsMuchAsPossible } from '@angular/core';\nimport { ResourceLoader } from '@angular/compiler';\nimport { Subject, Subscription, Observable, merge as merge$1 } from 'rxjs';\nimport { share } from 'rxjs/operators';\n\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {@link inject} call.\n *\n * Example:\n *\n * ```\n * it('...', waitForAsync(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * });\n * ```\n *\n * @publicApi\n */\nfunction waitForAsync(fn) {\n    const _Zone = typeof Zone !== 'undefined' ? Zone : null;\n    if (!_Zone) {\n        return function () {\n            return Promise.reject('Zone is needed for the waitForAsync() test helper but could not be found. ' +\n                'Please make sure that your environment includes zone.js');\n        };\n    }\n    const asyncTest = _Zone && _Zone[_Zone.__symbol__('asyncTest')];\n    if (typeof asyncTest === 'function') {\n        return asyncTest(fn);\n    }\n    return function () {\n        return Promise.reject('zone-testing.js is needed for the async() test helper but could not be found. ' +\n            'Please make sure that your environment includes zone.js/testing');\n    };\n}\n/**\n * @deprecated use `waitForAsync()`, (expected removal in v12)\n * @see {@link waitForAsync}\n * @publicApi\n * */\nfunction async(fn) {\n    return waitForAsync(fn);\n}\n\n/**\n * Fixture for debugging and testing a component.\n *\n * @publicApi\n */\nclass ComponentFixture {\n    constructor(componentRef, ngZone, _autoDetect) {\n        this.componentRef = componentRef;\n        this.ngZone = ngZone;\n        this._autoDetect = _autoDetect;\n        this._isStable = true;\n        this._isDestroyed = false;\n        this._resolve = null;\n        this._promise = null;\n        this._onUnstableSubscription = null;\n        this._onStableSubscription = null;\n        this._onMicrotaskEmptySubscription = null;\n        this._onErrorSubscription = null;\n        this.changeDetectorRef = componentRef.changeDetectorRef;\n        this.elementRef = componentRef.location;\n        this.debugElement = getDebugNode(this.elementRef.nativeElement);\n        this.componentInstance = componentRef.instance;\n        this.nativeElement = this.elementRef.nativeElement;\n        this.componentRef = componentRef;\n        this.ngZone = ngZone;\n        if (ngZone) {\n            // Create subscriptions outside the NgZone so that the callbacks run oustide\n            // of NgZone.\n            ngZone.runOutsideAngular(() => {\n                this._onUnstableSubscription = ngZone.onUnstable.subscribe({\n                    next: () => {\n                        this._isStable = false;\n                    }\n                });\n                this._onMicrotaskEmptySubscription = ngZone.onMicrotaskEmpty.subscribe({\n                    next: () => {\n                        if (this._autoDetect) {\n                            // Do a change detection run with checkNoChanges set to true to check\n                            // there are no changes on the second run.\n                            this.detectChanges(true);\n                        }\n                    }\n                });\n                this._onStableSubscription = ngZone.onStable.subscribe({\n                    next: () => {\n                        this._isStable = true;\n                        // Check whether there is a pending whenStable() completer to resolve.\n                        if (this._promise !== null) {\n                            // If so check whether there are no pending macrotasks before resolving.\n                            // Do this check in the next tick so that ngZone gets a chance to update the state of\n                            // pending macrotasks.\n                            queueMicrotask(() => {\n                                if (!ngZone.hasPendingMacrotasks) {\n                                    if (this._promise !== null) {\n                                        this._resolve(true);\n                                        this._resolve = null;\n                                        this._promise = null;\n                                    }\n                                }\n                            });\n                        }\n                    }\n                });\n                this._onErrorSubscription = ngZone.onError.subscribe({\n                    next: (error) => {\n                        throw error;\n                    }\n                });\n            });\n        }\n    }\n    _tick(checkNoChanges) {\n        this.changeDetectorRef.detectChanges();\n        if (checkNoChanges) {\n            this.checkNoChanges();\n        }\n    }\n    /**\n     * Trigger a change detection cycle for the component.\n     */\n    detectChanges(checkNoChanges = true) {\n        if (this.ngZone != null) {\n            // Run the change detection inside the NgZone so that any async tasks as part of the change\n            // detection are captured by the zone and can be waited for in isStable.\n            this.ngZone.run(() => {\n                this._tick(checkNoChanges);\n            });\n        }\n        else {\n            // Running without zone. Just do the change detection.\n            this._tick(checkNoChanges);\n        }\n    }\n    /**\n     * Do a change detection run to make sure there were no changes.\n     */\n    checkNoChanges() {\n        this.changeDetectorRef.checkNoChanges();\n    }\n    /**\n     * Set whether the fixture should autodetect changes.\n     *\n     * Also runs detectChanges once so that any existing change is detected.\n     */\n    autoDetectChanges(autoDetect = true) {\n        if (this.ngZone == null) {\n            throw new Error('Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set');\n        }\n        this._autoDetect = autoDetect;\n        this.detectChanges();\n    }\n    /**\n     * Return whether the fixture is currently stable or has async tasks that have not been completed\n     * yet.\n     */\n    isStable() {\n        return this._isStable && !this.ngZone.hasPendingMacrotasks;\n    }\n    /**\n     * Get a promise that resolves when the fixture is stable.\n     *\n     * This can be used to resume testing after events have triggered asynchronous activity or\n     * asynchronous change detection.\n     */\n    whenStable() {\n        if (this.isStable()) {\n            return Promise.resolve(false);\n        }\n        else if (this._promise !== null) {\n            return this._promise;\n        }\n        else {\n            this._promise = new Promise(res => {\n                this._resolve = res;\n            });\n            return this._promise;\n        }\n    }\n    _getRenderer() {\n        if (this._renderer === undefined) {\n            this._renderer = this.componentRef.injector.get(RendererFactory2$1, null);\n        }\n        return this._renderer;\n    }\n    /**\n     * Get a promise that resolves when the ui state is stable following animations.\n     */\n    whenRenderingDone() {\n        const renderer = this._getRenderer();\n        if (renderer && renderer.whenRenderingDone) {\n            return renderer.whenRenderingDone();\n        }\n        return this.whenStable();\n    }\n    /**\n     * Trigger component destruction.\n     */\n    destroy() {\n        if (!this._isDestroyed) {\n            this.componentRef.destroy();\n            if (this._onUnstableSubscription != null) {\n                this._onUnstableSubscription.unsubscribe();\n                this._onUnstableSubscription = null;\n            }\n            if (this._onStableSubscription != null) {\n                this._onStableSubscription.unsubscribe();\n                this._onStableSubscription = null;\n            }\n            if (this._onMicrotaskEmptySubscription != null) {\n                this._onMicrotaskEmptySubscription.unsubscribe();\n                this._onMicrotaskEmptySubscription = null;\n            }\n            if (this._onErrorSubscription != null) {\n                this._onErrorSubscription.unsubscribe();\n                this._onErrorSubscription = null;\n            }\n            this._isDestroyed = true;\n        }\n    }\n}\n\nconst _Zone = typeof Zone !== 'undefined' ? Zone : null;\nconst fakeAsyncTestModule = _Zone && _Zone[_Zone.__symbol__('fakeAsyncTest')];\nconst fakeAsyncTestModuleNotLoadedErrorMessage = `zone-testing.js is needed for the fakeAsync() test helper but could not be found.\n        Please make sure that your environment includes zone.js/testing`;\n/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * @publicApi\n */\nfunction resetFakeAsyncZone() {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.resetFakeAsyncZone();\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Wraps a function to be executed in the `fakeAsync` zone:\n * - Microtasks are manually executed by calling `flushMicrotasks()`.\n * - Timers are synchronous; `tick()` simulates the asynchronous passage of time.\n *\n * If there are any pending timers at the end of the function, an exception is thrown.\n *\n * Can be used to wrap `inject()` calls.\n *\n * @param fn The function that you want to wrap in the `fakeAsync` zone.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n *\n * @returns The function wrapped to be executed in the `fakeAsync` zone.\n * Any arguments passed when calling this returned function will be passed through to the `fn`\n * function in the parameters when it is called.\n *\n * @publicApi\n */\nfunction fakeAsync(fn) {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.fakeAsync(fn);\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the `fakeAsync` zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * @param millis The number of milliseconds to advance the virtual timer.\n * @param tickOptions The options to pass to the `tick()` function.\n *\n * @usageNotes\n *\n * The `tick()` option is a flag called `processNewMacroTasksSynchronously`,\n * which determines whether or not to invoke new macroTasks.\n *\n * If you provide a `tickOptions` object, but do not specify a\n * `processNewMacroTasksSynchronously` property (`tick(100, {})`),\n * then `processNewMacroTasksSynchronously` defaults to true.\n *\n * If you omit the `tickOptions` parameter (`tick(100))`), then\n * `tickOptions` defaults to `{processNewMacroTasksSynchronously: true}`.\n *\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * The following example includes a nested timeout (new macroTask), and\n * the `tickOptions` parameter is allowed to default. In this case,\n * `processNewMacroTasksSynchronously` defaults to true, and the nested\n * function is executed on each tick.\n *\n * ```\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick();\n *   expect(nestedTimeoutInvoked).toBe(true);\n * }));\n * ```\n *\n * In the following case, `processNewMacroTasksSynchronously` is explicitly\n * set to false, so the nested timeout function is not invoked.\n *\n * ```\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick(0, {processNewMacroTasksSynchronously: false});\n *   expect(nestedTimeoutInvoked).toBe(false);\n * }));\n * ```\n *\n *\n * @publicApi\n */\nfunction tick(millis = 0, tickOptions = {\n    processNewMacroTasksSynchronously: true\n}) {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.tick(millis, tickOptions);\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Flushes any pending microtasks and simulates the asynchronous passage of time for the timers in\n * the `fakeAsync` zone by\n * draining the macrotask queue until it is empty.\n *\n * @param maxTurns The maximum number of times the scheduler attempts to clear its queue before\n *     throwing an error.\n * @returns The simulated time elapsed, in milliseconds.\n *\n * @publicApi\n */\nfunction flush(maxTurns) {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.flush(maxTurns);\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Discard all remaining periodic tasks.\n *\n * @publicApi\n */\nfunction discardPeriodicTasks() {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.discardPeriodicTasks();\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Flush any pending microtasks.\n *\n * @publicApi\n */\nfunction flushMicrotasks() {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.flushMicrotasks();\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n\n/** Whether test modules should be torn down by default. */\nconst TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT = true;\n/** Whether unknown elements in templates should throw by default. */\nconst THROW_ON_UNKNOWN_ELEMENTS_DEFAULT = false;\n/** Whether unknown properties in templates should throw by default. */\nconst THROW_ON_UNKNOWN_PROPERTIES_DEFAULT = false;\n/**\n * An abstract class for inserting the root test component element in a platform independent way.\n *\n * @publicApi\n */\nclass TestComponentRenderer {\n    insertRootElement(rootElementId) { }\n    removeAllRootElements() { }\n}\n/**\n * @publicApi\n */\nconst ComponentFixtureAutoDetect = new InjectionToken$1('ComponentFixtureAutoDetect');\n/**\n * @publicApi\n */\nconst ComponentFixtureNoNgZone = new InjectionToken$1('ComponentFixtureNoNgZone');\n\n/**\n * Used to resolve resource URLs on `@Component` when used with JIT compilation.\n *\n * Example:\n * ```\n * @Component({\n *   selector: 'my-comp',\n *   templateUrl: 'my-comp.html', // This requires asynchronous resolution\n * })\n * class MyComponent{\n * }\n *\n * // Calling `renderComponent` will fail because `renderComponent` is a synchronous process\n * // and `MyComponent`'s `@Component.templateUrl` needs to be resolved asynchronously.\n *\n * // Calling `resolveComponentResources()` will resolve `@Component.templateUrl` into\n * // `@Component.template`, which allows `renderComponent` to proceed in a synchronous manner.\n *\n * // Use browser's `fetch()` function as the default resource resolution strategy.\n * resolveComponentResources(fetch).then(() => {\n *   // After resolution all URLs have been converted into `template` strings.\n *   renderComponent(MyComponent);\n * });\n *\n * ```\n *\n * NOTE: In AOT the resolution happens during compilation, and so there should be no need\n * to call this method outside JIT mode.\n *\n * @param resourceResolver a function which is responsible for returning a `Promise` to the\n * contents of the resolved URL. Browser's `fetch()` method is a good default implementation.\n */\nfunction resolveComponentResources(resourceResolver) {\n    // Store all promises which are fetching the resources.\n    const componentResolved = [];\n    // Cache so that we don't fetch the same resource more than once.\n    const urlMap = new Map();\n    function cachedResourceResolve(url) {\n        let promise = urlMap.get(url);\n        if (!promise) {\n            const resp = resourceResolver(url);\n            urlMap.set(url, promise = resp.then(unwrapResponse));\n        }\n        return promise;\n    }\n    componentResourceResolutionQueue.forEach((component, type) => {\n        const promises = [];\n        if (component.templateUrl) {\n            promises.push(cachedResourceResolve(component.templateUrl).then((template) => {\n                component.template = template;\n            }));\n        }\n        const styleUrls = component.styleUrls;\n        const styles = component.styles || (component.styles = []);\n        const styleOffset = component.styles.length;\n        styleUrls && styleUrls.forEach((styleUrl, index) => {\n            styles.push(''); // pre-allocate array.\n            promises.push(cachedResourceResolve(styleUrl).then((style) => {\n                styles[styleOffset + index] = style;\n                styleUrls.splice(styleUrls.indexOf(styleUrl), 1);\n                if (styleUrls.length == 0) {\n                    component.styleUrls = undefined;\n                }\n            }));\n        });\n        const fullyResolved = Promise.all(promises).then(() => componentDefResolved(type));\n        componentResolved.push(fullyResolved);\n    });\n    clearResolutionOfComponentResourcesQueue();\n    return Promise.all(componentResolved).then(() => undefined);\n}\nlet componentResourceResolutionQueue = new Map();\n// Track when existing ɵcmp for a Type is waiting on resources.\nconst componentDefPendingResolution = new Set();\nfunction maybeQueueResolutionOfComponentResources(type, metadata) {\n    if (componentNeedsResolution(metadata)) {\n        componentResourceResolutionQueue.set(type, metadata);\n        componentDefPendingResolution.add(type);\n    }\n}\nfunction isComponentDefPendingResolution(type) {\n    return componentDefPendingResolution.has(type);\n}\nfunction componentNeedsResolution(component) {\n    return !!((component.templateUrl && !component.hasOwnProperty('template')) ||\n        component.styleUrls && component.styleUrls.length);\n}\nfunction clearResolutionOfComponentResourcesQueue() {\n    const old = componentResourceResolutionQueue;\n    componentResourceResolutionQueue = new Map();\n    return old;\n}\nfunction restoreComponentResolutionQueue(queue) {\n    componentDefPendingResolution.clear();\n    queue.forEach((_, type) => componentDefPendingResolution.add(type));\n    componentResourceResolutionQueue = queue;\n}\nfunction isComponentResourceResolutionQueueEmpty() {\n    return componentResourceResolutionQueue.size === 0;\n}\nfunction unwrapResponse(response) {\n    return typeof response == 'string' ? response : response.text();\n}\nfunction componentDefResolved(type) {\n    componentDefPendingResolution.delete(type);\n}\n\nconst _global = globalThis;\n\nvar FactoryTarget;\n(function (FactoryTarget) {\n    FactoryTarget[FactoryTarget[\"Directive\"] = 0] = \"Directive\";\n    FactoryTarget[FactoryTarget[\"Component\"] = 1] = \"Component\";\n    FactoryTarget[FactoryTarget[\"Injectable\"] = 2] = \"Injectable\";\n    FactoryTarget[FactoryTarget[\"Pipe\"] = 3] = \"Pipe\";\n    FactoryTarget[FactoryTarget[\"NgModule\"] = 4] = \"NgModule\";\n})(FactoryTarget || (FactoryTarget = {}));\nvar R3TemplateDependencyKind;\n(function (R3TemplateDependencyKind) {\n    R3TemplateDependencyKind[R3TemplateDependencyKind[\"Directive\"] = 0] = \"Directive\";\n    R3TemplateDependencyKind[R3TemplateDependencyKind[\"Pipe\"] = 1] = \"Pipe\";\n    R3TemplateDependencyKind[R3TemplateDependencyKind[\"NgModule\"] = 2] = \"NgModule\";\n})(R3TemplateDependencyKind || (R3TemplateDependencyKind = {}));\nvar ViewEncapsulation$1;\n(function (ViewEncapsulation) {\n    ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\";\n    // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.\n    ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\n    ViewEncapsulation[ViewEncapsulation[\"ShadowDom\"] = 3] = \"ShadowDom\";\n})(ViewEncapsulation$1 || (ViewEncapsulation$1 = {}));\n\nfunction getCompilerFacade(request) {\n    const globalNg = _global['ng'];\n    if (globalNg && globalNg.ɵcompilerFacade) {\n        return globalNg.ɵcompilerFacade;\n    }\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        // Log the type as an error so that a developer can easily navigate to the type from the\n        // console.\n        console.error(`JIT compilation failed for ${request.kind}`, request.type);\n        let message = `The ${request.kind} '${request\n            .type.name}' needs to be compiled using the JIT compiler, but '@angular/compiler' is not available.\\n\\n`;\n        if (request.usage === 1 /* JitCompilerUsage.PartialDeclaration */) {\n            message += `The ${request.kind} is part of a library that has been partially compiled.\\n`;\n            message +=\n                `However, the Angular Linker has not processed the library such that JIT compilation is used as fallback.\\n`;\n            message += '\\n';\n            message +=\n                `Ideally, the library is processed using the Angular Linker to become fully AOT compiled.\\n`;\n        }\n        else {\n            message +=\n                `JIT compilation is discouraged for production use-cases! Consider using AOT mode instead.\\n`;\n        }\n        message +=\n            `Alternatively, the JIT compiler should be loaded by bootstrapping using '@angular/platform-browser-dynamic' or '@angular/platform-server',\\n`;\n        message +=\n            `or manually provide the compiler with 'import \"@angular/compiler\";' before bootstrapping.`;\n        throw new Error(message);\n    }\n    else {\n        throw new Error('JIT compiler unavailable');\n    }\n}\n\nfunction getClosureSafeProperty(objWithPropertyToExtract) {\n    for (let key in objWithPropertyToExtract) {\n        if (objWithPropertyToExtract[key] === getClosureSafeProperty) {\n            return key;\n        }\n    }\n    throw Error('Could not find renamed property on target object.');\n}\n/**\n * Sets properties on a target object from a source object, but only if\n * the property doesn't already exist on the target object.\n * @param target The target to set properties on\n * @param source The source of the property keys and values to set\n */\nfunction fillProperties(target, source) {\n    for (const key in source) {\n        if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {\n            target[key] = source[key];\n        }\n    }\n}\n\nfunction stringify(token) {\n    if (typeof token === 'string') {\n        return token;\n    }\n    if (Array.isArray(token)) {\n        return '[' + token.map(stringify).join(', ') + ']';\n    }\n    if (token == null) {\n        return '' + token;\n    }\n    if (token.overriddenName) {\n        return `${token.overriddenName}`;\n    }\n    if (token.name) {\n        return `${token.name}`;\n    }\n    const res = token.toString();\n    if (res == null) {\n        return '' + res;\n    }\n    const newLineIndex = res.indexOf('\\n');\n    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n}\n/**\n * Concatenates two strings with separator, allocating new strings only when necessary.\n *\n * @param before before string.\n * @param separator separator string.\n * @param after after string.\n * @returns concatenated string.\n */\nfunction concatStringsWithSpace(before, after) {\n    return (before == null || before === '') ?\n        (after === null ? '' : after) :\n        ((after == null || after === '') ? before : before + ' ' + after);\n}\n\nconst __forward_ref__ = getClosureSafeProperty({ __forward_ref__: getClosureSafeProperty });\n/**\n * Allows to refer to references which are not yet defined.\n *\n * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of\n * DI is declared, but not yet defined. It is also used when the `token` which we use when creating\n * a query is not yet defined.\n *\n * `forwardRef` is also used to break circularities in standalone components imports.\n *\n * @usageNotes\n * ### Circular dependency example\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}\n *\n * ### Circular standalone reference import example\n * ```ts\n * @Component({\n *   standalone: true,\n *   imports: [ChildComponent],\n *   selector: 'app-parent',\n *   template: `<app-child [hideParent]=\"hideParent\"></app-child>`,\n * })\n * export class ParentComponent {\n *   @Input() hideParent: boolean;\n * }\n *\n *\n * @Component({\n *   standalone: true,\n *   imports: [CommonModule, forwardRef(() => ParentComponent)],\n *   selector: 'app-child',\n *   template: `<app-parent *ngIf=\"!hideParent\"></app-parent>`,\n * })\n * export class ChildComponent {\n *   @Input() hideParent: boolean;\n * }\n * ```\n *\n * @publicApi\n */\nfunction forwardRef(forwardRefFn) {\n    forwardRefFn.__forward_ref__ = forwardRef;\n    forwardRefFn.toString = function () {\n        return stringify(this());\n    };\n    return forwardRefFn;\n}\n/**\n * Lazily retrieves the reference value from a forwardRef.\n *\n * Acts as the identity function when given a non-forward-ref value.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}\n *\n * @see {@link forwardRef}\n * @publicApi\n */\nfunction resolveForwardRef(type) {\n    return isForwardRef(type) ? type() : type;\n}\n/** Checks whether a function is wrapped by a `forwardRef`. */\nfunction isForwardRef(fn) {\n    return typeof fn === 'function' && fn.hasOwnProperty(__forward_ref__) &&\n        fn.__forward_ref__ === forwardRef;\n}\n\n/**\n * Construct an injectable definition which defines how a token will be constructed by the DI\n * system, and in which injectors (if any) it will be available.\n *\n * This should be assigned to a static `ɵprov` field on a type, which will then be an\n * `InjectableType`.\n *\n * Options:\n * * `providedIn` determines which injectors will include the injectable, by either associating it\n *   with an `@NgModule` or other `InjectorType`, or by specifying that this injectable should be\n *   provided in the `'root'` injector, which will be the application-level injector in most apps.\n * * `factory` gives the zero argument function which will create an instance of the injectable.\n *   The factory can call [`inject`](api/core/inject) to access the `Injector` and request injection\n * of dependencies.\n *\n * @codeGenApi\n * @publicApi This instruction has been emitted by ViewEngine for some time and is deployed to npm.\n */\nfunction ɵɵdefineInjectable(opts) {\n    return {\n        token: opts.token,\n        providedIn: opts.providedIn || null,\n        factory: opts.factory,\n        value: undefined,\n    };\n}\n/**\n * @deprecated in v8, delete after v10. This API should be used only by generated code, and that\n * code should now use ɵɵdefineInjectable instead.\n * @publicApi\n */\nconst defineInjectable = ɵɵdefineInjectable;\n/**\n * Construct an `InjectorDef` which configures an injector.\n *\n * This should be assigned to a static injector def (`ɵinj`) field on a type, which will then be an\n * `InjectorType`.\n *\n * Options:\n *\n * * `providers`: an optional array of providers to add to the injector. Each provider must\n *   either have a factory or point to a type which has a `ɵprov` static property (the\n *   type must be an `InjectableType`).\n * * `imports`: an optional array of imports of other `InjectorType`s or `InjectorTypeWithModule`s\n *   whose providers will also be added to the injector. Locally provided types will override\n *   providers from imports.\n *\n * @codeGenApi\n */\nfunction ɵɵdefineInjector(options) {\n    return { providers: options.providers || [], imports: options.imports || [] };\n}\n/**\n * Read the injectable def (`ɵprov`) for `type` in a way which is immune to accidentally reading\n * inherited value.\n *\n * @param type A type which may have its own (non-inherited) `ɵprov`.\n */\nfunction getInjectableDef(type) {\n    return getOwnDefinition(type, NG_PROV_DEF) || getOwnDefinition(type, NG_INJECTABLE_DEF);\n}\nfunction isInjectable(type) {\n    return getInjectableDef(type) !== null;\n}\n/**\n * Return definition only if it is defined directly on `type` and is not inherited from a base\n * class of `type`.\n */\nfunction getOwnDefinition(type, field) {\n    return type.hasOwnProperty(field) ? type[field] : null;\n}\n/**\n * Read the injectable def (`ɵprov`) for `type` or read the `ɵprov` from one of its ancestors.\n *\n * @param type A type which may have `ɵprov`, via inheritance.\n *\n * @deprecated Will be removed in a future version of Angular, where an error will occur in the\n *     scenario if we find the `ɵprov` on an ancestor only.\n */\nfunction getInheritedInjectableDef(type) {\n    const def = type && (type[NG_PROV_DEF] || type[NG_INJECTABLE_DEF]);\n    if (def) {\n        ngDevMode &&\n            console.warn(`DEPRECATED: DI is instantiating a token \"${type.name}\" that inherits its @Injectable decorator but does not provide one itself.\\n` +\n                `This will become an error in a future version of Angular. Please add @Injectable() to the \"${type.name}\" class.`);\n        return def;\n    }\n    else {\n        return null;\n    }\n}\n/**\n * Read the injector def type in a way which is immune to accidentally reading inherited value.\n *\n * @param type type which may have an injector def (`ɵinj`)\n */\nfunction getInjectorDef(type) {\n    return type && (type.hasOwnProperty(NG_INJ_DEF) || type.hasOwnProperty(NG_INJECTOR_DEF)) ?\n        type[NG_INJ_DEF] :\n        null;\n}\nconst NG_PROV_DEF = getClosureSafeProperty({ ɵprov: getClosureSafeProperty });\nconst NG_INJ_DEF = getClosureSafeProperty({ ɵinj: getClosureSafeProperty });\n// We need to keep these around so we can read off old defs if new defs are unavailable\nconst NG_INJECTABLE_DEF = getClosureSafeProperty({ ngInjectableDef: getClosureSafeProperty });\nconst NG_INJECTOR_DEF = getClosureSafeProperty({ ngInjectorDef: getClosureSafeProperty });\n\n/**\n * Base URL for the error details page.\n *\n * Keep this constant in sync across:\n *  - packages/compiler-cli/src/ngtsc/diagnostics/src/error_details_base_url.ts\n *  - packages/core/src/error_details_base_url.ts\n */\nconst ERROR_DETAILS_PAGE_BASE_URL = 'https://angular.io/errors';\n/**\n * URL for the XSS security documentation.\n */\nconst XSS_SECURITY_URL = 'https://g.co/ng/security#xss';\n\n/**\n * Class that represents a runtime error.\n * Formats and outputs the error message in a consistent way.\n *\n * Example:\n * ```\n *  throw new RuntimeError(\n *    RuntimeErrorCode.INJECTOR_ALREADY_DESTROYED,\n *    ngDevMode && 'Injector has already been destroyed.');\n * ```\n *\n * Note: the `message` argument contains a descriptive error message as a string in development\n * mode (when the `ngDevMode` is defined). In production mode (after tree-shaking pass), the\n * `message` argument becomes `false`, thus we account for it in the typings and the runtime\n * logic.\n */\nclass RuntimeError extends Error {\n    constructor(code, message) {\n        super(formatRuntimeError(code, message));\n        this.code = code;\n    }\n}\n/**\n * Called to format a runtime error.\n * See additional info on the `message` argument type in the `RuntimeError` class description.\n */\nfunction formatRuntimeError(code, message) {\n    // Error code might be a negative number, which is a special marker that instructs the logic to\n    // generate a link to the error details page on angular.io.\n    // We also prepend `0` to non-compile-time errors.\n    const fullCode = `NG0${Math.abs(code)}`;\n    let errorMessage = `${fullCode}${message ? ': ' + message : ''}`;\n    if (ngDevMode && code < 0) {\n        const addPeriodSeparator = !errorMessage.match(/[.,;!?\\n]$/);\n        const separator = addPeriodSeparator ? '.' : '';\n        errorMessage =\n            `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;\n    }\n    return errorMessage;\n}\n\n/**\n * @description\n *\n * Represents a type that a Component or other object is instances of.\n *\n * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is represented by\n * the `MyCustomComponent` constructor function.\n *\n * @publicApi\n */\nconst Type = Function;\nfunction isType(v) {\n    return typeof v === 'function';\n}\n\n// The functions in this file verify that the assumptions we are making\nfunction assertNumber(actual, msg) {\n    if (!(typeof actual === 'number')) {\n        throwError(msg, typeof actual, 'number', '===');\n    }\n}\nfunction assertNumberInRange(actual, minInclusive, maxInclusive) {\n    assertNumber(actual, 'Expected a number');\n    assertLessThanOrEqual(actual, maxInclusive, 'Expected number to be less than or equal to');\n    assertGreaterThanOrEqual(actual, minInclusive, 'Expected number to be greater than or equal to');\n}\nfunction assertString(actual, msg) {\n    if (!(typeof actual === 'string')) {\n        throwError(msg, actual === null ? 'null' : typeof actual, 'string', '===');\n    }\n}\nfunction assertFunction(actual, msg) {\n    if (!(typeof actual === 'function')) {\n        throwError(msg, actual === null ? 'null' : typeof actual, 'function', '===');\n    }\n}\nfunction assertEqual(actual, expected, msg) {\n    if (!(actual == expected)) {\n        throwError(msg, actual, expected, '==');\n    }\n}\nfunction assertNotEqual(actual, expected, msg) {\n    if (!(actual != expected)) {\n        throwError(msg, actual, expected, '!=');\n    }\n}\nfunction assertSame(actual, expected, msg) {\n    if (!(actual === expected)) {\n        throwError(msg, actual, expected, '===');\n    }\n}\nfunction assertNotSame(actual, expected, msg) {\n    if (!(actual !== expected)) {\n        throwError(msg, actual, expected, '!==');\n    }\n}\nfunction assertLessThan(actual, expected, msg) {\n    if (!(actual < expected)) {\n        throwError(msg, actual, expected, '<');\n    }\n}\nfunction assertLessThanOrEqual(actual, expected, msg) {\n    if (!(actual <= expected)) {\n        throwError(msg, actual, expected, '<=');\n    }\n}\nfunction assertGreaterThan(actual, expected, msg) {\n    if (!(actual > expected)) {\n        throwError(msg, actual, expected, '>');\n    }\n}\nfunction assertGreaterThanOrEqual(actual, expected, msg) {\n    if (!(actual >= expected)) {\n        throwError(msg, actual, expected, '>=');\n    }\n}\nfunction assertNotDefined(actual, msg) {\n    if (actual != null) {\n        throwError(msg, actual, null, '==');\n    }\n}\nfunction assertDefined(actual, msg) {\n    if (actual == null) {\n        throwError(msg, actual, null, '!=');\n    }\n}\nfunction throwError(msg, actual, expected, comparison) {\n    throw new Error(`ASSERTION ERROR: ${msg}` +\n        (comparison == null ? '' : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`));\n}\nfunction assertDomNode(node) {\n    if (!(node instanceof Node)) {\n        throwError(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`);\n    }\n}\nfunction assertIndexInRange(arr, index) {\n    assertDefined(arr, 'Array must be defined.');\n    const maxLen = arr.length;\n    if (index < 0 || index >= maxLen) {\n        throwError(`Index expected to be less than ${maxLen} but got ${index}`);\n    }\n}\nfunction assertOneOf(value, ...validValues) {\n    if (validValues.indexOf(value) !== -1)\n        return true;\n    throwError(`Expected value to be one of ${JSON.stringify(validValues)} but was ${JSON.stringify(value)}.`);\n}\n\n/**\n * Determines if the contents of two arrays is identical\n *\n * @param a first array\n * @param b second array\n * @param identityAccessor Optional function for extracting stable object identity from a value in\n *     the array.\n */\nfunction arrayEquals(a, b, identityAccessor) {\n    if (a.length !== b.length)\n        return false;\n    for (let i = 0; i < a.length; i++) {\n        let valueA = a[i];\n        let valueB = b[i];\n        if (identityAccessor) {\n            valueA = identityAccessor(valueA);\n            valueB = identityAccessor(valueB);\n        }\n        if (valueB !== valueA) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Flattens an array.\n */\nfunction flatten$1(list) {\n    return list.flat(Number.POSITIVE_INFINITY);\n}\nfunction deepForEach(input, fn) {\n    input.forEach(value => Array.isArray(value) ? deepForEach(value, fn) : fn(value));\n}\nfunction addToArray(arr, index, value) {\n    // perf: array.push is faster than array.splice!\n    if (index >= arr.length) {\n        arr.push(value);\n    }\n    else {\n        arr.splice(index, 0, value);\n    }\n}\nfunction removeFromArray(arr, index) {\n    // perf: array.pop is faster than array.splice!\n    if (index >= arr.length - 1) {\n        return arr.pop();\n    }\n    else {\n        return arr.splice(index, 1)[0];\n    }\n}\nfunction newArray(size, value) {\n    const list = [];\n    for (let i = 0; i < size; i++) {\n        list.push(value);\n    }\n    return list;\n}\n/**\n * Remove item from array (Same as `Array.splice()` but faster.)\n *\n * `Array.splice()` is not as fast because it has to allocate an array for the elements which were\n * removed. This causes memory pressure and slows down code when most of the time we don't\n * care about the deleted items array.\n *\n * https://jsperf.com/fast-array-splice (About 20x faster)\n *\n * @param array Array to splice\n * @param index Index of element in array to remove.\n * @param count Number of items to remove.\n */\nfunction arraySplice(array, index, count) {\n    const length = array.length - count;\n    while (index < length) {\n        array[index] = array[index + count];\n        index++;\n    }\n    while (count--) {\n        array.pop(); // shrink the array\n    }\n}\n/**\n * Same as `Array.splice(index, 0, value)` but faster.\n *\n * `Array.splice()` is not fast because it has to allocate an array for the elements which were\n * removed. This causes memory pressure and slows down code when most of the time we don't\n * care about the deleted items array.\n *\n * @param array Array to splice.\n * @param index Index in array where the `value` should be added.\n * @param value Value to add to array.\n */\nfunction arrayInsert(array, index, value) {\n    ngDevMode && assertLessThanOrEqual(index, array.length, 'Can\\'t insert past array end.');\n    let end = array.length;\n    while (end > index) {\n        const previousEnd = end - 1;\n        array[end] = array[previousEnd];\n        end = previousEnd;\n    }\n    array[index] = value;\n}\n/**\n * Same as `Array.splice2(index, 0, value1, value2)` but faster.\n *\n * `Array.splice()` is not fast because it has to allocate an array for the elements which were\n * removed. This causes memory pressure and slows down code when most of the time we don't\n * care about the deleted items array.\n *\n * @param array Array to splice.\n * @param index Index in array where the `value` should be added.\n * @param value1 Value to add to array.\n * @param value2 Value to add to array.\n */\nfunction arrayInsert2(array, index, value1, value2) {\n    ngDevMode && assertLessThanOrEqual(index, array.length, 'Can\\'t insert past array end.');\n    let end = array.length;\n    if (end == index) {\n        // inserting at the end.\n        array.push(value1, value2);\n    }\n    else if (end === 1) {\n        // corner case when we have less items in array than we have items to insert.\n        array.push(value2, array[0]);\n        array[0] = value1;\n    }\n    else {\n        end--;\n        array.push(array[end - 1], array[end]);\n        while (end > index) {\n            const previousEnd = end - 2;\n            array[end] = array[previousEnd];\n            end--;\n        }\n        array[index] = value1;\n        array[index + 1] = value2;\n    }\n}\n/**\n * Get an index of an `value` in a sorted `array`.\n *\n * NOTE:\n * - This uses binary search algorithm for fast removals.\n *\n * @param array A sorted array to binary search.\n * @param value The value to look for.\n * @returns index of the value.\n *   - positive index if value found.\n *   - negative index if value not found. (`~index` to get the value where it should have been\n *     located)\n */\nfunction arrayIndexOfSorted(array, value) {\n    return _arrayIndexOfSorted(array, value, 0);\n}\n/**\n * Set a `value` for a `key`.\n *\n * @param keyValueArray to modify.\n * @param key The key to locate or create.\n * @param value The value to set for a `key`.\n * @returns index (always even) of where the value vas set.\n */\nfunction keyValueArraySet(keyValueArray, key, value) {\n    let index = keyValueArrayIndexOf(keyValueArray, key);\n    if (index >= 0) {\n        // if we found it set it.\n        keyValueArray[index | 1] = value;\n    }\n    else {\n        index = ~index;\n        arrayInsert2(keyValueArray, index, key, value);\n    }\n    return index;\n}\n/**\n * Retrieve a `value` for a `key` (on `undefined` if not found.)\n *\n * @param keyValueArray to search.\n * @param key The key to locate.\n * @return The `value` stored at the `key` location or `undefined if not found.\n */\nfunction keyValueArrayGet(keyValueArray, key) {\n    const index = keyValueArrayIndexOf(keyValueArray, key);\n    if (index >= 0) {\n        // if we found it retrieve it.\n        return keyValueArray[index | 1];\n    }\n    return undefined;\n}\n/**\n * Retrieve a `key` index value in the array or `-1` if not found.\n *\n * @param keyValueArray to search.\n * @param key The key to locate.\n * @returns index of where the key is (or should have been.)\n *   - positive (even) index if key found.\n *   - negative index if key not found. (`~index` (even) to get the index where it should have\n *     been inserted.)\n */\nfunction keyValueArrayIndexOf(keyValueArray, key) {\n    return _arrayIndexOfSorted(keyValueArray, key, 1);\n}\n/**\n * Delete a `key` (and `value`) from the `KeyValueArray`.\n *\n * @param keyValueArray to modify.\n * @param key The key to locate or delete (if exist).\n * @returns index of where the key was (or should have been.)\n *   - positive (even) index if key found and deleted.\n *   - negative index if key not found. (`~index` (even) to get the index where it should have\n *     been.)\n */\nfunction keyValueArrayDelete(keyValueArray, key) {\n    const index = keyValueArrayIndexOf(keyValueArray, key);\n    if (index >= 0) {\n        // if we found it remove it.\n        arraySplice(keyValueArray, index, 2);\n    }\n    return index;\n}\n/**\n * INTERNAL: Get an index of an `value` in a sorted `array` by grouping search by `shift`.\n *\n * NOTE:\n * - This uses binary search algorithm for fast removals.\n *\n * @param array A sorted array to binary search.\n * @param value The value to look for.\n * @param shift grouping shift.\n *   - `0` means look at every location\n *   - `1` means only look at every other (even) location (the odd locations are to be ignored as\n *         they are values.)\n * @returns index of the value.\n *   - positive index if value found.\n *   - negative index if value not found. (`~index` to get the value where it should have been\n * inserted)\n */\nfunction _arrayIndexOfSorted(array, value, shift) {\n    ngDevMode && assertEqual(Array.isArray(array), true, 'Expecting an array');\n    let start = 0;\n    let end = array.length >> shift;\n    while (end !== start) {\n        const middle = start + ((end - start) >> 1); // find the middle.\n        const current = array[middle << shift];\n        if (value === current) {\n            return (middle << shift);\n        }\n        else if (current > value) {\n            end = middle;\n        }\n        else {\n            start = middle + 1; // We already searched middle so make it non-inclusive by adding 1\n        }\n    }\n    return ~(end << shift);\n}\n\n/**\n * Convince closure compiler that the wrapped function has no side-effects.\n *\n * Closure compiler always assumes that `toString` has no side-effects. We use this quirk to\n * allow us to execute a function but have closure compiler mark the call as no-side-effects.\n * It is important that the return value for the `noSideEffects` function be assigned\n * to something which is retained otherwise the call to `noSideEffects` will be removed by closure\n * compiler.\n */\nfunction noSideEffects(fn) {\n    return { toString: fn }.toString();\n}\n\nconst ANNOTATIONS = '__annotations__';\nconst PARAMETERS = '__parameters__';\nconst PROP_METADATA = '__prop__metadata__';\n/**\n * @suppress {globalThis}\n */\nfunction makeDecorator(name, props, parentClass, additionalProcessing, typeFn) {\n    return noSideEffects(() => {\n        const metaCtor = makeMetadataCtor(props);\n        function DecoratorFactory(...args) {\n            if (this instanceof DecoratorFactory) {\n                metaCtor.call(this, ...args);\n                return this;\n            }\n            const annotationInstance = new DecoratorFactory(...args);\n            return function TypeDecorator(cls) {\n                if (typeFn)\n                    typeFn(cls, ...args);\n                // Use of Object.defineProperty is important since it creates non-enumerable property which\n                // prevents the property is copied during subclassing.\n                const annotations = cls.hasOwnProperty(ANNOTATIONS) ?\n                    cls[ANNOTATIONS] :\n                    Object.defineProperty(cls, ANNOTATIONS, { value: [] })[ANNOTATIONS];\n                annotations.push(annotationInstance);\n                if (additionalProcessing)\n                    additionalProcessing(cls);\n                return cls;\n            };\n        }\n        if (parentClass) {\n            DecoratorFactory.prototype = Object.create(parentClass.prototype);\n        }\n        DecoratorFactory.prototype.ngMetadataName = name;\n        DecoratorFactory.annotationCls = DecoratorFactory;\n        return DecoratorFactory;\n    });\n}\nfunction makeMetadataCtor(props) {\n    return function ctor(...args) {\n        if (props) {\n            const values = props(...args);\n            for (const propName in values) {\n                this[propName] = values[propName];\n            }\n        }\n    };\n}\nfunction makeParamDecorator(name, props, parentClass) {\n    return noSideEffects(() => {\n        const metaCtor = makeMetadataCtor(props);\n        function ParamDecoratorFactory(...args) {\n            if (this instanceof ParamDecoratorFactory) {\n                metaCtor.apply(this, args);\n                return this;\n            }\n            const annotationInstance = new ParamDecoratorFactory(...args);\n            ParamDecorator.annotation = annotationInstance;\n            return ParamDecorator;\n            function ParamDecorator(cls, unusedKey, index) {\n                // Use of Object.defineProperty is important since it creates non-enumerable property which\n                // prevents the property is copied during subclassing.\n                const parameters = cls.hasOwnProperty(PARAMETERS) ?\n                    cls[PARAMETERS] :\n                    Object.defineProperty(cls, PARAMETERS, { value: [] })[PARAMETERS];\n                // there might be gaps if some in between parameters do not have annotations.\n                // we pad with nulls.\n                while (parameters.length <= index) {\n                    parameters.push(null);\n                }\n                (parameters[index] = parameters[index] || []).push(annotationInstance);\n                return cls;\n            }\n        }\n        if (parentClass) {\n            ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);\n        }\n        ParamDecoratorFactory.prototype.ngMetadataName = name;\n        ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;\n        return ParamDecoratorFactory;\n    });\n}\nfunction makePropDecorator(name, props, parentClass, additionalProcessing) {\n    return noSideEffects(() => {\n        const metaCtor = makeMetadataCtor(props);\n        function PropDecoratorFactory(...args) {\n            if (this instanceof PropDecoratorFactory) {\n                metaCtor.apply(this, args);\n                return this;\n            }\n            const decoratorInstance = new PropDecoratorFactory(...args);\n            function PropDecorator(target, name) {\n                // target is undefined with standard decorators. This case is not supported and will throw\n                // if this decorator is used in JIT mode with standard decorators.\n                if (target === undefined) {\n                    throw new Error('Standard Angular field decorators are not supported in JIT mode.');\n                }\n                const constructor = target.constructor;\n                // Use of Object.defineProperty is important because it creates a non-enumerable property\n                // which prevents the property from being copied during subclassing.\n                const meta = constructor.hasOwnProperty(PROP_METADATA) ?\n                    constructor[PROP_METADATA] :\n                    Object.defineProperty(constructor, PROP_METADATA, { value: {} })[PROP_METADATA];\n                meta[name] = meta.hasOwnProperty(name) && meta[name] || [];\n                meta[name].unshift(decoratorInstance);\n                if (additionalProcessing)\n                    additionalProcessing(target, name, ...args);\n            }\n            return PropDecorator;\n        }\n        if (parentClass) {\n            PropDecoratorFactory.prototype = Object.create(parentClass.prototype);\n        }\n        PropDecoratorFactory.prototype.ngMetadataName = name;\n        PropDecoratorFactory.annotationCls = PropDecoratorFactory;\n        return PropDecoratorFactory;\n    });\n}\n\n/*\n * #########################\n * Attention: These Regular expressions have to hold even if the code is minified!\n * ##########################\n */\n/**\n * Regular expression that detects pass-through constructors for ES5 output. This Regex\n * intends to capture the common delegation pattern emitted by TypeScript and Babel. Also\n * it intends to capture the pattern where existing constructors have been downleveled from\n * ES2015 to ES5 using TypeScript w/ downlevel iteration. e.g.\n *\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, arguments) || this;\n * ```\n *\n * downleveled to ES5 with `downlevelIteration` for TypeScript < 4.2:\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, __spread(arguments)) || this;\n * ```\n *\n * or downleveled to ES5 with `downlevelIteration` for TypeScript >= 4.2:\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;\n * ```\n *\n * More details can be found in: https://github.com/angular/angular/issues/38453.\n */\nconst ES5_DELEGATE_CTOR = /^function\\s+\\S+\\(\\)\\s*{[\\s\\S]+\\.apply\\(this,\\s*(arguments|(?:[^()]+\\(\\[\\],)?[^()]+\\(arguments\\).*)\\)/;\n/** Regular expression that detects ES2015 classes which extend from other classes. */\nconst ES2015_INHERITED_CLASS = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{/;\n/**\n * Regular expression that detects ES2015 classes which extend from other classes and\n * have an explicit constructor defined.\n */\nconst ES2015_INHERITED_CLASS_WITH_CTOR = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{[\\s\\S]*constructor\\s*\\(/;\n/**\n * Regular expression that detects ES2015 classes which extend from other classes\n * and inherit a constructor.\n */\nconst ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{[\\s\\S]*constructor\\s*\\(\\)\\s*{[^}]*super\\(\\.\\.\\.arguments\\)/;\n/**\n * Determine whether a stringified type is a class which delegates its constructor\n * to its parent.\n *\n * This is not trivial since compiled code can actually contain a constructor function\n * even if the original source code did not. For instance, when the child class contains\n * an initialized instance property.\n */\nfunction isDelegateCtor(typeStr) {\n    return ES5_DELEGATE_CTOR.test(typeStr) ||\n        ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) ||\n        (ES2015_INHERITED_CLASS.test(typeStr) && !ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr));\n}\nclass ReflectionCapabilities {\n    constructor(reflect) {\n        this._reflect = reflect || _global['Reflect'];\n    }\n    factory(t) {\n        return (...args) => new t(...args);\n    }\n    /** @internal */\n    _zipTypesAndAnnotations(paramTypes, paramAnnotations) {\n        let result;\n        if (typeof paramTypes === 'undefined') {\n            result = newArray(paramAnnotations.length);\n        }\n        else {\n            result = newArray(paramTypes.length);\n        }\n        for (let i = 0; i < result.length; i++) {\n            // TS outputs Object for parameters without types, while Traceur omits\n            // the annotations. For now we preserve the Traceur behavior to aid\n            // migration, but this can be revisited.\n            if (typeof paramTypes === 'undefined') {\n                result[i] = [];\n            }\n            else if (paramTypes[i] && paramTypes[i] != Object) {\n                result[i] = [paramTypes[i]];\n            }\n            else {\n                result[i] = [];\n            }\n            if (paramAnnotations && paramAnnotations[i] != null) {\n                result[i] = result[i].concat(paramAnnotations[i]);\n            }\n        }\n        return result;\n    }\n    _ownParameters(type, parentCtor) {\n        const typeStr = type.toString();\n        // If we have no decorators, we only have function.length as metadata.\n        // In that case, to detect whether a child class declared an own constructor or not,\n        // we need to look inside of that constructor to check whether it is\n        // just calling the parent.\n        // This also helps to work around for https://github.com/Microsoft/TypeScript/issues/12439\n        // that sets 'design:paramtypes' to []\n        // if a class inherits from another class but has no ctor declared itself.\n        if (isDelegateCtor(typeStr)) {\n            return null;\n        }\n        // Prefer the direct API.\n        if (type.parameters && type.parameters !== parentCtor.parameters) {\n            return type.parameters;\n        }\n        // API of tsickle for lowering decorators to properties on the class.\n        const tsickleCtorParams = type.ctorParameters;\n        if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {\n            // Newer tsickle uses a function closure\n            // Retain the non-function case for compatibility with older tsickle\n            const ctorParameters = typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;\n            const paramTypes = ctorParameters.map((ctorParam) => ctorParam && ctorParam.type);\n            const paramAnnotations = ctorParameters.map((ctorParam) => ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));\n            return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n        }\n        // API for metadata created by invoking the decorators.\n        const paramAnnotations = type.hasOwnProperty(PARAMETERS) && type[PARAMETERS];\n        const paramTypes = this._reflect && this._reflect.getOwnMetadata &&\n            this._reflect.getOwnMetadata('design:paramtypes', type);\n        if (paramTypes || paramAnnotations) {\n            return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n        }\n        // If a class has no decorators, at least create metadata\n        // based on function.length.\n        // Note: We know that this is a real constructor as we checked\n        // the content of the constructor above.\n        return newArray(type.length);\n    }\n    parameters(type) {\n        // Note: only report metadata if we have at least one class decorator\n        // to stay in sync with the static reflector.\n        if (!isType(type)) {\n            return [];\n        }\n        const parentCtor = getParentCtor(type);\n        let parameters = this._ownParameters(type, parentCtor);\n        if (!parameters && parentCtor !== Object) {\n            parameters = this.parameters(parentCtor);\n        }\n        return parameters || [];\n    }\n    _ownAnnotations(typeOrFunc, parentCtor) {\n        // Prefer the direct API.\n        if (typeOrFunc.annotations && typeOrFunc.annotations !== parentCtor.annotations) {\n            let annotations = typeOrFunc.annotations;\n            if (typeof annotations === 'function' && annotations.annotations) {\n                annotations = annotations.annotations;\n            }\n            return annotations;\n        }\n        // API of tsickle for lowering decorators to properties on the class.\n        if (typeOrFunc.decorators && typeOrFunc.decorators !== parentCtor.decorators) {\n            return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);\n        }\n        // API for metadata created by invoking the decorators.\n        if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {\n            return typeOrFunc[ANNOTATIONS];\n        }\n        return null;\n    }\n    annotations(typeOrFunc) {\n        if (!isType(typeOrFunc)) {\n            return [];\n        }\n        const parentCtor = getParentCtor(typeOrFunc);\n        const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];\n        const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];\n        return parentAnnotations.concat(ownAnnotations);\n    }\n    _ownPropMetadata(typeOrFunc, parentCtor) {\n        // Prefer the direct API.\n        if (typeOrFunc.propMetadata &&\n            typeOrFunc.propMetadata !== parentCtor.propMetadata) {\n            let propMetadata = typeOrFunc.propMetadata;\n            if (typeof propMetadata === 'function' && propMetadata.propMetadata) {\n                propMetadata = propMetadata.propMetadata;\n            }\n            return propMetadata;\n        }\n        // API of tsickle for lowering decorators to properties on the class.\n        if (typeOrFunc.propDecorators &&\n            typeOrFunc.propDecorators !== parentCtor.propDecorators) {\n            const propDecorators = typeOrFunc.propDecorators;\n            const propMetadata = {};\n            Object.keys(propDecorators).forEach(prop => {\n                propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);\n            });\n            return propMetadata;\n        }\n        // API for metadata created by invoking the decorators.\n        if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {\n            return typeOrFunc[PROP_METADATA];\n        }\n        return null;\n    }\n    propMetadata(typeOrFunc) {\n        if (!isType(typeOrFunc)) {\n            return {};\n        }\n        const parentCtor = getParentCtor(typeOrFunc);\n        const propMetadata = {};\n        if (parentCtor !== Object) {\n            const parentPropMetadata = this.propMetadata(parentCtor);\n            Object.keys(parentPropMetadata).forEach((propName) => {\n                propMetadata[propName] = parentPropMetadata[propName];\n            });\n        }\n        const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);\n        if (ownPropMetadata) {\n            Object.keys(ownPropMetadata).forEach((propName) => {\n                const decorators = [];\n                if (propMetadata.hasOwnProperty(propName)) {\n                    decorators.push(...propMetadata[propName]);\n                }\n                decorators.push(...ownPropMetadata[propName]);\n                propMetadata[propName] = decorators;\n            });\n        }\n        return propMetadata;\n    }\n    ownPropMetadata(typeOrFunc) {\n        if (!isType(typeOrFunc)) {\n            return {};\n        }\n        return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};\n    }\n    hasLifecycleHook(type, lcProperty) {\n        return type instanceof Type && lcProperty in type.prototype;\n    }\n}\nfunction convertTsickleDecoratorIntoMetadata(decoratorInvocations) {\n    if (!decoratorInvocations) {\n        return [];\n    }\n    return decoratorInvocations.map(decoratorInvocation => {\n        const decoratorType = decoratorInvocation.type;\n        const annotationCls = decoratorType.annotationCls;\n        const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];\n        return new annotationCls(...annotationArgs);\n    });\n}\nfunction getParentCtor(ctor) {\n    const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;\n    const parentCtor = parentProto ? parentProto.constructor : null;\n    // Note: We always use `Object` as the null value\n    // to simplify checking later on.\n    return parentCtor || Object;\n}\n\nfunction ngDevModeResetPerfCounters() {\n    const locationString = typeof location !== 'undefined' ? location.toString() : '';\n    const newCounters = {\n        namedConstructors: locationString.indexOf('ngDevMode=namedConstructors') != -1,\n        firstCreatePass: 0,\n        tNode: 0,\n        tView: 0,\n        rendererCreateTextNode: 0,\n        rendererSetText: 0,\n        rendererCreateElement: 0,\n        rendererAddEventListener: 0,\n        rendererSetAttribute: 0,\n        rendererRemoveAttribute: 0,\n        rendererSetProperty: 0,\n        rendererSetClassName: 0,\n        rendererAddClass: 0,\n        rendererRemoveClass: 0,\n        rendererSetStyle: 0,\n        rendererRemoveStyle: 0,\n        rendererDestroy: 0,\n        rendererDestroyNode: 0,\n        rendererMoveNode: 0,\n        rendererRemoveNode: 0,\n        rendererAppendChild: 0,\n        rendererInsertBefore: 0,\n        rendererCreateComment: 0,\n        hydratedNodes: 0,\n        hydratedComponents: 0,\n        dehydratedViewsRemoved: 0,\n        dehydratedViewsCleanupRuns: 0,\n        componentsSkippedHydration: 0,\n    };\n    // Make sure to refer to ngDevMode as ['ngDevMode'] for closure.\n    const allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;\n    _global['ngDevMode'] = allowNgDevModeTrue && newCounters;\n    return newCounters;\n}\n/**\n * This function checks to see if the `ngDevMode` has been set. If yes,\n * then we honor it, otherwise we default to dev mode with additional checks.\n *\n * The idea is that unless we are doing production build where we explicitly\n * set `ngDevMode == false` we should be helping the developer by providing\n * as much early warning and errors as possible.\n *\n * `ɵɵdefineComponent` is guaranteed to have been called before any component template functions\n * (and thus Ivy instructions), so a single initialization there is sufficient to ensure ngDevMode\n * is defined for the entire instruction set.\n *\n * When checking `ngDevMode` on toplevel, always init it before referencing it\n * (e.g. `((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode())`), otherwise you can\n *  get a `ReferenceError` like in https://github.com/angular/angular/issues/31595.\n *\n * Details on possible values for `ngDevMode` can be found on its docstring.\n *\n * NOTE:\n * - changes to the `ngDevMode` name must be synced with `compiler-cli/src/tooling.ts`.\n */\nfunction initNgDevMode() {\n    // The below checks are to ensure that calling `initNgDevMode` multiple times does not\n    // reset the counters.\n    // If the `ngDevMode` is not an object, then it means we have not created the perf counters\n    // yet.\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        if (typeof ngDevMode !== 'object') {\n            ngDevModeResetPerfCounters();\n        }\n        return typeof ngDevMode !== 'undefined' && !!ngDevMode;\n    }\n    return false;\n}\n\nlet _injectorProfilerContext;\nfunction getInjectorProfilerContext() {\n    !ngDevMode && throwError('getInjectorProfilerContext should never be called in production mode');\n    return _injectorProfilerContext;\n}\nfunction setInjectorProfilerContext(context) {\n    !ngDevMode && throwError('setInjectorProfilerContext should never be called in production mode');\n    const previous = _injectorProfilerContext;\n    _injectorProfilerContext = context;\n    return previous;\n}\nlet injectorProfilerCallback = null;\n/**\n * Sets the callback function which will be invoked during certain DI events within the\n * runtime (for example: injecting services, creating injectable instances, configuring providers)\n *\n * Warning: this function is *INTERNAL* and should not be relied upon in application's code.\n * The contract of the function might be changed in any release and/or the function can be removed\n * completely.\n *\n * @param profiler function provided by the caller or null value to disable profiling.\n */\nconst setInjectorProfiler = (injectorProfiler) => {\n    !ngDevMode && throwError('setInjectorProfiler should never be called in production mode');\n    injectorProfilerCallback = injectorProfiler;\n};\n/**\n * Injector profiler function which emits on DI events executed by the runtime.\n *\n * @param event InjectorProfilerEvent corresponding to the DI event being emitted\n */\nfunction injectorProfiler(event) {\n    !ngDevMode && throwError('Injector profiler should never be called in production mode');\n    if (injectorProfilerCallback != null /* both `null` and `undefined` */) {\n        injectorProfilerCallback(event);\n    }\n}\n/**\n * Emits an InjectorProfilerEventType.ProviderConfigured to the injector profiler. The data in the\n * emitted event includes the raw provider, as well as the token that provider is providing.\n *\n * @param provider A provider object\n */\nfunction emitProviderConfiguredEvent(provider, isViewProvider = false) {\n    !ngDevMode && throwError('Injector profiler should never be called in production mode');\n    injectorProfiler({\n        type: 2 /* InjectorProfilerEventType.ProviderConfigured */,\n        context: getInjectorProfilerContext(),\n        providerRecord: {\n            token: typeof provider === 'function' ? provider : resolveForwardRef(provider.provide),\n            provider,\n            isViewProvider\n        }\n    });\n}\n/**\n * Emits an event to the injector profiler with the instance that was created. Note that\n * the injector associated with this emission can be accessed by using getDebugInjectContext()\n *\n * @param instance an object created by an injector\n */\nfunction emitInstanceCreatedByInjectorEvent(instance) {\n    !ngDevMode && throwError('Injector profiler should never be called in production mode');\n    injectorProfiler({\n        type: 1 /* InjectorProfilerEventType.InstanceCreatedByInjector */,\n        context: getInjectorProfilerContext(),\n        instance: { value: instance }\n    });\n}\n/**\n * @param token DI token associated with injected service\n * @param value the instance of the injected service (i.e the result of `inject(token)`)\n * @param flags the flags that the token was injected with\n */\nfunction emitInjectEvent(token, value, flags) {\n    !ngDevMode && throwError('Injector profiler should never be called in production mode');\n    injectorProfiler({\n        type: 0 /* InjectorProfilerEventType.Inject */,\n        context: getInjectorProfilerContext(),\n        service: { token, value, flags }\n    });\n}\nfunction runInInjectorProfilerContext(injector, token, callback) {\n    !ngDevMode &&\n        throwError('runInInjectorProfilerContext should never be called in production mode');\n    const prevInjectContext = setInjectorProfilerContext({ injector, token });\n    try {\n        callback();\n    }\n    finally {\n        setInjectorProfilerContext(prevInjectContext);\n    }\n}\n\nfunction isEnvironmentProviders(value) {\n    return value && !!value.ɵproviders;\n}\n\n/**\n * Used for stringify render output in Ivy.\n * Important! This function is very performance-sensitive and we should\n * be extra careful not to introduce megamorphic reads in it.\n * Check `core/test/render3/perf/render_stringify` for benchmarks and alternate implementations.\n */\nfunction renderStringify(value) {\n    if (typeof value === 'string')\n        return value;\n    if (value == null)\n        return '';\n    // Use `String` so that it invokes the `toString` method of the value. Note that this\n    // appears to be faster than calling `value.toString` (see `render_stringify` benchmark).\n    return String(value);\n}\n/**\n * Used to stringify a value so that it can be displayed in an error message.\n * Important! This function contains a megamorphic read and should only be\n * used for error messages.\n */\nfunction stringifyForError(value) {\n    if (typeof value === 'function')\n        return value.name || value.toString();\n    if (typeof value === 'object' && value != null && typeof value.type === 'function') {\n        return value.type.name || value.type.toString();\n    }\n    return renderStringify(value);\n}\n\n/** Called when directives inject each other (creating a circular dependency) */\nfunction throwCyclicDependencyError(token, path) {\n    const depPath = path ? `. Dependency path: ${path.join(' > ')} > ${token}` : '';\n    throw new RuntimeError(-200 /* RuntimeErrorCode.CYCLIC_DI_DEPENDENCY */, `Circular dependency in DI detected for ${token}${depPath}`);\n}\nfunction throwMixedMultiProviderError() {\n    throw new Error(`Cannot mix multi providers and regular providers`);\n}\nfunction throwInvalidProviderError(ngModuleType, providers, provider) {\n    if (ngModuleType && providers) {\n        const providerDetail = providers.map(v => v == provider ? '?' + provider + '?' : '...');\n        throw new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}' - only instances of Provider and Type are allowed, got: [${providerDetail.join(', ')}]`);\n    }\n    else if (isEnvironmentProviders(provider)) {\n        if (provider.ɵfromNgModule) {\n            throw new RuntimeError(207 /* RuntimeErrorCode.PROVIDER_IN_WRONG_CONTEXT */, `Invalid providers from 'importProvidersFrom' present in a non-environment injector. 'importProvidersFrom' can't be used for component providers.`);\n        }\n        else {\n            throw new RuntimeError(207 /* RuntimeErrorCode.PROVIDER_IN_WRONG_CONTEXT */, `Invalid providers present in a non-environment injector. 'EnvironmentProviders' can't be used for component providers.`);\n        }\n    }\n    else {\n        throw new Error('Invalid provider');\n    }\n}\n/** Throws an error when a token is not found in DI. */\nfunction throwProviderNotFoundError(token, injectorName) {\n    const injectorDetails = injectorName ? ` in ${injectorName}` : '';\n    throw new RuntimeError(-201 /* RuntimeErrorCode.PROVIDER_NOT_FOUND */, ngDevMode && `No provider for ${stringifyForError(token)} found${injectorDetails}`);\n}\n\n/**\n * Injection flags for DI.\n *\n * @publicApi\n * @deprecated use an options object for [`inject`](api/core/inject) instead.\n */\nvar InjectFlags;\n(function (InjectFlags) {\n    // TODO(alxhub): make this 'const' (and remove `InternalInjectFlags` enum) when ngc no longer\n    // writes exports of it into ngfactory files.\n    /** Check self and check parent injector if needed */\n    InjectFlags[InjectFlags[\"Default\"] = 0] = \"Default\";\n    /**\n     * Specifies that an injector should retrieve a dependency from any injector until reaching the\n     * host element of the current component. (Only used with Element Injector)\n     */\n    InjectFlags[InjectFlags[\"Host\"] = 1] = \"Host\";\n    /** Don't ascend to ancestors of the node requesting injection. */\n    InjectFlags[InjectFlags[\"Self\"] = 2] = \"Self\";\n    /** Skip the node that is requesting injection. */\n    InjectFlags[InjectFlags[\"SkipSelf\"] = 4] = \"SkipSelf\";\n    /** Inject `defaultValue` instead if token not found. */\n    InjectFlags[InjectFlags[\"Optional\"] = 8] = \"Optional\";\n})(InjectFlags || (InjectFlags = {}));\n\n/**\n * Current implementation of inject.\n *\n * By default, it is `injectInjectorOnly`, which makes it `Injector`-only aware. It can be changed\n * to `directiveInject`, which brings in the `NodeInjector` system of ivy. It is designed this\n * way for two reasons:\n *  1. `Injector` should not depend on ivy logic.\n *  2. To maintain tree shake-ability we don't want to bring in unnecessary code.\n */\nlet _injectImplementation;\nfunction getInjectImplementation() {\n    return _injectImplementation;\n}\n/**\n * Sets the current inject implementation.\n */\nfunction setInjectImplementation(impl) {\n    const previous = _injectImplementation;\n    _injectImplementation = impl;\n    return previous;\n}\n/**\n * Injects `root` tokens in limp mode.\n *\n * If no injector exists, we can still inject tree-shakable providers which have `providedIn` set to\n * `\"root\"`. This is known as the limp mode injection. In such case the value is stored in the\n * injectable definition.\n */\nfunction injectRootLimpMode(token, notFoundValue, flags) {\n    const injectableDef = getInjectableDef(token);\n    if (injectableDef && injectableDef.providedIn == 'root') {\n        return injectableDef.value === undefined ? injectableDef.value = injectableDef.factory() :\n            injectableDef.value;\n    }\n    if (flags & InjectFlags.Optional)\n        return null;\n    if (notFoundValue !== undefined)\n        return notFoundValue;\n    throwProviderNotFoundError(stringify(token), 'Injector');\n}\n/**\n * Assert that `_injectImplementation` is not `fn`.\n *\n * This is useful, to prevent infinite recursion.\n *\n * @param fn Function which it should not equal to\n */\nfunction assertInjectImplementationNotEqual(fn) {\n    ngDevMode &&\n        assertNotEqual(_injectImplementation, fn, 'Calling ɵɵinject would cause infinite recursion');\n}\n\nconst _THROW_IF_NOT_FOUND = {};\nconst THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n/*\n * Name of a property (that we patch onto DI decorator), which is used as an annotation of which\n * InjectFlag this decorator represents. This allows to avoid direct references to the DI decorators\n * in the code, thus making them tree-shakable.\n */\nconst DI_DECORATOR_FLAG = '__NG_DI_FLAG__';\nconst NG_TEMP_TOKEN_PATH = 'ngTempTokenPath';\nconst NG_TOKEN_PATH = 'ngTokenPath';\nconst NEW_LINE = /\\n/gm;\nconst NO_NEW_LINE = 'ɵ';\nconst SOURCE = '__source';\n/**\n * Current injector value used by `inject`.\n * - `undefined`: it is an error to call `inject`\n * - `null`: `inject` can be called but there is no injector (limp-mode).\n * - Injector instance: Use the injector for resolution.\n */\nlet _currentInjector = undefined;\nfunction getCurrentInjector() {\n    return _currentInjector;\n}\nfunction setCurrentInjector(injector) {\n    const former = _currentInjector;\n    _currentInjector = injector;\n    return former;\n}\nfunction injectInjectorOnly(token, flags = InjectFlags.Default) {\n    if (_currentInjector === undefined) {\n        throw new RuntimeError(-203 /* RuntimeErrorCode.MISSING_INJECTION_CONTEXT */, ngDevMode &&\n            `inject() must be called from an injection context such as a constructor, a factory function, a field initializer, or a function used with \\`runInInjectionContext\\`.`);\n    }\n    else if (_currentInjector === null) {\n        return injectRootLimpMode(token, undefined, flags);\n    }\n    else {\n        const value = _currentInjector.get(token, flags & InjectFlags.Optional ? null : undefined, flags);\n        ngDevMode && emitInjectEvent(token, value, flags);\n        return value;\n    }\n}\nfunction ɵɵinject(token, flags = InjectFlags.Default) {\n    return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef(token), flags);\n}\n/**\n * Throws an error indicating that a factory function could not be generated by the compiler for a\n * particular class.\n *\n * The name of the class is not mentioned here, but will be in the generated factory function name\n * and thus in the stack trace.\n *\n * @codeGenApi\n */\nfunction ɵɵinvalidFactoryDep(index) {\n    throw new RuntimeError(202 /* RuntimeErrorCode.INVALID_FACTORY_DEPENDENCY */, ngDevMode &&\n        `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.\nThis can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.\n\nPlease check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.`);\n}\n/**\n * Injects a token from the currently active injector.\n * `inject` is only supported in an [injection context](/guide/dependency-injection-context). It can\n * be used during:\n * - Construction (via the `constructor`) of a class being instantiated by the DI system, such\n * as an `@Injectable` or `@Component`.\n * - In the initializer for fields of such classes.\n * - In the factory function specified for `useFactory` of a `Provider` or an `@Injectable`.\n * - In the `factory` function specified for an `InjectionToken`.\n * - In a stackframe of a function call in a DI context\n *\n * @param token A token that represents a dependency that should be injected.\n * @param flags Optional flags that control how injection is executed.\n * The flags correspond to injection strategies that can be specified with\n * parameter decorators `@Host`, `@Self`, `@SkipSelf`, and `@Optional`.\n * @returns the injected value if operation is successful, `null` otherwise.\n * @throws if called outside of a supported context.\n *\n * @usageNotes\n * In practice the `inject()` calls are allowed in a constructor, a constructor parameter and a\n * field initializer:\n *\n * ```typescript\n * @Injectable({providedIn: 'root'})\n * export class Car {\n *   radio: Radio|undefined;\n *   // OK: field initializer\n *   spareTyre = inject(Tyre);\n *\n *   constructor() {\n *     // OK: constructor body\n *     this.radio = inject(Radio);\n *   }\n * }\n * ```\n *\n * It is also legal to call `inject` from a provider's factory:\n *\n * ```typescript\n * providers: [\n *   {provide: Car, useFactory: () => {\n *     // OK: a class factory\n *     const engine = inject(Engine);\n *     return new Car(engine);\n *   }}\n * ]\n * ```\n *\n * Calls to the `inject()` function outside of the class creation context will result in error. Most\n * notably, calls to `inject()` are disallowed after a class instance was created, in methods\n * (including lifecycle hooks):\n *\n * ```typescript\n * @Component({ ... })\n * export class CarComponent {\n *   ngOnInit() {\n *     // ERROR: too late, the component instance was already created\n *     const engine = inject(Engine);\n *     engine.start();\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nfunction inject$1(token, flags = InjectFlags.Default) {\n    return ɵɵinject(token, convertToBitFlags(flags));\n}\n// Converts object-based DI flags (`InjectOptions`) to bit flags (`InjectFlags`).\nfunction convertToBitFlags(flags) {\n    if (typeof flags === 'undefined' || typeof flags === 'number') {\n        return flags;\n    }\n    // While TypeScript doesn't accept it without a cast, bitwise OR with false-y values in\n    // JavaScript is a no-op. We can use that for a very codesize-efficient conversion from\n    // `InjectOptions` to `InjectFlags`.\n    return (0 /* InternalInjectFlags.Default */ | // comment to force a line break in the formatter\n        (flags.optional && 8 /* InternalInjectFlags.Optional */) |\n        (flags.host && 1 /* InternalInjectFlags.Host */) |\n        (flags.self && 2 /* InternalInjectFlags.Self */) |\n        (flags.skipSelf && 4 /* InternalInjectFlags.SkipSelf */));\n}\nfunction injectArgs(types) {\n    const args = [];\n    for (let i = 0; i < types.length; i++) {\n        const arg = resolveForwardRef(types[i]);\n        if (Array.isArray(arg)) {\n            if (arg.length === 0) {\n                throw new RuntimeError(900 /* RuntimeErrorCode.INVALID_DIFFER_INPUT */, ngDevMode && 'Arguments array must have arguments.');\n            }\n            let type = undefined;\n            let flags = InjectFlags.Default;\n            for (let j = 0; j < arg.length; j++) {\n                const meta = arg[j];\n                const flag = getInjectFlag(meta);\n                if (typeof flag === 'number') {\n                    // Special case when we handle @Inject decorator.\n                    if (flag === -1 /* DecoratorFlags.Inject */) {\n                        type = meta.token;\n                    }\n                    else {\n                        flags |= flag;\n                    }\n                }\n                else {\n                    type = meta;\n                }\n            }\n            args.push(ɵɵinject(type, flags));\n        }\n        else {\n            args.push(ɵɵinject(arg));\n        }\n    }\n    return args;\n}\n/**\n * Attaches a given InjectFlag to a given decorator using monkey-patching.\n * Since DI decorators can be used in providers `deps` array (when provider is configured using\n * `useFactory`) without initialization (e.g. `Host`) and as an instance (e.g. `new Host()`), we\n * attach the flag to make it available both as a static property and as a field on decorator\n * instance.\n *\n * @param decorator Provided DI decorator.\n * @param flag InjectFlag that should be applied.\n */\nfunction attachInjectFlag(decorator, flag) {\n    decorator[DI_DECORATOR_FLAG] = flag;\n    decorator.prototype[DI_DECORATOR_FLAG] = flag;\n    return decorator;\n}\n/**\n * Reads monkey-patched property that contains InjectFlag attached to a decorator.\n *\n * @param token Token that may contain monkey-patched DI flags property.\n */\nfunction getInjectFlag(token) {\n    return token[DI_DECORATOR_FLAG];\n}\nfunction catchInjectorError(e, token, injectorErrorName, source) {\n    const tokenPath = e[NG_TEMP_TOKEN_PATH];\n    if (token[SOURCE]) {\n        tokenPath.unshift(token[SOURCE]);\n    }\n    e.message = formatError('\\n' + e.message, tokenPath, injectorErrorName, source);\n    e[NG_TOKEN_PATH] = tokenPath;\n    e[NG_TEMP_TOKEN_PATH] = null;\n    throw e;\n}\nfunction formatError(text, obj, injectorErrorName, source = null) {\n    text = text && text.charAt(0) === '\\n' && text.charAt(1) == NO_NEW_LINE ? text.slice(2) : text;\n    let context = stringify(obj);\n    if (Array.isArray(obj)) {\n        context = obj.map(stringify).join(' -> ');\n    }\n    else if (typeof obj === 'object') {\n        let parts = [];\n        for (let key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                let value = obj[key];\n                parts.push(key + ':' + (typeof value === 'string' ? JSON.stringify(value) : stringify(value)));\n            }\n        }\n        context = `{${parts.join(', ')}}`;\n    }\n    return `${injectorErrorName}${source ? '(' + source + ')' : ''}[${context}]: ${text.replace(NEW_LINE, '\\n  ')}`;\n}\n\n/**\n * Inject decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Inject = attachInjectFlag(\n// Disable tslint because `DecoratorFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nmakeParamDecorator('Inject', (token) => ({ token })), -1 /* DecoratorFlags.Inject */);\n/**\n * Optional decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Optional = \n// Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nattachInjectFlag(makeParamDecorator('Optional'), 8 /* InternalInjectFlags.Optional */);\n/**\n * Self decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Self = \n// Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nattachInjectFlag(makeParamDecorator('Self'), 2 /* InternalInjectFlags.Self */);\n/**\n * `SkipSelf` decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst SkipSelf = \n// Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nattachInjectFlag(makeParamDecorator('SkipSelf'), 4 /* InternalInjectFlags.SkipSelf */);\n/**\n * Host decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Host = \n// Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nattachInjectFlag(makeParamDecorator('Host'), 1 /* InternalInjectFlags.Host */);\n\n/**\n * The strategy that the default change detector uses to detect changes.\n * When set, takes effect the next time change detection is triggered.\n *\n * @see {@link ChangeDetectorRef#usage-notes Change detection usage}\n *\n * @publicApi\n */\nvar ChangeDetectionStrategy;\n(function (ChangeDetectionStrategy) {\n    /**\n     * Use the `CheckOnce` strategy, meaning that automatic change detection is deactivated\n     * until reactivated by setting the strategy to `Default` (`CheckAlways`).\n     * Change detection can still be explicitly invoked.\n     * This strategy applies to all child directives and cannot be overridden.\n     */\n    ChangeDetectionStrategy[ChangeDetectionStrategy[\"OnPush\"] = 0] = \"OnPush\";\n    /**\n     * Use the default `CheckAlways` strategy, in which change detection is automatic until\n     * explicitly deactivated.\n     */\n    ChangeDetectionStrategy[ChangeDetectionStrategy[\"Default\"] = 1] = \"Default\";\n})(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));\n\n/**\n * Defines the CSS styles encapsulation policies for the {@link Component} decorator's\n * `encapsulation` option.\n *\n * See {@link Component#encapsulation encapsulation}.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/ts/metadata/encapsulation.ts region='longform'}\n *\n * @publicApi\n */\nvar ViewEncapsulation;\n(function (ViewEncapsulation) {\n    // TODO: consider making `ViewEncapsulation` a `const enum` instead. See\n    // https://github.com/angular/angular/issues/44119 for additional information.\n    /**\n     * Emulates a native Shadow DOM encapsulation behavior by adding a specific attribute to the\n     * component's host element and applying the same attribute to all the CSS selectors provided\n     * via {@link Component#styles styles} or {@link Component#styleUrls styleUrls}.\n     *\n     * This is the default option.\n     */\n    ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\";\n    // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.\n    /**\n     * Doesn't provide any sort of CSS style encapsulation, meaning that all the styles provided\n     * via {@link Component#styles styles} or {@link Component#styleUrls styleUrls} are applicable\n     * to any HTML element of the application regardless of their host Component.\n     */\n    ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\n    /**\n     * Uses the browser's native Shadow DOM API to encapsulate CSS styles, meaning that it creates\n     * a ShadowRoot for the component's host element which is then used to encapsulate\n     * all the Component's styling.\n     */\n    ViewEncapsulation[ViewEncapsulation[\"ShadowDom\"] = 3] = \"ShadowDom\";\n})(ViewEncapsulation || (ViewEncapsulation = {}));\n\n/**\n * This file contains reuseable \"empty\" symbols that can be used as default return values\n * in different parts of the rendering code. Because the same symbols are returned, this\n * allows for identity checks against these values to be consistently used by the framework\n * code.\n */\nconst EMPTY_OBJ = {};\nconst EMPTY_ARRAY = [];\n// freezing the values prevents any code from accidentally inserting new values in\nif ((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode()) {\n    // These property accesses can be ignored because ngDevMode will be set to false\n    // when optimizing code and the whole if statement will be dropped.\n    // tslint:disable-next-line:no-toplevel-property-access\n    Object.freeze(EMPTY_OBJ);\n    // tslint:disable-next-line:no-toplevel-property-access\n    Object.freeze(EMPTY_ARRAY);\n}\n\nconst NG_COMP_DEF = getClosureSafeProperty({ ɵcmp: getClosureSafeProperty });\nconst NG_DIR_DEF = getClosureSafeProperty({ ɵdir: getClosureSafeProperty });\nconst NG_PIPE_DEF = getClosureSafeProperty({ ɵpipe: getClosureSafeProperty });\nconst NG_MOD_DEF = getClosureSafeProperty({ ɵmod: getClosureSafeProperty });\nconst NG_FACTORY_DEF = getClosureSafeProperty({ ɵfac: getClosureSafeProperty });\n/**\n * If a directive is diPublic, bloomAdd sets a property on the type with this constant as\n * the key and the directive's unique ID as the value. This allows us to map directives to their\n * bloom filter bit for DI.\n */\n// TODO(misko): This is wrong. The NG_ELEMENT_ID should never be minified.\nconst NG_ELEMENT_ID = getClosureSafeProperty({ __NG_ELEMENT_ID__: getClosureSafeProperty });\n/**\n * The `NG_ENV_ID` field on a DI token indicates special processing in the `EnvironmentInjector`:\n * getting such tokens from the `EnvironmentInjector` will bypass the standard DI resolution\n * strategy and instead will return implementation produced by the `NG_ENV_ID` factory function.\n *\n * This particular retrieval of DI tokens is mostly done to eliminate circular dependencies and\n * improve tree-shaking.\n */\nconst NG_ENV_ID = getClosureSafeProperty({ __NG_ENV_ID__: getClosureSafeProperty });\n\n/**\n * Returns an index of `classToSearch` in `className` taking token boundaries into account.\n *\n * `classIndexOf('AB A', 'A', 0)` will be 3 (not 0 since `AB!==A`)\n *\n * @param className A string containing classes (whitespace separated)\n * @param classToSearch A class name to locate\n * @param startingIndex Starting location of search\n * @returns an index of the located class (or -1 if not found)\n */\nfunction classIndexOf(className, classToSearch, startingIndex) {\n    ngDevMode && assertNotEqual(classToSearch, '', 'can not look for \"\" string.');\n    let end = className.length;\n    while (true) {\n        const foundIndex = className.indexOf(classToSearch, startingIndex);\n        if (foundIndex === -1)\n            return foundIndex;\n        if (foundIndex === 0 || className.charCodeAt(foundIndex - 1) <= 32 /* CharCode.SPACE */) {\n            // Ensure that it has leading whitespace\n            const length = classToSearch.length;\n            if (foundIndex + length === end ||\n                className.charCodeAt(foundIndex + length) <= 32 /* CharCode.SPACE */) {\n                // Ensure that it has trailing whitespace\n                return foundIndex;\n            }\n        }\n        // False positive, keep searching from where we left off.\n        startingIndex = foundIndex + 1;\n    }\n}\n\n/**\n * Assigns all attribute values to the provided element via the inferred renderer.\n *\n * This function accepts two forms of attribute entries:\n *\n * default: (key, value):\n *  attrs = [key1, value1, key2, value2]\n *\n * namespaced: (NAMESPACE_MARKER, uri, name, value)\n *  attrs = [NAMESPACE_MARKER, uri, name, value, NAMESPACE_MARKER, uri, name, value]\n *\n * The `attrs` array can contain a mix of both the default and namespaced entries.\n * The \"default\" values are set without a marker, but if the function comes across\n * a marker value then it will attempt to set a namespaced value. If the marker is\n * not of a namespaced value then the function will quit and return the index value\n * where it stopped during the iteration of the attrs array.\n *\n * See [AttributeMarker] to understand what the namespace marker value is.\n *\n * Note that this instruction does not support assigning style and class values to\n * an element. See `elementStart` and `elementHostAttrs` to learn how styling values\n * are applied to an element.\n * @param renderer The renderer to be used\n * @param native The element that the attributes will be assigned to\n * @param attrs The attribute array of values that will be assigned to the element\n * @returns the index value that was last accessed in the attributes array\n */\nfunction setUpAttributes(renderer, native, attrs) {\n    let i = 0;\n    while (i < attrs.length) {\n        const value = attrs[i];\n        if (typeof value === 'number') {\n            // only namespaces are supported. Other value types (such as style/class\n            // entries) are not supported in this function.\n            if (value !== 0 /* AttributeMarker.NamespaceURI */) {\n                break;\n            }\n            // we just landed on the marker value ... therefore\n            // we should skip to the next entry\n            i++;\n            const namespaceURI = attrs[i++];\n            const attrName = attrs[i++];\n            const attrVal = attrs[i++];\n            ngDevMode && ngDevMode.rendererSetAttribute++;\n            renderer.setAttribute(native, attrName, attrVal, namespaceURI);\n        }\n        else {\n            // attrName is string;\n            const attrName = value;\n            const attrVal = attrs[++i];\n            // Standard attributes\n            ngDevMode && ngDevMode.rendererSetAttribute++;\n            if (isAnimationProp(attrName)) {\n                renderer.setProperty(native, attrName, attrVal);\n            }\n            else {\n                renderer.setAttribute(native, attrName, attrVal);\n            }\n            i++;\n        }\n    }\n    // another piece of code may iterate over the same attributes array. Therefore\n    // it may be helpful to return the exact spot where the attributes array exited\n    // whether by running into an unsupported marker or if all the static values were\n    // iterated over.\n    return i;\n}\n/**\n * Test whether the given value is a marker that indicates that the following\n * attribute values in a `TAttributes` array are only the names of attributes,\n * and not name-value pairs.\n * @param marker The attribute marker to test.\n * @returns true if the marker is a \"name-only\" marker (e.g. `Bindings`, `Template` or `I18n`).\n */\nfunction isNameOnlyAttributeMarker(marker) {\n    return marker === 3 /* AttributeMarker.Bindings */ || marker === 4 /* AttributeMarker.Template */ ||\n        marker === 6 /* AttributeMarker.I18n */;\n}\nfunction isAnimationProp(name) {\n    // Perf note: accessing charCodeAt to check for the first character of a string is faster as\n    // compared to accessing a character at index 0 (ex. name[0]). The main reason for this is that\n    // charCodeAt doesn't allocate memory to return a substring.\n    return name.charCodeAt(0) === 64 /* CharCode.AT_SIGN */;\n}\n/**\n * Merges `src` `TAttributes` into `dst` `TAttributes` removing any duplicates in the process.\n *\n * This merge function keeps the order of attrs same.\n *\n * @param dst Location of where the merged `TAttributes` should end up.\n * @param src `TAttributes` which should be appended to `dst`\n */\nfunction mergeHostAttrs(dst, src) {\n    if (src === null || src.length === 0) {\n        // do nothing\n    }\n    else if (dst === null || dst.length === 0) {\n        // We have source, but dst is empty, just make a copy.\n        dst = src.slice();\n    }\n    else {\n        let srcMarker = -1 /* AttributeMarker.ImplicitAttributes */;\n        for (let i = 0; i < src.length; i++) {\n            const item = src[i];\n            if (typeof item === 'number') {\n                srcMarker = item;\n            }\n            else {\n                if (srcMarker === 0 /* AttributeMarker.NamespaceURI */) {\n                    // Case where we need to consume `key1`, `key2`, `value` items.\n                }\n                else if (srcMarker === -1 /* AttributeMarker.ImplicitAttributes */ ||\n                    srcMarker === 2 /* AttributeMarker.Styles */) {\n                    // Case where we have to consume `key1` and `value` only.\n                    mergeHostAttribute(dst, srcMarker, item, null, src[++i]);\n                }\n                else {\n                    // Case where we have to consume `key1` only.\n                    mergeHostAttribute(dst, srcMarker, item, null, null);\n                }\n            }\n        }\n    }\n    return dst;\n}\n/**\n * Append `key`/`value` to existing `TAttributes` taking region marker and duplicates into account.\n *\n * @param dst `TAttributes` to append to.\n * @param marker Region where the `key`/`value` should be added.\n * @param key1 Key to add to `TAttributes`\n * @param key2 Key to add to `TAttributes` (in case of `AttributeMarker.NamespaceURI`)\n * @param value Value to add or to overwrite to `TAttributes` Only used if `marker` is not Class.\n */\nfunction mergeHostAttribute(dst, marker, key1, key2, value) {\n    let i = 0;\n    // Assume that new markers will be inserted at the end.\n    let markerInsertPosition = dst.length;\n    // scan until correct type.\n    if (marker === -1 /* AttributeMarker.ImplicitAttributes */) {\n        markerInsertPosition = -1;\n    }\n    else {\n        while (i < dst.length) {\n            const dstValue = dst[i++];\n            if (typeof dstValue === 'number') {\n                if (dstValue === marker) {\n                    markerInsertPosition = -1;\n                    break;\n                }\n                else if (dstValue > marker) {\n                    // We need to save this as we want the markers to be inserted in specific order.\n                    markerInsertPosition = i - 1;\n                    break;\n                }\n            }\n        }\n    }\n    // search until you find place of insertion\n    while (i < dst.length) {\n        const item = dst[i];\n        if (typeof item === 'number') {\n            // since `i` started as the index after the marker, we did not find it if we are at the next\n            // marker\n            break;\n        }\n        else if (item === key1) {\n            // We already have same token\n            if (key2 === null) {\n                if (value !== null) {\n                    dst[i + 1] = value;\n                }\n                return;\n            }\n            else if (key2 === dst[i + 1]) {\n                dst[i + 2] = value;\n                return;\n            }\n        }\n        // Increment counter.\n        i++;\n        if (key2 !== null)\n            i++;\n        if (value !== null)\n            i++;\n    }\n    // insert at location.\n    if (markerInsertPosition !== -1) {\n        dst.splice(markerInsertPosition, 0, marker);\n        i = markerInsertPosition + 1;\n    }\n    dst.splice(i++, 0, key1);\n    if (key2 !== null) {\n        dst.splice(i++, 0, key2);\n    }\n    if (value !== null) {\n        dst.splice(i++, 0, value);\n    }\n}\n\nconst NG_TEMPLATE_SELECTOR = 'ng-template';\n/**\n * Search the `TAttributes` to see if it contains `cssClassToMatch` (case insensitive)\n *\n * @param attrs `TAttributes` to search through.\n * @param cssClassToMatch class to match (lowercase)\n * @param isProjectionMode Whether or not class matching should look into the attribute `class` in\n *    addition to the `AttributeMarker.Classes`.\n */\nfunction isCssClassMatching(attrs, cssClassToMatch, isProjectionMode) {\n    // TODO(misko): The fact that this function needs to know about `isProjectionMode` seems suspect.\n    // It is strange to me that sometimes the class information comes in form of `class` attribute\n    // and sometimes in form of `AttributeMarker.Classes`. Some investigation is needed to determine\n    // if that is the right behavior.\n    ngDevMode &&\n        assertEqual(cssClassToMatch, cssClassToMatch.toLowerCase(), 'Class name expected to be lowercase.');\n    let i = 0;\n    // Indicates whether we are processing value from the implicit\n    // attribute section (i.e. before the first marker in the array).\n    let isImplicitAttrsSection = true;\n    while (i < attrs.length) {\n        let item = attrs[i++];\n        if (typeof item === 'string' && isImplicitAttrsSection) {\n            const value = attrs[i++];\n            if (isProjectionMode && item === 'class') {\n                // We found a `class` attribute in the implicit attribute section,\n                // check if it matches the value of the `cssClassToMatch` argument.\n                if (classIndexOf(value.toLowerCase(), cssClassToMatch, 0) !== -1) {\n                    return true;\n                }\n            }\n        }\n        else if (item === 1 /* AttributeMarker.Classes */) {\n            // We found the classes section. Start searching for the class.\n            while (i < attrs.length && typeof (item = attrs[i++]) == 'string') {\n                // while we have strings\n                if (item.toLowerCase() === cssClassToMatch)\n                    return true;\n            }\n            return false;\n        }\n        else if (typeof item === 'number') {\n            // We've came across a first marker, which indicates\n            // that the implicit attribute section is over.\n            isImplicitAttrsSection = false;\n        }\n    }\n    return false;\n}\n/**\n * Checks whether the `tNode` represents an inline template (e.g. `*ngFor`).\n *\n * @param tNode current TNode\n */\nfunction isInlineTemplate(tNode) {\n    return tNode.type === 4 /* TNodeType.Container */ && tNode.value !== NG_TEMPLATE_SELECTOR;\n}\n/**\n * Function that checks whether a given tNode matches tag-based selector and has a valid type.\n *\n * Matching can be performed in 2 modes: projection mode (when we project nodes) and regular\n * directive matching mode:\n * - in the \"directive matching\" mode we do _not_ take TContainer's tagName into account if it is\n * different from NG_TEMPLATE_SELECTOR (value different from NG_TEMPLATE_SELECTOR indicates that a\n * tag name was extracted from * syntax so we would match the same directive twice);\n * - in the \"projection\" mode, we use a tag name potentially extracted from the * syntax processing\n * (applicable to TNodeType.Container only).\n */\nfunction hasTagAndTypeMatch(tNode, currentSelector, isProjectionMode) {\n    const tagNameToCompare = tNode.type === 4 /* TNodeType.Container */ && !isProjectionMode ? NG_TEMPLATE_SELECTOR : tNode.value;\n    return currentSelector === tagNameToCompare;\n}\n/**\n * A utility function to match an Ivy node static data against a simple CSS selector\n *\n * @param node static data of the node to match\n * @param selector The selector to try matching against the node.\n * @param isProjectionMode if `true` we are matching for content projection, otherwise we are doing\n * directive matching.\n * @returns true if node matches the selector.\n */\nfunction isNodeMatchingSelector(tNode, selector, isProjectionMode) {\n    ngDevMode && assertDefined(selector[0], 'Selector should have a tag name');\n    let mode = 4 /* SelectorFlags.ELEMENT */;\n    const nodeAttrs = tNode.attrs || [];\n    // Find the index of first attribute that has no value, only a name.\n    const nameOnlyMarkerIdx = getNameOnlyMarkerIndex(nodeAttrs);\n    // When processing \":not\" selectors, we skip to the next \":not\" if the\n    // current one doesn't match\n    let skipToNextSelector = false;\n    for (let i = 0; i < selector.length; i++) {\n        const current = selector[i];\n        if (typeof current === 'number') {\n            // If we finish processing a :not selector and it hasn't failed, return false\n            if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) {\n                return false;\n            }\n            // If we are skipping to the next :not() and this mode flag is positive,\n            // it's a part of the current :not() selector, and we should keep skipping\n            if (skipToNextSelector && isPositive(current))\n                continue;\n            skipToNextSelector = false;\n            mode = current | (mode & 1 /* SelectorFlags.NOT */);\n            continue;\n        }\n        if (skipToNextSelector)\n            continue;\n        if (mode & 4 /* SelectorFlags.ELEMENT */) {\n            mode = 2 /* SelectorFlags.ATTRIBUTE */ | mode & 1 /* SelectorFlags.NOT */;\n            if (current !== '' && !hasTagAndTypeMatch(tNode, current, isProjectionMode) ||\n                current === '' && selector.length === 1) {\n                if (isPositive(mode))\n                    return false;\n                skipToNextSelector = true;\n            }\n        }\n        else {\n            const selectorAttrValue = mode & 8 /* SelectorFlags.CLASS */ ? current : selector[++i];\n            // special case for matching against classes when a tNode has been instantiated with\n            // class and style values as separate attribute values (e.g. ['title', CLASS, 'foo'])\n            if ((mode & 8 /* SelectorFlags.CLASS */) && tNode.attrs !== null) {\n                if (!isCssClassMatching(tNode.attrs, selectorAttrValue, isProjectionMode)) {\n                    if (isPositive(mode))\n                        return false;\n                    skipToNextSelector = true;\n                }\n                continue;\n            }\n            const attrName = (mode & 8 /* SelectorFlags.CLASS */) ? 'class' : current;\n            const attrIndexInNode = findAttrIndexInNode(attrName, nodeAttrs, isInlineTemplate(tNode), isProjectionMode);\n            if (attrIndexInNode === -1) {\n                if (isPositive(mode))\n                    return false;\n                skipToNextSelector = true;\n                continue;\n            }\n            if (selectorAttrValue !== '') {\n                let nodeAttrValue;\n                if (attrIndexInNode > nameOnlyMarkerIdx) {\n                    nodeAttrValue = '';\n                }\n                else {\n                    ngDevMode &&\n                        assertNotEqual(nodeAttrs[attrIndexInNode], 0 /* AttributeMarker.NamespaceURI */, 'We do not match directives on namespaced attributes');\n                    // we lowercase the attribute value to be able to match\n                    // selectors without case-sensitivity\n                    // (selectors are already in lowercase when generated)\n                    nodeAttrValue = nodeAttrs[attrIndexInNode + 1].toLowerCase();\n                }\n                const compareAgainstClassName = mode & 8 /* SelectorFlags.CLASS */ ? nodeAttrValue : null;\n                if (compareAgainstClassName &&\n                    classIndexOf(compareAgainstClassName, selectorAttrValue, 0) !== -1 ||\n                    mode & 2 /* SelectorFlags.ATTRIBUTE */ && selectorAttrValue !== nodeAttrValue) {\n                    if (isPositive(mode))\n                        return false;\n                    skipToNextSelector = true;\n                }\n            }\n        }\n    }\n    return isPositive(mode) || skipToNextSelector;\n}\nfunction isPositive(mode) {\n    return (mode & 1 /* SelectorFlags.NOT */) === 0;\n}\n/**\n * Examines the attribute's definition array for a node to find the index of the\n * attribute that matches the given `name`.\n *\n * NOTE: This will not match namespaced attributes.\n *\n * Attribute matching depends upon `isInlineTemplate` and `isProjectionMode`.\n * The following table summarizes which types of attributes we attempt to match:\n *\n * ===========================================================================================================\n * Modes                   | Normal Attributes | Bindings Attributes | Template Attributes | I18n\n * Attributes\n * ===========================================================================================================\n * Inline + Projection     | YES               | YES                 | NO                  | YES\n * -----------------------------------------------------------------------------------------------------------\n * Inline + Directive      | NO                | NO                  | YES                 | NO\n * -----------------------------------------------------------------------------------------------------------\n * Non-inline + Projection | YES               | YES                 | NO                  | YES\n * -----------------------------------------------------------------------------------------------------------\n * Non-inline + Directive  | YES               | YES                 | NO                  | YES\n * ===========================================================================================================\n *\n * @param name the name of the attribute to find\n * @param attrs the attribute array to examine\n * @param isInlineTemplate true if the node being matched is an inline template (e.g. `*ngFor`)\n * rather than a manually expanded template node (e.g `<ng-template>`).\n * @param isProjectionMode true if we are matching against content projection otherwise we are\n * matching against directives.\n */\nfunction findAttrIndexInNode(name, attrs, isInlineTemplate, isProjectionMode) {\n    if (attrs === null)\n        return -1;\n    let i = 0;\n    if (isProjectionMode || !isInlineTemplate) {\n        let bindingsMode = false;\n        while (i < attrs.length) {\n            const maybeAttrName = attrs[i];\n            if (maybeAttrName === name) {\n                return i;\n            }\n            else if (maybeAttrName === 3 /* AttributeMarker.Bindings */ || maybeAttrName === 6 /* AttributeMarker.I18n */) {\n                bindingsMode = true;\n            }\n            else if (maybeAttrName === 1 /* AttributeMarker.Classes */ || maybeAttrName === 2 /* AttributeMarker.Styles */) {\n                let value = attrs[++i];\n                // We should skip classes here because we have a separate mechanism for\n                // matching classes in projection mode.\n                while (typeof value === 'string') {\n                    value = attrs[++i];\n                }\n                continue;\n            }\n            else if (maybeAttrName === 4 /* AttributeMarker.Template */) {\n                // We do not care about Template attributes in this scenario.\n                break;\n            }\n            else if (maybeAttrName === 0 /* AttributeMarker.NamespaceURI */) {\n                // Skip the whole namespaced attribute and value. This is by design.\n                i += 4;\n                continue;\n            }\n            // In binding mode there are only names, rather than name-value pairs.\n            i += bindingsMode ? 1 : 2;\n        }\n        // We did not match the attribute\n        return -1;\n    }\n    else {\n        return matchTemplateAttribute(attrs, name);\n    }\n}\nfunction isNodeMatchingSelectorList(tNode, selector, isProjectionMode = false) {\n    for (let i = 0; i < selector.length; i++) {\n        if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction getProjectAsAttrValue(tNode) {\n    const nodeAttrs = tNode.attrs;\n    if (nodeAttrs != null) {\n        const ngProjectAsAttrIdx = nodeAttrs.indexOf(5 /* AttributeMarker.ProjectAs */);\n        // only check for ngProjectAs in attribute names, don't accidentally match attribute's value\n        // (attribute names are stored at even indexes)\n        if ((ngProjectAsAttrIdx & 1) === 0) {\n            return nodeAttrs[ngProjectAsAttrIdx + 1];\n        }\n    }\n    return null;\n}\nfunction getNameOnlyMarkerIndex(nodeAttrs) {\n    for (let i = 0; i < nodeAttrs.length; i++) {\n        const nodeAttr = nodeAttrs[i];\n        if (isNameOnlyAttributeMarker(nodeAttr)) {\n            return i;\n        }\n    }\n    return nodeAttrs.length;\n}\nfunction matchTemplateAttribute(attrs, name) {\n    let i = attrs.indexOf(4 /* AttributeMarker.Template */);\n    if (i > -1) {\n        i++;\n        while (i < attrs.length) {\n            const attr = attrs[i];\n            // Return in case we checked all template attrs and are switching to the next section in the\n            // attrs array (that starts with a number that represents an attribute marker).\n            if (typeof attr === 'number')\n                return -1;\n            if (attr === name)\n                return i;\n            i++;\n        }\n    }\n    return -1;\n}\n/**\n * Checks whether a selector is inside a CssSelectorList\n * @param selector Selector to be checked.\n * @param list List in which to look for the selector.\n */\nfunction isSelectorInSelectorList(selector, list) {\n    selectorListLoop: for (let i = 0; i < list.length; i++) {\n        const currentSelectorInList = list[i];\n        if (selector.length !== currentSelectorInList.length) {\n            continue;\n        }\n        for (let j = 0; j < selector.length; j++) {\n            if (selector[j] !== currentSelectorInList[j]) {\n                continue selectorListLoop;\n            }\n        }\n        return true;\n    }\n    return false;\n}\nfunction maybeWrapInNotSelector(isNegativeMode, chunk) {\n    return isNegativeMode ? ':not(' + chunk.trim() + ')' : chunk;\n}\nfunction stringifyCSSSelector(selector) {\n    let result = selector[0];\n    let i = 1;\n    let mode = 2 /* SelectorFlags.ATTRIBUTE */;\n    let currentChunk = '';\n    let isNegativeMode = false;\n    while (i < selector.length) {\n        let valueOrMarker = selector[i];\n        if (typeof valueOrMarker === 'string') {\n            if (mode & 2 /* SelectorFlags.ATTRIBUTE */) {\n                const attrValue = selector[++i];\n                currentChunk +=\n                    '[' + valueOrMarker + (attrValue.length > 0 ? '=\"' + attrValue + '\"' : '') + ']';\n            }\n            else if (mode & 8 /* SelectorFlags.CLASS */) {\n                currentChunk += '.' + valueOrMarker;\n            }\n            else if (mode & 4 /* SelectorFlags.ELEMENT */) {\n                currentChunk += ' ' + valueOrMarker;\n            }\n        }\n        else {\n            //\n            // Append current chunk to the final result in case we come across SelectorFlag, which\n            // indicates that the previous section of a selector is over. We need to accumulate content\n            // between flags to make sure we wrap the chunk later in :not() selector if needed, e.g.\n            // ```\n            //  ['', Flags.CLASS, '.classA', Flags.CLASS | Flags.NOT, '.classB', '.classC']\n            // ```\n            // should be transformed to `.classA :not(.classB .classC)`.\n            //\n            // Note: for negative selector part, we accumulate content between flags until we find the\n            // next negative flag. This is needed to support a case where `:not()` rule contains more than\n            // one chunk, e.g. the following selector:\n            // ```\n            //  ['', Flags.ELEMENT | Flags.NOT, 'p', Flags.CLASS, 'foo', Flags.CLASS | Flags.NOT, 'bar']\n            // ```\n            // should be stringified to `:not(p.foo) :not(.bar)`\n            //\n            if (currentChunk !== '' && !isPositive(valueOrMarker)) {\n                result += maybeWrapInNotSelector(isNegativeMode, currentChunk);\n                currentChunk = '';\n            }\n            mode = valueOrMarker;\n            // According to CssSelector spec, once we come across `SelectorFlags.NOT` flag, the negative\n            // mode is maintained for remaining chunks of a selector.\n            isNegativeMode = isNegativeMode || !isPositive(mode);\n        }\n        i++;\n    }\n    if (currentChunk !== '') {\n        result += maybeWrapInNotSelector(isNegativeMode, currentChunk);\n    }\n    return result;\n}\n/**\n * Generates string representation of CSS selector in parsed form.\n *\n * ComponentDef and DirectiveDef are generated with the selector in parsed form to avoid doing\n * additional parsing at runtime (for example, for directive matching). However in some cases (for\n * example, while bootstrapping a component), a string version of the selector is required to query\n * for the host element on the page. This function takes the parsed form of a selector and returns\n * its string representation.\n *\n * @param selectorList selector in parsed form\n * @returns string representation of a given selector\n */\nfunction stringifyCSSSelectorList(selectorList) {\n    return selectorList.map(stringifyCSSSelector).join(',');\n}\n/**\n * Extracts attributes and classes information from a given CSS selector.\n *\n * This function is used while creating a component dynamically. In this case, the host element\n * (that is created dynamically) should contain attributes and classes specified in component's CSS\n * selector.\n *\n * @param selector CSS selector in parsed form (in a form of array)\n * @returns object with `attrs` and `classes` fields that contain extracted information\n */\nfunction extractAttrsAndClassesFromSelector(selector) {\n    const attrs = [];\n    const classes = [];\n    let i = 1;\n    let mode = 2 /* SelectorFlags.ATTRIBUTE */;\n    while (i < selector.length) {\n        let valueOrMarker = selector[i];\n        if (typeof valueOrMarker === 'string') {\n            if (mode === 2 /* SelectorFlags.ATTRIBUTE */) {\n                if (valueOrMarker !== '') {\n                    attrs.push(valueOrMarker, selector[++i]);\n                }\n            }\n            else if (mode === 8 /* SelectorFlags.CLASS */) {\n                classes.push(valueOrMarker);\n            }\n        }\n        else {\n            // According to CssSelector spec, once we come across `SelectorFlags.NOT` flag, the negative\n            // mode is maintained for remaining chunks of a selector. Since attributes and classes are\n            // extracted only for \"positive\" part of the selector, we can stop here.\n            if (!isPositive(mode))\n                break;\n            mode = valueOrMarker;\n        }\n        i++;\n    }\n    return { attrs, classes };\n}\n\n/**\n * Create a component definition object.\n *\n *\n * # Example\n * ```\n * class MyComponent {\n *   // Generated by Angular Template Compiler\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\n *   static ɵcmp = defineComponent({\n *     ...\n *   });\n * }\n * ```\n * @codeGenApi\n */\nfunction ɵɵdefineComponent(componentDefinition) {\n    return noSideEffects(() => {\n        // Initialize ngDevMode. This must be the first statement in ɵɵdefineComponent.\n        // See the `initNgDevMode` docstring for more information.\n        (typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode();\n        const baseDef = getNgDirectiveDef(componentDefinition);\n        const def = {\n            ...baseDef,\n            decls: componentDefinition.decls,\n            vars: componentDefinition.vars,\n            template: componentDefinition.template,\n            consts: componentDefinition.consts || null,\n            ngContentSelectors: componentDefinition.ngContentSelectors,\n            onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,\n            directiveDefs: null,\n            pipeDefs: null,\n            dependencies: baseDef.standalone && componentDefinition.dependencies || null,\n            getStandaloneInjector: null,\n            signals: componentDefinition.signals ?? false,\n            data: componentDefinition.data || {},\n            encapsulation: componentDefinition.encapsulation || ViewEncapsulation.Emulated,\n            styles: componentDefinition.styles || EMPTY_ARRAY,\n            _: null,\n            schemas: componentDefinition.schemas || null,\n            tView: null,\n            id: '',\n        };\n        initFeatures(def);\n        const dependencies = componentDefinition.dependencies;\n        def.directiveDefs = extractDefListOrFactory(dependencies, /* pipeDef */ false);\n        def.pipeDefs = extractDefListOrFactory(dependencies, /* pipeDef */ true);\n        def.id = getComponentId(def);\n        return def;\n    });\n}\n/**\n * Generated next to NgModules to monkey-patch directive and pipe references onto a component's\n * definition, when generating a direct reference in the component file would otherwise create an\n * import cycle.\n *\n * See [this explanation](https://hackmd.io/Odw80D0pR6yfsOjg_7XCJg?view) for more details.\n *\n * @codeGenApi\n */\nfunction ɵɵsetComponentScope(type, directives, pipes) {\n    const def = type.ɵcmp;\n    def.directiveDefs = extractDefListOrFactory(directives, /* pipeDef */ false);\n    def.pipeDefs = extractDefListOrFactory(pipes, /* pipeDef */ true);\n}\nfunction extractDirectiveDef(type) {\n    return getComponentDef$1(type) || getDirectiveDef(type);\n}\nfunction nonNull(value) {\n    return value !== null;\n}\n/**\n * @codeGenApi\n */\nfunction ɵɵdefineNgModule(def) {\n    return noSideEffects(() => {\n        const res = {\n            type: def.type,\n            bootstrap: def.bootstrap || EMPTY_ARRAY,\n            declarations: def.declarations || EMPTY_ARRAY,\n            imports: def.imports || EMPTY_ARRAY,\n            exports: def.exports || EMPTY_ARRAY,\n            transitiveCompileScopes: null,\n            schemas: def.schemas || null,\n            id: def.id || null,\n        };\n        return res;\n    });\n}\n/**\n * Adds the module metadata that is necessary to compute the module's transitive scope to an\n * existing module definition.\n *\n * Scope metadata of modules is not used in production builds, so calls to this function can be\n * marked pure to tree-shake it from the bundle, allowing for all referenced declarations\n * to become eligible for tree-shaking as well.\n *\n * @codeGenApi\n */\nfunction ɵɵsetNgModuleScope(type, scope) {\n    return noSideEffects(() => {\n        const ngModuleDef = getNgModuleDef(type, true);\n        ngModuleDef.declarations = scope.declarations || EMPTY_ARRAY;\n        ngModuleDef.imports = scope.imports || EMPTY_ARRAY;\n        ngModuleDef.exports = scope.exports || EMPTY_ARRAY;\n    });\n}\n/**\n * Inverts an inputs or outputs lookup such that the keys, which were the\n * minified keys, are part of the values, and the values are parsed so that\n * the publicName of the property is the new key\n *\n * e.g. for\n *\n * ```\n * class Comp {\n *   @Input()\n *   propName1: string;\n *\n *   @Input('publicName2')\n *   declaredPropName2: number;\n * }\n * ```\n *\n * will be serialized as\n *\n * ```\n * {\n *   propName1: 'propName1',\n *   declaredPropName2: ['publicName2', 'declaredPropName2'],\n * }\n * ```\n *\n * which is than translated by the minifier as:\n *\n * ```\n * {\n *   minifiedPropName1: 'propName1',\n *   minifiedPropName2: ['publicName2', 'declaredPropName2'],\n * }\n * ```\n *\n * becomes: (public name => minifiedName)\n *\n * ```\n * {\n *  'propName1': 'minifiedPropName1',\n *  'publicName2': 'minifiedPropName2',\n * }\n * ```\n *\n * Optionally the function can take `secondary` which will result in: (public name => declared name)\n *\n * ```\n * {\n *  'propName1': 'propName1',\n *  'publicName2': 'declaredPropName2',\n * }\n * ```\n *\n\n */\nfunction invertObject(obj, secondary) {\n    if (obj == null)\n        return EMPTY_OBJ;\n    const newLookup = {};\n    for (const minifiedKey in obj) {\n        if (obj.hasOwnProperty(minifiedKey)) {\n            let publicName = obj[minifiedKey];\n            let declaredName = publicName;\n            if (Array.isArray(publicName)) {\n                declaredName = publicName[1];\n                publicName = publicName[0];\n            }\n            newLookup[publicName] = minifiedKey;\n            if (secondary) {\n                (secondary[publicName] = declaredName);\n            }\n        }\n    }\n    return newLookup;\n}\n/**\n * Create a directive definition object.\n *\n * # Example\n * ```ts\n * class MyDirective {\n *   // Generated by Angular Template Compiler\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\n *   static ɵdir = ɵɵdefineDirective({\n *     ...\n *   });\n * }\n * ```\n *\n * @codeGenApi\n */\nfunction ɵɵdefineDirective(directiveDefinition) {\n    return noSideEffects(() => {\n        const def = getNgDirectiveDef(directiveDefinition);\n        initFeatures(def);\n        return def;\n    });\n}\n/**\n * Create a pipe definition object.\n *\n * # Example\n * ```\n * class MyPipe implements PipeTransform {\n *   // Generated by Angular Template Compiler\n *   static ɵpipe = definePipe({\n *     ...\n *   });\n * }\n * ```\n * @param pipeDef Pipe definition generated by the compiler\n *\n * @codeGenApi\n */\nfunction ɵɵdefinePipe(pipeDef) {\n    return {\n        type: pipeDef.type,\n        name: pipeDef.name,\n        factory: null,\n        pure: pipeDef.pure !== false,\n        standalone: pipeDef.standalone === true,\n        onDestroy: pipeDef.type.prototype.ngOnDestroy || null\n    };\n}\n/**\n * The following getter methods retrieve the definition from the type. Currently the retrieval\n * honors inheritance, but in the future we may change the rule to require that definitions are\n * explicit. This would require some sort of migration strategy.\n */\nfunction getComponentDef$1(type) {\n    return type[NG_COMP_DEF] || null;\n}\nfunction getDirectiveDef(type) {\n    return type[NG_DIR_DEF] || null;\n}\nfunction getPipeDef$1(type) {\n    return type[NG_PIPE_DEF] || null;\n}\n/**\n * Checks whether a given Component, Directive or Pipe is marked as standalone.\n * This will return false if passed anything other than a Component, Directive, or Pipe class\n * See [this guide](/guide/standalone-components) for additional information:\n *\n * @param type A reference to a Component, Directive or Pipe.\n * @publicApi\n */\nfunction isStandalone(type) {\n    const def = getComponentDef$1(type) || getDirectiveDef(type) || getPipeDef$1(type);\n    return def !== null ? def.standalone : false;\n}\nfunction getNgModuleDef(type, throwNotFound) {\n    const ngModuleDef = type[NG_MOD_DEF] || null;\n    if (!ngModuleDef && throwNotFound === true) {\n        throw new Error(`Type ${stringify(type)} does not have 'ɵmod' property.`);\n    }\n    return ngModuleDef;\n}\nfunction getNgDirectiveDef(directiveDefinition) {\n    const declaredInputs = {};\n    return {\n        type: directiveDefinition.type,\n        providersResolver: null,\n        factory: null,\n        hostBindings: directiveDefinition.hostBindings || null,\n        hostVars: directiveDefinition.hostVars || 0,\n        hostAttrs: directiveDefinition.hostAttrs || null,\n        contentQueries: directiveDefinition.contentQueries || null,\n        declaredInputs,\n        inputTransforms: null,\n        inputConfig: directiveDefinition.inputs || EMPTY_OBJ,\n        exportAs: directiveDefinition.exportAs || null,\n        standalone: directiveDefinition.standalone === true,\n        signals: directiveDefinition.signals === true,\n        selectors: directiveDefinition.selectors || EMPTY_ARRAY,\n        viewQuery: directiveDefinition.viewQuery || null,\n        features: directiveDefinition.features || null,\n        setInput: null,\n        findHostDirectiveDefs: null,\n        hostDirectives: null,\n        inputs: invertObject(directiveDefinition.inputs, declaredInputs),\n        outputs: invertObject(directiveDefinition.outputs),\n    };\n}\nfunction initFeatures(definition) {\n    definition.features?.forEach((fn) => fn(definition));\n}\nfunction extractDefListOrFactory(dependencies, pipeDef) {\n    if (!dependencies) {\n        return null;\n    }\n    const defExtractor = pipeDef ? getPipeDef$1 : extractDirectiveDef;\n    return () => (typeof dependencies === 'function' ? dependencies() : dependencies)\n        .map(dep => defExtractor(dep))\n        .filter(nonNull);\n}\n/**\n * A map that contains the generated component IDs and type.\n */\nconst GENERATED_COMP_IDS = new Map();\n/**\n * A method can returns a component ID from the component definition using a variant of DJB2 hash\n * algorithm.\n */\nfunction getComponentId(componentDef) {\n    let hash = 0;\n    // We cannot rely solely on the component selector as the same selector can be used in different\n    // modules.\n    //\n    // `componentDef.style` is not used, due to it causing inconsistencies. Ex: when server\n    // component styles has no sourcemaps and browsers do.\n    //\n    // Example:\n    // https://github.com/angular/components/blob/d9f82c8f95309e77a6d82fd574c65871e91354c2/src/material/core/option/option.ts#L248\n    // https://github.com/angular/components/blob/285f46dc2b4c5b127d356cb7c4714b221f03ce50/src/material/legacy-core/option/option.ts#L32\n    const hashSelectors = [\n        componentDef.selectors,\n        componentDef.ngContentSelectors,\n        componentDef.hostVars,\n        componentDef.hostAttrs,\n        componentDef.consts,\n        componentDef.vars,\n        componentDef.decls,\n        componentDef.encapsulation,\n        componentDef.standalone,\n        componentDef.signals,\n        componentDef.exportAs,\n        JSON.stringify(componentDef.inputs),\n        JSON.stringify(componentDef.outputs),\n        // We cannot use 'componentDef.type.name' as the name of the symbol will change and will not\n        // match in the server and browser bundles.\n        Object.getOwnPropertyNames(componentDef.type.prototype),\n        !!componentDef.contentQueries,\n        !!componentDef.viewQuery,\n    ].join('|');\n    for (const char of hashSelectors) {\n        hash = Math.imul(31, hash) + char.charCodeAt(0) << 0;\n    }\n    // Force positive number hash.\n    // 2147483647 = equivalent of Integer.MAX_VALUE.\n    hash += 2147483647 + 1;\n    const compId = 'c' + hash;\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        if (GENERATED_COMP_IDS.has(compId)) {\n            const previousCompDefType = GENERATED_COMP_IDS.get(compId);\n            if (previousCompDefType !== componentDef.type) {\n                console.warn(formatRuntimeError(-912 /* RuntimeErrorCode.COMPONENT_ID_COLLISION */, `Component ID generation collision detected. Components '${previousCompDefType.name}' and '${componentDef.type.name}' with selector '${stringifyCSSSelectorList(componentDef\n                    .selectors)}' generated the same component ID. To fix this, you can change the selector of one of those components or add an extra host attribute to force a different ID.`));\n            }\n        }\n        else {\n            GENERATED_COMP_IDS.set(compId, componentDef.type);\n        }\n    }\n    return compId;\n}\n\n// Below are constants for LView indices to help us look up LView members\n// without having to remember the specific indices.\n// Uglify will inline these when minifying so there shouldn't be a cost.\nconst HOST = 0;\nconst TVIEW = 1;\nconst FLAGS = 2;\nconst PARENT = 3;\nconst NEXT = 4;\nconst DESCENDANT_VIEWS_TO_REFRESH = 5;\nconst T_HOST = 6;\nconst CLEANUP = 7;\nconst CONTEXT = 8;\nconst INJECTOR$1 = 9;\nconst ENVIRONMENT = 10;\nconst RENDERER = 11;\nconst CHILD_HEAD = 12;\nconst CHILD_TAIL = 13;\n// FIXME(misko): Investigate if the three declarations aren't all same thing.\nconst DECLARATION_VIEW = 14;\nconst DECLARATION_COMPONENT_VIEW = 15;\nconst DECLARATION_LCONTAINER = 16;\nconst PREORDER_HOOK_FLAGS = 17;\nconst QUERIES = 18;\nconst ID = 19;\nconst EMBEDDED_VIEW_INJECTOR = 20;\nconst ON_DESTROY_HOOKS = 21;\nconst HYDRATION = 22;\nconst REACTIVE_TEMPLATE_CONSUMER = 23;\nconst REACTIVE_HOST_BINDING_CONSUMER = 24;\n/**\n * Size of LView's header. Necessary to adjust for it when setting slots.\n *\n * IMPORTANT: `HEADER_OFFSET` should only be referred to the in the `ɵɵ*` instructions to translate\n * instruction index into `LView` index. All other indexes should be in the `LView` index space and\n * there should be no need to refer to `HEADER_OFFSET` anywhere else.\n */\nconst HEADER_OFFSET = 25;\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd$4 = 1;\n\n/**\n * Special location which allows easy identification of type. If we have an array which was\n * retrieved from the `LView` and that array has `true` at `TYPE` location, we know it is\n * `LContainer`.\n */\nconst TYPE = 1;\n/**\n * Below are constants for LContainer indices to help us look up LContainer members\n * without having to remember the specific indices.\n * Uglify will inline these when minifying so there shouldn't be a cost.\n */\n/**\n * Flag to signify that this `LContainer` may have transplanted views which need to be change\n * detected. (see: `LView[DECLARATION_COMPONENT_VIEW])`.\n *\n * This flag, once set, is never unset for the `LContainer`. This means that when unset we can skip\n * a lot of work in `refreshEmbeddedViews`. But when set we still need to verify\n * that the `MOVED_VIEWS` are transplanted and on-push.\n */\nconst HAS_TRANSPLANTED_VIEWS = 2;\n// PARENT, NEXT, DESCENDANT_VIEWS_TO_REFRESH are indices 3, 4, and 5\n// As we already have these constants in LView, we don't need to re-create them.\n// T_HOST is index 6\n// We already have this constants in LView, we don't need to re-create it.\nconst NATIVE = 7;\nconst VIEW_REFS = 8;\nconst MOVED_VIEWS = 9;\nconst DEHYDRATED_VIEWS = 10;\n/**\n * Size of LContainer's header. Represents the index after which all views in the\n * container will be inserted. We need to keep a record of current views so we know\n * which views are already in the DOM (and don't need to be re-added) and so we can\n * remove views from the DOM when they are no longer required.\n */\nconst CONTAINER_HEADER_OFFSET = 11;\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd$3 = 1;\n\n/**\n * True if `value` is `LView`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nfunction isLView(value) {\n    return Array.isArray(value) && typeof value[TYPE] === 'object';\n}\n/**\n * True if `value` is `LContainer`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nfunction isLContainer(value) {\n    return Array.isArray(value) && value[TYPE] === true;\n}\nfunction isContentQueryHost(tNode) {\n    return (tNode.flags & 4 /* TNodeFlags.hasContentQuery */) !== 0;\n}\nfunction isComponentHost(tNode) {\n    return tNode.componentOffset > -1;\n}\nfunction isDirectiveHost(tNode) {\n    return (tNode.flags & 1 /* TNodeFlags.isDirectiveHost */) === 1 /* TNodeFlags.isDirectiveHost */;\n}\nfunction isComponentDef(def) {\n    return !!def.template;\n}\nfunction isRootView(target) {\n    return (target[FLAGS] & 512 /* LViewFlags.IsRoot */) !== 0;\n}\nfunction isProjectionTNode(tNode) {\n    return (tNode.type & 16 /* TNodeType.Projection */) === 16 /* TNodeType.Projection */;\n}\nfunction hasI18n(lView) {\n    return (lView[FLAGS] & 32 /* LViewFlags.HasI18n */) === 32 /* LViewFlags.HasI18n */;\n}\n\n// [Assert functions do not constraint type when they are guarded by a truthy\n// expression.](https://github.com/microsoft/TypeScript/issues/37295)\nfunction assertTNodeForLView(tNode, lView) {\n    assertTNodeForTView(tNode, lView[TVIEW]);\n}\nfunction assertTNodeForTView(tNode, tView) {\n    assertTNode(tNode);\n    const tData = tView.data;\n    for (let i = HEADER_OFFSET; i < tData.length; i++) {\n        if (tData[i] === tNode) {\n            return;\n        }\n    }\n    throwError('This TNode does not belong to this TView.');\n}\nfunction assertTNode(tNode) {\n    assertDefined(tNode, 'TNode must be defined');\n    if (!(tNode && typeof tNode === 'object' && tNode.hasOwnProperty('directiveStylingLast'))) {\n        throwError('Not of type TNode, got: ' + tNode);\n    }\n}\nfunction assertTIcu(tIcu) {\n    assertDefined(tIcu, 'Expected TIcu to be defined');\n    if (!(typeof tIcu.currentCaseLViewIndex === 'number')) {\n        throwError('Object is not of TIcu type.');\n    }\n}\nfunction assertComponentType(actual, msg = 'Type passed in is not ComponentType, it does not have \\'ɵcmp\\' property.') {\n    if (!getComponentDef$1(actual)) {\n        throwError(msg);\n    }\n}\nfunction assertNgModuleType(actual, msg = 'Type passed in is not NgModuleType, it does not have \\'ɵmod\\' property.') {\n    if (!getNgModuleDef(actual)) {\n        throwError(msg);\n    }\n}\nfunction assertCurrentTNodeIsParent(isParent) {\n    assertEqual(isParent, true, 'currentTNode should be a parent');\n}\nfunction assertHasParent(tNode) {\n    assertDefined(tNode, 'currentTNode should exist!');\n    assertDefined(tNode.parent, 'currentTNode should have a parent');\n}\nfunction assertLContainer(value) {\n    assertDefined(value, 'LContainer must be defined');\n    assertEqual(isLContainer(value), true, 'Expecting LContainer');\n}\nfunction assertLViewOrUndefined(value) {\n    value && assertEqual(isLView(value), true, 'Expecting LView or undefined or null');\n}\nfunction assertLView(value) {\n    assertDefined(value, 'LView must be defined');\n    assertEqual(isLView(value), true, 'Expecting LView');\n}\nfunction assertFirstCreatePass(tView, errMessage) {\n    assertEqual(tView.firstCreatePass, true, errMessage || 'Should only be called in first create pass.');\n}\nfunction assertFirstUpdatePass(tView, errMessage) {\n    assertEqual(tView.firstUpdatePass, true, errMessage || 'Should only be called in first update pass.');\n}\n/**\n * This is a basic sanity check that an object is probably a directive def. DirectiveDef is\n * an interface, so we can't do a direct instanceof check.\n */\nfunction assertDirectiveDef(obj) {\n    if (obj.type === undefined || obj.selectors == undefined || obj.inputs === undefined) {\n        throwError(`Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);\n    }\n}\nfunction assertIndexInDeclRange(lView, index) {\n    const tView = lView[1];\n    assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);\n}\nfunction assertIndexInExpandoRange(lView, index) {\n    const tView = lView[1];\n    assertBetween(tView.expandoStartIndex, lView.length, index);\n}\nfunction assertBetween(lower, upper, index) {\n    if (!(lower <= index && index < upper)) {\n        throwError(`Index out of range (expecting ${lower} <= ${index} < ${upper})`);\n    }\n}\nfunction assertProjectionSlots(lView, errMessage) {\n    assertDefined(lView[DECLARATION_COMPONENT_VIEW], 'Component views should exist.');\n    assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection, errMessage ||\n        'Components with projection nodes (<ng-content>) must have projection slots defined.');\n}\nfunction assertParentView(lView, errMessage) {\n    assertDefined(lView, errMessage || 'Component views should always have a parent view (component\\'s host view)');\n}\n/**\n * This is a basic sanity check that the `injectorIndex` seems to point to what looks like a\n * NodeInjector data structure.\n *\n * @param lView `LView` which should be checked.\n * @param injectorIndex index into the `LView` where the `NodeInjector` is expected.\n */\nfunction assertNodeInjector(lView, injectorIndex) {\n    assertIndexInExpandoRange(lView, injectorIndex);\n    assertIndexInExpandoRange(lView, injectorIndex + 8 /* NodeInjectorOffset.PARENT */);\n    assertNumber(lView[injectorIndex + 0], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 1], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 2], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 3], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 4], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 5], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 6], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 7], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 8 /* NodeInjectorOffset.PARENT */], 'injectorIndex should point to parent injector');\n}\n\nfunction getFactoryDef(type, throwNotFound) {\n    const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);\n    if (!hasFactoryDef && throwNotFound === true && ngDevMode) {\n        throw new Error(`Type ${stringify(type)} does not have 'ɵfac' property.`);\n    }\n    return hasFactoryDef ? type[NG_FACTORY_DEF] : null;\n}\n\n/**\n * Symbol used to tell `Signal`s apart from other functions.\n *\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\n */\nconst SIGNAL = /* @__PURE__ */ Symbol('SIGNAL');\n/**\n * Checks if the given `value` is a reactive `Signal`.\n *\n * @developerPreview\n */\nfunction isSignal(value) {\n    return typeof value === 'function' && value[SIGNAL] !== undefined;\n}\n/**\n * The default equality function used for `signal` and `computed`, which treats objects and arrays\n * as never equal, and all other primitive values using identity semantics.\n *\n * This allows signals to hold non-primitive values (arrays, objects, other collections) and still\n * propagate change notification upon explicit mutation without identity change.\n *\n * @developerPreview\n */\nfunction defaultEquals(a, b) {\n    // `Object.is` compares two values using identity semantics which is desired behavior for\n    // primitive values. If `Object.is` determines two values to be equal we need to make sure that\n    // those don't represent objects (we want to make sure that 2 objects are always considered\n    // \"unequal\"). The null check is needed for the special case of JavaScript reporting null values\n    // as objects (`typeof null === 'object'`).\n    return (a === null || typeof a !== 'object') && Object.is(a, b);\n}\n\n// Required as the signals library is in a separate package, so we need to explicitly ensure the\n/**\n * The currently active consumer `ReactiveNode`, if running code in a reactive context.\n *\n * Change this via `setActiveConsumer`.\n */\nlet activeConsumer = null;\nlet inNotificationPhase = false;\nfunction setActiveConsumer(consumer) {\n    const prev = activeConsumer;\n    activeConsumer = consumer;\n    return prev;\n}\nconst REACTIVE_NODE = {\n    version: 0,\n    dirty: false,\n    producerNode: undefined,\n    producerLastReadVersion: undefined,\n    producerIndexOfThis: undefined,\n    nextProducerIndex: 0,\n    liveConsumerNode: undefined,\n    liveConsumerIndexOfThis: undefined,\n    consumerAllowSignalWrites: false,\n    consumerIsAlwaysLive: false,\n    producerMustRecompute: () => false,\n    producerRecomputeValue: () => { },\n    consumerMarkedDirty: () => { },\n};\n/**\n * Called by implementations when a producer's signal is read.\n */\nfunction producerAccessed(node) {\n    if (inNotificationPhase) {\n        throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ?\n            `Assertion error: signal read during notification phase` :\n            '');\n    }\n    if (activeConsumer === null) {\n        // Accessed outside of a reactive context, so nothing to record.\n        return;\n    }\n    // This producer is the `idx`th dependency of `activeConsumer`.\n    const idx = activeConsumer.nextProducerIndex++;\n    assertConsumerNode(activeConsumer);\n    if (idx < activeConsumer.producerNode.length && activeConsumer.producerNode[idx] !== node) {\n        // There's been a change in producers since the last execution of `activeConsumer`.\n        // `activeConsumer.producerNode[idx]` holds a stale dependency which will be be removed and\n        // replaced with `this`.\n        //\n        // If `activeConsumer` isn't live, then this is a no-op, since we can replace the producer in\n        // `activeConsumer.producerNode` directly. However, if `activeConsumer` is live, then we need\n        // to remove it from the stale producer's `liveConsumer`s.\n        if (consumerIsLive(activeConsumer)) {\n            const staleProducer = activeConsumer.producerNode[idx];\n            producerRemoveLiveConsumerAtIndex(staleProducer, activeConsumer.producerIndexOfThis[idx]);\n            // At this point, the only record of `staleProducer` is the reference at\n            // `activeConsumer.producerNode[idx]` which will be overwritten below.\n        }\n    }\n    if (activeConsumer.producerNode[idx] !== node) {\n        // We're a new dependency of the consumer (at `idx`).\n        activeConsumer.producerNode[idx] = node;\n        // If the active consumer is live, then add it as a live consumer. If not, then use 0 as a\n        // placeholder value.\n        activeConsumer.producerIndexOfThis[idx] =\n            consumerIsLive(activeConsumer) ? producerAddLiveConsumer(node, activeConsumer, idx) : 0;\n    }\n    activeConsumer.producerLastReadVersion[idx] = node.version;\n}\n/**\n * Ensure this producer's `version` is up-to-date.\n */\nfunction producerUpdateValueVersion(node) {\n    if (consumerIsLive(node) && !node.dirty) {\n        // A live consumer will be marked dirty by producers, so a clean state means that its version\n        // is guaranteed to be up-to-date.\n        return;\n    }\n    if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\n        // None of our producers report a change since the last time they were read, so no\n        // recomputation of our value is necessary, and we can consider ourselves clean.\n        node.dirty = false;\n        return;\n    }\n    node.producerRecomputeValue(node);\n    // After recomputing the value, we're no longer dirty.\n    node.dirty = false;\n}\n/**\n * Propagate a dirty notification to live consumers of this producer.\n */\nfunction producerNotifyConsumers(node) {\n    if (node.liveConsumerNode === undefined) {\n        return;\n    }\n    // Prevent signal reads when we're updating the graph\n    const prev = inNotificationPhase;\n    inNotificationPhase = true;\n    try {\n        for (const consumer of node.liveConsumerNode) {\n            if (!consumer.dirty) {\n                consumerMarkDirty(consumer);\n            }\n        }\n    }\n    finally {\n        inNotificationPhase = prev;\n    }\n}\n/**\n * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\n * based on the current consumer context.\n */\nfunction producerUpdatesAllowed() {\n    return activeConsumer?.consumerAllowSignalWrites !== false;\n}\nfunction consumerMarkDirty(node) {\n    node.dirty = true;\n    producerNotifyConsumers(node);\n    node.consumerMarkedDirty?.(node);\n}\n/**\n * Prepare this consumer to run a computation in its reactive context.\n *\n * Must be called by subclasses which represent reactive computations, before those computations\n * begin.\n */\nfunction consumerBeforeComputation(node) {\n    node && (node.nextProducerIndex = 0);\n    return setActiveConsumer(node);\n}\n/**\n * Finalize this consumer's state after a reactive computation has run.\n *\n * Must be called by subclasses which represent reactive computations, after those computations\n * have finished.\n */\nfunction consumerAfterComputation(node, prevConsumer) {\n    setActiveConsumer(prevConsumer);\n    if (!node || node.producerNode === undefined || node.producerIndexOfThis === undefined ||\n        node.producerLastReadVersion === undefined) {\n        return;\n    }\n    if (consumerIsLive(node)) {\n        // For live consumers, we need to remove the producer -> consumer edge for any stale producers\n        // which weren't dependencies after the recomputation.\n        for (let i = node.nextProducerIndex; i < node.producerNode.length; i++) {\n            producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n        }\n    }\n    // Truncate the producer tracking arrays.\n    // Perf note: this is essentially truncating the length to `node.nextProducerIndex`, but\n    // benchmarking has shown that individual pop operations are faster.\n    while (node.producerNode.length > node.nextProducerIndex) {\n        node.producerNode.pop();\n        node.producerLastReadVersion.pop();\n        node.producerIndexOfThis.pop();\n    }\n}\n/**\n * Determine whether this consumer has any dependencies which have changed since the last time\n * they were read.\n */\nfunction consumerPollProducersForChange(node) {\n    assertConsumerNode(node);\n    // Poll producers for change.\n    for (let i = 0; i < node.producerNode.length; i++) {\n        const producer = node.producerNode[i];\n        const seenVersion = node.producerLastReadVersion[i];\n        // First check the versions. A mismatch means that the producer's value is known to have\n        // changed since the last time we read it.\n        if (seenVersion !== producer.version) {\n            return true;\n        }\n        // The producer's version is the same as the last time we read it, but it might itself be\n        // stale. Force the producer to recompute its version (calculating a new value if necessary).\n        producerUpdateValueVersion(producer);\n        // Now when we do this check, `producer.version` is guaranteed to be up to date, so if the\n        // versions still match then it has not changed since the last time we read it.\n        if (seenVersion !== producer.version) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Disconnect this consumer from the graph.\n */\nfunction consumerDestroy(node) {\n    assertConsumerNode(node);\n    if (consumerIsLive(node)) {\n        // Drop all connections from the graph to this node.\n        for (let i = 0; i < node.producerNode.length; i++) {\n            producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n        }\n    }\n    // Truncate all the arrays to drop all connection from this node to the graph.\n    node.producerNode.length = node.producerLastReadVersion.length = node.producerIndexOfThis.length =\n        0;\n    if (node.liveConsumerNode) {\n        node.liveConsumerNode.length = node.liveConsumerIndexOfThis.length = 0;\n    }\n}\n/**\n * Add `consumer` as a live consumer of this node.\n *\n * Note that this operation is potentially transitive. If this node becomes live, then it becomes\n * a live consumer of all of its current producers.\n */\nfunction producerAddLiveConsumer(node, consumer, indexOfThis) {\n    assertProducerNode(node);\n    assertConsumerNode(node);\n    if (node.liveConsumerNode.length === 0) {\n        // When going from 0 to 1 live consumers, we become a live consumer to our producers.\n        for (let i = 0; i < node.producerNode.length; i++) {\n            node.producerIndexOfThis[i] = producerAddLiveConsumer(node.producerNode[i], node, i);\n        }\n    }\n    node.liveConsumerIndexOfThis.push(indexOfThis);\n    return node.liveConsumerNode.push(consumer) - 1;\n}\n/**\n * Remove the live consumer at `idx`.\n */\nfunction producerRemoveLiveConsumerAtIndex(node, idx) {\n    assertProducerNode(node);\n    assertConsumerNode(node);\n    if (typeof ngDevMode !== 'undefined' && ngDevMode && idx >= node.liveConsumerNode.length) {\n        throw new Error(`Assertion error: active consumer index ${idx} is out of bounds of ${node.liveConsumerNode.length} consumers)`);\n    }\n    if (node.liveConsumerNode.length === 1) {\n        // When removing the last live consumer, we will no longer be live. We need to remove\n        // ourselves from our producers' tracking (which may cause consumer-producers to lose\n        // liveness as well).\n        for (let i = 0; i < node.producerNode.length; i++) {\n            producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n        }\n    }\n    // Move the last value of `liveConsumers` into `idx`. Note that if there's only a single\n    // live consumer, this is a no-op.\n    const lastIdx = node.liveConsumerNode.length - 1;\n    node.liveConsumerNode[idx] = node.liveConsumerNode[lastIdx];\n    node.liveConsumerIndexOfThis[idx] = node.liveConsumerIndexOfThis[lastIdx];\n    // Truncate the array.\n    node.liveConsumerNode.length--;\n    node.liveConsumerIndexOfThis.length--;\n    // If the index is still valid, then we need to fix the index pointer from the producer to this\n    // consumer, and update it from `lastIdx` to `idx` (accounting for the move above).\n    if (idx < node.liveConsumerNode.length) {\n        const idxProducer = node.liveConsumerIndexOfThis[idx];\n        const consumer = node.liveConsumerNode[idx];\n        assertConsumerNode(consumer);\n        consumer.producerIndexOfThis[idxProducer] = idx;\n    }\n}\nfunction consumerIsLive(node) {\n    return node.consumerIsAlwaysLive || (node?.liveConsumerNode?.length ?? 0) > 0;\n}\nfunction assertConsumerNode(node) {\n    node.producerNode ??= [];\n    node.producerIndexOfThis ??= [];\n    node.producerLastReadVersion ??= [];\n}\nfunction assertProducerNode(node) {\n    node.liveConsumerNode ??= [];\n    node.liveConsumerIndexOfThis ??= [];\n}\n\n/**\n * Create a computed `Signal` which derives a reactive value from an expression.\n *\n * @developerPreview\n */\nfunction computed(computation, options) {\n    const node = Object.create(COMPUTED_NODE);\n    node.computation = computation;\n    options?.equal && (node.equal = options.equal);\n    const computed = () => {\n        // Check if the value needs updating before returning it.\n        producerUpdateValueVersion(node);\n        // Record that someone looked at this signal.\n        producerAccessed(node);\n        if (node.value === ERRORED) {\n            throw node.error;\n        }\n        return node.value;\n    };\n    computed[SIGNAL] = node;\n    return computed;\n}\n/**\n * A dedicated symbol used before a computed value has been calculated for the first time.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst UNSET = /* @__PURE__ */ Symbol('UNSET');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * is in progress. Used to detect cycles in computation chains.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst COMPUTING = /* @__PURE__ */ Symbol('COMPUTING');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * failed. The thrown error is cached until the computation gets dirty again.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst ERRORED = /* @__PURE__ */ Symbol('ERRORED');\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst COMPUTED_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        value: UNSET,\n        dirty: true,\n        error: null,\n        equal: defaultEquals,\n        producerMustRecompute(node) {\n            // Force a recomputation if there's no current value, or if the current value is in the\n            // process of being calculated (which should throw an error).\n            return node.value === UNSET || node.value === COMPUTING;\n        },\n        producerRecomputeValue(node) {\n            if (node.value === COMPUTING) {\n                // Our computation somehow led to a cyclic read of itself.\n                throw new Error('Detected cycle in computations.');\n            }\n            const oldValue = node.value;\n            node.value = COMPUTING;\n            const prevConsumer = consumerBeforeComputation(node);\n            let newValue;\n            try {\n                newValue = node.computation();\n            }\n            catch (err) {\n                newValue = ERRORED;\n                node.error = err;\n            }\n            finally {\n                consumerAfterComputation(node, prevConsumer);\n            }\n            if (oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED &&\n                node.equal(oldValue, newValue)) {\n                // No change to `valueVersion` - old and new values are\n                // semantically equivalent.\n                node.value = oldValue;\n                return;\n            }\n            node.value = newValue;\n            node.version++;\n        },\n    };\n})();\n\nfunction defaultThrowError() {\n    throw new Error();\n}\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\nfunction throwInvalidWriteToSignalError() {\n    throwInvalidWriteToSignalErrorFn();\n}\nfunction setThrowInvalidWriteToSignalError(fn) {\n    throwInvalidWriteToSignalErrorFn = fn;\n}\n\n/**\n * If set, called after `WritableSignal`s are updated.\n *\n * This hook can be used to achieve various effects, such as running effects synchronously as part\n * of setting a signal.\n */\nlet postSignalSetFn = null;\n/**\n * Create a `Signal` that can be set or updated directly.\n *\n * @developerPreview\n */\nfunction signal(initialValue, options) {\n    const node = Object.create(SIGNAL_NODE);\n    node.value = initialValue;\n    options?.equal && (node.equal = options.equal);\n    function signalFn() {\n        producerAccessed(node);\n        return node.value;\n    }\n    signalFn.set = signalSetFn;\n    signalFn.update = signalUpdateFn;\n    signalFn.mutate = signalMutateFn;\n    signalFn.asReadonly = signalAsReadonlyFn;\n    signalFn[SIGNAL] = node;\n    return signalFn;\n}\nfunction setPostSignalSetFn(fn) {\n    const prev = postSignalSetFn;\n    postSignalSetFn = fn;\n    return prev;\n}\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst SIGNAL_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        equal: defaultEquals,\n        readonlyFn: undefined,\n    };\n})();\nfunction signalValueChanged(node) {\n    node.version++;\n    producerNotifyConsumers(node);\n    postSignalSetFn?.();\n}\nfunction signalSetFn(newValue) {\n    const node = this[SIGNAL];\n    if (!producerUpdatesAllowed()) {\n        throwInvalidWriteToSignalError();\n    }\n    if (!node.equal(node.value, newValue)) {\n        node.value = newValue;\n        signalValueChanged(node);\n    }\n}\nfunction signalUpdateFn(updater) {\n    if (!producerUpdatesAllowed()) {\n        throwInvalidWriteToSignalError();\n    }\n    signalSetFn.call(this, updater(this[SIGNAL].value));\n}\nfunction signalMutateFn(mutator) {\n    const node = this[SIGNAL];\n    if (!producerUpdatesAllowed()) {\n        throwInvalidWriteToSignalError();\n    }\n    // Mutate bypasses equality checks as it's by definition changing the value.\n    mutator(node.value);\n    signalValueChanged(node);\n}\nfunction signalAsReadonlyFn() {\n    const node = this[SIGNAL];\n    if (node.readonlyFn === undefined) {\n        const readonlyFn = () => this();\n        readonlyFn[SIGNAL] = node;\n        node.readonlyFn = readonlyFn;\n    }\n    return node.readonlyFn;\n}\n\n/**\n * Execute an arbitrary function in a non-reactive (non-tracking) context. The executed function\n * can, optionally, return a value.\n *\n * @developerPreview\n */\nfunction untracked(nonReactiveReadsFn) {\n    const prevConsumer = setActiveConsumer(null);\n    // We are not trying to catch any particular errors here, just making sure that the consumers\n    // stack is restored in case of errors.\n    try {\n        return nonReactiveReadsFn();\n    }\n    finally {\n        setActiveConsumer(prevConsumer);\n    }\n}\n\nfunction watch(fn, schedule, allowSignalWrites) {\n    const node = Object.create(WATCH_NODE);\n    if (allowSignalWrites) {\n        node.consumerAllowSignalWrites = true;\n    }\n    node.fn = fn;\n    node.schedule = schedule;\n    const registerOnCleanup = (cleanupFn) => {\n        node.cleanupFn = cleanupFn;\n    };\n    const run = () => {\n        node.dirty = false;\n        if (node.hasRun && !consumerPollProducersForChange(node)) {\n            return;\n        }\n        node.hasRun = true;\n        const prevConsumer = consumerBeforeComputation(node);\n        try {\n            node.cleanupFn();\n            node.cleanupFn = NOOP_CLEANUP_FN;\n            node.fn(registerOnCleanup);\n        }\n        finally {\n            consumerAfterComputation(node, prevConsumer);\n        }\n    };\n    node.ref = {\n        notify: () => consumerMarkDirty(node),\n        run,\n        cleanup: () => node.cleanupFn(),\n    };\n    return node.ref;\n}\nconst NOOP_CLEANUP_FN = () => { };\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst WATCH_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        consumerIsAlwaysLive: true,\n        consumerAllowSignalWrites: false,\n        consumerMarkedDirty: (node) => {\n            node.schedule(node.ref);\n        },\n        hasRun: false,\n        cleanupFn: NOOP_CLEANUP_FN,\n    };\n})();\n\nfunction setAlternateWeakRefImpl(impl) {\n    // TODO: remove this function\n}\n\n/**\n * Represents a basic change from a previous to a new value for a single\n * property on a directive instance. Passed as a value in a\n * {@link SimpleChanges} object to the `ngOnChanges` hook.\n *\n * @see {@link OnChanges}\n *\n * @publicApi\n */\nclass SimpleChange {\n    constructor(previousValue, currentValue, firstChange) {\n        this.previousValue = previousValue;\n        this.currentValue = currentValue;\n        this.firstChange = firstChange;\n    }\n    /**\n     * Check whether the new value is the first value assigned.\n     */\n    isFirstChange() {\n        return this.firstChange;\n    }\n}\n\n/**\n * The NgOnChangesFeature decorates a component with support for the ngOnChanges\n * lifecycle hook, so it should be included in any component that implements\n * that hook.\n *\n * If the component or directive uses inheritance, the NgOnChangesFeature MUST\n * be included as a feature AFTER {@link InheritDefinitionFeature}, otherwise\n * inherited properties will not be propagated to the ngOnChanges lifecycle\n * hook.\n *\n * Example usage:\n *\n * ```\n * static ɵcmp = defineComponent({\n *   ...\n *   inputs: {name: 'publicName'},\n *   features: [NgOnChangesFeature]\n * });\n * ```\n *\n * @codeGenApi\n */\nfunction ɵɵNgOnChangesFeature() {\n    return NgOnChangesFeatureImpl;\n}\nfunction NgOnChangesFeatureImpl(definition) {\n    if (definition.type.prototype.ngOnChanges) {\n        definition.setInput = ngOnChangesSetInput;\n    }\n    return rememberChangeHistoryAndInvokeOnChangesHook;\n}\n// This option ensures that the ngOnChanges lifecycle hook will be inherited\n// from superclasses (in InheritDefinitionFeature).\n/** @nocollapse */\n// tslint:disable-next-line:no-toplevel-property-access\nɵɵNgOnChangesFeature.ngInherit = true;\n/**\n * This is a synthetic lifecycle hook which gets inserted into `TView.preOrderHooks` to simulate\n * `ngOnChanges`.\n *\n * The hook reads the `NgSimpleChangesStore` data from the component instance and if changes are\n * found it invokes `ngOnChanges` on the component instance.\n *\n * @param this Component instance. Because this function gets inserted into `TView.preOrderHooks`,\n *     it is guaranteed to be called with component instance.\n */\nfunction rememberChangeHistoryAndInvokeOnChangesHook() {\n    const simpleChangesStore = getSimpleChangesStore(this);\n    const current = simpleChangesStore?.current;\n    if (current) {\n        const previous = simpleChangesStore.previous;\n        if (previous === EMPTY_OBJ) {\n            simpleChangesStore.previous = current;\n        }\n        else {\n            // New changes are copied to the previous store, so that we don't lose history for inputs\n            // which were not changed this time\n            for (let key in current) {\n                previous[key] = current[key];\n            }\n        }\n        simpleChangesStore.current = null;\n        this.ngOnChanges(current);\n    }\n}\nfunction ngOnChangesSetInput(instance, value, publicName, privateName) {\n    const declaredName = this.declaredInputs[publicName];\n    ngDevMode && assertString(declaredName, 'Name of input in ngOnChanges has to be a string');\n    const simpleChangesStore = getSimpleChangesStore(instance) ||\n        setSimpleChangesStore(instance, { previous: EMPTY_OBJ, current: null });\n    const current = simpleChangesStore.current || (simpleChangesStore.current = {});\n    const previous = simpleChangesStore.previous;\n    const previousChange = previous[declaredName];\n    current[declaredName] = new SimpleChange(previousChange && previousChange.currentValue, value, previous === EMPTY_OBJ);\n    instance[privateName] = value;\n}\nconst SIMPLE_CHANGES_STORE = '__ngSimpleChanges__';\nfunction getSimpleChangesStore(instance) {\n    return instance[SIMPLE_CHANGES_STORE] || null;\n}\nfunction setSimpleChangesStore(instance, store) {\n    return instance[SIMPLE_CHANGES_STORE] = store;\n}\n\nlet profilerCallback = null;\n/**\n * Sets the callback function which will be invoked before and after performing certain actions at\n * runtime (for example, before and after running change detection).\n *\n * Warning: this function is *INTERNAL* and should not be relied upon in application's code.\n * The contract of the function might be changed in any release and/or the function can be removed\n * completely.\n *\n * @param profiler function provided by the caller or null value to disable profiling.\n */\nconst setProfiler = (profiler) => {\n    profilerCallback = profiler;\n};\n/**\n * Profiler function which wraps user code executed by the runtime.\n *\n * @param event ProfilerEvent corresponding to the execution context\n * @param instance component instance\n * @param hookOrListener lifecycle hook function or output listener. The value depends on the\n *  execution context\n * @returns\n */\nconst profiler = function (event, instance, hookOrListener) {\n    if (profilerCallback != null /* both `null` and `undefined` */) {\n        profilerCallback(event, instance, hookOrListener);\n    }\n};\n\nconst SVG_NAMESPACE = 'svg';\nconst MATH_ML_NAMESPACE = 'math';\n\n/**\n * For efficiency reasons we often put several different data types (`RNode`, `LView`, `LContainer`)\n * in same location in `LView`. This is because we don't want to pre-allocate space for it\n * because the storage is sparse. This file contains utilities for dealing with such data types.\n *\n * How do we know what is stored at a given location in `LView`.\n * - `Array.isArray(value) === false` => `RNode` (The normal storage value)\n * - `Array.isArray(value) === true` => then the `value[0]` represents the wrapped value.\n *   - `typeof value[TYPE] === 'object'` => `LView`\n *      - This happens when we have a component at a given location\n *   - `typeof value[TYPE] === true` => `LContainer`\n *      - This happens when we have `LContainer` binding at a given location.\n *\n *\n * NOTE: it is assumed that `Array.isArray` and `typeof` operations are very efficient.\n */\n/**\n * Returns `RNode`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nfunction unwrapRNode(value) {\n    while (Array.isArray(value)) {\n        value = value[HOST];\n    }\n    return value;\n}\n/**\n * Returns `LView` or `null` if not found.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nfunction unwrapLView(value) {\n    while (Array.isArray(value)) {\n        // This check is same as `isLView()` but we don't call at as we don't want to call\n        // `Array.isArray()` twice and give JITer more work for inlining.\n        if (typeof value[TYPE] === 'object')\n            return value;\n        value = value[HOST];\n    }\n    return null;\n}\n/**\n * Retrieves an element value from the provided `viewData`, by unwrapping\n * from any containers, component views, or style contexts.\n */\nfunction getNativeByIndex(index, lView) {\n    ngDevMode && assertIndexInRange(lView, index);\n    ngDevMode && assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Expected to be past HEADER_OFFSET');\n    return unwrapRNode(lView[index]);\n}\n/**\n * Retrieve an `RNode` for a given `TNode` and `LView`.\n *\n * This function guarantees in dev mode to retrieve a non-null `RNode`.\n *\n * @param tNode\n * @param lView\n */\nfunction getNativeByTNode(tNode, lView) {\n    ngDevMode && assertTNodeForLView(tNode, lView);\n    ngDevMode && assertIndexInRange(lView, tNode.index);\n    const node = unwrapRNode(lView[tNode.index]);\n    return node;\n}\n/**\n * Retrieve an `RNode` or `null` for a given `TNode` and `LView`.\n *\n * Some `TNode`s don't have associated `RNode`s. For example `Projection`\n *\n * @param tNode\n * @param lView\n */\nfunction getNativeByTNodeOrNull(tNode, lView) {\n    const index = tNode === null ? -1 : tNode.index;\n    if (index !== -1) {\n        ngDevMode && assertTNodeForLView(tNode, lView);\n        const node = unwrapRNode(lView[index]);\n        return node;\n    }\n    return null;\n}\n// fixme(misko): The return Type should be `TNode|null`\nfunction getTNode(tView, index) {\n    ngDevMode && assertGreaterThan(index, -1, 'wrong index for TNode');\n    ngDevMode && assertLessThan(index, tView.data.length, 'wrong index for TNode');\n    const tNode = tView.data[index];\n    ngDevMode && tNode !== null && assertTNode(tNode);\n    return tNode;\n}\n/** Retrieves a value from any `LView` or `TData`. */\nfunction load(view, index) {\n    ngDevMode && assertIndexInRange(view, index);\n    return view[index];\n}\nfunction getComponentLViewByIndex(nodeIndex, hostView) {\n    // Could be an LView or an LContainer. If LContainer, unwrap to find LView.\n    ngDevMode && assertIndexInRange(hostView, nodeIndex);\n    const slotValue = hostView[nodeIndex];\n    const lView = isLView(slotValue) ? slotValue : slotValue[HOST];\n    return lView;\n}\n/** Checks whether a given view is in creation mode */\nfunction isCreationMode(view) {\n    return (view[FLAGS] & 4 /* LViewFlags.CreationMode */) === 4 /* LViewFlags.CreationMode */;\n}\n/**\n * Returns a boolean for whether the view is attached to the change detection tree.\n *\n * Note: This determines whether a view should be checked, not whether it's inserted\n * into a container. For that, you'll want `viewAttachedToContainer` below.\n */\nfunction viewAttachedToChangeDetector(view) {\n    return (view[FLAGS] & 128 /* LViewFlags.Attached */) === 128 /* LViewFlags.Attached */;\n}\n/** Returns a boolean for whether the view is attached to a container. */\nfunction viewAttachedToContainer(view) {\n    return isLContainer(view[PARENT]);\n}\nfunction getConstant(consts, index) {\n    if (index === null || index === undefined)\n        return null;\n    ngDevMode && assertIndexInRange(consts, index);\n    return consts[index];\n}\n/**\n * Resets the pre-order hook flags of the view.\n * @param lView the LView on which the flags are reset\n */\nfunction resetPreOrderHookFlags(lView) {\n    lView[PREORDER_HOOK_FLAGS] = 0;\n}\n/**\n * Adds the `RefreshView` flag from the lView and updates DESCENDANT_VIEWS_TO_REFRESH counters of\n * parents.\n */\nfunction markViewForRefresh(lView) {\n    if ((lView[FLAGS] & 1024 /* LViewFlags.RefreshView */) === 0) {\n        lView[FLAGS] |= 1024 /* LViewFlags.RefreshView */;\n        updateViewsToRefresh(lView, 1);\n    }\n}\n/**\n * Removes the `RefreshView` flag from the lView and updates DESCENDANT_VIEWS_TO_REFRESH counters of\n * parents.\n */\nfunction clearViewRefreshFlag(lView) {\n    if (lView[FLAGS] & 1024 /* LViewFlags.RefreshView */) {\n        lView[FLAGS] &= ~1024 /* LViewFlags.RefreshView */;\n        updateViewsToRefresh(lView, -1);\n    }\n}\n/**\n * Updates the `DESCENDANT_VIEWS_TO_REFRESH` counter on the parents of the `LView` as well as the\n * parents above that whose\n *  1. counter goes from 0 to 1, indicating that there is a new child that has a view to refresh\n *  or\n *  2. counter goes from 1 to 0, indicating there are no more descendant views to refresh\n */\nfunction updateViewsToRefresh(lView, amount) {\n    let parent = lView[PARENT];\n    if (parent === null) {\n        return;\n    }\n    parent[DESCENDANT_VIEWS_TO_REFRESH] += amount;\n    let viewOrContainer = parent;\n    parent = parent[PARENT];\n    while (parent !== null &&\n        ((amount === 1 && viewOrContainer[DESCENDANT_VIEWS_TO_REFRESH] === 1) ||\n            (amount === -1 && viewOrContainer[DESCENDANT_VIEWS_TO_REFRESH] === 0))) {\n        parent[DESCENDANT_VIEWS_TO_REFRESH] += amount;\n        viewOrContainer = parent;\n        parent = parent[PARENT];\n    }\n}\n/**\n * Stores a LView-specific destroy callback.\n */\nfunction storeLViewOnDestroy(lView, onDestroyCallback) {\n    if ((lView[FLAGS] & 256 /* LViewFlags.Destroyed */) === 256 /* LViewFlags.Destroyed */) {\n        throw new RuntimeError(911 /* RuntimeErrorCode.VIEW_ALREADY_DESTROYED */, ngDevMode && 'View has already been destroyed.');\n    }\n    if (lView[ON_DESTROY_HOOKS] === null) {\n        lView[ON_DESTROY_HOOKS] = [];\n    }\n    lView[ON_DESTROY_HOOKS].push(onDestroyCallback);\n}\n/**\n * Removes previously registered LView-specific destroy callback.\n */\nfunction removeLViewOnDestroy(lView, onDestroyCallback) {\n    if (lView[ON_DESTROY_HOOKS] === null)\n        return;\n    const destroyCBIdx = lView[ON_DESTROY_HOOKS].indexOf(onDestroyCallback);\n    if (destroyCBIdx !== -1) {\n        lView[ON_DESTROY_HOOKS].splice(destroyCBIdx, 1);\n    }\n}\n\nconst instructionState = {\n    lFrame: createLFrame(null),\n    bindingsEnabled: true,\n    skipHydrationRootTNode: null,\n};\n/**\n * In this mode, any changes in bindings will throw an ExpressionChangedAfterChecked error.\n *\n * Necessary to support ChangeDetectorRef.checkNoChanges().\n *\n * The `checkNoChanges` function is invoked only in ngDevMode=true and verifies that no unintended\n * changes exist in the change detector or its children.\n */\nlet _isInCheckNoChangesMode = false;\n/**\n * Returns true if the instruction state stack is empty.\n *\n * Intended to be called from tests only (tree shaken otherwise).\n */\nfunction specOnlyIsInstructionStateEmpty() {\n    return instructionState.lFrame.parent === null;\n}\nfunction getElementDepthCount() {\n    return instructionState.lFrame.elementDepthCount;\n}\nfunction increaseElementDepthCount() {\n    instructionState.lFrame.elementDepthCount++;\n}\nfunction decreaseElementDepthCount() {\n    instructionState.lFrame.elementDepthCount--;\n}\nfunction getBindingsEnabled() {\n    return instructionState.bindingsEnabled;\n}\n/**\n * Returns true if currently inside a skip hydration block.\n * @returns boolean\n */\nfunction isInSkipHydrationBlock$1() {\n    return instructionState.skipHydrationRootTNode !== null;\n}\n/**\n * Returns true if this is the root TNode of the skip hydration block.\n * @param tNode the current TNode\n * @returns boolean\n */\nfunction isSkipHydrationRootTNode(tNode) {\n    return instructionState.skipHydrationRootTNode === tNode;\n}\n/**\n * Enables directive matching on elements.\n *\n *  * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- ɵɵdisableBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- ɵɵenableBindings() -->\n * </div>\n * ```\n *\n * @codeGenApi\n */\nfunction ɵɵenableBindings() {\n    instructionState.bindingsEnabled = true;\n}\n/**\n * Sets a flag to specify that the TNode is in a skip hydration block.\n * @param tNode the current TNode\n */\nfunction enterSkipHydrationBlock(tNode) {\n    instructionState.skipHydrationRootTNode = tNode;\n}\n/**\n * Disables directive matching on element.\n *\n *  * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- ɵɵdisableBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- ɵɵenableBindings() -->\n * </div>\n * ```\n *\n * @codeGenApi\n */\nfunction ɵɵdisableBindings() {\n    instructionState.bindingsEnabled = false;\n}\n/**\n * Clears the root skip hydration node when leaving a skip hydration block.\n */\nfunction leaveSkipHydrationBlock() {\n    instructionState.skipHydrationRootTNode = null;\n}\n/**\n * Return the current `LView`.\n */\nfunction getLView() {\n    return instructionState.lFrame.lView;\n}\n/**\n * Return the current `TView`.\n */\nfunction getTView() {\n    return instructionState.lFrame.tView;\n}\n/**\n * Restores `contextViewData` to the given OpaqueViewState instance.\n *\n * Used in conjunction with the getCurrentView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n *\n * @param viewToRestore The OpaqueViewState instance to restore.\n * @returns Context of the restored OpaqueViewState instance.\n *\n * @codeGenApi\n */\nfunction ɵɵrestoreView(viewToRestore) {\n    instructionState.lFrame.contextLView = viewToRestore;\n    return viewToRestore[CONTEXT];\n}\n/**\n * Clears the view set in `ɵɵrestoreView` from memory. Returns the passed in\n * value so that it can be used as a return value of an instruction.\n *\n * @codeGenApi\n */\nfunction ɵɵresetView(value) {\n    instructionState.lFrame.contextLView = null;\n    return value;\n}\nfunction getCurrentTNode() {\n    let currentTNode = getCurrentTNodePlaceholderOk();\n    while (currentTNode !== null && currentTNode.type === 64 /* TNodeType.Placeholder */) {\n        currentTNode = currentTNode.parent;\n    }\n    return currentTNode;\n}\nfunction getCurrentTNodePlaceholderOk() {\n    return instructionState.lFrame.currentTNode;\n}\nfunction getCurrentParentTNode() {\n    const lFrame = instructionState.lFrame;\n    const currentTNode = lFrame.currentTNode;\n    return lFrame.isParent ? currentTNode : currentTNode.parent;\n}\nfunction setCurrentTNode(tNode, isParent) {\n    ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);\n    const lFrame = instructionState.lFrame;\n    lFrame.currentTNode = tNode;\n    lFrame.isParent = isParent;\n}\nfunction isCurrentTNodeParent() {\n    return instructionState.lFrame.isParent;\n}\nfunction setCurrentTNodeAsNotParent() {\n    instructionState.lFrame.isParent = false;\n}\nfunction getContextLView() {\n    const contextLView = instructionState.lFrame.contextLView;\n    ngDevMode && assertDefined(contextLView, 'contextLView must be defined.');\n    return contextLView;\n}\nfunction isInCheckNoChangesMode() {\n    !ngDevMode && throwError('Must never be called in production mode');\n    return _isInCheckNoChangesMode;\n}\nfunction setIsInCheckNoChangesMode(mode) {\n    !ngDevMode && throwError('Must never be called in production mode');\n    _isInCheckNoChangesMode = mode;\n}\n// top level variables should not be exported for performance reasons (PERF_NOTES.md)\nfunction getBindingRoot() {\n    const lFrame = instructionState.lFrame;\n    let index = lFrame.bindingRootIndex;\n    if (index === -1) {\n        index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;\n    }\n    return index;\n}\nfunction getBindingIndex() {\n    return instructionState.lFrame.bindingIndex;\n}\nfunction setBindingIndex(value) {\n    return instructionState.lFrame.bindingIndex = value;\n}\nfunction nextBindingIndex() {\n    return instructionState.lFrame.bindingIndex++;\n}\nfunction incrementBindingIndex(count) {\n    const lFrame = instructionState.lFrame;\n    const index = lFrame.bindingIndex;\n    lFrame.bindingIndex = lFrame.bindingIndex + count;\n    return index;\n}\nfunction isInI18nBlock() {\n    return instructionState.lFrame.inI18n;\n}\nfunction setInI18nBlock(isInI18nBlock) {\n    instructionState.lFrame.inI18n = isInI18nBlock;\n}\n/**\n * Set a new binding root index so that host template functions can execute.\n *\n * Bindings inside the host template are 0 index. But because we don't know ahead of time\n * how many host bindings we have we can't pre-compute them. For this reason they are all\n * 0 index and we just shift the root so that they match next available location in the LView.\n *\n * @param bindingRootIndex Root index for `hostBindings`\n * @param currentDirectiveIndex `TData[currentDirectiveIndex]` will point to the current directive\n *        whose `hostBindings` are being processed.\n */\nfunction setBindingRootForHostBindings(bindingRootIndex, currentDirectiveIndex) {\n    const lFrame = instructionState.lFrame;\n    lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;\n    setCurrentDirectiveIndex(currentDirectiveIndex);\n}\n/**\n * When host binding is executing this points to the directive index.\n * `TView.data[getCurrentDirectiveIndex()]` is `DirectiveDef`\n * `LView[getCurrentDirectiveIndex()]` is directive instance.\n */\nfunction getCurrentDirectiveIndex() {\n    return instructionState.lFrame.currentDirectiveIndex;\n}\n/**\n * Sets an index of a directive whose `hostBindings` are being processed.\n *\n * @param currentDirectiveIndex `TData` index where current directive instance can be found.\n */\nfunction setCurrentDirectiveIndex(currentDirectiveIndex) {\n    instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;\n}\n/**\n * Retrieve the current `DirectiveDef` which is active when `hostBindings` instruction is being\n * executed.\n *\n * @param tData Current `TData` where the `DirectiveDef` will be looked up at.\n */\nfunction getCurrentDirectiveDef(tData) {\n    const currentDirectiveIndex = instructionState.lFrame.currentDirectiveIndex;\n    return currentDirectiveIndex === -1 ? null : tData[currentDirectiveIndex];\n}\nfunction getCurrentQueryIndex() {\n    return instructionState.lFrame.currentQueryIndex;\n}\nfunction setCurrentQueryIndex(value) {\n    instructionState.lFrame.currentQueryIndex = value;\n}\n/**\n * Returns a `TNode` of the location where the current `LView` is declared at.\n *\n * @param lView an `LView` that we want to find parent `TNode` for.\n */\nfunction getDeclarationTNode(lView) {\n    const tView = lView[TVIEW];\n    // Return the declaration parent for embedded views\n    if (tView.type === 2 /* TViewType.Embedded */) {\n        ngDevMode && assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');\n        return tView.declTNode;\n    }\n    // Components don't have `TView.declTNode` because each instance of component could be\n    // inserted in different location, hence `TView.declTNode` is meaningless.\n    // Falling back to `T_HOST` in case we cross component boundary.\n    if (tView.type === 1 /* TViewType.Component */) {\n        return lView[T_HOST];\n    }\n    // Remaining TNode type is `TViewType.Root` which doesn't have a parent TNode.\n    return null;\n}\n/**\n * This is a light weight version of the `enterView` which is needed by the DI system.\n *\n * @param lView `LView` location of the DI context.\n * @param tNode `TNode` for DI context\n * @param flags DI context flags. if `SkipSelf` flag is set than we walk up the declaration\n *     tree from `tNode`  until we find parent declared `TElementNode`.\n * @returns `true` if we have successfully entered DI associated with `tNode` (or with declared\n *     `TNode` if `flags` has  `SkipSelf`). Failing to enter DI implies that no associated\n *     `NodeInjector` can be found and we should instead use `ModuleInjector`.\n *     - If `true` than this call must be fallowed by `leaveDI`\n *     - If `false` than this call failed and we should NOT call `leaveDI`\n */\nfunction enterDI(lView, tNode, flags) {\n    ngDevMode && assertLViewOrUndefined(lView);\n    if (flags & InjectFlags.SkipSelf) {\n        ngDevMode && assertTNodeForTView(tNode, lView[TVIEW]);\n        let parentTNode = tNode;\n        let parentLView = lView;\n        while (true) {\n            ngDevMode && assertDefined(parentTNode, 'Parent TNode should be defined');\n            parentTNode = parentTNode.parent;\n            if (parentTNode === null && !(flags & InjectFlags.Host)) {\n                parentTNode = getDeclarationTNode(parentLView);\n                if (parentTNode === null)\n                    break;\n                // In this case, a parent exists and is definitely an element. So it will definitely\n                // have an existing lView as the declaration view, which is why we can assume it's defined.\n                ngDevMode && assertDefined(parentLView, 'Parent LView should be defined');\n                parentLView = parentLView[DECLARATION_VIEW];\n                // In Ivy there are Comment nodes that correspond to ngIf and NgFor embedded directives\n                // We want to skip those and look only at Elements and ElementContainers to ensure\n                // we're looking at true parent nodes, and not content or other types.\n                if (parentTNode.type & (2 /* TNodeType.Element */ | 8 /* TNodeType.ElementContainer */)) {\n                    break;\n                }\n            }\n            else {\n                break;\n            }\n        }\n        if (parentTNode === null) {\n            // If we failed to find a parent TNode this means that we should use module injector.\n            return false;\n        }\n        else {\n            tNode = parentTNode;\n            lView = parentLView;\n        }\n    }\n    ngDevMode && assertTNodeForLView(tNode, lView);\n    const lFrame = instructionState.lFrame = allocLFrame();\n    lFrame.currentTNode = tNode;\n    lFrame.lView = lView;\n    return true;\n}\n/**\n * Swap the current lView with a new lView.\n *\n * For performance reasons we store the lView in the top level of the module.\n * This way we minimize the number of properties to read. Whenever a new view\n * is entered we have to store the lView for later, and when the view is\n * exited the state has to be restored\n *\n * @param newView New lView to become active\n * @returns the previously active lView;\n */\nfunction enterView(newView) {\n    ngDevMode && assertNotEqual(newView[0], newView[1], '????');\n    ngDevMode && assertLViewOrUndefined(newView);\n    const newLFrame = allocLFrame();\n    if (ngDevMode) {\n        assertEqual(newLFrame.isParent, true, 'Expected clean LFrame');\n        assertEqual(newLFrame.lView, null, 'Expected clean LFrame');\n        assertEqual(newLFrame.tView, null, 'Expected clean LFrame');\n        assertEqual(newLFrame.selectedIndex, -1, 'Expected clean LFrame');\n        assertEqual(newLFrame.elementDepthCount, 0, 'Expected clean LFrame');\n        assertEqual(newLFrame.currentDirectiveIndex, -1, 'Expected clean LFrame');\n        assertEqual(newLFrame.currentNamespace, null, 'Expected clean LFrame');\n        assertEqual(newLFrame.bindingRootIndex, -1, 'Expected clean LFrame');\n        assertEqual(newLFrame.currentQueryIndex, 0, 'Expected clean LFrame');\n    }\n    const tView = newView[TVIEW];\n    instructionState.lFrame = newLFrame;\n    ngDevMode && tView.firstChild && assertTNodeForTView(tView.firstChild, tView);\n    newLFrame.currentTNode = tView.firstChild;\n    newLFrame.lView = newView;\n    newLFrame.tView = tView;\n    newLFrame.contextLView = newView;\n    newLFrame.bindingIndex = tView.bindingStartIndex;\n    newLFrame.inI18n = false;\n}\n/**\n * Allocates next free LFrame. This function tries to reuse the `LFrame`s to lower memory pressure.\n */\nfunction allocLFrame() {\n    const currentLFrame = instructionState.lFrame;\n    const childLFrame = currentLFrame === null ? null : currentLFrame.child;\n    const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;\n    return newLFrame;\n}\nfunction createLFrame(parent) {\n    const lFrame = {\n        currentTNode: null,\n        isParent: true,\n        lView: null,\n        tView: null,\n        selectedIndex: -1,\n        contextLView: null,\n        elementDepthCount: 0,\n        currentNamespace: null,\n        currentDirectiveIndex: -1,\n        bindingRootIndex: -1,\n        bindingIndex: -1,\n        currentQueryIndex: 0,\n        parent: parent,\n        child: null,\n        inI18n: false,\n    };\n    parent !== null && (parent.child = lFrame); // link the new LFrame for reuse.\n    return lFrame;\n}\n/**\n * A lightweight version of leave which is used with DI.\n *\n * This function only resets `currentTNode` and `LView` as those are the only properties\n * used with DI (`enterDI()`).\n *\n * NOTE: This function is reexported as `leaveDI`. However `leaveDI` has return type of `void` where\n * as `leaveViewLight` has `LFrame`. This is so that `leaveViewLight` can be used in `leaveView`.\n */\nfunction leaveViewLight() {\n    const oldLFrame = instructionState.lFrame;\n    instructionState.lFrame = oldLFrame.parent;\n    oldLFrame.currentTNode = null;\n    oldLFrame.lView = null;\n    return oldLFrame;\n}\n/**\n * This is a lightweight version of the `leaveView` which is needed by the DI system.\n *\n * NOTE: this function is an alias so that we can change the type of the function to have `void`\n * return type.\n */\nconst leaveDI = leaveViewLight;\n/**\n * Leave the current `LView`\n *\n * This pops the `LFrame` with the associated `LView` from the stack.\n *\n * IMPORTANT: We must zero out the `LFrame` values here otherwise they will be retained. This is\n * because for performance reasons we don't release `LFrame` but rather keep it for next use.\n */\nfunction leaveView() {\n    const oldLFrame = leaveViewLight();\n    oldLFrame.isParent = true;\n    oldLFrame.tView = null;\n    oldLFrame.selectedIndex = -1;\n    oldLFrame.contextLView = null;\n    oldLFrame.elementDepthCount = 0;\n    oldLFrame.currentDirectiveIndex = -1;\n    oldLFrame.currentNamespace = null;\n    oldLFrame.bindingRootIndex = -1;\n    oldLFrame.bindingIndex = -1;\n    oldLFrame.currentQueryIndex = 0;\n}\nfunction nextContextImpl(level) {\n    const contextLView = instructionState.lFrame.contextLView =\n        walkUpViews(level, instructionState.lFrame.contextLView);\n    return contextLView[CONTEXT];\n}\nfunction walkUpViews(nestingLevel, currentView) {\n    while (nestingLevel > 0) {\n        ngDevMode &&\n            assertDefined(currentView[DECLARATION_VIEW], 'Declaration view should be defined if nesting level is greater than 0.');\n        currentView = currentView[DECLARATION_VIEW];\n        nestingLevel--;\n    }\n    return currentView;\n}\n/**\n * Gets the currently selected element index.\n *\n * Used with {@link property} instruction (and more in the future) to identify the index in the\n * current `LView` to act on.\n */\nfunction getSelectedIndex() {\n    return instructionState.lFrame.selectedIndex;\n}\n/**\n * Sets the most recent index passed to {@link select}\n *\n * Used with {@link property} instruction (and more in the future) to identify the index in the\n * current `LView` to act on.\n *\n * (Note that if an \"exit function\" was set earlier (via `setElementExitFn()`) then that will be\n * run if and when the provided `index` value is different from the current selected index value.)\n */\nfunction setSelectedIndex(index) {\n    ngDevMode && index !== -1 &&\n        assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Index must be past HEADER_OFFSET (or -1).');\n    ngDevMode &&\n        assertLessThan(index, instructionState.lFrame.lView.length, 'Can\\'t set index passed end of LView');\n    instructionState.lFrame.selectedIndex = index;\n}\n/**\n * Gets the `tNode` that represents currently selected element.\n */\nfunction getSelectedTNode() {\n    const lFrame = instructionState.lFrame;\n    return getTNode(lFrame.tView, lFrame.selectedIndex);\n}\n/**\n * Sets the namespace used to create elements to `'http://www.w3.org/2000/svg'` in global state.\n *\n * @codeGenApi\n */\nfunction ɵɵnamespaceSVG() {\n    instructionState.lFrame.currentNamespace = SVG_NAMESPACE;\n}\n/**\n * Sets the namespace used to create elements to `'http://www.w3.org/1998/MathML/'` in global state.\n *\n * @codeGenApi\n */\nfunction ɵɵnamespaceMathML() {\n    instructionState.lFrame.currentNamespace = MATH_ML_NAMESPACE;\n}\n/**\n * Sets the namespace used to create elements to `null`, which forces element creation to use\n * `createElement` rather than `createElementNS`.\n *\n * @codeGenApi\n */\nfunction ɵɵnamespaceHTML() {\n    namespaceHTMLInternal();\n}\n/**\n * Sets the namespace used to create elements to `null`, which forces element creation to use\n * `createElement` rather than `createElementNS`.\n */\nfunction namespaceHTMLInternal() {\n    instructionState.lFrame.currentNamespace = null;\n}\nfunction getNamespace$1() {\n    return instructionState.lFrame.currentNamespace;\n}\nlet _wasLastNodeCreated = true;\n/**\n * Retrieves a global flag that indicates whether the most recent DOM node\n * was created or hydrated.\n */\nfunction wasLastNodeCreated() {\n    return _wasLastNodeCreated;\n}\n/**\n * Sets a global flag to indicate whether the most recent DOM node\n * was created or hydrated.\n */\nfunction lastNodeWasCreated(flag) {\n    _wasLastNodeCreated = flag;\n}\n\n/**\n * Adds all directive lifecycle hooks from the given `DirectiveDef` to the given `TView`.\n *\n * Must be run *only* on the first template pass.\n *\n * Sets up the pre-order hooks on the provided `tView`,\n * see {@link HookData} for details about the data structure.\n *\n * @param directiveIndex The index of the directive in LView\n * @param directiveDef The definition containing the hooks to setup in tView\n * @param tView The current TView\n */\nfunction registerPreOrderHooks(directiveIndex, directiveDef, tView) {\n    ngDevMode && assertFirstCreatePass(tView);\n    const { ngOnChanges, ngOnInit, ngDoCheck } = directiveDef.type.prototype;\n    if (ngOnChanges) {\n        const wrappedOnChanges = NgOnChangesFeatureImpl(directiveDef);\n        (tView.preOrderHooks ??= []).push(directiveIndex, wrappedOnChanges);\n        (tView.preOrderCheckHooks ??= []).push(directiveIndex, wrappedOnChanges);\n    }\n    if (ngOnInit) {\n        (tView.preOrderHooks ??= []).push(0 - directiveIndex, ngOnInit);\n    }\n    if (ngDoCheck) {\n        (tView.preOrderHooks ??= []).push(directiveIndex, ngDoCheck);\n        (tView.preOrderCheckHooks ??= []).push(directiveIndex, ngDoCheck);\n    }\n}\n/**\n *\n * Loops through the directives on the provided `tNode` and queues hooks to be\n * run that are not initialization hooks.\n *\n * Should be executed during `elementEnd()` and similar to\n * preserve hook execution order. Content, view, and destroy hooks for projected\n * components and directives must be called *before* their hosts.\n *\n * Sets up the content, view, and destroy hooks on the provided `tView`,\n * see {@link HookData} for details about the data structure.\n *\n * NOTE: This does not set up `onChanges`, `onInit` or `doCheck`, those are set up\n * separately at `elementStart`.\n *\n * @param tView The current TView\n * @param tNode The TNode whose directives are to be searched for hooks to queue\n */\nfunction registerPostOrderHooks(tView, tNode) {\n    ngDevMode && assertFirstCreatePass(tView);\n    // It's necessary to loop through the directives at elementEnd() (rather than processing in\n    // directiveCreate) so we can preserve the current hook order. Content, view, and destroy\n    // hooks for projected components and directives must be called *before* their hosts.\n    for (let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {\n        const directiveDef = tView.data[i];\n        ngDevMode && assertDefined(directiveDef, 'Expecting DirectiveDef');\n        const lifecycleHooks = directiveDef.type.prototype;\n        const { ngAfterContentInit, ngAfterContentChecked, ngAfterViewInit, ngAfterViewChecked, ngOnDestroy } = lifecycleHooks;\n        if (ngAfterContentInit) {\n            (tView.contentHooks ??= []).push(-i, ngAfterContentInit);\n        }\n        if (ngAfterContentChecked) {\n            (tView.contentHooks ??= []).push(i, ngAfterContentChecked);\n            (tView.contentCheckHooks ??= []).push(i, ngAfterContentChecked);\n        }\n        if (ngAfterViewInit) {\n            (tView.viewHooks ??= []).push(-i, ngAfterViewInit);\n        }\n        if (ngAfterViewChecked) {\n            (tView.viewHooks ??= []).push(i, ngAfterViewChecked);\n            (tView.viewCheckHooks ??= []).push(i, ngAfterViewChecked);\n        }\n        if (ngOnDestroy != null) {\n            (tView.destroyHooks ??= []).push(i, ngOnDestroy);\n        }\n    }\n}\n/**\n * Executing hooks requires complex logic as we need to deal with 2 constraints.\n *\n * 1. Init hooks (ngOnInit, ngAfterContentInit, ngAfterViewInit) must all be executed once and only\n * once, across many change detection cycles. This must be true even if some hooks throw, or if\n * some recursively trigger a change detection cycle.\n * To solve that, it is required to track the state of the execution of these init hooks.\n * This is done by storing and maintaining flags in the view: the {@link InitPhaseState},\n * and the index within that phase. They can be seen as a cursor in the following structure:\n * [[onInit1, onInit2], [afterContentInit1], [afterViewInit1, afterViewInit2, afterViewInit3]]\n * They are stored as flags in LView[FLAGS].\n *\n * 2. Pre-order hooks can be executed in batches, because of the select instruction.\n * To be able to pause and resume their execution, we also need some state about the hook's array\n * that is being processed:\n * - the index of the next hook to be executed\n * - the number of init hooks already found in the processed part of the  array\n * They are stored as flags in LView[PREORDER_HOOK_FLAGS].\n */\n/**\n * Executes pre-order check hooks ( OnChanges, DoChanges) given a view where all the init hooks were\n * executed once. This is a light version of executeInitAndCheckPreOrderHooks where we can skip read\n * / write of the init-hooks related flags.\n * @param lView The LView where hooks are defined\n * @param hooks Hooks to be run\n * @param nodeIndex 3 cases depending on the value:\n * - undefined: all hooks from the array should be executed (post-order case)\n * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\n * flushing the remaining hooks)\n * - number: execute hooks only from the saved index until that node index exclusive (pre-order\n * case, when executing select(number))\n */\nfunction executeCheckHooks(lView, hooks, nodeIndex) {\n    callHooks(lView, hooks, 3 /* InitPhaseState.InitPhaseCompleted */, nodeIndex);\n}\n/**\n * Executes post-order init and check hooks (one of AfterContentInit, AfterContentChecked,\n * AfterViewInit, AfterViewChecked) given a view where there are pending init hooks to be executed.\n * @param lView The LView where hooks are defined\n * @param hooks Hooks to be run\n * @param initPhase A phase for which hooks should be run\n * @param nodeIndex 3 cases depending on the value:\n * - undefined: all hooks from the array should be executed (post-order case)\n * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\n * flushing the remaining hooks)\n * - number: execute hooks only from the saved index until that node index exclusive (pre-order\n * case, when executing select(number))\n */\nfunction executeInitAndCheckHooks(lView, hooks, initPhase, nodeIndex) {\n    ngDevMode &&\n        assertNotEqual(initPhase, 3 /* InitPhaseState.InitPhaseCompleted */, 'Init pre-order hooks should not be called more than once');\n    if ((lView[FLAGS] & 3 /* LViewFlags.InitPhaseStateMask */) === initPhase) {\n        callHooks(lView, hooks, initPhase, nodeIndex);\n    }\n}\nfunction incrementInitPhaseFlags(lView, initPhase) {\n    ngDevMode &&\n        assertNotEqual(initPhase, 3 /* InitPhaseState.InitPhaseCompleted */, 'Init hooks phase should not be incremented after all init hooks have been run.');\n    let flags = lView[FLAGS];\n    if ((flags & 3 /* LViewFlags.InitPhaseStateMask */) === initPhase) {\n        flags &= 8191 /* LViewFlags.IndexWithinInitPhaseReset */;\n        flags += 1 /* LViewFlags.InitPhaseStateIncrementer */;\n        lView[FLAGS] = flags;\n    }\n}\n/**\n * Calls lifecycle hooks with their contexts, skipping init hooks if it's not\n * the first LView pass\n *\n * @param currentView The current view\n * @param arr The array in which the hooks are found\n * @param initPhaseState the current state of the init phase\n * @param currentNodeIndex 3 cases depending on the value:\n * - undefined: all hooks from the array should be executed (post-order case)\n * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\n * flushing the remaining hooks)\n * - number: execute hooks only from the saved index until that node index exclusive (pre-order\n * case, when executing select(number))\n */\nfunction callHooks(currentView, arr, initPhase, currentNodeIndex) {\n    ngDevMode &&\n        assertEqual(isInCheckNoChangesMode(), false, 'Hooks should never be run when in check no changes mode.');\n    const startIndex = currentNodeIndex !== undefined ?\n        (currentView[PREORDER_HOOK_FLAGS] & 65535 /* PreOrderHookFlags.IndexOfTheNextPreOrderHookMaskMask */) :\n        0;\n    const nodeIndexLimit = currentNodeIndex != null ? currentNodeIndex : -1;\n    const max = arr.length - 1; // Stop the loop at length - 1, because we look for the hook at i + 1\n    let lastNodeIndexFound = 0;\n    for (let i = startIndex; i < max; i++) {\n        const hook = arr[i + 1];\n        if (typeof hook === 'number') {\n            lastNodeIndexFound = arr[i];\n            if (currentNodeIndex != null && lastNodeIndexFound >= currentNodeIndex) {\n                break;\n            }\n        }\n        else {\n            const isInitHook = arr[i] < 0;\n            if (isInitHook) {\n                currentView[PREORDER_HOOK_FLAGS] += 65536 /* PreOrderHookFlags.NumberOfInitHooksCalledIncrementer */;\n            }\n            if (lastNodeIndexFound < nodeIndexLimit || nodeIndexLimit == -1) {\n                callHook(currentView, initPhase, arr, i);\n                currentView[PREORDER_HOOK_FLAGS] =\n                    (currentView[PREORDER_HOOK_FLAGS] & 4294901760 /* PreOrderHookFlags.NumberOfInitHooksCalledMask */) + i +\n                        2;\n            }\n            i++;\n        }\n    }\n}\n/**\n * Executes a single lifecycle hook, making sure that:\n * - it is called in the non-reactive context;\n * - profiling data are registered.\n */\nfunction callHookInternal(directive, hook) {\n    profiler(4 /* ProfilerEvent.LifecycleHookStart */, directive, hook);\n    const prevConsumer = setActiveConsumer(null);\n    try {\n        hook.call(directive);\n    }\n    finally {\n        setActiveConsumer(prevConsumer);\n        profiler(5 /* ProfilerEvent.LifecycleHookEnd */, directive, hook);\n    }\n}\n/**\n * Execute one hook against the current `LView`.\n *\n * @param currentView The current view\n * @param initPhaseState the current state of the init phase\n * @param arr The array in which the hooks are found\n * @param i The current index within the hook data array\n */\nfunction callHook(currentView, initPhase, arr, i) {\n    const isInitHook = arr[i] < 0;\n    const hook = arr[i + 1];\n    const directiveIndex = isInitHook ? -arr[i] : arr[i];\n    const directive = currentView[directiveIndex];\n    if (isInitHook) {\n        const indexWithintInitPhase = currentView[FLAGS] >> 13 /* LViewFlags.IndexWithinInitPhaseShift */;\n        // The init phase state must be always checked here as it may have been recursively updated.\n        if (indexWithintInitPhase <\n            (currentView[PREORDER_HOOK_FLAGS] >> 16 /* PreOrderHookFlags.NumberOfInitHooksCalledShift */) &&\n            (currentView[FLAGS] & 3 /* LViewFlags.InitPhaseStateMask */) === initPhase) {\n            currentView[FLAGS] += 8192 /* LViewFlags.IndexWithinInitPhaseIncrementer */;\n            callHookInternal(directive, hook);\n        }\n    }\n    else {\n        callHookInternal(directive, hook);\n    }\n}\n\nconst NO_PARENT_INJECTOR = -1;\n/**\n * Each injector is saved in 9 contiguous slots in `LView` and 9 contiguous slots in\n * `TView.data`. This allows us to store information about the current node's tokens (which\n * can be shared in `TView`) as well as the tokens of its ancestor nodes (which cannot be\n * shared, so they live in `LView`).\n *\n * Each of these slots (aside from the last slot) contains a bloom filter. This bloom filter\n * determines whether a directive is available on the associated node or not. This prevents us\n * from searching the directives array at this level unless it's probable the directive is in it.\n *\n * See: https://en.wikipedia.org/wiki/Bloom_filter for more about bloom filters.\n *\n * Because all injectors have been flattened into `LView` and `TViewData`, they cannot typed\n * using interfaces as they were previously. The start index of each `LInjector` and `TInjector`\n * will differ based on where it is flattened into the main array, so it's not possible to know\n * the indices ahead of time and save their types here. The interfaces are still included here\n * for documentation purposes.\n *\n * export interface LInjector extends Array<any> {\n *\n *    // Cumulative bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)\n *    [0]: number;\n *\n *    // Cumulative bloom for directive IDs 32-63\n *    [1]: number;\n *\n *    // Cumulative bloom for directive IDs 64-95\n *    [2]: number;\n *\n *    // Cumulative bloom for directive IDs 96-127\n *    [3]: number;\n *\n *    // Cumulative bloom for directive IDs 128-159\n *    [4]: number;\n *\n *    // Cumulative bloom for directive IDs 160 - 191\n *    [5]: number;\n *\n *    // Cumulative bloom for directive IDs 192 - 223\n *    [6]: number;\n *\n *    // Cumulative bloom for directive IDs 224 - 255\n *    [7]: number;\n *\n *    // We need to store a reference to the injector's parent so DI can keep looking up\n *    // the injector tree until it finds the dependency it's looking for.\n *    [PARENT_INJECTOR]: number;\n * }\n *\n * export interface TInjector extends Array<any> {\n *\n *    // Shared node bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)\n *    [0]: number;\n *\n *    // Shared node bloom for directive IDs 32-63\n *    [1]: number;\n *\n *    // Shared node bloom for directive IDs 64-95\n *    [2]: number;\n *\n *    // Shared node bloom for directive IDs 96-127\n *    [3]: number;\n *\n *    // Shared node bloom for directive IDs 128-159\n *    [4]: number;\n *\n *    // Shared node bloom for directive IDs 160 - 191\n *    [5]: number;\n *\n *    // Shared node bloom for directive IDs 192 - 223\n *    [6]: number;\n *\n *    // Shared node bloom for directive IDs 224 - 255\n *    [7]: number;\n *\n *    // Necessary to find directive indices for a particular node.\n *    [TNODE]: TElementNode|TElementContainerNode|TContainerNode;\n *  }\n */\n/**\n * Factory for creating instances of injectors in the NodeInjector.\n *\n * This factory is complicated by the fact that it can resolve `multi` factories as well.\n *\n * NOTE: Some of the fields are optional which means that this class has two hidden classes.\n * - One without `multi` support (most common)\n * - One with `multi` values, (rare).\n *\n * Since VMs can cache up to 4 inline hidden classes this is OK.\n *\n * - Single factory: Only `resolving` and `factory` is defined.\n * - `providers` factory: `componentProviders` is a number and `index = -1`.\n * - `viewProviders` factory: `componentProviders` is a number and `index` points to `providers`.\n */\nclass NodeInjectorFactory {\n    constructor(\n    /**\n     * Factory to invoke in order to create a new instance.\n     */\n    factory, \n    /**\n     * Set to `true` if the token is declared in `viewProviders` (or if it is component).\n     */\n    isViewProvider, injectImplementation) {\n        this.factory = factory;\n        /**\n         * Marker set to true during factory invocation to see if we get into recursive loop.\n         * Recursive loop causes an error to be displayed.\n         */\n        this.resolving = false;\n        ngDevMode && assertDefined(factory, 'Factory not specified');\n        ngDevMode && assertEqual(typeof factory, 'function', 'Expected factory function.');\n        this.canSeeViewProviders = isViewProvider;\n        this.injectImpl = injectImplementation;\n    }\n}\nfunction isFactory(obj) {\n    return obj instanceof NodeInjectorFactory;\n}\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd$2 = 1;\n\n/**\n * Converts `TNodeType` into human readable text.\n * Make sure this matches with `TNodeType`\n */\nfunction toTNodeTypeAsString(tNodeType) {\n    let text = '';\n    (tNodeType & 1 /* TNodeType.Text */) && (text += '|Text');\n    (tNodeType & 2 /* TNodeType.Element */) && (text += '|Element');\n    (tNodeType & 4 /* TNodeType.Container */) && (text += '|Container');\n    (tNodeType & 8 /* TNodeType.ElementContainer */) && (text += '|ElementContainer');\n    (tNodeType & 16 /* TNodeType.Projection */) && (text += '|Projection');\n    (tNodeType & 32 /* TNodeType.Icu */) && (text += '|IcuContainer');\n    (tNodeType & 64 /* TNodeType.Placeholder */) && (text += '|Placeholder');\n    return text.length > 0 ? text.substring(1) : text;\n}\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd$1 = 1;\n/**\n * Returns `true` if the `TNode` has a directive which has `@Input()` for `class` binding.\n *\n * ```\n * <div my-dir [class]=\"exp\"></div>\n * ```\n * and\n * ```\n * @Directive({\n * })\n * class MyDirective {\n *   @Input()\n *   class: string;\n * }\n * ```\n *\n * In the above case it is necessary to write the reconciled styling information into the\n * directive's input.\n *\n * @param tNode\n */\nfunction hasClassInput(tNode) {\n    return (tNode.flags & 8 /* TNodeFlags.hasClassInput */) !== 0;\n}\n/**\n * Returns `true` if the `TNode` has a directive which has `@Input()` for `style` binding.\n *\n * ```\n * <div my-dir [style]=\"exp\"></div>\n * ```\n * and\n * ```\n * @Directive({\n * })\n * class MyDirective {\n *   @Input()\n *   class: string;\n * }\n * ```\n *\n * In the above case it is necessary to write the reconciled styling information into the\n * directive's input.\n *\n * @param tNode\n */\nfunction hasStyleInput(tNode) {\n    return (tNode.flags & 16 /* TNodeFlags.hasStyleInput */) !== 0;\n}\n\nfunction assertTNodeType(tNode, expectedTypes, message) {\n    assertDefined(tNode, 'should be called with a TNode');\n    if ((tNode.type & expectedTypes) === 0) {\n        throwError(message ||\n            `Expected [${toTNodeTypeAsString(expectedTypes)}] but got ${toTNodeTypeAsString(tNode.type)}.`);\n    }\n}\nfunction assertPureTNodeType(type) {\n    if (!(type === 2 /* TNodeType.Element */ || //\n        type === 1 /* TNodeType.Text */ || //\n        type === 4 /* TNodeType.Container */ || //\n        type === 8 /* TNodeType.ElementContainer */ || //\n        type === 32 /* TNodeType.Icu */ || //\n        type === 16 /* TNodeType.Projection */ || //\n        type === 64 /* TNodeType.Placeholder */)) {\n        throwError(`Expected TNodeType to have only a single type selected, but got ${toTNodeTypeAsString(type)}.`);\n    }\n}\n\n/// Parent Injector Utils ///////////////////////////////////////////////////////////////\nfunction hasParentInjector(parentLocation) {\n    return parentLocation !== NO_PARENT_INJECTOR;\n}\nfunction getParentInjectorIndex(parentLocation) {\n    ngDevMode && assertNumber(parentLocation, 'Number expected');\n    ngDevMode && assertNotEqual(parentLocation, -1, 'Not a valid state.');\n    const parentInjectorIndex = parentLocation & 32767 /* RelativeInjectorLocationFlags.InjectorIndexMask */;\n    ngDevMode &&\n        assertGreaterThan(parentInjectorIndex, HEADER_OFFSET, 'Parent injector must be pointing past HEADER_OFFSET.');\n    return parentLocation & 32767 /* RelativeInjectorLocationFlags.InjectorIndexMask */;\n}\nfunction getParentInjectorViewOffset(parentLocation) {\n    return parentLocation >> 16 /* RelativeInjectorLocationFlags.ViewOffsetShift */;\n}\n/**\n * Unwraps a parent injector location number to find the view offset from the current injector,\n * then walks up the declaration view tree until the view is found that contains the parent\n * injector.\n *\n * @param location The location of the parent injector, which contains the view offset\n * @param startView The LView instance from which to start walking up the view tree\n * @returns The LView instance that contains the parent injector\n */\nfunction getParentInjectorView(location, startView) {\n    let viewOffset = getParentInjectorViewOffset(location);\n    let parentView = startView;\n    // For most cases, the parent injector can be found on the host node (e.g. for component\n    // or container), but we must keep the loop here to support the rarer case of deeply nested\n    // <ng-template> tags or inline views, where the parent injector might live many views\n    // above the child injector.\n    while (viewOffset > 0) {\n        parentView = parentView[DECLARATION_VIEW];\n        viewOffset--;\n    }\n    return parentView;\n}\n\n/**\n * Defines if the call to `inject` should include `viewProviders` in its resolution.\n *\n * This is set to true when we try to instantiate a component. This value is reset in\n * `getNodeInjectable` to a value which matches the declaration location of the token about to be\n * instantiated. This is done so that if we are injecting a token which was declared outside of\n * `viewProviders` we don't accidentally pull `viewProviders` in.\n *\n * Example:\n *\n * ```\n * @Injectable()\n * class MyService {\n *   constructor(public value: String) {}\n * }\n *\n * @Component({\n *   providers: [\n *     MyService,\n *     {provide: String, value: 'providers' }\n *   ]\n *   viewProviders: [\n *     {provide: String, value: 'viewProviders'}\n *   ]\n * })\n * class MyComponent {\n *   constructor(myService: MyService, value: String) {\n *     // We expect that Component can see into `viewProviders`.\n *     expect(value).toEqual('viewProviders');\n *     // `MyService` was not declared in `viewProviders` hence it can't see it.\n *     expect(myService.value).toEqual('providers');\n *   }\n * }\n *\n * ```\n */\nlet includeViewProviders = true;\nfunction setIncludeViewProviders(v) {\n    const oldValue = includeViewProviders;\n    includeViewProviders = v;\n    return oldValue;\n}\n/**\n * The number of slots in each bloom filter (used by DI). The larger this number, the fewer\n * directives that will share slots, and thus, the fewer false positives when checking for\n * the existence of a directive.\n */\nconst BLOOM_SIZE = 256;\nconst BLOOM_MASK = BLOOM_SIZE - 1;\n/**\n * The number of bits that is represented by a single bloom bucket. JS bit operations are 32 bits,\n * so each bucket represents 32 distinct tokens which accounts for log2(32) = 5 bits of a bloom hash\n * number.\n */\nconst BLOOM_BUCKET_BITS = 5;\n/** Counter used to generate unique IDs for directives. */\nlet nextNgElementId = 0;\n/** Value used when something wasn't found by an injector. */\nconst NOT_FOUND = {};\n/**\n * Registers this directive as present in its node's injector by flipping the directive's\n * corresponding bit in the injector's bloom filter.\n *\n * @param injectorIndex The index of the node injector where this token should be registered\n * @param tView The TView for the injector's bloom filters\n * @param type The directive token to register\n */\nfunction bloomAdd(injectorIndex, tView, type) {\n    ngDevMode && assertEqual(tView.firstCreatePass, true, 'expected firstCreatePass to be true');\n    let id;\n    if (typeof type === 'string') {\n        id = type.charCodeAt(0) || 0;\n    }\n    else if (type.hasOwnProperty(NG_ELEMENT_ID)) {\n        id = type[NG_ELEMENT_ID];\n    }\n    // Set a unique ID on the directive type, so if something tries to inject the directive,\n    // we can easily retrieve the ID and hash it into the bloom bit that should be checked.\n    if (id == null) {\n        id = type[NG_ELEMENT_ID] = nextNgElementId++;\n    }\n    // We only have BLOOM_SIZE (256) slots in our bloom filter (8 buckets * 32 bits each),\n    // so all unique IDs must be modulo-ed into a number from 0 - 255 to fit into the filter.\n    const bloomHash = id & BLOOM_MASK;\n    // Create a mask that targets the specific bit associated with the directive.\n    // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n    // to bit positions 0 - 31 in a 32 bit integer.\n    const mask = 1 << bloomHash;\n    // Each bloom bucket in `tData` represents `BLOOM_BUCKET_BITS` number of bits of `bloomHash`.\n    // Any bits in `bloomHash` beyond `BLOOM_BUCKET_BITS` indicate the bucket offset that the mask\n    // should be written to.\n    tView.data[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)] |= mask;\n}\n/**\n * Creates (or gets an existing) injector for a given element or container.\n *\n * @param tNode for which an injector should be retrieved / created.\n * @param lView View where the node is stored\n * @returns Node injector\n */\nfunction getOrCreateNodeInjectorForNode(tNode, lView) {\n    const existingInjectorIndex = getInjectorIndex(tNode, lView);\n    if (existingInjectorIndex !== -1) {\n        return existingInjectorIndex;\n    }\n    const tView = lView[TVIEW];\n    if (tView.firstCreatePass) {\n        tNode.injectorIndex = lView.length;\n        insertBloom(tView.data, tNode); // foundation for node bloom\n        insertBloom(lView, null); // foundation for cumulative bloom\n        insertBloom(tView.blueprint, null);\n    }\n    const parentLoc = getParentInjectorLocation(tNode, lView);\n    const injectorIndex = tNode.injectorIndex;\n    // If a parent injector can't be found, its location is set to -1.\n    // In that case, we don't need to set up a cumulative bloom\n    if (hasParentInjector(parentLoc)) {\n        const parentIndex = getParentInjectorIndex(parentLoc);\n        const parentLView = getParentInjectorView(parentLoc, lView);\n        const parentData = parentLView[TVIEW].data;\n        // Creates a cumulative bloom filter that merges the parent's bloom filter\n        // and its own cumulative bloom (which contains tokens for all ancestors)\n        for (let i = 0; i < 8 /* NodeInjectorOffset.BLOOM_SIZE */; i++) {\n            lView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];\n        }\n    }\n    lView[injectorIndex + 8 /* NodeInjectorOffset.PARENT */] = parentLoc;\n    return injectorIndex;\n}\nfunction insertBloom(arr, footer) {\n    arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);\n}\nfunction getInjectorIndex(tNode, lView) {\n    if (tNode.injectorIndex === -1 ||\n        // If the injector index is the same as its parent's injector index, then the index has been\n        // copied down from the parent node. No injector has been created yet on this node.\n        (tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex) ||\n        // After the first template pass, the injector index might exist but the parent values\n        // might not have been calculated yet for this instance\n        lView[tNode.injectorIndex + 8 /* NodeInjectorOffset.PARENT */] === null) {\n        return -1;\n    }\n    else {\n        ngDevMode && assertIndexInRange(lView, tNode.injectorIndex);\n        return tNode.injectorIndex;\n    }\n}\n/**\n * Finds the index of the parent injector, with a view offset if applicable. Used to set the\n * parent injector initially.\n *\n * @returns Returns a number that is the combination of the number of LViews that we have to go up\n * to find the LView containing the parent inject AND the index of the injector within that LView.\n */\nfunction getParentInjectorLocation(tNode, lView) {\n    if (tNode.parent && tNode.parent.injectorIndex !== -1) {\n        // If we have a parent `TNode` and there is an injector associated with it we are done, because\n        // the parent injector is within the current `LView`.\n        return tNode.parent.injectorIndex; // ViewOffset is 0\n    }\n    // When parent injector location is computed it may be outside of the current view. (ie it could\n    // be pointing to a declared parent location). This variable stores number of declaration parents\n    // we need to walk up in order to find the parent injector location.\n    let declarationViewOffset = 0;\n    let parentTNode = null;\n    let lViewCursor = lView;\n    // The parent injector is not in the current `LView`. We will have to walk the declared parent\n    // `LView` hierarchy and look for it. If we walk of the top, that means that there is no parent\n    // `NodeInjector`.\n    while (lViewCursor !== null) {\n        parentTNode = getTNodeFromLView(lViewCursor);\n        if (parentTNode === null) {\n            // If we have no parent, than we are done.\n            return NO_PARENT_INJECTOR;\n        }\n        ngDevMode && parentTNode && assertTNodeForLView(parentTNode, lViewCursor[DECLARATION_VIEW]);\n        // Every iteration of the loop requires that we go to the declared parent.\n        declarationViewOffset++;\n        lViewCursor = lViewCursor[DECLARATION_VIEW];\n        if (parentTNode.injectorIndex !== -1) {\n            // We found a NodeInjector which points to something.\n            return (parentTNode.injectorIndex |\n                (declarationViewOffset << 16 /* RelativeInjectorLocationFlags.ViewOffsetShift */));\n        }\n    }\n    return NO_PARENT_INJECTOR;\n}\n/**\n * Makes a type or an injection token public to the DI system by adding it to an\n * injector's bloom filter.\n *\n * @param di The node injector in which a directive will be added\n * @param token The type or the injection token to be made public\n */\nfunction diPublicInInjector(injectorIndex, tView, token) {\n    bloomAdd(injectorIndex, tView, token);\n}\n/**\n * Inject static attribute value into directive constructor.\n *\n * This method is used with `factory` functions which are generated as part of\n * `defineDirective` or `defineComponent`. The method retrieves the static value\n * of an attribute. (Dynamic attributes are not supported since they are not resolved\n *  at the time of injection and can change over time.)\n *\n * # Example\n * Given:\n * ```\n * @Component(...)\n * class MyComponent {\n *   constructor(@Attribute('title') title: string) { ... }\n * }\n * ```\n * When instantiated with\n * ```\n * <my-component title=\"Hello\"></my-component>\n * ```\n *\n * Then factory method generated is:\n * ```\n * MyComponent.ɵcmp = defineComponent({\n *   factory: () => new MyComponent(injectAttribute('title'))\n *   ...\n * })\n * ```\n *\n * @publicApi\n */\nfunction injectAttributeImpl(tNode, attrNameToInject) {\n    ngDevMode && assertTNodeType(tNode, 12 /* TNodeType.AnyContainer */ | 3 /* TNodeType.AnyRNode */);\n    ngDevMode && assertDefined(tNode, 'expecting tNode');\n    if (attrNameToInject === 'class') {\n        return tNode.classes;\n    }\n    if (attrNameToInject === 'style') {\n        return tNode.styles;\n    }\n    const attrs = tNode.attrs;\n    if (attrs) {\n        const attrsLength = attrs.length;\n        let i = 0;\n        while (i < attrsLength) {\n            const value = attrs[i];\n            // If we hit a `Bindings` or `Template` marker then we are done.\n            if (isNameOnlyAttributeMarker(value))\n                break;\n            // Skip namespaced attributes\n            if (value === 0 /* AttributeMarker.NamespaceURI */) {\n                // we skip the next two values\n                // as namespaced attributes looks like\n                // [..., AttributeMarker.NamespaceURI, 'http://someuri.com/test', 'test:exist',\n                // 'existValue', ...]\n                i = i + 2;\n            }\n            else if (typeof value === 'number') {\n                // Skip to the first value of the marked attribute.\n                i++;\n                while (i < attrsLength && typeof attrs[i] === 'string') {\n                    i++;\n                }\n            }\n            else if (value === attrNameToInject) {\n                return attrs[i + 1];\n            }\n            else {\n                i = i + 2;\n            }\n        }\n    }\n    return null;\n}\nfunction notFoundValueOrThrow(notFoundValue, token, flags) {\n    if ((flags & InjectFlags.Optional) || notFoundValue !== undefined) {\n        return notFoundValue;\n    }\n    else {\n        throwProviderNotFoundError(token, 'NodeInjector');\n    }\n}\n/**\n * Returns the value associated to the given token from the ModuleInjector or throws exception\n *\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\n * @returns the value from the injector or throws an exception\n */\nfunction lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue) {\n    if ((flags & InjectFlags.Optional) && notFoundValue === undefined) {\n        // This must be set or the NullInjector will throw for optional deps\n        notFoundValue = null;\n    }\n    if ((flags & (InjectFlags.Self | InjectFlags.Host)) === 0) {\n        const moduleInjector = lView[INJECTOR$1];\n        // switch to `injectInjectorOnly` implementation for module injector, since module injector\n        // should not have access to Component/Directive DI scope (that may happen through\n        // `directiveInject` implementation)\n        const previousInjectImplementation = setInjectImplementation(undefined);\n        try {\n            if (moduleInjector) {\n                return moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional);\n            }\n            else {\n                return injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);\n            }\n        }\n        finally {\n            setInjectImplementation(previousInjectImplementation);\n        }\n    }\n    return notFoundValueOrThrow(notFoundValue, token, flags);\n}\n/**\n * Returns the value associated to the given token from the NodeInjectors => ModuleInjector.\n *\n * Look for the injector providing the token by walking up the node injector tree and then\n * the module injector tree.\n *\n * This function patches `token` with `__NG_ELEMENT_ID__` which contains the id for the bloom\n * filter. `-1` is reserved for injecting `Injector` (implemented by `NodeInjector`)\n *\n * @param tNode The Node where the search for the injector should start\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\n * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided\n */\nfunction getOrCreateInjectable(tNode, lView, token, flags = InjectFlags.Default, notFoundValue) {\n    if (tNode !== null) {\n        // If the view or any of its ancestors have an embedded\n        // view injector, we have to look it up there first.\n        if (lView[FLAGS] & 2048 /* LViewFlags.HasEmbeddedViewInjector */ &&\n            // The token must be present on the current node injector when the `Self`\n            // flag is set, so the lookup on embedded view injector(s) can be skipped.\n            !(flags & InjectFlags.Self)) {\n            const embeddedInjectorValue = lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, NOT_FOUND);\n            if (embeddedInjectorValue !== NOT_FOUND) {\n                return embeddedInjectorValue;\n            }\n        }\n        // Otherwise try the node injector.\n        const value = lookupTokenUsingNodeInjector(tNode, lView, token, flags, NOT_FOUND);\n        if (value !== NOT_FOUND) {\n            return value;\n        }\n    }\n    // Finally, fall back to the module injector.\n    return lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);\n}\n/**\n * Returns the value associated to the given token from the node injector.\n *\n * @param tNode The Node where the search for the injector should start\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\n * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided\n */\nfunction lookupTokenUsingNodeInjector(tNode, lView, token, flags, notFoundValue) {\n    const bloomHash = bloomHashBitOrFactory(token);\n    // If the ID stored here is a function, this is a special object like ElementRef or TemplateRef\n    // so just call the factory function to create it.\n    if (typeof bloomHash === 'function') {\n        if (!enterDI(lView, tNode, flags)) {\n            // Failed to enter DI, try module injector instead. If a token is injected with the @Host\n            // flag, the module injector is not searched for that token in Ivy.\n            return (flags & InjectFlags.Host) ?\n                notFoundValueOrThrow(notFoundValue, token, flags) :\n                lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);\n        }\n        try {\n            let value;\n            if (ngDevMode) {\n                runInInjectorProfilerContext(new NodeInjector(getCurrentTNode(), getLView()), token, () => {\n                    value = bloomHash(flags);\n                    if (value != null) {\n                        emitInstanceCreatedByInjectorEvent(value);\n                    }\n                });\n            }\n            else {\n                value = bloomHash(flags);\n            }\n            if (value == null && !(flags & InjectFlags.Optional)) {\n                throwProviderNotFoundError(token);\n            }\n            else {\n                return value;\n            }\n        }\n        finally {\n            leaveDI();\n        }\n    }\n    else if (typeof bloomHash === 'number') {\n        // A reference to the previous injector TView that was found while climbing the element\n        // injector tree. This is used to know if viewProviders can be accessed on the current\n        // injector.\n        let previousTView = null;\n        let injectorIndex = getInjectorIndex(tNode, lView);\n        let parentLocation = NO_PARENT_INJECTOR;\n        let hostTElementNode = flags & InjectFlags.Host ? lView[DECLARATION_COMPONENT_VIEW][T_HOST] : null;\n        // If we should skip this injector, or if there is no injector on this node, start by\n        // searching the parent injector.\n        if (injectorIndex === -1 || flags & InjectFlags.SkipSelf) {\n            parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) :\n                lView[injectorIndex + 8 /* NodeInjectorOffset.PARENT */];\n            if (parentLocation === NO_PARENT_INJECTOR || !shouldSearchParent(flags, false)) {\n                injectorIndex = -1;\n            }\n            else {\n                previousTView = lView[TVIEW];\n                injectorIndex = getParentInjectorIndex(parentLocation);\n                lView = getParentInjectorView(parentLocation, lView);\n            }\n        }\n        // Traverse up the injector tree until we find a potential match or until we know there\n        // *isn't* a match.\n        while (injectorIndex !== -1) {\n            ngDevMode && assertNodeInjector(lView, injectorIndex);\n            // Check the current injector. If it matches, see if it contains token.\n            const tView = lView[TVIEW];\n            ngDevMode &&\n                assertTNodeForLView(tView.data[injectorIndex + 8 /* NodeInjectorOffset.TNODE */], lView);\n            if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {\n                // At this point, we have an injector which *may* contain the token, so we step through\n                // the providers and directives associated with the injector's corresponding node to get\n                // the instance.\n                const instance = searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode);\n                if (instance !== NOT_FOUND) {\n                    return instance;\n                }\n            }\n            parentLocation = lView[injectorIndex + 8 /* NodeInjectorOffset.PARENT */];\n            if (parentLocation !== NO_PARENT_INJECTOR &&\n                shouldSearchParent(flags, lView[TVIEW].data[injectorIndex + 8 /* NodeInjectorOffset.TNODE */] === hostTElementNode) &&\n                bloomHasToken(bloomHash, injectorIndex, lView)) {\n                // The def wasn't found anywhere on this node, so it was a false positive.\n                // Traverse up the tree and continue searching.\n                previousTView = tView;\n                injectorIndex = getParentInjectorIndex(parentLocation);\n                lView = getParentInjectorView(parentLocation, lView);\n            }\n            else {\n                // If we should not search parent OR If the ancestor bloom filter value does not have the\n                // bit corresponding to the directive we can give up on traversing up to find the specific\n                // injector.\n                injectorIndex = -1;\n            }\n        }\n    }\n    return notFoundValue;\n}\nfunction searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode) {\n    const currentTView = lView[TVIEW];\n    const tNode = currentTView.data[injectorIndex + 8 /* NodeInjectorOffset.TNODE */];\n    // First, we need to determine if view providers can be accessed by the starting element.\n    // There are two possibilities\n    const canAccessViewProviders = previousTView == null ?\n        // 1) This is the first invocation `previousTView == null` which means that we are at the\n        // `TNode` of where injector is starting to look. In such a case the only time we are allowed\n        // to look into the ViewProviders is if:\n        // - we are on a component\n        // - AND the injector set `includeViewProviders` to true (implying that the token can see\n        // ViewProviders because it is the Component or a Service which itself was declared in\n        // ViewProviders)\n        (isComponentHost(tNode) && includeViewProviders) :\n        // 2) `previousTView != null` which means that we are now walking across the parent nodes.\n        // In such a case we are only allowed to look into the ViewProviders if:\n        // - We just crossed from child View to Parent View `previousTView != currentTView`\n        // - AND the parent TNode is an Element.\n        // This means that we just came from the Component's View and therefore are allowed to see\n        // into the ViewProviders.\n        (previousTView != currentTView && ((tNode.type & 3 /* TNodeType.AnyRNode */) !== 0));\n    // This special case happens when there is a @host on the inject and when we are searching\n    // on the host element node.\n    const isHostSpecialCase = (flags & InjectFlags.Host) && hostTElementNode === tNode;\n    const injectableIdx = locateDirectiveOrProvider(tNode, currentTView, token, canAccessViewProviders, isHostSpecialCase);\n    if (injectableIdx !== null) {\n        return getNodeInjectable(lView, currentTView, injectableIdx, tNode);\n    }\n    else {\n        return NOT_FOUND;\n    }\n}\n/**\n * Searches for the given token among the node's directives and providers.\n *\n * @param tNode TNode on which directives are present.\n * @param tView The tView we are currently processing\n * @param token Provider token or type of a directive to look for.\n * @param canAccessViewProviders Whether view providers should be considered.\n * @param isHostSpecialCase Whether the host special case applies.\n * @returns Index of a found directive or provider, or null when none found.\n */\nfunction locateDirectiveOrProvider(tNode, tView, token, canAccessViewProviders, isHostSpecialCase) {\n    const nodeProviderIndexes = tNode.providerIndexes;\n    const tInjectables = tView.data;\n    const injectablesStart = nodeProviderIndexes & 1048575 /* TNodeProviderIndexes.ProvidersStartIndexMask */;\n    const directivesStart = tNode.directiveStart;\n    const directiveEnd = tNode.directiveEnd;\n    const cptViewProvidersCount = nodeProviderIndexes >> 20 /* TNodeProviderIndexes.CptViewProvidersCountShift */;\n    const startingIndex = canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount;\n    // When the host special case applies, only the viewProviders and the component are visible\n    const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;\n    for (let i = startingIndex; i < endIndex; i++) {\n        const providerTokenOrDef = tInjectables[i];\n        if (i < directivesStart && token === providerTokenOrDef ||\n            i >= directivesStart && providerTokenOrDef.type === token) {\n            return i;\n        }\n    }\n    if (isHostSpecialCase) {\n        const dirDef = tInjectables[directivesStart];\n        if (dirDef && isComponentDef(dirDef) && dirDef.type === token) {\n            return directivesStart;\n        }\n    }\n    return null;\n}\n/**\n * Retrieve or instantiate the injectable from the `LView` at particular `index`.\n *\n * This function checks to see if the value has already been instantiated and if so returns the\n * cached `injectable`. Otherwise if it detects that the value is still a factory it\n * instantiates the `injectable` and caches the value.\n */\nfunction getNodeInjectable(lView, tView, index, tNode) {\n    let value = lView[index];\n    const tData = tView.data;\n    if (isFactory(value)) {\n        const factory = value;\n        if (factory.resolving) {\n            throwCyclicDependencyError(stringifyForError(tData[index]));\n        }\n        const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);\n        factory.resolving = true;\n        let prevInjectContext;\n        if (ngDevMode) {\n            // tData indexes mirror the concrete instances in its corresponding LView.\n            // lView[index] here is either the injectable instace itself or a factory,\n            // therefore tData[index] is the constructor of that injectable or a\n            // definition object that contains the constructor in a `.type` field.\n            const token = tData[index].type || tData[index];\n            const injector = new NodeInjector(tNode, lView);\n            prevInjectContext = setInjectorProfilerContext({ injector, token });\n        }\n        const previousInjectImplementation = factory.injectImpl ? setInjectImplementation(factory.injectImpl) : null;\n        const success = enterDI(lView, tNode, InjectFlags.Default);\n        ngDevMode &&\n            assertEqual(success, true, 'Because flags do not contain \\`SkipSelf\\' we expect this to always succeed.');\n        try {\n            value = lView[index] = factory.factory(undefined, tData, lView, tNode);\n            ngDevMode && emitInstanceCreatedByInjectorEvent(value);\n            // This code path is hit for both directives and providers.\n            // For perf reasons, we want to avoid searching for hooks on providers.\n            // It does no harm to try (the hooks just won't exist), but the extra\n            // checks are unnecessary and this is a hot path. So we check to see\n            // if the index of the dependency is in the directive range for this\n            // tNode. If it's not, we know it's a provider and skip hook registration.\n            if (tView.firstCreatePass && index >= tNode.directiveStart) {\n                ngDevMode && assertDirectiveDef(tData[index]);\n                registerPreOrderHooks(index, tData[index], tView);\n            }\n        }\n        finally {\n            ngDevMode && setInjectorProfilerContext(prevInjectContext);\n            previousInjectImplementation !== null &&\n                setInjectImplementation(previousInjectImplementation);\n            setIncludeViewProviders(previousIncludeViewProviders);\n            factory.resolving = false;\n            leaveDI();\n        }\n    }\n    return value;\n}\n/**\n * Returns the bit in an injector's bloom filter that should be used to determine whether or not\n * the directive might be provided by the injector.\n *\n * When a directive is public, it is added to the bloom filter and given a unique ID that can be\n * retrieved on the Type. When the directive isn't public or the token is not a directive `null`\n * is returned as the node injector can not possibly provide that token.\n *\n * @param token the injection token\n * @returns the matching bit to check in the bloom filter or `null` if the token is not known.\n *   When the returned value is negative then it represents special values such as `Injector`.\n */\nfunction bloomHashBitOrFactory(token) {\n    ngDevMode && assertDefined(token, 'token must be defined');\n    if (typeof token === 'string') {\n        return token.charCodeAt(0) || 0;\n    }\n    const tokenId = \n    // First check with `hasOwnProperty` so we don't get an inherited ID.\n    token.hasOwnProperty(NG_ELEMENT_ID) ? token[NG_ELEMENT_ID] : undefined;\n    // Negative token IDs are used for special objects such as `Injector`\n    if (typeof tokenId === 'number') {\n        if (tokenId >= 0) {\n            return tokenId & BLOOM_MASK;\n        }\n        else {\n            ngDevMode &&\n                assertEqual(tokenId, -1 /* InjectorMarkers.Injector */, 'Expecting to get Special Injector Id');\n            return createNodeInjector;\n        }\n    }\n    else {\n        return tokenId;\n    }\n}\nfunction bloomHasToken(bloomHash, injectorIndex, injectorView) {\n    // Create a mask that targets the specific bit associated with the directive we're looking for.\n    // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n    // to bit positions 0 - 31 in a 32 bit integer.\n    const mask = 1 << bloomHash;\n    // Each bloom bucket in `injectorView` represents `BLOOM_BUCKET_BITS` number of bits of\n    // `bloomHash`. Any bits in `bloomHash` beyond `BLOOM_BUCKET_BITS` indicate the bucket offset\n    // that should be used.\n    const value = injectorView[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)];\n    // If the bloom filter value has the bit corresponding to the directive's bloomBit flipped on,\n    // this injector is a potential match.\n    return !!(value & mask);\n}\n/** Returns true if flags prevent parent injector from being searched for tokens */\nfunction shouldSearchParent(flags, isFirstHostTNode) {\n    return !(flags & InjectFlags.Self) && !(flags & InjectFlags.Host && isFirstHostTNode);\n}\nfunction getNodeInjectorLView(nodeInjector) {\n    return nodeInjector._lView;\n}\nfunction getNodeInjectorTNode(nodeInjector) {\n    return nodeInjector._tNode;\n}\nclass NodeInjector {\n    constructor(_tNode, _lView) {\n        this._tNode = _tNode;\n        this._lView = _lView;\n    }\n    get(token, notFoundValue, flags) {\n        return getOrCreateInjectable(this._tNode, this._lView, token, convertToBitFlags(flags), notFoundValue);\n    }\n}\n/** Creates a `NodeInjector` for the current node. */\nfunction createNodeInjector() {\n    return new NodeInjector(getCurrentTNode(), getLView());\n}\n/**\n * @codeGenApi\n */\nfunction ɵɵgetInheritedFactory(type) {\n    return noSideEffects(() => {\n        const ownConstructor = type.prototype.constructor;\n        const ownFactory = ownConstructor[NG_FACTORY_DEF] || getFactoryOf(ownConstructor);\n        const objectPrototype = Object.prototype;\n        let parent = Object.getPrototypeOf(type.prototype).constructor;\n        // Go up the prototype until we hit `Object`.\n        while (parent && parent !== objectPrototype) {\n            const factory = parent[NG_FACTORY_DEF] || getFactoryOf(parent);\n            // If we hit something that has a factory and the factory isn't the same as the type,\n            // we've found the inherited factory. Note the check that the factory isn't the type's\n            // own factory is redundant in most cases, but if the user has custom decorators on the\n            // class, this lookup will start one level down in the prototype chain, causing us to\n            // find the own factory first and potentially triggering an infinite loop downstream.\n            if (factory && factory !== ownFactory) {\n                return factory;\n            }\n            parent = Object.getPrototypeOf(parent);\n        }\n        // There is no factory defined. Either this was improper usage of inheritance\n        // (no Angular decorator on the superclass) or there is no constructor at all\n        // in the inheritance chain. Since the two cases cannot be distinguished, the\n        // latter has to be assumed.\n        return (t) => new t();\n    });\n}\nfunction getFactoryOf(type) {\n    if (isForwardRef(type)) {\n        return () => {\n            const factory = getFactoryOf(resolveForwardRef(type));\n            return factory && factory();\n        };\n    }\n    return getFactoryDef(type);\n}\n/**\n * Returns a value from the closest embedded or node injector.\n *\n * @param tNode The Node where the search for the injector should start\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\n * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided\n */\nfunction lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, notFoundValue) {\n    let currentTNode = tNode;\n    let currentLView = lView;\n    // When an LView with an embedded view injector is inserted, it'll likely be interlaced with\n    // nodes who may have injectors (e.g. node injector -> embedded view injector -> node injector).\n    // Since the bloom filters for the node injectors have already been constructed and we don't\n    // have a way of extracting the records from an injector, the only way to maintain the correct\n    // hierarchy when resolving the value is to walk it node-by-node while attempting to resolve\n    // the token at each level.\n    while (currentTNode !== null && currentLView !== null &&\n        (currentLView[FLAGS] & 2048 /* LViewFlags.HasEmbeddedViewInjector */) &&\n        !(currentLView[FLAGS] & 512 /* LViewFlags.IsRoot */)) {\n        ngDevMode && assertTNodeForLView(currentTNode, currentLView);\n        // Note that this lookup on the node injector is using the `Self` flag, because\n        // we don't want the node injector to look at any parent injectors since we\n        // may hit the embedded view injector first.\n        const nodeInjectorValue = lookupTokenUsingNodeInjector(currentTNode, currentLView, token, flags | InjectFlags.Self, NOT_FOUND);\n        if (nodeInjectorValue !== NOT_FOUND) {\n            return nodeInjectorValue;\n        }\n        // Has an explicit type due to a TS bug: https://github.com/microsoft/TypeScript/issues/33191\n        let parentTNode = currentTNode.parent;\n        // `TNode.parent` includes the parent within the current view only. If it doesn't exist,\n        // it means that we've hit the view boundary and we need to go up to the next view.\n        if (!parentTNode) {\n            // Before we go to the next LView, check if the token exists on the current embedded injector.\n            const embeddedViewInjector = currentLView[EMBEDDED_VIEW_INJECTOR];\n            if (embeddedViewInjector) {\n                const embeddedViewInjectorValue = embeddedViewInjector.get(token, NOT_FOUND, flags);\n                if (embeddedViewInjectorValue !== NOT_FOUND) {\n                    return embeddedViewInjectorValue;\n                }\n            }\n            // Otherwise keep going up the tree.\n            parentTNode = getTNodeFromLView(currentLView);\n            currentLView = currentLView[DECLARATION_VIEW];\n        }\n        currentTNode = parentTNode;\n    }\n    return notFoundValue;\n}\n/** Gets the TNode associated with an LView inside of the declaration view. */\nfunction getTNodeFromLView(lView) {\n    const tView = lView[TVIEW];\n    const tViewType = tView.type;\n    // The parent pointer differs based on `TView.type`.\n    if (tViewType === 2 /* TViewType.Embedded */) {\n        ngDevMode && assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');\n        return tView.declTNode;\n    }\n    else if (tViewType === 1 /* TViewType.Component */) {\n        // Components don't have `TView.declTNode` because each instance of component could be\n        // inserted in different location, hence `TView.declTNode` is meaningless.\n        return lView[T_HOST];\n    }\n    return null;\n}\n\n/**\n * Facade for the attribute injection from DI.\n *\n * @codeGenApi\n */\nfunction ɵɵinjectAttribute(attrNameToInject) {\n    return injectAttributeImpl(getCurrentTNode(), attrNameToInject);\n}\n\n/**\n * Attribute decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Attribute = makeParamDecorator('Attribute', (attributeName) => ({ attributeName, __NG_ELEMENT_ID__: () => ɵɵinjectAttribute(attributeName) }));\n\nlet _reflect = null;\nfunction getReflect() {\n    return (_reflect = _reflect || new ReflectionCapabilities());\n}\nfunction reflectDependencies(type) {\n    return convertDependencies(getReflect().parameters(type));\n}\nfunction convertDependencies(deps) {\n    return deps.map(dep => reflectDependency(dep));\n}\nfunction reflectDependency(dep) {\n    const meta = {\n        token: null,\n        attribute: null,\n        host: false,\n        optional: false,\n        self: false,\n        skipSelf: false,\n    };\n    if (Array.isArray(dep) && dep.length > 0) {\n        for (let j = 0; j < dep.length; j++) {\n            const param = dep[j];\n            if (param === undefined) {\n                // param may be undefined if type of dep is not set by ngtsc\n                continue;\n            }\n            const proto = Object.getPrototypeOf(param);\n            if (param instanceof Optional || proto.ngMetadataName === 'Optional') {\n                meta.optional = true;\n            }\n            else if (param instanceof SkipSelf || proto.ngMetadataName === 'SkipSelf') {\n                meta.skipSelf = true;\n            }\n            else if (param instanceof Self || proto.ngMetadataName === 'Self') {\n                meta.self = true;\n            }\n            else if (param instanceof Host || proto.ngMetadataName === 'Host') {\n                meta.host = true;\n            }\n            else if (param instanceof Inject) {\n                meta.token = param.token;\n            }\n            else if (param instanceof Attribute) {\n                if (param.attributeName === undefined) {\n                    throw new RuntimeError(204 /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */, ngDevMode && `Attribute name must be defined.`);\n                }\n                meta.attribute = param.attributeName;\n            }\n            else {\n                meta.token = param;\n            }\n        }\n    }\n    else if (dep === undefined || (Array.isArray(dep) && dep.length === 0)) {\n        meta.token = null;\n    }\n    else {\n        meta.token = dep;\n    }\n    return meta;\n}\n\n/**\n * Map of module-id to the corresponding NgModule.\n */\nconst modules = new Map();\n/**\n * Whether to check for duplicate NgModule registrations.\n *\n * This can be disabled for testing.\n */\nlet checkForDuplicateNgModules = true;\nfunction assertSameOrNotExisting(id, type, incoming) {\n    if (type && type !== incoming && checkForDuplicateNgModules) {\n        throw new Error(`Duplicate module registered for ${id} - ${stringify(type)} vs ${stringify(type.name)}`);\n    }\n}\n/**\n * Adds the given NgModule type to Angular's NgModule registry.\n *\n * This is generated as a side-effect of NgModule compilation. Note that the `id` is passed in\n * explicitly and not read from the NgModule definition. This is for two reasons: it avoids a\n * megamorphic read, and in JIT there's a chicken-and-egg problem where the NgModule may not be\n * fully resolved when it's registered.\n *\n * @codeGenApi\n */\nfunction registerNgModuleType(ngModuleType, id) {\n    const existing = modules.get(id) || null;\n    assertSameOrNotExisting(id, existing, ngModuleType);\n    modules.set(id, ngModuleType);\n}\nfunction clearModulesForTest() {\n    modules.clear();\n}\nfunction getRegisteredNgModuleType(id) {\n    return modules.get(id);\n}\n/**\n * Control whether the NgModule registration system enforces that each NgModule type registered has\n * a unique id.\n *\n * This is useful for testing as the NgModule registry cannot be properly reset between tests with\n * Angular's current API.\n */\nfunction setAllowDuplicateNgModuleIdsForTest(allowDuplicates) {\n    checkForDuplicateNgModules = !allowDuplicates;\n}\n\n/**\n * Creates a token that can be used in a DI Provider.\n *\n * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a\n * runtime representation) such as when injecting an interface, callable type, array or\n * parameterized type.\n *\n * `InjectionToken` is parameterized on `T` which is the type of object which will be returned by\n * the `Injector`. This provides an additional level of type safety.\n *\n * <div class=\"alert is-helpful\">\n *\n * **Important Note**: Ensure that you use the same instance of the `InjectionToken` in both the\n * provider and the injection call. Creating a new instance of `InjectionToken` in different places,\n * even with the same description, will be treated as different tokens by Angular's DI system,\n * leading to a `NullInjectorError`.\n *\n * </div>\n *\n * <code-example format=\"typescript\" language=\"typescript\" path=\"injection-token/src/main.ts\"\n * region=\"InjectionToken\"></code-example>\n *\n * When creating an `InjectionToken`, you can optionally specify a factory function which returns\n * (possibly by creating) a default value of the parameterized type `T`. This sets up the\n * `InjectionToken` using this factory as a provider as if it was defined explicitly in the\n * application's root injector. If the factory function, which takes zero arguments, needs to inject\n * dependencies, it can do so using the [`inject`](api/core/inject) function.\n * As you can see in the Tree-shakable InjectionToken example below.\n *\n * Additionally, if a `factory` is specified you can also specify the `providedIn` option, which\n * overrides the above behavior and marks the token as belonging to a particular `@NgModule` (note:\n * this option is now deprecated). As mentioned above, `'root'` is the default value for\n * `providedIn`.\n *\n * The `providedIn: NgModule` and `providedIn: 'any'` options are deprecated.\n *\n * @usageNotes\n * ### Basic Examples\n *\n * ### Plain InjectionToken\n *\n * {@example core/di/ts/injector_spec.ts region='InjectionToken'}\n *\n * ### Tree-shakable InjectionToken\n *\n * {@example core/di/ts/injector_spec.ts region='ShakableInjectionToken'}\n *\n * @publicApi\n */\nclass InjectionToken {\n    /**\n     * @param _desc   Description for the token,\n     *                used only for debugging purposes,\n     *                it should but does not need to be unique\n     * @param options Options for the token's usage, as described above\n     */\n    constructor(_desc, options) {\n        this._desc = _desc;\n        /** @internal */\n        this.ngMetadataName = 'InjectionToken';\n        this.ɵprov = undefined;\n        if (typeof options == 'number') {\n            (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                assertLessThan(options, 0, 'Only negative numbers are supported here');\n            // This is a special hack to assign __NG_ELEMENT_ID__ to this instance.\n            // See `InjectorMarkers`\n            this.__NG_ELEMENT_ID__ = options;\n        }\n        else if (options !== undefined) {\n            this.ɵprov = ɵɵdefineInjectable({\n                token: this,\n                providedIn: options.providedIn || 'root',\n                factory: options.factory,\n            });\n        }\n    }\n    /**\n     * @internal\n     */\n    get multi() {\n        return this;\n    }\n    toString() {\n        return `InjectionToken ${this._desc}`;\n    }\n}\n\n/**\n * Most of the use of `document` in Angular is from within the DI system so it is possible to simply\n * inject the `DOCUMENT` token and are done.\n *\n * Ivy is special because it does not rely upon the DI and must get hold of the document some other\n * way.\n *\n * The solution is to define `getDocument()` and `setDocument()` top-level functions for ivy.\n * Wherever ivy needs the global document, it calls `getDocument()` instead.\n *\n * When running ivy outside of a browser environment, it is necessary to call `setDocument()` to\n * tell ivy what the global `document` is.\n *\n * Angular does this for us in each of the standard platforms (`Browser` and `Server`)\n * by calling `setDocument()` when providing the `DOCUMENT` token.\n */\nlet DOCUMENT = undefined;\n/**\n * Tell ivy what the `document` is for this platform.\n *\n * It is only necessary to call this if the current platform is not a browser.\n *\n * @param document The object representing the global `document` in this environment.\n */\nfunction setDocument(document) {\n    DOCUMENT = document;\n}\n/**\n * Access the object that represents the `document` for this platform.\n *\n * Ivy calls this whenever it needs to access the `document` object.\n * For example to create the renderer or to do sanitization.\n */\nfunction getDocument() {\n    if (DOCUMENT !== undefined) {\n        return DOCUMENT;\n    }\n    else if (typeof document !== 'undefined') {\n        return document;\n    }\n    throw new RuntimeError(210 /* RuntimeErrorCode.MISSING_DOCUMENT */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n        `The document object is not available in this context. Make sure the DOCUMENT injection token is provided.`);\n    // No \"document\" can be found. This should only happen if we are running ivy outside Angular and\n    // the current platform is not a browser. Since this is not a supported scenario at the moment\n    // this should not happen in Angular apps.\n    // Once we support running ivy outside of Angular we will need to publish `setDocument()` as a\n    // public API.\n}\n\n/**\n * A [DI token](guide/glossary#di-token \"DI token definition\") representing a string ID, used\n * primarily for prefixing application attributes and CSS styles when\n * {@link ViewEncapsulation#Emulated} is being used.\n *\n * The token is needed in cases when multiple applications are bootstrapped on a page\n * (for example, using `bootstrapApplication` calls). In this case, ensure that those applications\n * have different `APP_ID` value setup. For example:\n *\n * ```\n * bootstrapApplication(ComponentA, {\n *   providers: [\n *     { provide: APP_ID, useValue: 'app-a' },\n *     // ... other providers ...\n *   ]\n * });\n *\n * bootstrapApplication(ComponentB, {\n *   providers: [\n *     { provide: APP_ID, useValue: 'app-b' },\n *     // ... other providers ...\n *   ]\n * });\n * ```\n *\n * By default, when there is only one application bootstrapped, you don't need to provide the\n * `APP_ID` token (the `ng` will be used as an app ID).\n *\n * @publicApi\n */\nconst APP_ID = new InjectionToken('AppId', {\n    providedIn: 'root',\n    factory: () => DEFAULT_APP_ID,\n});\n/** Default value of the `APP_ID` token. */\nconst DEFAULT_APP_ID = 'ng';\n/**\n * A function that is executed when a platform is initialized.\n * @publicApi\n */\nconst PLATFORM_INITIALIZER = new InjectionToken('Platform Initializer');\n/**\n * A token that indicates an opaque platform ID.\n * @publicApi\n */\nconst PLATFORM_ID = new InjectionToken('Platform ID', {\n    providedIn: 'platform',\n    factory: () => 'unknown', // set a default platform name, when none set explicitly\n});\n/**\n * A [DI token](guide/glossary#di-token \"DI token definition\") that indicates the root directory of\n * the application\n * @publicApi\n * @deprecated\n */\nconst PACKAGE_ROOT_URL = new InjectionToken('Application Packages Root URL');\n// We keep this token here, rather than the animations package, so that modules that only care\n// about which animations module is loaded (e.g. the CDK) can retrieve it without having to\n// include extra dependencies. See #44970 for more context.\n/**\n * A [DI token](guide/glossary#di-token \"DI token definition\") that indicates which animations\n * module has been loaded.\n * @publicApi\n */\nconst ANIMATION_MODULE_TYPE = new InjectionToken('AnimationModuleType');\n// TODO(crisbeto): link to CSP guide here.\n/**\n * Token used to configure the [Content Security Policy](https://web.dev/strict-csp/) nonce that\n * Angular will apply when inserting inline styles. If not provided, Angular will look up its value\n * from the `ngCspNonce` attribute of the application root node.\n *\n * @publicApi\n */\nconst CSP_NONCE = new InjectionToken('CSP nonce', {\n    providedIn: 'root',\n    factory: () => {\n        // Ideally we wouldn't have to use `querySelector` here since we know that the nonce will be on\n        // the root node, but because the token value is used in renderers, it has to be available\n        // *very* early in the bootstrapping process. This should be a fairly shallow search, because\n        // the app won't have been added to the DOM yet. Some approaches that were considered:\n        // 1. Find the root node through `ApplicationRef.components[i].location` - normally this would\n        // be enough for our purposes, but the token is injected very early so the `components` array\n        // isn't populated yet.\n        // 2. Find the root `LView` through the current `LView` - renderers are a prerequisite to\n        // creating the `LView`. This means that no `LView` will have been entered when this factory is\n        // invoked for the root component.\n        // 3. Have the token factory return `() => string` which is invoked when a nonce is requested -\n        // the slightly later execution does allow us to get an `LView` reference, but the fact that\n        // it is a function means that it could be executed at *any* time (including immediately) which\n        // may lead to weird bugs.\n        // 4. Have the `ComponentFactory` read the attribute and provide it to the injector under the\n        // hood - has the same problem as #1 and #2 in that the renderer is used to query for the root\n        // node and the nonce value needs to be available when the renderer is created.\n        return getDocument().body?.querySelector('[ngCspNonce]')?.getAttribute('ngCspNonce') || null;\n    },\n});\n/**\n * Internal token to collect all SSR-related features enabled for this application.\n *\n * Note: the token is in `core` to let other packages register features (the `core`\n * package is imported in other packages).\n */\nconst ENABLED_SSR_FEATURES = new InjectionToken((typeof ngDevMode === 'undefined' || ngDevMode) ? 'ENABLED_SSR_FEATURES' : '', {\n    providedIn: 'root',\n    factory: () => new Set(),\n});\n\n/**\n * A multi-provider token for initialization functions that will run upon construction of an\n * environment injector.\n *\n * @publicApi\n */\nconst ENVIRONMENT_INITIALIZER = new InjectionToken('ENVIRONMENT_INITIALIZER');\n\n/**\n * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.\n *\n * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a\n * project.\n *\n * @publicApi\n */\nconst INJECTOR = new InjectionToken('INJECTOR', \n// Disable tslint because this is const enum which gets inlined not top level prop access.\n// tslint:disable-next-line: no-toplevel-property-access\n-1 /* InjectorMarkers.Injector */);\n\nconst INJECTOR_DEF_TYPES = new InjectionToken('INJECTOR_DEF_TYPES');\n\nclass NullInjector {\n    get(token, notFoundValue = THROW_IF_NOT_FOUND) {\n        if (notFoundValue === THROW_IF_NOT_FOUND) {\n            const error = new Error(`NullInjectorError: No provider for ${stringify(token)}!`);\n            error.name = 'NullInjectorError';\n            throw error;\n        }\n        return notFoundValue;\n    }\n}\n\n/**\n * Wrap an array of `Provider`s into `EnvironmentProviders`, preventing them from being accidentally\n * referenced in `@Component` in a component injector.\n */\nfunction makeEnvironmentProviders(providers) {\n    return {\n        ɵproviders: providers,\n    };\n}\n/**\n * Collects providers from all NgModules and standalone components, including transitively imported\n * ones.\n *\n * Providers extracted via `importProvidersFrom` are only usable in an application injector or\n * another environment injector (such as a route injector). They should not be used in component\n * providers.\n *\n * More information about standalone components can be found in [this\n * guide](guide/standalone-components).\n *\n * @usageNotes\n * The results of the `importProvidersFrom` call can be used in the `bootstrapApplication` call:\n *\n * ```typescript\n * await bootstrapApplication(RootComponent, {\n *   providers: [\n *     importProvidersFrom(NgModuleOne, NgModuleTwo)\n *   ]\n * });\n * ```\n *\n * You can also use the `importProvidersFrom` results in the `providers` field of a route, when a\n * standalone component is used:\n *\n * ```typescript\n * export const ROUTES: Route[] = [\n *   {\n *     path: 'foo',\n *     providers: [\n *       importProvidersFrom(NgModuleOne, NgModuleTwo)\n *     ],\n *     component: YourStandaloneComponent\n *   }\n * ];\n * ```\n *\n * @returns Collected providers from the specified list of types.\n * @publicApi\n */\nfunction importProvidersFrom(...sources) {\n    return {\n        ɵproviders: internalImportProvidersFrom(true, sources),\n        ɵfromNgModule: true,\n    };\n}\nfunction internalImportProvidersFrom(checkForStandaloneCmp, ...sources) {\n    const providersOut = [];\n    const dedup = new Set(); // already seen types\n    let injectorTypesWithProviders;\n    const collectProviders = (provider) => {\n        providersOut.push(provider);\n    };\n    deepForEach(sources, source => {\n        if ((typeof ngDevMode === 'undefined' || ngDevMode) && checkForStandaloneCmp) {\n            const cmpDef = getComponentDef$1(source);\n            if (cmpDef?.standalone) {\n                throw new RuntimeError(800 /* RuntimeErrorCode.IMPORT_PROVIDERS_FROM_STANDALONE */, `Importing providers supports NgModule or ModuleWithProviders but got a standalone component \"${stringifyForError(source)}\"`);\n            }\n        }\n        // Narrow `source` to access the internal type analogue for `ModuleWithProviders`.\n        const internalSource = source;\n        if (walkProviderTree(internalSource, collectProviders, [], dedup)) {\n            injectorTypesWithProviders ||= [];\n            injectorTypesWithProviders.push(internalSource);\n        }\n    });\n    // Collect all providers from `ModuleWithProviders` types.\n    if (injectorTypesWithProviders !== undefined) {\n        processInjectorTypesWithProviders(injectorTypesWithProviders, collectProviders);\n    }\n    return providersOut;\n}\n/**\n * Collects all providers from the list of `ModuleWithProviders` and appends them to the provided\n * array.\n */\nfunction processInjectorTypesWithProviders(typesWithProviders, visitor) {\n    for (let i = 0; i < typesWithProviders.length; i++) {\n        const { ngModule, providers } = typesWithProviders[i];\n        deepForEachProvider(providers, provider => {\n            ngDevMode && validateProvider(provider, providers || EMPTY_ARRAY, ngModule);\n            visitor(provider, ngModule);\n        });\n    }\n}\n/**\n * The logic visits an `InjectorType`, an `InjectorTypeWithProviders`, or a standalone\n * `ComponentType`, and all of its transitive providers and collects providers.\n *\n * If an `InjectorTypeWithProviders` that declares providers besides the type is specified,\n * the function will return \"true\" to indicate that the providers of the type definition need\n * to be processed. This allows us to process providers of injector types after all imports of\n * an injector definition are processed. (following View Engine semantics: see FW-1349)\n */\nfunction walkProviderTree(container, visitor, parents, dedup) {\n    container = resolveForwardRef(container);\n    if (!container)\n        return false;\n    // The actual type which had the definition. Usually `container`, but may be an unwrapped type\n    // from `InjectorTypeWithProviders`.\n    let defType = null;\n    let injDef = getInjectorDef(container);\n    const cmpDef = !injDef && getComponentDef$1(container);\n    if (!injDef && !cmpDef) {\n        // `container` is not an injector type or a component type. It might be:\n        //  * An `InjectorTypeWithProviders` that wraps an injector type.\n        //  * A standalone directive or pipe that got pulled in from a standalone component's\n        //    dependencies.\n        // Try to unwrap it as an `InjectorTypeWithProviders` first.\n        const ngModule = container.ngModule;\n        injDef = getInjectorDef(ngModule);\n        if (injDef) {\n            defType = ngModule;\n        }\n        else {\n            // Not a component or injector type, so ignore it.\n            return false;\n        }\n    }\n    else if (cmpDef && !cmpDef.standalone) {\n        return false;\n    }\n    else {\n        defType = container;\n    }\n    // Check for circular dependencies.\n    if (ngDevMode && parents.indexOf(defType) !== -1) {\n        const defName = stringify(defType);\n        const path = parents.map(stringify);\n        throwCyclicDependencyError(defName, path);\n    }\n    // Check for multiple imports of the same module\n    const isDuplicate = dedup.has(defType);\n    if (cmpDef) {\n        if (isDuplicate) {\n            // This component definition has already been processed.\n            return false;\n        }\n        dedup.add(defType);\n        if (cmpDef.dependencies) {\n            const deps = typeof cmpDef.dependencies === 'function' ? cmpDef.dependencies() : cmpDef.dependencies;\n            for (const dep of deps) {\n                walkProviderTree(dep, visitor, parents, dedup);\n            }\n        }\n    }\n    else if (injDef) {\n        // First, include providers from any imports.\n        if (injDef.imports != null && !isDuplicate) {\n            // Before processing defType's imports, add it to the set of parents. This way, if it ends\n            // up deeply importing itself, this can be detected.\n            ngDevMode && parents.push(defType);\n            // Add it to the set of dedups. This way we can detect multiple imports of the same module\n            dedup.add(defType);\n            let importTypesWithProviders;\n            try {\n                deepForEach(injDef.imports, imported => {\n                    if (walkProviderTree(imported, visitor, parents, dedup)) {\n                        importTypesWithProviders ||= [];\n                        // If the processed import is an injector type with providers, we store it in the\n                        // list of import types with providers, so that we can process those afterwards.\n                        importTypesWithProviders.push(imported);\n                    }\n                });\n            }\n            finally {\n                // Remove it from the parents set when finished.\n                ngDevMode && parents.pop();\n            }\n            // Imports which are declared with providers (TypeWithProviders) need to be processed\n            // after all imported modules are processed. This is similar to how View Engine\n            // processes/merges module imports in the metadata resolver. See: FW-1349.\n            if (importTypesWithProviders !== undefined) {\n                processInjectorTypesWithProviders(importTypesWithProviders, visitor);\n            }\n        }\n        if (!isDuplicate) {\n            // Track the InjectorType and add a provider for it.\n            // It's important that this is done after the def's imports.\n            const factory = getFactoryDef(defType) || (() => new defType());\n            // Append extra providers to make more info available for consumers (to retrieve an injector\n            // type), as well as internally (to calculate an injection scope correctly and eagerly\n            // instantiate a `defType` when an injector is created).\n            // Provider to create `defType` using its factory.\n            visitor({ provide: defType, useFactory: factory, deps: EMPTY_ARRAY }, defType);\n            // Make this `defType` available to an internal logic that calculates injector scope.\n            visitor({ provide: INJECTOR_DEF_TYPES, useValue: defType, multi: true }, defType);\n            // Provider to eagerly instantiate `defType` via `INJECTOR_INITIALIZER`.\n            visitor({ provide: ENVIRONMENT_INITIALIZER, useValue: () => ɵɵinject(defType), multi: true }, defType);\n        }\n        // Next, include providers listed on the definition itself.\n        const defProviders = injDef.providers;\n        if (defProviders != null && !isDuplicate) {\n            const injectorType = container;\n            deepForEachProvider(defProviders, provider => {\n                ngDevMode && validateProvider(provider, defProviders, injectorType);\n                visitor(provider, injectorType);\n            });\n        }\n    }\n    else {\n        // Should not happen, but just in case.\n        return false;\n    }\n    return (defType !== container &&\n        container.providers !== undefined);\n}\nfunction validateProvider(provider, providers, containerType) {\n    if (isTypeProvider(provider) || isValueProvider(provider) || isFactoryProvider(provider) ||\n        isExistingProvider(provider)) {\n        return;\n    }\n    // Here we expect the provider to be a `useClass` provider (by elimination).\n    const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));\n    if (!classRef) {\n        throwInvalidProviderError(containerType, providers, provider);\n    }\n}\nfunction deepForEachProvider(providers, fn) {\n    for (let provider of providers) {\n        if (isEnvironmentProviders(provider)) {\n            provider = provider.ɵproviders;\n        }\n        if (Array.isArray(provider)) {\n            deepForEachProvider(provider, fn);\n        }\n        else {\n            fn(provider);\n        }\n    }\n}\nconst USE_VALUE$1 = getClosureSafeProperty({ provide: String, useValue: getClosureSafeProperty });\nfunction isValueProvider(value) {\n    return value !== null && typeof value == 'object' && USE_VALUE$1 in value;\n}\nfunction isExistingProvider(value) {\n    return !!(value && value.useExisting);\n}\nfunction isFactoryProvider(value) {\n    return !!(value && value.useFactory);\n}\nfunction isTypeProvider(value) {\n    return typeof value === 'function';\n}\nfunction isClassProvider(value) {\n    return !!value.useClass;\n}\n\n/**\n * An internal token whose presence in an injector indicates that the injector should treat itself\n * as a root scoped injector when processing requests for unknown tokens which may indicate\n * they are provided in the root scope.\n */\nconst INJECTOR_SCOPE = new InjectionToken('Set Injector scope.');\n\n/**\n * Marker which indicates that a value has not yet been created from the factory function.\n */\nconst NOT_YET = {};\n/**\n * Marker which indicates that the factory function for a token is in the process of being called.\n *\n * If the injector is asked to inject a token with its value set to CIRCULAR, that indicates\n * injection of a dependency has recursively attempted to inject the original token, and there is\n * a circular dependency among the providers.\n */\nconst CIRCULAR = {};\n/**\n * A lazily initialized NullInjector.\n */\nlet NULL_INJECTOR = undefined;\nfunction getNullInjector() {\n    if (NULL_INJECTOR === undefined) {\n        NULL_INJECTOR = new NullInjector();\n    }\n    return NULL_INJECTOR;\n}\n/**\n * An `Injector` that's part of the environment injector hierarchy, which exists outside of the\n * component tree.\n */\nclass EnvironmentInjector {\n}\nclass R3Injector extends EnvironmentInjector {\n    /**\n     * Flag indicating that this injector was previously destroyed.\n     */\n    get destroyed() {\n        return this._destroyed;\n    }\n    constructor(providers, parent, source, scopes) {\n        super();\n        this.parent = parent;\n        this.source = source;\n        this.scopes = scopes;\n        /**\n         * Map of tokens to records which contain the instances of those tokens.\n         * - `null` value implies that we don't have the record. Used by tree-shakable injectors\n         * to prevent further searches.\n         */\n        this.records = new Map();\n        /**\n         * Set of values instantiated by this injector which contain `ngOnDestroy` lifecycle hooks.\n         */\n        this._ngOnDestroyHooks = new Set();\n        this._onDestroyHooks = [];\n        this._destroyed = false;\n        // Start off by creating Records for every provider.\n        forEachSingleProvider(providers, provider => this.processProvider(provider));\n        // Make sure the INJECTOR token provides this injector.\n        this.records.set(INJECTOR, makeRecord(undefined, this));\n        // And `EnvironmentInjector` if the current injector is supposed to be env-scoped.\n        if (scopes.has('environment')) {\n            this.records.set(EnvironmentInjector, makeRecord(undefined, this));\n        }\n        // Detect whether this injector has the APP_ROOT_SCOPE token and thus should provide\n        // any injectable scoped to APP_ROOT_SCOPE.\n        const record = this.records.get(INJECTOR_SCOPE);\n        if (record != null && typeof record.value === 'string') {\n            this.scopes.add(record.value);\n        }\n        this.injectorDefTypes =\n            new Set(this.get(INJECTOR_DEF_TYPES.multi, EMPTY_ARRAY, InjectFlags.Self));\n    }\n    /**\n     * Destroy the injector and release references to every instance or provider associated with it.\n     *\n     * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a\n     * hook was found.\n     */\n    destroy() {\n        this.assertNotDestroyed();\n        // Set destroyed = true first, in case lifecycle hooks re-enter destroy().\n        this._destroyed = true;\n        try {\n            // Call all the lifecycle hooks.\n            for (const service of this._ngOnDestroyHooks) {\n                service.ngOnDestroy();\n            }\n            const onDestroyHooks = this._onDestroyHooks;\n            // Reset the _onDestroyHooks array before iterating over it to prevent hooks that unregister\n            // themselves from mutating the array during iteration.\n            this._onDestroyHooks = [];\n            for (const hook of onDestroyHooks) {\n                hook();\n            }\n        }\n        finally {\n            // Release all references.\n            this.records.clear();\n            this._ngOnDestroyHooks.clear();\n            this.injectorDefTypes.clear();\n        }\n    }\n    onDestroy(callback) {\n        this.assertNotDestroyed();\n        this._onDestroyHooks.push(callback);\n        return () => this.removeOnDestroy(callback);\n    }\n    runInContext(fn) {\n        this.assertNotDestroyed();\n        const previousInjector = setCurrentInjector(this);\n        const previousInjectImplementation = setInjectImplementation(undefined);\n        let prevInjectContext;\n        if (ngDevMode) {\n            prevInjectContext = setInjectorProfilerContext({ injector: this, token: null });\n        }\n        try {\n            return fn();\n        }\n        finally {\n            setCurrentInjector(previousInjector);\n            setInjectImplementation(previousInjectImplementation);\n            ngDevMode && setInjectorProfilerContext(prevInjectContext);\n        }\n    }\n    get(token, notFoundValue = THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n        this.assertNotDestroyed();\n        if (token.hasOwnProperty(NG_ENV_ID)) {\n            return token[NG_ENV_ID](this);\n        }\n        flags = convertToBitFlags(flags);\n        // Set the injection context.\n        let prevInjectContext;\n        if (ngDevMode) {\n            prevInjectContext = setInjectorProfilerContext({ injector: this, token: token });\n        }\n        const previousInjector = setCurrentInjector(this);\n        const previousInjectImplementation = setInjectImplementation(undefined);\n        try {\n            // Check for the SkipSelf flag.\n            if (!(flags & InjectFlags.SkipSelf)) {\n                // SkipSelf isn't set, check if the record belongs to this injector.\n                let record = this.records.get(token);\n                if (record === undefined) {\n                    // No record, but maybe the token is scoped to this injector. Look for an injectable\n                    // def with a scope matching this injector.\n                    const def = couldBeInjectableType(token) && getInjectableDef(token);\n                    if (def && this.injectableDefInScope(def)) {\n                        // Found an injectable def and it's scoped to this injector. Pretend as if it was here\n                        // all along.\n                        record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);\n                    }\n                    else {\n                        record = null;\n                    }\n                    this.records.set(token, record);\n                }\n                // If a record was found, get the instance for it and return it.\n                if (record != null /* NOT null || undefined */) {\n                    return this.hydrate(token, record);\n                }\n            }\n            // Select the next injector based on the Self flag - if self is set, the next injector is\n            // the NullInjector, otherwise it's the parent.\n            const nextInjector = !(flags & InjectFlags.Self) ? this.parent : getNullInjector();\n            // Set the notFoundValue based on the Optional flag - if optional is set and notFoundValue\n            // is undefined, the value is null, otherwise it's the notFoundValue.\n            notFoundValue = (flags & InjectFlags.Optional) && notFoundValue === THROW_IF_NOT_FOUND ?\n                null :\n                notFoundValue;\n            return nextInjector.get(token, notFoundValue);\n        }\n        catch (e) {\n            if (e.name === 'NullInjectorError') {\n                const path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];\n                path.unshift(stringify(token));\n                if (previousInjector) {\n                    // We still have a parent injector, keep throwing\n                    throw e;\n                }\n                else {\n                    // Format & throw the final error message when we don't have any previous injector\n                    return catchInjectorError(e, token, 'R3InjectorError', this.source);\n                }\n            }\n            else {\n                throw e;\n            }\n        }\n        finally {\n            // Lastly, restore the previous injection context.\n            setInjectImplementation(previousInjectImplementation);\n            setCurrentInjector(previousInjector);\n            ngDevMode && setInjectorProfilerContext(prevInjectContext);\n        }\n    }\n    /** @internal */\n    resolveInjectorInitializers() {\n        const previousInjector = setCurrentInjector(this);\n        const previousInjectImplementation = setInjectImplementation(undefined);\n        let prevInjectContext;\n        if (ngDevMode) {\n            prevInjectContext = setInjectorProfilerContext({ injector: this, token: null });\n        }\n        try {\n            const initializers = this.get(ENVIRONMENT_INITIALIZER.multi, EMPTY_ARRAY, InjectFlags.Self);\n            if (ngDevMode && !Array.isArray(initializers)) {\n                throw new RuntimeError(-209 /* RuntimeErrorCode.INVALID_MULTI_PROVIDER */, 'Unexpected type of the `ENVIRONMENT_INITIALIZER` token value ' +\n                    `(expected an array, but got ${typeof initializers}). ` +\n                    'Please check that the `ENVIRONMENT_INITIALIZER` token is configured as a ' +\n                    '`multi: true` provider.');\n            }\n            for (const initializer of initializers) {\n                initializer();\n            }\n        }\n        finally {\n            setCurrentInjector(previousInjector);\n            setInjectImplementation(previousInjectImplementation);\n            ngDevMode && setInjectorProfilerContext(prevInjectContext);\n        }\n    }\n    toString() {\n        const tokens = [];\n        const records = this.records;\n        for (const token of records.keys()) {\n            tokens.push(stringify(token));\n        }\n        return `R3Injector[${tokens.join(', ')}]`;\n    }\n    assertNotDestroyed() {\n        if (this._destroyed) {\n            throw new RuntimeError(205 /* RuntimeErrorCode.INJECTOR_ALREADY_DESTROYED */, ngDevMode && 'Injector has already been destroyed.');\n        }\n    }\n    /**\n     * Process a `SingleProvider` and add it.\n     */\n    processProvider(provider) {\n        // Determine the token from the provider. Either it's its own token, or has a {provide: ...}\n        // property.\n        provider = resolveForwardRef(provider);\n        let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider && provider.provide);\n        // Construct a `Record` for the provider.\n        const record = providerToRecord(provider);\n        if (ngDevMode) {\n            runInInjectorProfilerContext(this, token, () => {\n                // Emit InjectorProfilerEventType.Create if provider is a value provider because\n                // these are the only providers that do not go through the value hydration logic\n                // where this event would normally be emitted from.\n                if (isValueProvider(provider)) {\n                    emitInstanceCreatedByInjectorEvent(provider.useValue);\n                }\n                emitProviderConfiguredEvent(provider);\n            });\n        }\n        if (!isTypeProvider(provider) && provider.multi === true) {\n            // If the provider indicates that it's a multi-provider, process it specially.\n            // First check whether it's been defined already.\n            let multiRecord = this.records.get(token);\n            if (multiRecord) {\n                // It has. Throw a nice error if\n                if (ngDevMode && multiRecord.multi === undefined) {\n                    throwMixedMultiProviderError();\n                }\n            }\n            else {\n                multiRecord = makeRecord(undefined, NOT_YET, true);\n                multiRecord.factory = () => injectArgs(multiRecord.multi);\n                this.records.set(token, multiRecord);\n            }\n            token = provider;\n            multiRecord.multi.push(provider);\n        }\n        else {\n            const existing = this.records.get(token);\n            if (ngDevMode && existing && existing.multi !== undefined) {\n                throwMixedMultiProviderError();\n            }\n        }\n        this.records.set(token, record);\n    }\n    hydrate(token, record) {\n        if (ngDevMode && record.value === CIRCULAR) {\n            throwCyclicDependencyError(stringify(token));\n        }\n        else if (record.value === NOT_YET) {\n            record.value = CIRCULAR;\n            if (ngDevMode) {\n                runInInjectorProfilerContext(this, token, () => {\n                    record.value = record.factory();\n                    emitInstanceCreatedByInjectorEvent(record.value);\n                });\n            }\n            else {\n                record.value = record.factory();\n            }\n        }\n        if (typeof record.value === 'object' && record.value && hasOnDestroy(record.value)) {\n            this._ngOnDestroyHooks.add(record.value);\n        }\n        return record.value;\n    }\n    injectableDefInScope(def) {\n        if (!def.providedIn) {\n            return false;\n        }\n        const providedIn = resolveForwardRef(def.providedIn);\n        if (typeof providedIn === 'string') {\n            return providedIn === 'any' || (this.scopes.has(providedIn));\n        }\n        else {\n            return this.injectorDefTypes.has(providedIn);\n        }\n    }\n    removeOnDestroy(callback) {\n        const destroyCBIdx = this._onDestroyHooks.indexOf(callback);\n        if (destroyCBIdx !== -1) {\n            this._onDestroyHooks.splice(destroyCBIdx, 1);\n        }\n    }\n}\nfunction injectableDefOrInjectorDefFactory(token) {\n    // Most tokens will have an injectable def directly on them, which specifies a factory directly.\n    const injectableDef = getInjectableDef(token);\n    const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);\n    if (factory !== null) {\n        return factory;\n    }\n    // InjectionTokens should have an injectable def (ɵprov) and thus should be handled above.\n    // If it's missing that, it's an error.\n    if (token instanceof InjectionToken) {\n        throw new RuntimeError(204 /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */, ngDevMode && `Token ${stringify(token)} is missing a ɵprov definition.`);\n    }\n    // Undecorated types can sometimes be created if they have no constructor arguments.\n    if (token instanceof Function) {\n        return getUndecoratedInjectableFactory(token);\n    }\n    // There was no way to resolve a factory for this token.\n    throw new RuntimeError(204 /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */, ngDevMode && 'unreachable');\n}\nfunction getUndecoratedInjectableFactory(token) {\n    // If the token has parameters then it has dependencies that we cannot resolve implicitly.\n    const paramLength = token.length;\n    if (paramLength > 0) {\n        const args = newArray(paramLength, '?');\n        throw new RuntimeError(204 /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */, ngDevMode && `Can't resolve all parameters for ${stringify(token)}: (${args.join(', ')}).`);\n    }\n    // The constructor function appears to have no parameters.\n    // This might be because it inherits from a super-class. In which case, use an injectable\n    // def from an ancestor if there is one.\n    // Otherwise this really is a simple class with no dependencies, so return a factory that\n    // just instantiates the zero-arg constructor.\n    const inheritedInjectableDef = getInheritedInjectableDef(token);\n    if (inheritedInjectableDef !== null) {\n        return () => inheritedInjectableDef.factory(token);\n    }\n    else {\n        return () => new token();\n    }\n}\nfunction providerToRecord(provider) {\n    if (isValueProvider(provider)) {\n        return makeRecord(undefined, provider.useValue);\n    }\n    else {\n        const factory = providerToFactory(provider);\n        return makeRecord(factory, NOT_YET);\n    }\n}\n/**\n * Converts a `SingleProvider` into a factory function.\n *\n * @param provider provider to convert to factory\n */\nfunction providerToFactory(provider, ngModuleType, providers) {\n    let factory = undefined;\n    if (ngDevMode && isEnvironmentProviders(provider)) {\n        throwInvalidProviderError(undefined, providers, provider);\n    }\n    if (isTypeProvider(provider)) {\n        const unwrappedProvider = resolveForwardRef(provider);\n        return getFactoryDef(unwrappedProvider) || injectableDefOrInjectorDefFactory(unwrappedProvider);\n    }\n    else {\n        if (isValueProvider(provider)) {\n            factory = () => resolveForwardRef(provider.useValue);\n        }\n        else if (isFactoryProvider(provider)) {\n            factory = () => provider.useFactory(...injectArgs(provider.deps || []));\n        }\n        else if (isExistingProvider(provider)) {\n            factory = () => ɵɵinject(resolveForwardRef(provider.useExisting));\n        }\n        else {\n            const classRef = resolveForwardRef(provider &&\n                (provider.useClass || provider.provide));\n            if (ngDevMode && !classRef) {\n                throwInvalidProviderError(ngModuleType, providers, provider);\n            }\n            if (hasDeps(provider)) {\n                factory = () => new (classRef)(...injectArgs(provider.deps));\n            }\n            else {\n                return getFactoryDef(classRef) || injectableDefOrInjectorDefFactory(classRef);\n            }\n        }\n    }\n    return factory;\n}\nfunction makeRecord(factory, value, multi = false) {\n    return {\n        factory: factory,\n        value: value,\n        multi: multi ? [] : undefined,\n    };\n}\nfunction hasDeps(value) {\n    return !!value.deps;\n}\nfunction hasOnDestroy(value) {\n    return value !== null && typeof value === 'object' &&\n        typeof value.ngOnDestroy === 'function';\n}\nfunction couldBeInjectableType(value) {\n    return (typeof value === 'function') ||\n        (typeof value === 'object' && value instanceof InjectionToken);\n}\nfunction forEachSingleProvider(providers, fn) {\n    for (const provider of providers) {\n        if (Array.isArray(provider)) {\n            forEachSingleProvider(provider, fn);\n        }\n        else if (provider && isEnvironmentProviders(provider)) {\n            forEachSingleProvider(provider.ɵproviders, fn);\n        }\n        else {\n            fn(provider);\n        }\n    }\n}\n\n/**\n * Runs the given function in the [context](guide/dependency-injection-context) of the given\n * `Injector`.\n *\n * Within the function's stack frame, [`inject`](api/core/inject) can be used to inject dependencies\n * from the given `Injector`. Note that `inject` is only usable synchronously, and cannot be used in\n * any asynchronous callbacks or after any `await` points.\n *\n * @param injector the injector which will satisfy calls to [`inject`](api/core/inject) while `fn`\n *     is executing\n * @param fn the closure to be run in the context of `injector`\n * @returns the return value of the function, if any\n * @publicApi\n */\nfunction runInInjectionContext(injector, fn) {\n    if (injector instanceof R3Injector) {\n        injector.assertNotDestroyed();\n    }\n    let prevInjectorProfilerContext;\n    if (ngDevMode) {\n        prevInjectorProfilerContext = setInjectorProfilerContext({ injector, token: null });\n    }\n    const prevInjector = setCurrentInjector(injector);\n    const previousInjectImplementation = setInjectImplementation(undefined);\n    try {\n        return fn();\n    }\n    finally {\n        setCurrentInjector(prevInjector);\n        ngDevMode && setInjectorProfilerContext(prevInjectorProfilerContext);\n        setInjectImplementation(previousInjectImplementation);\n    }\n}\n/**\n * Asserts that the current stack frame is within an [injection\n * context](guide/dependency-injection-context) and has access to `inject`.\n *\n * @param debugFn a reference to the function making the assertion (used for the error message).\n *\n * @publicApi\n */\nfunction assertInInjectionContext(debugFn) {\n    // Taking a `Function` instead of a string name here prevents the unminified name of the function\n    // from being retained in the bundle regardless of minification.\n    if (!getInjectImplementation() && !getCurrentInjector()) {\n        throw new RuntimeError(-203 /* RuntimeErrorCode.MISSING_INJECTION_CONTEXT */, ngDevMode &&\n            (debugFn.name +\n                '() can only be used within an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext`'));\n    }\n}\n\n/**\n * A mapping of the @angular/core API surface used in generated expressions to the actual symbols.\n *\n * This should be kept up to date with the public exports of @angular/core.\n */\nconst angularCoreDiEnv = {\n    'ɵɵdefineInjectable': ɵɵdefineInjectable,\n    'ɵɵdefineInjector': ɵɵdefineInjector,\n    'ɵɵinject': ɵɵinject,\n    'ɵɵinvalidFactoryDep': ɵɵinvalidFactoryDep,\n    'resolveForwardRef': resolveForwardRef,\n};\n\n/**\n * Compile an Angular injectable according to its `Injectable` metadata, and patch the resulting\n * injectable def (`ɵprov`) onto the injectable type.\n */\nfunction compileInjectable(type, meta) {\n    let ngInjectableDef = null;\n    let ngFactoryDef = null;\n    // if NG_PROV_DEF is already defined on this class then don't overwrite it\n    if (!type.hasOwnProperty(NG_PROV_DEF)) {\n        Object.defineProperty(type, NG_PROV_DEF, {\n            get: () => {\n                if (ngInjectableDef === null) {\n                    const compiler = getCompilerFacade({ usage: 0 /* JitCompilerUsage.Decorator */, kind: 'injectable', type });\n                    ngInjectableDef = compiler.compileInjectable(angularCoreDiEnv, `ng:///${type.name}/ɵprov.js`, getInjectableMetadata(type, meta));\n                }\n                return ngInjectableDef;\n            },\n        });\n    }\n    // if NG_FACTORY_DEF is already defined on this class then don't overwrite it\n    if (!type.hasOwnProperty(NG_FACTORY_DEF)) {\n        Object.defineProperty(type, NG_FACTORY_DEF, {\n            get: () => {\n                if (ngFactoryDef === null) {\n                    const compiler = getCompilerFacade({ usage: 0 /* JitCompilerUsage.Decorator */, kind: 'injectable', type });\n                    ngFactoryDef = compiler.compileFactory(angularCoreDiEnv, `ng:///${type.name}/ɵfac.js`, {\n                        name: type.name,\n                        type,\n                        typeArgumentCount: 0,\n                        deps: reflectDependencies(type),\n                        target: compiler.FactoryTarget.Injectable\n                    });\n                }\n                return ngFactoryDef;\n            },\n            // Leave this configurable so that the factories from directives or pipes can take precedence.\n            configurable: true\n        });\n    }\n}\nconst USE_VALUE = getClosureSafeProperty({ provide: String, useValue: getClosureSafeProperty });\nfunction isUseClassProvider(meta) {\n    return meta.useClass !== undefined;\n}\nfunction isUseValueProvider(meta) {\n    return USE_VALUE in meta;\n}\nfunction isUseFactoryProvider(meta) {\n    return meta.useFactory !== undefined;\n}\nfunction isUseExistingProvider(meta) {\n    return meta.useExisting !== undefined;\n}\nfunction getInjectableMetadata(type, srcMeta) {\n    // Allow the compilation of a class with a `@Injectable()` decorator without parameters\n    const meta = srcMeta || { providedIn: null };\n    const compilerMeta = {\n        name: type.name,\n        type: type,\n        typeArgumentCount: 0,\n        providedIn: meta.providedIn,\n    };\n    if ((isUseClassProvider(meta) || isUseFactoryProvider(meta)) && meta.deps !== undefined) {\n        compilerMeta.deps = convertDependencies(meta.deps);\n    }\n    // Check to see if the user explicitly provided a `useXxxx` property.\n    if (isUseClassProvider(meta)) {\n        compilerMeta.useClass = meta.useClass;\n    }\n    else if (isUseValueProvider(meta)) {\n        compilerMeta.useValue = meta.useValue;\n    }\n    else if (isUseFactoryProvider(meta)) {\n        compilerMeta.useFactory = meta.useFactory;\n    }\n    else if (isUseExistingProvider(meta)) {\n        compilerMeta.useExisting = meta.useExisting;\n    }\n    return compilerMeta;\n}\n\n/**\n * Injectable decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Injectable = makeDecorator('Injectable', undefined, undefined, undefined, (type, meta) => compileInjectable(type, meta));\n\n/**\n * Create a new `Injector` which is configured using a `defType` of `InjectorType<any>`s.\n */\nfunction createInjector(defType, parent = null, additionalProviders = null, name) {\n    const injector = createInjectorWithoutInjectorInstances(defType, parent, additionalProviders, name);\n    injector.resolveInjectorInitializers();\n    return injector;\n}\n/**\n * Creates a new injector without eagerly resolving its injector types. Can be used in places\n * where resolving the injector types immediately can lead to an infinite loop. The injector types\n * should be resolved at a later point by calling `_resolveInjectorDefTypes`.\n */\nfunction createInjectorWithoutInjectorInstances(defType, parent = null, additionalProviders = null, name, scopes = new Set()) {\n    const providers = [\n        additionalProviders || EMPTY_ARRAY,\n        importProvidersFrom(defType),\n    ];\n    name = name || (typeof defType === 'object' ? undefined : stringify(defType));\n    return new R3Injector(providers, parent || getNullInjector(), name || null, scopes);\n}\n\n/**\n * Concrete injectors implement this interface. Injectors are configured\n * with [providers](guide/glossary#provider) that associate\n * dependencies of various types with [injection tokens](guide/glossary#di-token).\n *\n * @see [\"DI Providers\"](guide/dependency-injection-providers).\n * @see {@link StaticProvider}\n *\n * @usageNotes\n *\n *  The following example creates a service injector instance.\n *\n * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}\n *\n * ### Usage example\n *\n * {@example core/di/ts/injector_spec.ts region='Injector'}\n *\n * `Injector` returns itself when given `Injector` as a token:\n *\n * {@example core/di/ts/injector_spec.ts region='injectInjector'}\n *\n * @publicApi\n */\nclass Injector {\n    static { this.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND; }\n    static { this.NULL = ( /* @__PURE__ */new NullInjector()); }\n    static create(options, parent) {\n        if (Array.isArray(options)) {\n            return createInjector({ name: '' }, parent, options, '');\n        }\n        else {\n            const name = options.name ?? '';\n            return createInjector({ name }, options.parent, options.providers, name);\n        }\n    }\n    /** @nocollapse */\n    static { this.ɵprov = ɵɵdefineInjectable({\n        token: Injector,\n        providedIn: 'any',\n        factory: () => ɵɵinject(INJECTOR),\n    }); }\n    /**\n     * @internal\n     * @nocollapse\n     */\n    static { this.__NG_ELEMENT_ID__ = -1 /* InjectorMarkers.Injector */; }\n}\n\n/**\n * @module\n * @description\n * The `di` module provides dependency injection container services.\n */\n\n/**\n * This file should not be necessary because node resolution should just default to `./di/index`!\n *\n * However it does not seem to work and it breaks:\n *  - //packages/animations/browser/test:test_web_chromium-local\n *  - //packages/compiler-cli/test:extract_i18n\n *  - //packages/compiler-cli/test:ngc\n *  - //packages/compiler-cli/test:perform_watch\n *  - //packages/compiler-cli/test/diagnostics:check_types\n *  - //packages/compiler-cli/test/transformers:test\n *  - //packages/compiler/test:test\n *  - //tools/public_api_guard:core_api\n *\n * Remove this file once the above is solved or wait until `ngc` is deleted and then it should be\n * safe to delete this file.\n */\n\n/**\n *\n * @codeGenApi\n */\nfunction ɵɵresolveWindow(element) {\n    return element.ownerDocument.defaultView;\n}\n/**\n *\n * @codeGenApi\n */\nfunction ɵɵresolveDocument(element) {\n    return element.ownerDocument;\n}\n/**\n *\n * @codeGenApi\n */\nfunction ɵɵresolveBody(element) {\n    return element.ownerDocument.body;\n}\n/**\n * The special delimiter we use to separate property names, prefixes, and suffixes\n * in property binding metadata. See storeBindingMetadata().\n *\n * We intentionally use the Unicode \"REPLACEMENT CHARACTER\" (U+FFFD) as a delimiter\n * because it is a very uncommon character that is unlikely to be part of a user's\n * property names or interpolation strings. If it is in fact used in a property\n * binding, DebugElement.properties will not return the correct value for that\n * binding. However, there should be no runtime effect for real applications.\n *\n * This character is typically rendered as a question mark inside of a diamond.\n * See https://en.wikipedia.org/wiki/Specials_(Unicode_block)\n *\n */\nconst INTERPOLATION_DELIMITER = `�`;\n/**\n * Unwrap a value which might be behind a closure (for forward declaration reasons).\n */\nfunction maybeUnwrapFn$1(value) {\n    if (value instanceof Function) {\n        return value();\n    }\n    else {\n        return value;\n    }\n}\n/**\n * Detects whether the code is invoked in a browser.\n * Later on, this check should be replaced with a tree-shakable\n * flag (e.g. `!isServer`).\n */\nfunction isPlatformBrowser(injector) {\n    return (injector ?? inject$1(Injector)).get(PLATFORM_ID) === 'browser';\n}\n\n/**\n * Defines a schema that allows an NgModule to contain the following:\n * - Non-Angular elements named with dash case (`-`).\n * - Element properties named with dash case (`-`).\n * Dash case is the naming convention for custom elements.\n *\n * @publicApi\n */\nconst CUSTOM_ELEMENTS_SCHEMA = {\n    name: 'custom-elements'\n};\n/**\n * Defines a schema that allows any property on any element.\n *\n * This schema allows you to ignore the errors related to any unknown elements or properties in a\n * template. The usage of this schema is generally discouraged because it prevents useful validation\n * and may hide real errors in your template. Consider using the `CUSTOM_ELEMENTS_SCHEMA` instead.\n *\n * @publicApi\n */\nconst NO_ERRORS_SCHEMA = {\n    name: 'no-errors-schema'\n};\n\nlet shouldThrowErrorOnUnknownElement = false;\n/**\n * Sets a strict mode for JIT-compiled components to throw an error on unknown elements,\n * instead of just logging the error.\n * (for AOT-compiled ones this check happens at build time).\n */\nfunction ɵsetUnknownElementStrictMode(shouldThrow) {\n    shouldThrowErrorOnUnknownElement = shouldThrow;\n}\n/**\n * Gets the current value of the strict mode.\n */\nfunction ɵgetUnknownElementStrictMode() {\n    return shouldThrowErrorOnUnknownElement;\n}\nlet shouldThrowErrorOnUnknownProperty = false;\n/**\n * Sets a strict mode for JIT-compiled components to throw an error on unknown properties,\n * instead of just logging the error.\n * (for AOT-compiled ones this check happens at build time).\n */\nfunction ɵsetUnknownPropertyStrictMode(shouldThrow) {\n    shouldThrowErrorOnUnknownProperty = shouldThrow;\n}\n/**\n * Gets the current value of the strict mode.\n */\nfunction ɵgetUnknownPropertyStrictMode() {\n    return shouldThrowErrorOnUnknownProperty;\n}\n/**\n * Validates that the element is known at runtime and produces\n * an error if it's not the case.\n * This check is relevant for JIT-compiled components (for AOT-compiled\n * ones this check happens at build time).\n *\n * The element is considered known if either:\n * - it's a known HTML element\n * - it's a known custom element\n * - the element matches any directive\n * - the element is allowed by one of the schemas\n *\n * @param element Element to validate\n * @param lView An `LView` that represents a current component that is being rendered\n * @param tagName Name of the tag to check\n * @param schemas Array of schemas\n * @param hasDirectives Boolean indicating that the element matches any directive\n */\nfunction validateElementIsKnown(element, lView, tagName, schemas, hasDirectives) {\n    // If `schemas` is set to `null`, that's an indication that this Component was compiled in AOT\n    // mode where this check happens at compile time. In JIT mode, `schemas` is always present and\n    // defined as an array (as an empty array in case `schemas` field is not defined) and we should\n    // execute the check below.\n    if (schemas === null)\n        return;\n    // If the element matches any directive, it's considered as valid.\n    if (!hasDirectives && tagName !== null) {\n        // The element is unknown if it's an instance of HTMLUnknownElement, or it isn't registered\n        // as a custom element. Note that unknown elements with a dash in their name won't be instances\n        // of HTMLUnknownElement in browsers that support web components.\n        const isUnknown = \n        // Note that we can't check for `typeof HTMLUnknownElement === 'function'` because\n        // Domino doesn't expose HTMLUnknownElement globally.\n        (typeof HTMLUnknownElement !== 'undefined' && HTMLUnknownElement &&\n            element instanceof HTMLUnknownElement) ||\n            (typeof customElements !== 'undefined' && tagName.indexOf('-') > -1 &&\n                !customElements.get(tagName));\n        if (isUnknown && !matchingSchemas(schemas, tagName)) {\n            const isHostStandalone = isHostComponentStandalone(lView);\n            const templateLocation = getTemplateLocationDetails(lView);\n            const schemas = `'${isHostStandalone ? '@Component' : '@NgModule'}.schemas'`;\n            let message = `'${tagName}' is not a known element${templateLocation}:\\n`;\n            message += `1. If '${tagName}' is an Angular component, then verify that it is ${isHostStandalone ? 'included in the \\'@Component.imports\\' of this component' :\n                'a part of an @NgModule where this component is declared'}.\\n`;\n            if (tagName && tagName.indexOf('-') > -1) {\n                message +=\n                    `2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas} of this component to suppress this message.`;\n            }\n            else {\n                message +=\n                    `2. To allow any element add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;\n            }\n            if (shouldThrowErrorOnUnknownElement) {\n                throw new RuntimeError(304 /* RuntimeErrorCode.UNKNOWN_ELEMENT */, message);\n            }\n            else {\n                console.error(formatRuntimeError(304 /* RuntimeErrorCode.UNKNOWN_ELEMENT */, message));\n            }\n        }\n    }\n}\n/**\n * Validates that the property of the element is known at runtime and returns\n * false if it's not the case.\n * This check is relevant for JIT-compiled components (for AOT-compiled\n * ones this check happens at build time).\n *\n * The property is considered known if either:\n * - it's a known property of the element\n * - the element is allowed by one of the schemas\n * - the property is used for animations\n *\n * @param element Element to validate\n * @param propName Name of the property to check\n * @param tagName Name of the tag hosting the property\n * @param schemas Array of schemas\n */\nfunction isPropertyValid(element, propName, tagName, schemas) {\n    // If `schemas` is set to `null`, that's an indication that this Component was compiled in AOT\n    // mode where this check happens at compile time. In JIT mode, `schemas` is always present and\n    // defined as an array (as an empty array in case `schemas` field is not defined) and we should\n    // execute the check below.\n    if (schemas === null)\n        return true;\n    // The property is considered valid if the element matches the schema, it exists on the element,\n    // or it is synthetic.\n    if (matchingSchemas(schemas, tagName) || propName in element || isAnimationProp(propName)) {\n        return true;\n    }\n    // Note: `typeof Node` returns 'function' in most browsers, but is undefined with domino.\n    return typeof Node === 'undefined' || Node === null || !(element instanceof Node);\n}\n/**\n * Logs or throws an error that a property is not supported on an element.\n *\n * @param propName Name of the invalid property\n * @param tagName Name of the tag hosting the property\n * @param nodeType Type of the node hosting the property\n * @param lView An `LView` that represents a current component\n */\nfunction handleUnknownPropertyError(propName, tagName, nodeType, lView) {\n    // Special-case a situation when a structural directive is applied to\n    // an `<ng-template>` element, for example: `<ng-template *ngIf=\"true\">`.\n    // In this case the compiler generates the `ɵɵtemplate` instruction with\n    // the `null` as the tagName. The directive matching logic at runtime relies\n    // on this effect (see `isInlineTemplate`), thus using the 'ng-template' as\n    // a default value of the `tNode.value` is not feasible at this moment.\n    if (!tagName && nodeType === 4 /* TNodeType.Container */) {\n        tagName = 'ng-template';\n    }\n    const isHostStandalone = isHostComponentStandalone(lView);\n    const templateLocation = getTemplateLocationDetails(lView);\n    let message = `Can't bind to '${propName}' since it isn't a known property of '${tagName}'${templateLocation}.`;\n    const schemas = `'${isHostStandalone ? '@Component' : '@NgModule'}.schemas'`;\n    const importLocation = isHostStandalone ?\n        'included in the \\'@Component.imports\\' of this component' :\n        'a part of an @NgModule where this component is declared';\n    if (KNOWN_CONTROL_FLOW_DIRECTIVES.has(propName)) {\n        // Most likely this is a control flow directive (such as `*ngIf`) used in\n        // a template, but the directive or the `CommonModule` is not imported.\n        const correspondingImport = KNOWN_CONTROL_FLOW_DIRECTIVES.get(propName);\n        message += `\\nIf the '${propName}' is an Angular control flow directive, ` +\n            `please make sure that either the '${correspondingImport}' directive or the 'CommonModule' is ${importLocation}.`;\n    }\n    else {\n        // May be an Angular component, which is not imported/declared?\n        message += `\\n1. If '${tagName}' is an Angular component and it has the ` +\n            `'${propName}' input, then verify that it is ${importLocation}.`;\n        // May be a Web Component?\n        if (tagName && tagName.indexOf('-') > -1) {\n            message += `\\n2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' ` +\n                `to the ${schemas} of this component to suppress this message.`;\n            message += `\\n3. To allow any property add 'NO_ERRORS_SCHEMA' to ` +\n                `the ${schemas} of this component.`;\n        }\n        else {\n            // If it's expected, the error can be suppressed by the `NO_ERRORS_SCHEMA` schema.\n            message += `\\n2. To allow any property add 'NO_ERRORS_SCHEMA' to ` +\n                `the ${schemas} of this component.`;\n        }\n    }\n    reportUnknownPropertyError(message);\n}\nfunction reportUnknownPropertyError(message) {\n    if (shouldThrowErrorOnUnknownProperty) {\n        throw new RuntimeError(303 /* RuntimeErrorCode.UNKNOWN_BINDING */, message);\n    }\n    else {\n        console.error(formatRuntimeError(303 /* RuntimeErrorCode.UNKNOWN_BINDING */, message));\n    }\n}\n/**\n * WARNING: this is a **dev-mode only** function (thus should always be guarded by the `ngDevMode`)\n * and must **not** be used in production bundles. The function makes megamorphic reads, which might\n * be too slow for production mode and also it relies on the constructor function being available.\n *\n * Gets a reference to the host component def (where a current component is declared).\n *\n * @param lView An `LView` that represents a current component that is being rendered.\n */\nfunction getDeclarationComponentDef(lView) {\n    !ngDevMode && throwError('Must never be called in production mode');\n    const declarationLView = lView[DECLARATION_COMPONENT_VIEW];\n    const context = declarationLView[CONTEXT];\n    // Unable to obtain a context.\n    if (!context)\n        return null;\n    return context.constructor ? getComponentDef$1(context.constructor) : null;\n}\n/**\n * WARNING: this is a **dev-mode only** function (thus should always be guarded by the `ngDevMode`)\n * and must **not** be used in production bundles. The function makes megamorphic reads, which might\n * be too slow for production mode.\n *\n * Checks if the current component is declared inside of a standalone component template.\n *\n * @param lView An `LView` that represents a current component that is being rendered.\n */\nfunction isHostComponentStandalone(lView) {\n    !ngDevMode && throwError('Must never be called in production mode');\n    const componentDef = getDeclarationComponentDef(lView);\n    // Treat host component as non-standalone if we can't obtain the def.\n    return !!componentDef?.standalone;\n}\n/**\n * WARNING: this is a **dev-mode only** function (thus should always be guarded by the `ngDevMode`)\n * and must **not** be used in production bundles. The function makes megamorphic reads, which might\n * be too slow for production mode.\n *\n * Constructs a string describing the location of the host component template. The function is used\n * in dev mode to produce error messages.\n *\n * @param lView An `LView` that represents a current component that is being rendered.\n */\nfunction getTemplateLocationDetails(lView) {\n    !ngDevMode && throwError('Must never be called in production mode');\n    const hostComponentDef = getDeclarationComponentDef(lView);\n    const componentClassName = hostComponentDef?.type?.name;\n    return componentClassName ? ` (used in the '${componentClassName}' component template)` : '';\n}\n/**\n * The set of known control flow directives and their corresponding imports.\n * We use this set to produce a more precises error message with a note\n * that the `CommonModule` should also be included.\n */\nconst KNOWN_CONTROL_FLOW_DIRECTIVES = new Map([\n    ['ngIf', 'NgIf'], ['ngFor', 'NgFor'], ['ngSwitchCase', 'NgSwitchCase'],\n    ['ngSwitchDefault', 'NgSwitchDefault']\n]);\n/**\n * Returns true if the tag name is allowed by specified schemas.\n * @param schemas Array of schemas\n * @param tagName Name of the tag\n */\nfunction matchingSchemas(schemas, tagName) {\n    if (schemas !== null) {\n        for (let i = 0; i < schemas.length; i++) {\n            const schema = schemas[i];\n            if (schema === NO_ERRORS_SCHEMA ||\n                schema === CUSTOM_ELEMENTS_SCHEMA && tagName && tagName.indexOf('-') > -1) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * The name of an attribute that can be added to the hydration boundary node\n * (component host node) to disable hydration for the content within that boundary.\n */\nconst SKIP_HYDRATION_ATTR_NAME = 'ngSkipHydration';\n/**\n * Helper function to check if a given TNode has the 'ngSkipHydration' attribute.\n */\nfunction hasSkipHydrationAttrOnTNode(tNode) {\n    const SKIP_HYDRATION_ATTR_NAME_LOWER_CASE = SKIP_HYDRATION_ATTR_NAME.toLowerCase();\n    const attrs = tNode.mergedAttrs;\n    if (attrs === null)\n        return false;\n    // only ever look at the attribute name and skip the values\n    for (let i = 0; i < attrs.length; i += 2) {\n        const value = attrs[i];\n        // This is a marker, which means that the static attributes section is over,\n        // so we can exit early.\n        if (typeof value === 'number')\n            return false;\n        if (typeof value === 'string' && value.toLowerCase() === SKIP_HYDRATION_ATTR_NAME_LOWER_CASE) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Helper function to check if a given RElement has the 'ngSkipHydration' attribute.\n */\nfunction hasSkipHydrationAttrOnRElement(rNode) {\n    return rNode.hasAttribute(SKIP_HYDRATION_ATTR_NAME);\n}\n/**\n * Checks whether a TNode has a flag to indicate that it's a part of\n * a skip hydration block.\n */\nfunction hasInSkipHydrationBlockFlag(tNode) {\n    return (tNode.flags & 128 /* TNodeFlags.inSkipHydrationBlock */) === 128 /* TNodeFlags.inSkipHydrationBlock */;\n}\n/**\n * Helper function that determines if a given node is within a skip hydration block\n * by navigating up the TNode tree to see if any parent nodes have skip hydration\n * attribute.\n *\n * TODO(akushnir): this function should contain the logic of `hasInSkipHydrationBlockFlag`,\n * there is no need to traverse parent nodes when we have a TNode flag (which would also\n * make this lookup O(1)).\n */\nfunction isInSkipHydrationBlock(tNode) {\n    let currentTNode = tNode.parent;\n    while (currentTNode) {\n        if (hasSkipHydrationAttrOnTNode(currentTNode)) {\n            return true;\n        }\n        currentTNode = currentTNode.parent;\n    }\n    return false;\n}\n\n/**\n * Flags for renderer-specific style modifiers.\n * @publicApi\n */\nvar RendererStyleFlags2;\n(function (RendererStyleFlags2) {\n    // TODO(misko): This needs to be refactored into a separate file so that it can be imported from\n    // `node_manipulation.ts` Currently doing the import cause resolution order to change and fails\n    // the tests. The work around is to have hard coded value in `node_manipulation.ts` for now.\n    /**\n     * Marks a style as important.\n     */\n    RendererStyleFlags2[RendererStyleFlags2[\"Important\"] = 1] = \"Important\";\n    /**\n     * Marks a style as using dash case naming (this-is-dash-case).\n     */\n    RendererStyleFlags2[RendererStyleFlags2[\"DashCase\"] = 2] = \"DashCase\";\n})(RendererStyleFlags2 || (RendererStyleFlags2 = {}));\n\n/**\n * Disallowed strings in the comment.\n *\n * see: https://html.spec.whatwg.org/multipage/syntax.html#comments\n */\nconst COMMENT_DISALLOWED = /^>|^->|<!--|-->|--!>|<!-$/g;\n/**\n * Delimiter in the disallowed strings which needs to be wrapped with zero with character.\n */\nconst COMMENT_DELIMITER = /(<|>)/g;\nconst COMMENT_DELIMITER_ESCAPED = '\\u200B$1\\u200B';\n/**\n * Escape the content of comment strings so that it can be safely inserted into a comment node.\n *\n * The issue is that HTML does not specify any way to escape comment end text inside the comment.\n * Consider: `<!-- The way you close a comment is with \">\", and \"->\" at the beginning or by \"-->\" or\n * \"--!>\" at the end. -->`. Above the `\"-->\"` is meant to be text not an end to the comment. This\n * can be created programmatically through DOM APIs. (`<!--` are also disallowed.)\n *\n * see: https://html.spec.whatwg.org/multipage/syntax.html#comments\n *\n * ```\n * div.innerHTML = div.innerHTML\n * ```\n *\n * One would expect that the above code would be safe to do, but it turns out that because comment\n * text is not escaped, the comment may contain text which will prematurely close the comment\n * opening up the application for XSS attack. (In SSR we programmatically create comment nodes which\n * may contain such text and expect them to be safe.)\n *\n * This function escapes the comment text by looking for comment delimiters (`<` and `>`) and\n * surrounding them with `_>_` where the `_` is a zero width space `\\u200B`. The result is that if a\n * comment contains any of the comment start/end delimiters (such as `<!--`, `-->` or `--!>`) the\n * text it will render normally but it will not cause the HTML parser to close/open the comment.\n *\n * @param value text to make safe for comment node by escaping the comment open/close character\n *     sequence.\n */\nfunction escapeCommentText(value) {\n    return value.replace(COMMENT_DISALLOWED, (text) => text.replace(COMMENT_DELIMITER, COMMENT_DELIMITER_ESCAPED));\n}\n\n// Keeps track of the currently-active LViews.\nconst TRACKED_LVIEWS = new Map();\n// Used for generating unique IDs for LViews.\nlet uniqueIdCounter = 0;\n/** Gets a unique ID that can be assigned to an LView. */\nfunction getUniqueLViewId() {\n    return uniqueIdCounter++;\n}\n/** Starts tracking an LView. */\nfunction registerLView(lView) {\n    ngDevMode && assertNumber(lView[ID], 'LView must have an ID in order to be registered');\n    TRACKED_LVIEWS.set(lView[ID], lView);\n}\n/** Gets an LView by its unique ID. */\nfunction getLViewById(id) {\n    ngDevMode && assertNumber(id, 'ID used for LView lookup must be a number');\n    return TRACKED_LVIEWS.get(id) || null;\n}\n/** Stops tracking an LView. */\nfunction unregisterLView(lView) {\n    ngDevMode && assertNumber(lView[ID], 'Cannot stop tracking an LView that does not have an ID');\n    TRACKED_LVIEWS.delete(lView[ID]);\n}\n\n/**\n * The internal view context which is specific to a given DOM element, directive or\n * component instance. Each value in here (besides the LView and element node details)\n * can be present, null or undefined. If undefined then it implies the value has not been\n * looked up yet, otherwise, if null, then a lookup was executed and nothing was found.\n *\n * Each value will get filled when the respective value is examined within the getContext\n * function. The component, element and each directive instance will share the same instance\n * of the context.\n */\nclass LContext {\n    /** Component's parent view data. */\n    get lView() {\n        return getLViewById(this.lViewId);\n    }\n    constructor(\n    /**\n     * ID of the component's parent view data.\n     */\n    lViewId, \n    /**\n     * The index instance of the node.\n     */\n    nodeIndex, \n    /**\n     * The instance of the DOM node that is attached to the lNode.\n     */\n    native) {\n        this.lViewId = lViewId;\n        this.nodeIndex = nodeIndex;\n        this.native = native;\n    }\n}\n\n/**\n * Returns the matching `LContext` data for a given DOM node, directive or component instance.\n *\n * This function will examine the provided DOM element, component, or directive instance\\'s\n * monkey-patched property to derive the `LContext` data. Once called then the monkey-patched\n * value will be that of the newly created `LContext`.\n *\n * If the monkey-patched value is the `LView` instance then the context value for that\n * target will be created and the monkey-patch reference will be updated. Therefore when this\n * function is called it may mutate the provided element\\'s, component\\'s or any of the associated\n * directive\\'s monkey-patch values.\n *\n * If the monkey-patch value is not detected then the code will walk up the DOM until an element\n * is found which contains a monkey-patch reference. When that occurs then the provided element\n * will be updated with a new context (which is then returned). If the monkey-patch value is not\n * detected for a component/directive instance then it will throw an error (all components and\n * directives should be automatically monkey-patched by ivy).\n *\n * @param target Component, Directive or DOM Node.\n */\nfunction getLContext(target) {\n    let mpValue = readPatchedData(target);\n    if (mpValue) {\n        // only when it's an array is it considered an LView instance\n        // ... otherwise it's an already constructed LContext instance\n        if (isLView(mpValue)) {\n            const lView = mpValue;\n            let nodeIndex;\n            let component = undefined;\n            let directives = undefined;\n            if (isComponentInstance(target)) {\n                nodeIndex = findViaComponent(lView, target);\n                if (nodeIndex == -1) {\n                    throw new Error('The provided component was not found in the application');\n                }\n                component = target;\n            }\n            else if (isDirectiveInstance(target)) {\n                nodeIndex = findViaDirective(lView, target);\n                if (nodeIndex == -1) {\n                    throw new Error('The provided directive was not found in the application');\n                }\n                directives = getDirectivesAtNodeIndex(nodeIndex, lView);\n            }\n            else {\n                nodeIndex = findViaNativeElement(lView, target);\n                if (nodeIndex == -1) {\n                    return null;\n                }\n            }\n            // the goal is not to fill the entire context full of data because the lookups\n            // are expensive. Instead, only the target data (the element, component, container, ICU\n            // expression or directive details) are filled into the context. If called multiple times\n            // with different target values then the missing target data will be filled in.\n            const native = unwrapRNode(lView[nodeIndex]);\n            const existingCtx = readPatchedData(native);\n            const context = (existingCtx && !Array.isArray(existingCtx)) ?\n                existingCtx :\n                createLContext(lView, nodeIndex, native);\n            // only when the component has been discovered then update the monkey-patch\n            if (component && context.component === undefined) {\n                context.component = component;\n                attachPatchData(context.component, context);\n            }\n            // only when the directives have been discovered then update the monkey-patch\n            if (directives && context.directives === undefined) {\n                context.directives = directives;\n                for (let i = 0; i < directives.length; i++) {\n                    attachPatchData(directives[i], context);\n                }\n            }\n            attachPatchData(context.native, context);\n            mpValue = context;\n        }\n    }\n    else {\n        const rElement = target;\n        ngDevMode && assertDomNode(rElement);\n        // if the context is not found then we need to traverse upwards up the DOM\n        // to find the nearest element that has already been monkey patched with data\n        let parent = rElement;\n        while (parent = parent.parentNode) {\n            const parentContext = readPatchedData(parent);\n            if (parentContext) {\n                const lView = Array.isArray(parentContext) ? parentContext : parentContext.lView;\n                // the edge of the app was also reached here through another means\n                // (maybe because the DOM was changed manually).\n                if (!lView) {\n                    return null;\n                }\n                const index = findViaNativeElement(lView, rElement);\n                if (index >= 0) {\n                    const native = unwrapRNode(lView[index]);\n                    const context = createLContext(lView, index, native);\n                    attachPatchData(native, context);\n                    mpValue = context;\n                    break;\n                }\n            }\n        }\n    }\n    return mpValue || null;\n}\n/**\n * Creates an empty instance of a `LContext` context\n */\nfunction createLContext(lView, nodeIndex, native) {\n    return new LContext(lView[ID], nodeIndex, native);\n}\n/**\n * Takes a component instance and returns the view for that component.\n *\n * @param componentInstance\n * @returns The component's view\n */\nfunction getComponentViewByInstance(componentInstance) {\n    let patchedData = readPatchedData(componentInstance);\n    let lView;\n    if (isLView(patchedData)) {\n        const contextLView = patchedData;\n        const nodeIndex = findViaComponent(contextLView, componentInstance);\n        lView = getComponentLViewByIndex(nodeIndex, contextLView);\n        const context = createLContext(contextLView, nodeIndex, lView[HOST]);\n        context.component = componentInstance;\n        attachPatchData(componentInstance, context);\n        attachPatchData(context.native, context);\n    }\n    else {\n        const context = patchedData;\n        const contextLView = context.lView;\n        ngDevMode && assertLView(contextLView);\n        lView = getComponentLViewByIndex(context.nodeIndex, contextLView);\n    }\n    return lView;\n}\n/**\n * This property will be monkey-patched on elements, components and directives.\n */\nconst MONKEY_PATCH_KEY_NAME = '__ngContext__';\n/**\n * Assigns the given data to the given target (which could be a component,\n * directive or DOM node instance) using monkey-patching.\n */\nfunction attachPatchData(target, data) {\n    ngDevMode && assertDefined(target, 'Target expected');\n    // Only attach the ID of the view in order to avoid memory leaks (see #41047). We only do this\n    // for `LView`, because we have control over when an `LView` is created and destroyed, whereas\n    // we can't know when to remove an `LContext`.\n    if (isLView(data)) {\n        target[MONKEY_PATCH_KEY_NAME] = data[ID];\n        registerLView(data);\n    }\n    else {\n        target[MONKEY_PATCH_KEY_NAME] = data;\n    }\n}\n/**\n * Returns the monkey-patch value data present on the target (which could be\n * a component, directive or a DOM node).\n */\nfunction readPatchedData(target) {\n    ngDevMode && assertDefined(target, 'Target expected');\n    const data = target[MONKEY_PATCH_KEY_NAME];\n    return (typeof data === 'number') ? getLViewById(data) : data || null;\n}\nfunction readPatchedLView(target) {\n    const value = readPatchedData(target);\n    if (value) {\n        return (isLView(value) ? value : value.lView);\n    }\n    return null;\n}\nfunction isComponentInstance(instance) {\n    return instance && instance.constructor && instance.constructor.ɵcmp;\n}\nfunction isDirectiveInstance(instance) {\n    return instance && instance.constructor && instance.constructor.ɵdir;\n}\n/**\n * Locates the element within the given LView and returns the matching index\n */\nfunction findViaNativeElement(lView, target) {\n    const tView = lView[TVIEW];\n    for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {\n        if (unwrapRNode(lView[i]) === target) {\n            return i;\n        }\n    }\n    return -1;\n}\n/**\n * Locates the next tNode (child, sibling or parent).\n */\nfunction traverseNextElement(tNode) {\n    if (tNode.child) {\n        return tNode.child;\n    }\n    else if (tNode.next) {\n        return tNode.next;\n    }\n    else {\n        // Let's take the following template: <div><span>text</span></div><component/>\n        // After checking the text node, we need to find the next parent that has a \"next\" TNode,\n        // in this case the parent `div`, so that we can find the component.\n        while (tNode.parent && !tNode.parent.next) {\n            tNode = tNode.parent;\n        }\n        return tNode.parent && tNode.parent.next;\n    }\n}\n/**\n * Locates the component within the given LView and returns the matching index\n */\nfunction findViaComponent(lView, componentInstance) {\n    const componentIndices = lView[TVIEW].components;\n    if (componentIndices) {\n        for (let i = 0; i < componentIndices.length; i++) {\n            const elementComponentIndex = componentIndices[i];\n            const componentView = getComponentLViewByIndex(elementComponentIndex, lView);\n            if (componentView[CONTEXT] === componentInstance) {\n                return elementComponentIndex;\n            }\n        }\n    }\n    else {\n        const rootComponentView = getComponentLViewByIndex(HEADER_OFFSET, lView);\n        const rootComponent = rootComponentView[CONTEXT];\n        if (rootComponent === componentInstance) {\n            // we are dealing with the root element here therefore we know that the\n            // element is the very first element after the HEADER data in the lView\n            return HEADER_OFFSET;\n        }\n    }\n    return -1;\n}\n/**\n * Locates the directive within the given LView and returns the matching index\n */\nfunction findViaDirective(lView, directiveInstance) {\n    // if a directive is monkey patched then it will (by default)\n    // have a reference to the LView of the current view. The\n    // element bound to the directive being search lives somewhere\n    // in the view data. We loop through the nodes and check their\n    // list of directives for the instance.\n    let tNode = lView[TVIEW].firstChild;\n    while (tNode) {\n        const directiveIndexStart = tNode.directiveStart;\n        const directiveIndexEnd = tNode.directiveEnd;\n        for (let i = directiveIndexStart; i < directiveIndexEnd; i++) {\n            if (lView[i] === directiveInstance) {\n                return tNode.index;\n            }\n        }\n        tNode = traverseNextElement(tNode);\n    }\n    return -1;\n}\n/**\n * Returns a list of directives applied to a node at a specific index. The list includes\n * directives matched by selector and any host directives, but it excludes components.\n * Use `getComponentAtNodeIndex` to find the component applied to a node.\n *\n * @param nodeIndex The node index\n * @param lView The target view data\n */\nfunction getDirectivesAtNodeIndex(nodeIndex, lView) {\n    const tNode = lView[TVIEW].data[nodeIndex];\n    if (tNode.directiveStart === 0)\n        return EMPTY_ARRAY;\n    const results = [];\n    for (let i = tNode.directiveStart; i < tNode.directiveEnd; i++) {\n        const directiveInstance = lView[i];\n        if (!isComponentInstance(directiveInstance)) {\n            results.push(directiveInstance);\n        }\n    }\n    return results;\n}\nfunction getComponentAtNodeIndex(nodeIndex, lView) {\n    const tNode = lView[TVIEW].data[nodeIndex];\n    const { directiveStart, componentOffset } = tNode;\n    return componentOffset > -1 ? lView[directiveStart + componentOffset] : null;\n}\n/**\n * Returns a map of local references (local reference name => element or directive instance) that\n * exist on a given element.\n */\nfunction discoverLocalRefs(lView, nodeIndex) {\n    const tNode = lView[TVIEW].data[nodeIndex];\n    if (tNode && tNode.localNames) {\n        const result = {};\n        let localIndex = tNode.index + 1;\n        for (let i = 0; i < tNode.localNames.length; i += 2) {\n            result[tNode.localNames[i]] = lView[localIndex];\n            localIndex++;\n        }\n        return result;\n    }\n    return null;\n}\n\nlet _icuContainerIterate;\n/**\n * Iterator which provides ability to visit all of the `TIcuContainerNode` root `RNode`s.\n */\nfunction icuContainerIterate(tIcuContainerNode, lView) {\n    return _icuContainerIterate(tIcuContainerNode, lView);\n}\n/**\n * Ensures that `IcuContainerVisitor`'s implementation is present.\n *\n * This function is invoked when i18n instruction comes across an ICU. The purpose is to allow the\n * bundler to tree shake ICU logic and only load it if ICU instruction is executed.\n */\nfunction ensureIcuContainerVisitorLoaded(loader) {\n    if (_icuContainerIterate === undefined) {\n        // Do not inline this function. We want to keep `ensureIcuContainerVisitorLoaded` light, so it\n        // can be inlined into call-site.\n        _icuContainerIterate = loader();\n    }\n}\n\n/**\n * Gets the parent LView of the passed LView, if the PARENT is an LContainer, will get the parent of\n * that LContainer, which is an LView\n * @param lView the lView whose parent to get\n */\nfunction getLViewParent(lView) {\n    ngDevMode && assertLView(lView);\n    const parent = lView[PARENT];\n    return isLContainer(parent) ? parent[PARENT] : parent;\n}\n/**\n * Retrieve the root view from any component or `LView` by walking the parent `LView` until\n * reaching the root `LView`.\n *\n * @param componentOrLView any component or `LView`\n */\nfunction getRootView(componentOrLView) {\n    ngDevMode && assertDefined(componentOrLView, 'component');\n    let lView = isLView(componentOrLView) ? componentOrLView : readPatchedLView(componentOrLView);\n    while (lView && !(lView[FLAGS] & 512 /* LViewFlags.IsRoot */)) {\n        lView = getLViewParent(lView);\n    }\n    ngDevMode && assertLView(lView);\n    return lView;\n}\n/**\n * Returns the context information associated with the application where the target is situated. It\n * does this by walking the parent views until it gets to the root view, then getting the context\n * off of that.\n *\n * @param viewOrComponent the `LView` or component to get the root context for.\n */\nfunction getRootContext(viewOrComponent) {\n    const rootView = getRootView(viewOrComponent);\n    ngDevMode &&\n        assertDefined(rootView[CONTEXT], 'Root view has no context. Perhaps it is disconnected?');\n    return rootView[CONTEXT];\n}\n/**\n * Gets the first `LContainer` in the LView or `null` if none exists.\n */\nfunction getFirstLContainer(lView) {\n    return getNearestLContainer(lView[CHILD_HEAD]);\n}\n/**\n * Gets the next `LContainer` that is a sibling of the given container.\n */\nfunction getNextLContainer(container) {\n    return getNearestLContainer(container[NEXT]);\n}\nfunction getNearestLContainer(viewOrContainer) {\n    while (viewOrContainer !== null && !isLContainer(viewOrContainer)) {\n        viewOrContainer = viewOrContainer[NEXT];\n    }\n    return viewOrContainer;\n}\n\n/**\n * NOTE: for performance reasons, the possible actions are inlined within the function instead of\n * being passed as an argument.\n */\nfunction applyToElementOrContainer(action, renderer, parent, lNodeToHandle, beforeNode) {\n    // If this slot was allocated for a text node dynamically created by i18n, the text node itself\n    // won't be created until i18nApply() in the update block, so this node should be skipped.\n    // For more info, see \"ICU expressions should work inside an ngTemplateOutlet inside an ngFor\"\n    // in `i18n_spec.ts`.\n    if (lNodeToHandle != null) {\n        let lContainer;\n        let isComponent = false;\n        // We are expecting an RNode, but in the case of a component or LContainer the `RNode` is\n        // wrapped in an array which needs to be unwrapped. We need to know if it is a component and if\n        // it has LContainer so that we can process all of those cases appropriately.\n        if (isLContainer(lNodeToHandle)) {\n            lContainer = lNodeToHandle;\n        }\n        else if (isLView(lNodeToHandle)) {\n            isComponent = true;\n            ngDevMode && assertDefined(lNodeToHandle[HOST], 'HOST must be defined for a component LView');\n            lNodeToHandle = lNodeToHandle[HOST];\n        }\n        const rNode = unwrapRNode(lNodeToHandle);\n        if (action === 0 /* WalkTNodeTreeAction.Create */ && parent !== null) {\n            if (beforeNode == null) {\n                nativeAppendChild(renderer, parent, rNode);\n            }\n            else {\n                nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);\n            }\n        }\n        else if (action === 1 /* WalkTNodeTreeAction.Insert */ && parent !== null) {\n            nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);\n        }\n        else if (action === 2 /* WalkTNodeTreeAction.Detach */) {\n            nativeRemoveNode(renderer, rNode, isComponent);\n        }\n        else if (action === 3 /* WalkTNodeTreeAction.Destroy */) {\n            ngDevMode && ngDevMode.rendererDestroyNode++;\n            renderer.destroyNode(rNode);\n        }\n        if (lContainer != null) {\n            applyContainer(renderer, action, lContainer, parent, beforeNode);\n        }\n    }\n}\nfunction createTextNode(renderer, value) {\n    ngDevMode && ngDevMode.rendererCreateTextNode++;\n    ngDevMode && ngDevMode.rendererSetText++;\n    return renderer.createText(value);\n}\nfunction updateTextNode(renderer, rNode, value) {\n    ngDevMode && ngDevMode.rendererSetText++;\n    renderer.setValue(rNode, value);\n}\nfunction createCommentNode(renderer, value) {\n    ngDevMode && ngDevMode.rendererCreateComment++;\n    return renderer.createComment(escapeCommentText(value));\n}\n/**\n * Creates a native element from a tag name, using a renderer.\n * @param renderer A renderer to use\n * @param name the tag name\n * @param namespace Optional namespace for element.\n * @returns the element created\n */\nfunction createElementNode(renderer, name, namespace) {\n    ngDevMode && ngDevMode.rendererCreateElement++;\n    return renderer.createElement(name, namespace);\n}\n/**\n * Removes all DOM elements associated with a view.\n *\n * Because some root nodes of the view may be containers, we sometimes need\n * to propagate deeply into the nested containers to remove all elements in the\n * views beneath it.\n *\n * @param tView The `TView' of the `LView` from which elements should be added or removed\n * @param lView The view from which elements should be added or removed\n */\nfunction removeViewFromDOM(tView, lView) {\n    const renderer = lView[RENDERER];\n    applyView(tView, lView, renderer, 2 /* WalkTNodeTreeAction.Detach */, null, null);\n    lView[HOST] = null;\n    lView[T_HOST] = null;\n}\n/**\n * Adds all DOM elements associated with a view.\n *\n * Because some root nodes of the view may be containers, we sometimes need\n * to propagate deeply into the nested containers to add all elements in the\n * views beneath it.\n *\n * @param tView The `TView' of the `LView` from which elements should be added or removed\n * @param parentTNode The `TNode` where the `LView` should be attached to.\n * @param renderer Current renderer to use for DOM manipulations.\n * @param lView The view from which elements should be added or removed\n * @param parentNativeNode The parent `RElement` where it should be inserted into.\n * @param beforeNode The node before which elements should be added, if insert mode\n */\nfunction addViewToDOM(tView, parentTNode, renderer, lView, parentNativeNode, beforeNode) {\n    lView[HOST] = parentNativeNode;\n    lView[T_HOST] = parentTNode;\n    applyView(tView, lView, renderer, 1 /* WalkTNodeTreeAction.Insert */, parentNativeNode, beforeNode);\n}\n/**\n * Detach a `LView` from the DOM by detaching its nodes.\n *\n * @param tView The `TView' of the `LView` to be detached\n * @param lView the `LView` to be detached.\n */\nfunction detachViewFromDOM(tView, lView) {\n    applyView(tView, lView, lView[RENDERER], 2 /* WalkTNodeTreeAction.Detach */, null, null);\n}\n/**\n * Traverses down and up the tree of views and containers to remove listeners and\n * call onDestroy callbacks.\n *\n * Notes:\n *  - Because it's used for onDestroy calls, it needs to be bottom-up.\n *  - Must process containers instead of their views to avoid splicing\n *  when views are destroyed and re-added.\n *  - Using a while loop because it's faster than recursion\n *  - Destroy only called on movement to sibling or movement to parent (laterally or up)\n *\n *  @param rootView The view to destroy\n */\nfunction destroyViewTree(rootView) {\n    // If the view has no children, we can clean it up and return early.\n    let lViewOrLContainer = rootView[CHILD_HEAD];\n    if (!lViewOrLContainer) {\n        return cleanUpView(rootView[TVIEW], rootView);\n    }\n    while (lViewOrLContainer) {\n        let next = null;\n        if (isLView(lViewOrLContainer)) {\n            // If LView, traverse down to child.\n            next = lViewOrLContainer[CHILD_HEAD];\n        }\n        else {\n            ngDevMode && assertLContainer(lViewOrLContainer);\n            // If container, traverse down to its first LView.\n            const firstView = lViewOrLContainer[CONTAINER_HEADER_OFFSET];\n            if (firstView)\n                next = firstView;\n        }\n        if (!next) {\n            // Only clean up view when moving to the side or up, as destroy hooks\n            // should be called in order from the bottom up.\n            while (lViewOrLContainer && !lViewOrLContainer[NEXT] && lViewOrLContainer !== rootView) {\n                if (isLView(lViewOrLContainer)) {\n                    cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);\n                }\n                lViewOrLContainer = lViewOrLContainer[PARENT];\n            }\n            if (lViewOrLContainer === null)\n                lViewOrLContainer = rootView;\n            if (isLView(lViewOrLContainer)) {\n                cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);\n            }\n            next = lViewOrLContainer && lViewOrLContainer[NEXT];\n        }\n        lViewOrLContainer = next;\n    }\n}\n/**\n * Inserts a view into a container.\n *\n * This adds the view to the container's array of active views in the correct\n * position. It also adds the view's elements to the DOM if the container isn't a\n * root node of another view (in that case, the view's elements will be added when\n * the container's parent view is added later).\n *\n * @param tView The `TView' of the `LView` to insert\n * @param lView The view to insert\n * @param lContainer The container into which the view should be inserted\n * @param index Which index in the container to insert the child view into\n */\nfunction insertView(tView, lView, lContainer, index) {\n    ngDevMode && assertLView(lView);\n    ngDevMode && assertLContainer(lContainer);\n    const indexInContainer = CONTAINER_HEADER_OFFSET + index;\n    const containerLength = lContainer.length;\n    if (index > 0) {\n        // This is a new view, we need to add it to the children.\n        lContainer[indexInContainer - 1][NEXT] = lView;\n    }\n    if (index < containerLength - CONTAINER_HEADER_OFFSET) {\n        lView[NEXT] = lContainer[indexInContainer];\n        addToArray(lContainer, CONTAINER_HEADER_OFFSET + index, lView);\n    }\n    else {\n        lContainer.push(lView);\n        lView[NEXT] = null;\n    }\n    lView[PARENT] = lContainer;\n    // track views where declaration and insertion points are different\n    const declarationLContainer = lView[DECLARATION_LCONTAINER];\n    if (declarationLContainer !== null && lContainer !== declarationLContainer) {\n        trackMovedView(declarationLContainer, lView);\n    }\n    // notify query that a new view has been added\n    const lQueries = lView[QUERIES];\n    if (lQueries !== null) {\n        lQueries.insertView(tView);\n    }\n    // Sets the attached flag\n    lView[FLAGS] |= 128 /* LViewFlags.Attached */;\n}\n/**\n * Track views created from the declaration container (TemplateRef) and inserted into a\n * different LContainer.\n */\nfunction trackMovedView(declarationContainer, lView) {\n    ngDevMode && assertDefined(lView, 'LView required');\n    ngDevMode && assertLContainer(declarationContainer);\n    const movedViews = declarationContainer[MOVED_VIEWS];\n    const insertedLContainer = lView[PARENT];\n    ngDevMode && assertLContainer(insertedLContainer);\n    const insertedComponentLView = insertedLContainer[PARENT][DECLARATION_COMPONENT_VIEW];\n    ngDevMode && assertDefined(insertedComponentLView, 'Missing insertedComponentLView');\n    const declaredComponentLView = lView[DECLARATION_COMPONENT_VIEW];\n    ngDevMode && assertDefined(declaredComponentLView, 'Missing declaredComponentLView');\n    if (declaredComponentLView !== insertedComponentLView) {\n        // At this point the declaration-component is not same as insertion-component; this means that\n        // this is a transplanted view. Mark the declared lView as having transplanted views so that\n        // those views can participate in CD.\n        declarationContainer[HAS_TRANSPLANTED_VIEWS] = true;\n    }\n    if (movedViews === null) {\n        declarationContainer[MOVED_VIEWS] = [lView];\n    }\n    else {\n        movedViews.push(lView);\n    }\n}\nfunction detachMovedView(declarationContainer, lView) {\n    ngDevMode && assertLContainer(declarationContainer);\n    ngDevMode &&\n        assertDefined(declarationContainer[MOVED_VIEWS], 'A projected view should belong to a non-empty projected views collection');\n    const movedViews = declarationContainer[MOVED_VIEWS];\n    const declarationViewIndex = movedViews.indexOf(lView);\n    const insertionLContainer = lView[PARENT];\n    ngDevMode && assertLContainer(insertionLContainer);\n    // If the view was marked for refresh but then detached before it was checked (where the flag\n    // would be cleared and the counter decremented), we need to update the status here.\n    clearViewRefreshFlag(lView);\n    movedViews.splice(declarationViewIndex, 1);\n}\n/**\n * Detaches a view from a container.\n *\n * This method removes the view from the container's array of active views. It also\n * removes the view's elements from the DOM.\n *\n * @param lContainer The container from which to detach a view\n * @param removeIndex The index of the view to detach\n * @returns Detached LView instance.\n */\nfunction detachView(lContainer, removeIndex) {\n    if (lContainer.length <= CONTAINER_HEADER_OFFSET)\n        return;\n    const indexInContainer = CONTAINER_HEADER_OFFSET + removeIndex;\n    const viewToDetach = lContainer[indexInContainer];\n    if (viewToDetach) {\n        const declarationLContainer = viewToDetach[DECLARATION_LCONTAINER];\n        if (declarationLContainer !== null && declarationLContainer !== lContainer) {\n            detachMovedView(declarationLContainer, viewToDetach);\n        }\n        if (removeIndex > 0) {\n            lContainer[indexInContainer - 1][NEXT] = viewToDetach[NEXT];\n        }\n        const removedLView = removeFromArray(lContainer, CONTAINER_HEADER_OFFSET + removeIndex);\n        removeViewFromDOM(viewToDetach[TVIEW], viewToDetach);\n        // notify query that a view has been removed\n        const lQueries = removedLView[QUERIES];\n        if (lQueries !== null) {\n            lQueries.detachView(removedLView[TVIEW]);\n        }\n        viewToDetach[PARENT] = null;\n        viewToDetach[NEXT] = null;\n        // Unsets the attached flag\n        viewToDetach[FLAGS] &= ~128 /* LViewFlags.Attached */;\n    }\n    return viewToDetach;\n}\n/**\n * A standalone function which destroys an LView,\n * conducting clean up (e.g. removing listeners, calling onDestroys).\n *\n * @param tView The `TView' of the `LView` to be destroyed\n * @param lView The view to be destroyed.\n */\nfunction destroyLView(tView, lView) {\n    if (!(lView[FLAGS] & 256 /* LViewFlags.Destroyed */)) {\n        const renderer = lView[RENDERER];\n        lView[REACTIVE_TEMPLATE_CONSUMER] && consumerDestroy(lView[REACTIVE_TEMPLATE_CONSUMER]);\n        lView[REACTIVE_HOST_BINDING_CONSUMER] && consumerDestroy(lView[REACTIVE_HOST_BINDING_CONSUMER]);\n        if (renderer.destroyNode) {\n            applyView(tView, lView, renderer, 3 /* WalkTNodeTreeAction.Destroy */, null, null);\n        }\n        destroyViewTree(lView);\n    }\n}\n/**\n * Calls onDestroys hooks for all directives and pipes in a given view and then removes all\n * listeners. Listeners are removed as the last step so events delivered in the onDestroys hooks\n * can be propagated to @Output listeners.\n *\n * @param tView `TView` for the `LView` to clean up.\n * @param lView The LView to clean up\n */\nfunction cleanUpView(tView, lView) {\n    if (!(lView[FLAGS] & 256 /* LViewFlags.Destroyed */)) {\n        // Usually the Attached flag is removed when the view is detached from its parent, however\n        // if it's a root view, the flag won't be unset hence why we're also removing on destroy.\n        lView[FLAGS] &= ~128 /* LViewFlags.Attached */;\n        // Mark the LView as destroyed *before* executing the onDestroy hooks. An onDestroy hook\n        // runs arbitrary user code, which could include its own `viewRef.destroy()` (or similar). If\n        // We don't flag the view as destroyed before the hooks, this could lead to an infinite loop.\n        // This also aligns with the ViewEngine behavior. It also means that the onDestroy hook is\n        // really more of an \"afterDestroy\" hook if you think about it.\n        lView[FLAGS] |= 256 /* LViewFlags.Destroyed */;\n        executeOnDestroys(tView, lView);\n        processCleanups(tView, lView);\n        // For component views only, the local renderer is destroyed at clean up time.\n        if (lView[TVIEW].type === 1 /* TViewType.Component */) {\n            ngDevMode && ngDevMode.rendererDestroy++;\n            lView[RENDERER].destroy();\n        }\n        const declarationContainer = lView[DECLARATION_LCONTAINER];\n        // we are dealing with an embedded view that is still inserted into a container\n        if (declarationContainer !== null && isLContainer(lView[PARENT])) {\n            // and this is a projected view\n            if (declarationContainer !== lView[PARENT]) {\n                detachMovedView(declarationContainer, lView);\n            }\n            // For embedded views still attached to a container: remove query result from this view.\n            const lQueries = lView[QUERIES];\n            if (lQueries !== null) {\n                lQueries.detachView(tView);\n            }\n        }\n        // Unregister the view once everything else has been cleaned up.\n        unregisterLView(lView);\n    }\n}\n/** Removes listeners and unsubscribes from output subscriptions */\nfunction processCleanups(tView, lView) {\n    const tCleanup = tView.cleanup;\n    const lCleanup = lView[CLEANUP];\n    if (tCleanup !== null) {\n        for (let i = 0; i < tCleanup.length - 1; i += 2) {\n            if (typeof tCleanup[i] === 'string') {\n                // This is a native DOM listener. It will occupy 4 entries in the TCleanup array (hence i +=\n                // 2 at the end of this block).\n                const targetIdx = tCleanup[i + 3];\n                ngDevMode && assertNumber(targetIdx, 'cleanup target must be a number');\n                if (targetIdx >= 0) {\n                    // unregister\n                    lCleanup[targetIdx]();\n                }\n                else {\n                    // Subscription\n                    lCleanup[-targetIdx].unsubscribe();\n                }\n                i += 2;\n            }\n            else {\n                // This is a cleanup function that is grouped with the index of its context\n                const context = lCleanup[tCleanup[i + 1]];\n                tCleanup[i].call(context);\n            }\n        }\n    }\n    if (lCleanup !== null) {\n        lView[CLEANUP] = null;\n    }\n    const destroyHooks = lView[ON_DESTROY_HOOKS];\n    if (destroyHooks !== null) {\n        // Reset the ON_DESTROY_HOOKS array before iterating over it to prevent hooks that unregister\n        // themselves from mutating the array during iteration.\n        lView[ON_DESTROY_HOOKS] = null;\n        for (let i = 0; i < destroyHooks.length; i++) {\n            const destroyHooksFn = destroyHooks[i];\n            ngDevMode && assertFunction(destroyHooksFn, 'Expecting destroy hook to be a function.');\n            destroyHooksFn();\n        }\n    }\n}\n/** Calls onDestroy hooks for this view */\nfunction executeOnDestroys(tView, lView) {\n    let destroyHooks;\n    if (tView != null && (destroyHooks = tView.destroyHooks) != null) {\n        for (let i = 0; i < destroyHooks.length; i += 2) {\n            const context = lView[destroyHooks[i]];\n            // Only call the destroy hook if the context has been requested.\n            if (!(context instanceof NodeInjectorFactory)) {\n                const toCall = destroyHooks[i + 1];\n                if (Array.isArray(toCall)) {\n                    for (let j = 0; j < toCall.length; j += 2) {\n                        const callContext = context[toCall[j]];\n                        const hook = toCall[j + 1];\n                        profiler(4 /* ProfilerEvent.LifecycleHookStart */, callContext, hook);\n                        try {\n                            hook.call(callContext);\n                        }\n                        finally {\n                            profiler(5 /* ProfilerEvent.LifecycleHookEnd */, callContext, hook);\n                        }\n                    }\n                }\n                else {\n                    profiler(4 /* ProfilerEvent.LifecycleHookStart */, context, toCall);\n                    try {\n                        toCall.call(context);\n                    }\n                    finally {\n                        profiler(5 /* ProfilerEvent.LifecycleHookEnd */, context, toCall);\n                    }\n                }\n            }\n        }\n    }\n}\n/**\n * Returns a native element if a node can be inserted into the given parent.\n *\n * There are two reasons why we may not be able to insert a element immediately.\n * - Projection: When creating a child content element of a component, we have to skip the\n *   insertion because the content of a component will be projected.\n *   `<component><content>delayed due to projection</content></component>`\n * - Parent container is disconnected: This can happen when we are inserting a view into\n *   parent container, which itself is disconnected. For example the parent container is part\n *   of a View which has not be inserted or is made for projection but has not been inserted\n *   into destination.\n *\n * @param tView: Current `TView`.\n * @param tNode: `TNode` for which we wish to retrieve render parent.\n * @param lView: Current `LView`.\n */\nfunction getParentRElement(tView, tNode, lView) {\n    return getClosestRElement(tView, tNode.parent, lView);\n}\n/**\n * Get closest `RElement` or `null` if it can't be found.\n *\n * If `TNode` is `TNodeType.Element` => return `RElement` at `LView[tNode.index]` location.\n * If `TNode` is `TNodeType.ElementContainer|IcuContain` => return the parent (recursively).\n * If `TNode` is `null` then return host `RElement`:\n *   - return `null` if projection\n *   - return `null` if parent container is disconnected (we have no parent.)\n *\n * @param tView: Current `TView`.\n * @param tNode: `TNode` for which we wish to retrieve `RElement` (or `null` if host element is\n *     needed).\n * @param lView: Current `LView`.\n * @returns `null` if the `RElement` can't be determined at this time (no parent / projection)\n */\nfunction getClosestRElement(tView, tNode, lView) {\n    let parentTNode = tNode;\n    // Skip over element and ICU containers as those are represented by a comment node and\n    // can't be used as a render parent.\n    while (parentTNode !== null &&\n        (parentTNode.type & (8 /* TNodeType.ElementContainer */ | 32 /* TNodeType.Icu */))) {\n        tNode = parentTNode;\n        parentTNode = tNode.parent;\n    }\n    // If the parent tNode is null, then we are inserting across views: either into an embedded view\n    // or a component view.\n    if (parentTNode === null) {\n        // We are inserting a root element of the component view into the component host element and\n        // it should always be eager.\n        return lView[HOST];\n    }\n    else {\n        ngDevMode && assertTNodeType(parentTNode, 3 /* TNodeType.AnyRNode */ | 4 /* TNodeType.Container */);\n        const { componentOffset } = parentTNode;\n        if (componentOffset > -1) {\n            ngDevMode && assertTNodeForLView(parentTNode, lView);\n            const { encapsulation } = tView.data[parentTNode.directiveStart + componentOffset];\n            // We've got a parent which is an element in the current view. We just need to verify if the\n            // parent element is not a component. Component's content nodes are not inserted immediately\n            // because they will be projected, and so doing insert at this point would be wasteful.\n            // Since the projection would then move it to its final destination. Note that we can't\n            // make this assumption when using the Shadow DOM, because the native projection placeholders\n            // (<content> or <slot>) have to be in place as elements are being inserted.\n            if (encapsulation === ViewEncapsulation.None ||\n                encapsulation === ViewEncapsulation.Emulated) {\n                return null;\n            }\n        }\n        return getNativeByTNode(parentTNode, lView);\n    }\n}\n/**\n * Inserts a native node before another native node for a given parent.\n * This is a utility function that can be used when native nodes were determined.\n */\nfunction nativeInsertBefore(renderer, parent, child, beforeNode, isMove) {\n    ngDevMode && ngDevMode.rendererInsertBefore++;\n    renderer.insertBefore(parent, child, beforeNode, isMove);\n}\nfunction nativeAppendChild(renderer, parent, child) {\n    ngDevMode && ngDevMode.rendererAppendChild++;\n    ngDevMode && assertDefined(parent, 'parent node must be defined');\n    renderer.appendChild(parent, child);\n}\nfunction nativeAppendOrInsertBefore(renderer, parent, child, beforeNode, isMove) {\n    if (beforeNode !== null) {\n        nativeInsertBefore(renderer, parent, child, beforeNode, isMove);\n    }\n    else {\n        nativeAppendChild(renderer, parent, child);\n    }\n}\n/** Removes a node from the DOM given its native parent. */\nfunction nativeRemoveChild(renderer, parent, child, isHostElement) {\n    renderer.removeChild(parent, child, isHostElement);\n}\n/** Checks if an element is a `<template>` node. */\nfunction isTemplateNode(node) {\n    return node.tagName === 'TEMPLATE' && node.content !== undefined;\n}\n/**\n * Returns a native parent of a given native node.\n */\nfunction nativeParentNode(renderer, node) {\n    return renderer.parentNode(node);\n}\n/**\n * Returns a native sibling of a given native node.\n */\nfunction nativeNextSibling(renderer, node) {\n    return renderer.nextSibling(node);\n}\n/**\n * Find a node in front of which `currentTNode` should be inserted.\n *\n * This method determines the `RNode` in front of which we should insert the `currentRNode`. This\n * takes `TNode.insertBeforeIndex` into account if i18n code has been invoked.\n *\n * @param parentTNode parent `TNode`\n * @param currentTNode current `TNode` (The node which we would like to insert into the DOM)\n * @param lView current `LView`\n */\nfunction getInsertInFrontOfRNode(parentTNode, currentTNode, lView) {\n    return _getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView);\n}\n/**\n * Find a node in front of which `currentTNode` should be inserted. (Does not take i18n into\n * account)\n *\n * This method determines the `RNode` in front of which we should insert the `currentRNode`. This\n * does not take `TNode.insertBeforeIndex` into account.\n *\n * @param parentTNode parent `TNode`\n * @param currentTNode current `TNode` (The node which we would like to insert into the DOM)\n * @param lView current `LView`\n */\nfunction getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView) {\n    if (parentTNode.type & (8 /* TNodeType.ElementContainer */ | 32 /* TNodeType.Icu */)) {\n        return getNativeByTNode(parentTNode, lView);\n    }\n    return null;\n}\n/**\n * Tree shakable boundary for `getInsertInFrontOfRNodeWithI18n` function.\n *\n * This function will only be set if i18n code runs.\n */\nlet _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithNoI18n;\n/**\n * Tree shakable boundary for `processI18nInsertBefore` function.\n *\n * This function will only be set if i18n code runs.\n */\nlet _processI18nInsertBefore;\nfunction setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore) {\n    _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithI18n;\n    _processI18nInsertBefore = processI18nInsertBefore;\n}\n/**\n * Appends the `child` native node (or a collection of nodes) to the `parent`.\n *\n * @param tView The `TView' to be appended\n * @param lView The current LView\n * @param childRNode The native child (or children) that should be appended\n * @param childTNode The TNode of the child element\n */\nfunction appendChild(tView, lView, childRNode, childTNode) {\n    const parentRNode = getParentRElement(tView, childTNode, lView);\n    const renderer = lView[RENDERER];\n    const parentTNode = childTNode.parent || lView[T_HOST];\n    const anchorNode = getInsertInFrontOfRNode(parentTNode, childTNode, lView);\n    if (parentRNode != null) {\n        if (Array.isArray(childRNode)) {\n            for (let i = 0; i < childRNode.length; i++) {\n                nativeAppendOrInsertBefore(renderer, parentRNode, childRNode[i], anchorNode, false);\n            }\n        }\n        else {\n            nativeAppendOrInsertBefore(renderer, parentRNode, childRNode, anchorNode, false);\n        }\n    }\n    _processI18nInsertBefore !== undefined &&\n        _processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRNode);\n}\n/**\n * Returns the first native node for a given LView, starting from the provided TNode.\n *\n * Native nodes are returned in the order in which those appear in the native tree (DOM).\n */\nfunction getFirstNativeNode(lView, tNode) {\n    if (tNode !== null) {\n        ngDevMode &&\n            assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 12 /* TNodeType.AnyContainer */ | 32 /* TNodeType.Icu */ | 16 /* TNodeType.Projection */);\n        const tNodeType = tNode.type;\n        if (tNodeType & 3 /* TNodeType.AnyRNode */) {\n            return getNativeByTNode(tNode, lView);\n        }\n        else if (tNodeType & 4 /* TNodeType.Container */) {\n            return getBeforeNodeForView(-1, lView[tNode.index]);\n        }\n        else if (tNodeType & 8 /* TNodeType.ElementContainer */) {\n            const elIcuContainerChild = tNode.child;\n            if (elIcuContainerChild !== null) {\n                return getFirstNativeNode(lView, elIcuContainerChild);\n            }\n            else {\n                const rNodeOrLContainer = lView[tNode.index];\n                if (isLContainer(rNodeOrLContainer)) {\n                    return getBeforeNodeForView(-1, rNodeOrLContainer);\n                }\n                else {\n                    return unwrapRNode(rNodeOrLContainer);\n                }\n            }\n        }\n        else if (tNodeType & 32 /* TNodeType.Icu */) {\n            let nextRNode = icuContainerIterate(tNode, lView);\n            let rNode = nextRNode();\n            // If the ICU container has no nodes, than we use the ICU anchor as the node.\n            return rNode || unwrapRNode(lView[tNode.index]);\n        }\n        else {\n            const projectionNodes = getProjectionNodes(lView, tNode);\n            if (projectionNodes !== null) {\n                if (Array.isArray(projectionNodes)) {\n                    return projectionNodes[0];\n                }\n                const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);\n                ngDevMode && assertParentView(parentView);\n                return getFirstNativeNode(parentView, projectionNodes);\n            }\n            else {\n                return getFirstNativeNode(lView, tNode.next);\n            }\n        }\n    }\n    return null;\n}\nfunction getProjectionNodes(lView, tNode) {\n    if (tNode !== null) {\n        const componentView = lView[DECLARATION_COMPONENT_VIEW];\n        const componentHost = componentView[T_HOST];\n        const slotIdx = tNode.projection;\n        ngDevMode && assertProjectionSlots(lView);\n        return componentHost.projection[slotIdx];\n    }\n    return null;\n}\nfunction getBeforeNodeForView(viewIndexInContainer, lContainer) {\n    const nextViewIndex = CONTAINER_HEADER_OFFSET + viewIndexInContainer + 1;\n    if (nextViewIndex < lContainer.length) {\n        const lView = lContainer[nextViewIndex];\n        const firstTNodeOfView = lView[TVIEW].firstChild;\n        if (firstTNodeOfView !== null) {\n            return getFirstNativeNode(lView, firstTNodeOfView);\n        }\n    }\n    return lContainer[NATIVE];\n}\n/**\n * Removes a native node itself using a given renderer. To remove the node we are looking up its\n * parent from the native tree as not all platforms / browsers support the equivalent of\n * node.remove().\n *\n * @param renderer A renderer to be used\n * @param rNode The native node that should be removed\n * @param isHostElement A flag indicating if a node to be removed is a host of a component.\n */\nfunction nativeRemoveNode(renderer, rNode, isHostElement) {\n    ngDevMode && ngDevMode.rendererRemoveNode++;\n    const nativeParent = nativeParentNode(renderer, rNode);\n    if (nativeParent) {\n        nativeRemoveChild(renderer, nativeParent, rNode, isHostElement);\n    }\n}\n/**\n * Clears the contents of a given RElement.\n *\n * @param rElement the native RElement to be cleared\n */\nfunction clearElementContents(rElement) {\n    rElement.textContent = '';\n}\n/**\n * Performs the operation of `action` on the node. Typically this involves inserting or removing\n * nodes on the LView or projection boundary.\n */\nfunction applyNodes(renderer, action, tNode, lView, parentRElement, beforeNode, isProjection) {\n    while (tNode != null) {\n        ngDevMode && assertTNodeForLView(tNode, lView);\n        ngDevMode &&\n            assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 12 /* TNodeType.AnyContainer */ | 16 /* TNodeType.Projection */ | 32 /* TNodeType.Icu */);\n        const rawSlotValue = lView[tNode.index];\n        const tNodeType = tNode.type;\n        if (isProjection) {\n            if (action === 0 /* WalkTNodeTreeAction.Create */) {\n                rawSlotValue && attachPatchData(unwrapRNode(rawSlotValue), lView);\n                tNode.flags |= 2 /* TNodeFlags.isProjected */;\n            }\n        }\n        if ((tNode.flags & 32 /* TNodeFlags.isDetached */) !== 32 /* TNodeFlags.isDetached */) {\n            if (tNodeType & 8 /* TNodeType.ElementContainer */) {\n                applyNodes(renderer, action, tNode.child, lView, parentRElement, beforeNode, false);\n                applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);\n            }\n            else if (tNodeType & 32 /* TNodeType.Icu */) {\n                const nextRNode = icuContainerIterate(tNode, lView);\n                let rNode;\n                while (rNode = nextRNode()) {\n                    applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);\n                }\n                applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);\n            }\n            else if (tNodeType & 16 /* TNodeType.Projection */) {\n                applyProjectionRecursive(renderer, action, lView, tNode, parentRElement, beforeNode);\n            }\n            else {\n                ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 4 /* TNodeType.Container */);\n                applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);\n            }\n        }\n        tNode = isProjection ? tNode.projectionNext : tNode.next;\n    }\n}\nfunction applyView(tView, lView, renderer, action, parentRElement, beforeNode) {\n    applyNodes(renderer, action, tView.firstChild, lView, parentRElement, beforeNode, false);\n}\n/**\n * `applyProjection` performs operation on the projection.\n *\n * Inserting a projection requires us to locate the projected nodes from the parent component. The\n * complication is that those nodes themselves could be re-projected from their parent component.\n *\n * @param tView The `TView` of `LView` which needs to be inserted, detached, destroyed\n * @param lView The `LView` which needs to be inserted, detached, destroyed.\n * @param tProjectionNode node to project\n */\nfunction applyProjection(tView, lView, tProjectionNode) {\n    const renderer = lView[RENDERER];\n    const parentRNode = getParentRElement(tView, tProjectionNode, lView);\n    const parentTNode = tProjectionNode.parent || lView[T_HOST];\n    let beforeNode = getInsertInFrontOfRNode(parentTNode, tProjectionNode, lView);\n    applyProjectionRecursive(renderer, 0 /* WalkTNodeTreeAction.Create */, lView, tProjectionNode, parentRNode, beforeNode);\n}\n/**\n * `applyProjectionRecursive` performs operation on the projection specified by `action` (insert,\n * detach, destroy)\n *\n * Inserting a projection requires us to locate the projected nodes from the parent component. The\n * complication is that those nodes themselves could be re-projected from their parent component.\n *\n * @param renderer Render to use\n * @param action action to perform (insert, detach, destroy)\n * @param lView The LView which needs to be inserted, detached, destroyed.\n * @param tProjectionNode node to project\n * @param parentRElement parent DOM element for insertion/removal.\n * @param beforeNode Before which node the insertions should happen.\n */\nfunction applyProjectionRecursive(renderer, action, lView, tProjectionNode, parentRElement, beforeNode) {\n    const componentLView = lView[DECLARATION_COMPONENT_VIEW];\n    const componentNode = componentLView[T_HOST];\n    ngDevMode &&\n        assertEqual(typeof tProjectionNode.projection, 'number', 'expecting projection index');\n    const nodeToProjectOrRNodes = componentNode.projection[tProjectionNode.projection];\n    if (Array.isArray(nodeToProjectOrRNodes)) {\n        // This should not exist, it is a bit of a hack. When we bootstrap a top level node and we\n        // need to support passing projectable nodes, so we cheat and put them in the TNode\n        // of the Host TView. (Yes we put instance info at the T Level). We can get away with it\n        // because we know that that TView is not shared and therefore it will not be a problem.\n        // This should be refactored and cleaned up.\n        for (let i = 0; i < nodeToProjectOrRNodes.length; i++) {\n            const rNode = nodeToProjectOrRNodes[i];\n            applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);\n        }\n    }\n    else {\n        let nodeToProject = nodeToProjectOrRNodes;\n        const projectedComponentLView = componentLView[PARENT];\n        // If a parent <ng-content> is located within a skip hydration block,\n        // annotate an actual node that is being projected with the same flag too.\n        if (hasInSkipHydrationBlockFlag(tProjectionNode)) {\n            nodeToProject.flags |= 128 /* TNodeFlags.inSkipHydrationBlock */;\n        }\n        applyNodes(renderer, action, nodeToProject, projectedComponentLView, parentRElement, beforeNode, true);\n    }\n}\n/**\n * `applyContainer` performs an operation on the container and its views as specified by\n * `action` (insert, detach, destroy)\n *\n * Inserting a Container is complicated by the fact that the container may have Views which\n * themselves have containers or projections.\n *\n * @param renderer Renderer to use\n * @param action action to perform (insert, detach, destroy)\n * @param lContainer The LContainer which needs to be inserted, detached, destroyed.\n * @param parentRElement parent DOM element for insertion/removal.\n * @param beforeNode Before which node the insertions should happen.\n */\nfunction applyContainer(renderer, action, lContainer, parentRElement, beforeNode) {\n    ngDevMode && assertLContainer(lContainer);\n    const anchor = lContainer[NATIVE]; // LContainer has its own before node.\n    const native = unwrapRNode(lContainer);\n    // An LContainer can be created dynamically on any node by injecting ViewContainerRef.\n    // Asking for a ViewContainerRef on an element will result in a creation of a separate anchor\n    // node (comment in the DOM) that will be different from the LContainer's host node. In this\n    // particular case we need to execute action on 2 nodes:\n    // - container's host node (this is done in the executeActionOnElementOrContainer)\n    // - container's host node (this is done here)\n    if (anchor !== native) {\n        // This is very strange to me (Misko). I would expect that the native is same as anchor. I\n        // don't see a reason why they should be different, but they are.\n        //\n        // If they are we need to process the second anchor as well.\n        applyToElementOrContainer(action, renderer, parentRElement, anchor, beforeNode);\n    }\n    for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n        const lView = lContainer[i];\n        applyView(lView[TVIEW], lView, renderer, action, parentRElement, anchor);\n    }\n}\n/**\n * Writes class/style to element.\n *\n * @param renderer Renderer to use.\n * @param isClassBased `true` if it should be written to `class` (`false` to write to `style`)\n * @param rNode The Node to write to.\n * @param prop Property to write to. This would be the class/style name.\n * @param value Value to write. If `null`/`undefined`/`false` this is considered a remove (set/add\n *        otherwise).\n */\nfunction applyStyling(renderer, isClassBased, rNode, prop, value) {\n    if (isClassBased) {\n        // We actually want JS true/false here because any truthy value should add the class\n        if (!value) {\n            ngDevMode && ngDevMode.rendererRemoveClass++;\n            renderer.removeClass(rNode, prop);\n        }\n        else {\n            ngDevMode && ngDevMode.rendererAddClass++;\n            renderer.addClass(rNode, prop);\n        }\n    }\n    else {\n        let flags = prop.indexOf('-') === -1 ? undefined : RendererStyleFlags2.DashCase;\n        if (value == null /** || value === undefined */) {\n            ngDevMode && ngDevMode.rendererRemoveStyle++;\n            renderer.removeStyle(rNode, prop, flags);\n        }\n        else {\n            // A value is important if it ends with `!important`. The style\n            // parser strips any semicolons at the end of the value.\n            const isImportant = typeof value === 'string' ? value.endsWith('!important') : false;\n            if (isImportant) {\n                // !important has to be stripped from the value for it to be valid.\n                value = value.slice(0, -10);\n                flags |= RendererStyleFlags2.Important;\n            }\n            ngDevMode && ngDevMode.rendererSetStyle++;\n            renderer.setStyle(rNode, prop, value, flags);\n        }\n    }\n}\n/**\n * Write `cssText` to `RElement`.\n *\n * This function does direct write without any reconciliation. Used for writing initial values, so\n * that static styling values do not pull in the style parser.\n *\n * @param renderer Renderer to use\n * @param element The element which needs to be updated.\n * @param newValue The new class list to write.\n */\nfunction writeDirectStyle(renderer, element, newValue) {\n    ngDevMode && assertString(newValue, '\\'newValue\\' should be a string');\n    renderer.setAttribute(element, 'style', newValue);\n    ngDevMode && ngDevMode.rendererSetStyle++;\n}\n/**\n * Write `className` to `RElement`.\n *\n * This function does direct write without any reconciliation. Used for writing initial values, so\n * that static styling values do not pull in the style parser.\n *\n * @param renderer Renderer to use\n * @param element The element which needs to be updated.\n * @param newValue The new class list to write.\n */\nfunction writeDirectClass(renderer, element, newValue) {\n    ngDevMode && assertString(newValue, '\\'newValue\\' should be a string');\n    if (newValue === '') {\n        // There are tests in `google3` which expect `element.getAttribute('class')` to be `null`.\n        renderer.removeAttribute(element, 'class');\n    }\n    else {\n        renderer.setAttribute(element, 'class', newValue);\n    }\n    ngDevMode && ngDevMode.rendererSetClassName++;\n}\n/** Sets up the static DOM attributes on an `RNode`. */\nfunction setupStaticAttributes(renderer, element, tNode) {\n    const { mergedAttrs, classes, styles } = tNode;\n    if (mergedAttrs !== null) {\n        setUpAttributes(renderer, element, mergedAttrs);\n    }\n    if (classes !== null) {\n        writeDirectClass(renderer, element, classes);\n    }\n    if (styles !== null) {\n        writeDirectStyle(renderer, element, styles);\n    }\n}\n\n/**\n * @fileoverview\n * A module to facilitate use of a Trusted Types policy internally within\n * Angular. It lazily constructs the Trusted Types policy, providing helper\n * utilities for promoting strings to Trusted Types. When Trusted Types are not\n * available, strings are used as a fallback.\n * @security All use of this module is security-sensitive and should go through\n * security review.\n */\n/**\n * The Trusted Types policy, or null if Trusted Types are not\n * enabled/supported, or undefined if the policy has not been created yet.\n */\nlet policy$1;\n/**\n * Returns the Trusted Types policy, or null if Trusted Types are not\n * enabled/supported. The first call to this function will create the policy.\n */\nfunction getPolicy$1() {\n    if (policy$1 === undefined) {\n        policy$1 = null;\n        if (_global.trustedTypes) {\n            try {\n                policy$1 = _global.trustedTypes.createPolicy('angular', {\n                    createHTML: (s) => s,\n                    createScript: (s) => s,\n                    createScriptURL: (s) => s,\n                });\n            }\n            catch {\n                // trustedTypes.createPolicy throws if called with a name that is\n                // already registered, even in report-only mode. Until the API changes,\n                // catch the error not to break the applications functionally. In such\n                // cases, the code will fall back to using strings.\n            }\n        }\n    }\n    return policy$1;\n}\n/**\n * Unsafely promote a string to a TrustedHTML, falling back to strings when\n * Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that the\n * provided string will never cause an XSS vulnerability if used in a context\n * that will be interpreted as HTML by a browser, e.g. when assigning to\n * element.innerHTML.\n */\nfunction trustedHTMLFromString(html) {\n    return getPolicy$1()?.createHTML(html) || html;\n}\n/**\n * Unsafely promote a string to a TrustedScript, falling back to strings when\n * Trusted Types are not available.\n * @security In particular, it must be assured that the provided string will\n * never cause an XSS vulnerability if used in a context that will be\n * interpreted and executed as a script by a browser, e.g. when calling eval.\n */\nfunction trustedScriptFromString(script) {\n    return getPolicy$1()?.createScript(script) || script;\n}\n/**\n * Unsafely promote a string to a TrustedScriptURL, falling back to strings\n * when Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that the\n * provided string will never cause an XSS vulnerability if used in a context\n * that will cause a browser to load and execute a resource, e.g. when\n * assigning to script.src.\n */\nfunction trustedScriptURLFromString(url) {\n    return getPolicy$1()?.createScriptURL(url) || url;\n}\n/**\n * Unsafely call the Function constructor with the given string arguments. It\n * is only available in development mode, and should be stripped out of\n * production code.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only called from development code, as use in production code can lead to\n * XSS vulnerabilities.\n */\nfunction newTrustedFunctionForDev(...args) {\n    if (typeof ngDevMode === 'undefined') {\n        throw new Error('newTrustedFunctionForDev should never be called in production');\n    }\n    if (!_global.trustedTypes) {\n        // In environments that don't support Trusted Types, fall back to the most\n        // straightforward implementation:\n        return new Function(...args);\n    }\n    // Chrome currently does not support passing TrustedScript to the Function\n    // constructor. The following implements the workaround proposed on the page\n    // below, where the Chromium bug is also referenced:\n    // https://github.com/w3c/webappsec-trusted-types/wiki/Trusted-Types-for-function-constructor\n    const fnArgs = args.slice(0, -1).join(',');\n    const fnBody = args[args.length - 1];\n    const body = `(function anonymous(${fnArgs}\n) { ${fnBody}\n})`;\n    // Using eval directly confuses the compiler and prevents this module from\n    // being stripped out of JS binaries even if not used. The global['eval']\n    // indirection fixes that.\n    const fn = _global['eval'](trustedScriptFromString(body));\n    if (fn.bind === undefined) {\n        // Workaround for a browser bug that only exists in Chrome 83, where passing\n        // a TrustedScript to eval just returns the TrustedScript back without\n        // evaluating it. In that case, fall back to the most straightforward\n        // implementation:\n        return new Function(...args);\n    }\n    // To completely mimic the behavior of calling \"new Function\", two more\n    // things need to happen:\n    // 1. Stringifying the resulting function should return its source code\n    fn.toString = () => body;\n    // 2. When calling the resulting function, `this` should refer to `global`\n    return fn.bind(_global);\n    // When Trusted Types support in Function constructors is widely available,\n    // the implementation of this function can be simplified to:\n    // return new Function(...args.map(a => trustedScriptFromString(a)));\n}\n\n/**\n * Validation function invoked at runtime for each binding that might potentially\n * represent a security-sensitive attribute of an <iframe>.\n * See `IFRAME_SECURITY_SENSITIVE_ATTRS` in the\n * `packages/compiler/src/schema/dom_security_schema.ts` script for the full list\n * of such attributes.\n *\n * @codeGenApi\n */\nfunction ɵɵvalidateIframeAttribute(attrValue, tagName, attrName) {\n    const lView = getLView();\n    const tNode = getSelectedTNode();\n    const element = getNativeByTNode(tNode, lView);\n    // Restrict any dynamic bindings of security-sensitive attributes/properties\n    // on an <iframe> for security reasons.\n    if (tNode.type === 2 /* TNodeType.Element */ && tagName.toLowerCase() === 'iframe') {\n        const iframe = element;\n        // Unset previously applied `src` and `srcdoc` if we come across a situation when\n        // a security-sensitive attribute is set later via an attribute/property binding.\n        iframe.src = '';\n        iframe.srcdoc = trustedHTMLFromString('');\n        // Also remove the <iframe> from the document.\n        nativeRemoveNode(lView[RENDERER], iframe);\n        const errorMessage = ngDevMode &&\n            `Angular has detected that the \\`${attrName}\\` was applied ` +\n                `as a binding to an <iframe>${getTemplateLocationDetails(lView)}. ` +\n                `For security reasons, the \\`${attrName}\\` can be set on an <iframe> ` +\n                `as a static attribute only. \\n` +\n                `To fix this, switch the \\`${attrName}\\` binding to a static attribute ` +\n                `in a template or in host bindings section.`;\n        throw new RuntimeError(-910 /* RuntimeErrorCode.UNSAFE_IFRAME_ATTRS */, errorMessage);\n    }\n    return attrValue;\n}\n\n/**\n * @fileoverview\n * A module to facilitate use of a Trusted Types policy internally within\n * Angular specifically for bypassSecurityTrust* and custom sanitizers. It\n * lazily constructs the Trusted Types policy, providing helper utilities for\n * promoting strings to Trusted Types. When Trusted Types are not available,\n * strings are used as a fallback.\n * @security All use of this module is security-sensitive and should go through\n * security review.\n */\n/**\n * The Trusted Types policy, or null if Trusted Types are not\n * enabled/supported, or undefined if the policy has not been created yet.\n */\nlet policy;\n/**\n * Returns the Trusted Types policy, or null if Trusted Types are not\n * enabled/supported. The first call to this function will create the policy.\n */\nfunction getPolicy() {\n    if (policy === undefined) {\n        policy = null;\n        if (_global.trustedTypes) {\n            try {\n                policy = _global.trustedTypes\n                    .createPolicy('angular#unsafe-bypass', {\n                    createHTML: (s) => s,\n                    createScript: (s) => s,\n                    createScriptURL: (s) => s,\n                });\n            }\n            catch {\n                // trustedTypes.createPolicy throws if called with a name that is\n                // already registered, even in report-only mode. Until the API changes,\n                // catch the error not to break the applications functionally. In such\n                // cases, the code will fall back to using strings.\n            }\n        }\n    }\n    return policy;\n}\n/**\n * Unsafely promote a string to a TrustedHTML, falling back to strings when\n * Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only passed strings that come directly from custom sanitizers or the\n * bypassSecurityTrust* functions.\n */\nfunction trustedHTMLFromStringBypass(html) {\n    return getPolicy()?.createHTML(html) || html;\n}\n/**\n * Unsafely promote a string to a TrustedScript, falling back to strings when\n * Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only passed strings that come directly from custom sanitizers or the\n * bypassSecurityTrust* functions.\n */\nfunction trustedScriptFromStringBypass(script) {\n    return getPolicy()?.createScript(script) || script;\n}\n/**\n * Unsafely promote a string to a TrustedScriptURL, falling back to strings\n * when Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only passed strings that come directly from custom sanitizers or the\n * bypassSecurityTrust* functions.\n */\nfunction trustedScriptURLFromStringBypass(url) {\n    return getPolicy()?.createScriptURL(url) || url;\n}\n\nclass SafeValueImpl {\n    constructor(changingThisBreaksApplicationSecurity) {\n        this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;\n    }\n    toString() {\n        return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity}` +\n            ` (see ${XSS_SECURITY_URL})`;\n    }\n}\nclass SafeHtmlImpl extends SafeValueImpl {\n    getTypeName() {\n        return \"HTML\" /* BypassType.Html */;\n    }\n}\nclass SafeStyleImpl extends SafeValueImpl {\n    getTypeName() {\n        return \"Style\" /* BypassType.Style */;\n    }\n}\nclass SafeScriptImpl extends SafeValueImpl {\n    getTypeName() {\n        return \"Script\" /* BypassType.Script */;\n    }\n}\nclass SafeUrlImpl extends SafeValueImpl {\n    getTypeName() {\n        return \"URL\" /* BypassType.Url */;\n    }\n}\nclass SafeResourceUrlImpl extends SafeValueImpl {\n    getTypeName() {\n        return \"ResourceURL\" /* BypassType.ResourceUrl */;\n    }\n}\nfunction unwrapSafeValue(value) {\n    return value instanceof SafeValueImpl ? value.changingThisBreaksApplicationSecurity :\n        value;\n}\nfunction allowSanitizationBypassAndThrow(value, type) {\n    const actualType = getSanitizationBypassType(value);\n    if (actualType != null && actualType !== type) {\n        // Allow ResourceURLs in URL contexts, they are strictly more trusted.\n        if (actualType === \"ResourceURL\" /* BypassType.ResourceUrl */ && type === \"URL\" /* BypassType.Url */)\n            return true;\n        throw new Error(`Required a safe ${type}, got a ${actualType} (see ${XSS_SECURITY_URL})`);\n    }\n    return actualType === type;\n}\nfunction getSanitizationBypassType(value) {\n    return value instanceof SafeValueImpl && value.getTypeName() || null;\n}\n/**\n * Mark `html` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link htmlSanitizer} to be trusted implicitly.\n *\n * @param trustedHtml `html` string which needs to be implicitly trusted.\n * @returns a `html` which has been branded to be implicitly trusted.\n */\nfunction bypassSanitizationTrustHtml(trustedHtml) {\n    return new SafeHtmlImpl(trustedHtml);\n}\n/**\n * Mark `style` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link styleSanitizer} to be trusted implicitly.\n *\n * @param trustedStyle `style` string which needs to be implicitly trusted.\n * @returns a `style` hich has been branded to be implicitly trusted.\n */\nfunction bypassSanitizationTrustStyle(trustedStyle) {\n    return new SafeStyleImpl(trustedStyle);\n}\n/**\n * Mark `script` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link scriptSanitizer} to be trusted implicitly.\n *\n * @param trustedScript `script` string which needs to be implicitly trusted.\n * @returns a `script` which has been branded to be implicitly trusted.\n */\nfunction bypassSanitizationTrustScript(trustedScript) {\n    return new SafeScriptImpl(trustedScript);\n}\n/**\n * Mark `url` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link urlSanitizer} to be trusted implicitly.\n *\n * @param trustedUrl `url` string which needs to be implicitly trusted.\n * @returns a `url`  which has been branded to be implicitly trusted.\n */\nfunction bypassSanitizationTrustUrl(trustedUrl) {\n    return new SafeUrlImpl(trustedUrl);\n}\n/**\n * Mark `url` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link resourceUrlSanitizer} to be trusted implicitly.\n *\n * @param trustedResourceUrl `url` string which needs to be implicitly trusted.\n * @returns a `url` which has been branded to be implicitly trusted.\n */\nfunction bypassSanitizationTrustResourceUrl(trustedResourceUrl) {\n    return new SafeResourceUrlImpl(trustedResourceUrl);\n}\n\n/**\n * This helper is used to get hold of an inert tree of DOM elements containing dirty HTML\n * that needs sanitizing.\n * Depending upon browser support we use one of two strategies for doing this.\n * Default: DOMParser strategy\n * Fallback: InertDocument strategy\n */\nfunction getInertBodyHelper(defaultDoc) {\n    const inertDocumentHelper = new InertDocumentHelper(defaultDoc);\n    return isDOMParserAvailable() ? new DOMParserHelper(inertDocumentHelper) : inertDocumentHelper;\n}\n/**\n * Uses DOMParser to create and fill an inert body element.\n * This is the default strategy used in browsers that support it.\n */\nclass DOMParserHelper {\n    constructor(inertDocumentHelper) {\n        this.inertDocumentHelper = inertDocumentHelper;\n    }\n    getInertBodyElement(html) {\n        // We add these extra elements to ensure that the rest of the content is parsed as expected\n        // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the\n        // `<head>` tag. Note that the `<body>` tag is closed implicitly to prevent unclosed tags\n        // in `html` from consuming the otherwise explicit `</body>` tag.\n        html = '<body><remove></remove>' + html;\n        try {\n            const body = new window.DOMParser()\n                .parseFromString(trustedHTMLFromString(html), 'text/html')\n                .body;\n            if (body === null) {\n                // In some browsers (e.g. Mozilla/5.0 iPad AppleWebKit Mobile) the `body` property only\n                // becomes available in the following tick of the JS engine. In that case we fall back to\n                // the `inertDocumentHelper` instead.\n                return this.inertDocumentHelper.getInertBodyElement(html);\n            }\n            body.removeChild(body.firstChild);\n            return body;\n        }\n        catch {\n            return null;\n        }\n    }\n}\n/**\n * Use an HTML5 `template` element to create and fill an inert DOM element.\n * This is the fallback strategy if the browser does not support DOMParser.\n */\nclass InertDocumentHelper {\n    constructor(defaultDoc) {\n        this.defaultDoc = defaultDoc;\n        this.inertDocument = this.defaultDoc.implementation.createHTMLDocument('sanitization-inert');\n    }\n    getInertBodyElement(html) {\n        const templateEl = this.inertDocument.createElement('template');\n        templateEl.innerHTML = trustedHTMLFromString(html);\n        return templateEl;\n    }\n}\n/**\n * We need to determine whether the DOMParser exists in the global context and\n * supports parsing HTML; HTML parsing support is not as wide as other formats, see\n * https://developer.mozilla.org/en-US/docs/Web/API/DOMParser#Browser_compatibility.\n *\n * @suppress {uselessCode}\n */\nfunction isDOMParserAvailable() {\n    try {\n        return !!new window.DOMParser().parseFromString(trustedHTMLFromString(''), 'text/html');\n    }\n    catch {\n        return false;\n    }\n}\n\n/**\n * A pattern that recognizes URLs that are safe wrt. XSS in URL navigation\n * contexts.\n *\n * This regular expression matches a subset of URLs that will not cause script\n * execution if used in URL context within a HTML document. Specifically, this\n * regular expression matches if:\n * (1) Either a protocol that is not javascript:, and that has valid characters\n *     (alphanumeric or [+-.]).\n * (2) or no protocol.  A protocol must be followed by a colon. The below\n *     allows that by allowing colons only after one of the characters [/?#].\n *     A colon after a hash (#) must be in the fragment.\n *     Otherwise, a colon after a (?) must be in a query.\n *     Otherwise, a colon after a single solidus (/) must be in a path.\n *     Otherwise, a colon after a double solidus (//) must be in the authority\n *     (before port).\n *\n * The pattern disallows &, used in HTML entity declarations before\n * one of the characters in [/?#]. This disallows HTML entities used in the\n * protocol name, which should never happen, e.g. \"h&#116;tp\" for \"http\".\n * It also disallows HTML entities in the first path part of a relative path,\n * e.g. \"foo&lt;bar/baz\".  Our existing escaping functions should not produce\n * that. More importantly, it disallows masking of a colon,\n * e.g. \"javascript&#58;...\".\n *\n * This regular expression was taken from the Closure sanitization library.\n */\nconst SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\\/?#]*(?:[\\/?#]|$))/i;\nfunction _sanitizeUrl(url) {\n    url = String(url);\n    if (url.match(SAFE_URL_PATTERN))\n        return url;\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        console.warn(`WARNING: sanitizing unsafe URL value ${url} (see ${XSS_SECURITY_URL})`);\n    }\n    return 'unsafe:' + url;\n}\n\nfunction tagSet(tags) {\n    const res = {};\n    for (const t of tags.split(','))\n        res[t] = true;\n    return res;\n}\nfunction merge(...sets) {\n    const res = {};\n    for (const s of sets) {\n        for (const v in s) {\n            if (s.hasOwnProperty(v))\n                res[v] = true;\n        }\n    }\n    return res;\n}\n// Good source of info about elements and attributes\n// https://html.spec.whatwg.org/#semantics\n// https://simon.html5.org/html-elements\n// Safe Void Elements - HTML5\n// https://html.spec.whatwg.org/#void-elements\nconst VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');\n// Elements that you can, intentionally, leave open (and which close themselves)\n// https://html.spec.whatwg.org/#optional-tags\nconst OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');\nconst OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');\nconst OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);\n// Safe Block Elements - HTML5\nconst BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet('address,article,' +\n    'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' +\n    'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'));\n// Inline Elements - HTML5\nconst INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet('a,abbr,acronym,audio,b,' +\n    'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' +\n    'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));\nconst VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);\n// Attributes that have href and hence need to be sanitized\nconst URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');\nconst HTML_ATTRS = tagSet('abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' +\n    'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' +\n    'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' +\n    'scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,' +\n    'valign,value,vspace,width');\n// Accessibility attributes as per WAI-ARIA 1.1 (W3C Working Draft 14 December 2018)\nconst ARIA_ATTRS = tagSet('aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,' +\n    'aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,' +\n    'aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,' +\n    'aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,' +\n    'aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,' +\n    'aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,' +\n    'aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext');\n// NB: This currently consciously doesn't support SVG. SVG sanitization has had several security\n// issues in the past, so it seems safer to leave it out if possible. If support for binding SVG via\n// innerHTML is required, SVG attributes should be added here.\n// NB: Sanitization does not allow <form> elements or other active elements (<button> etc). Those\n// can be sanitized, but they increase security surface area without a legitimate use case, so they\n// are left out here.\nconst VALID_ATTRS = merge(URI_ATTRS, HTML_ATTRS, ARIA_ATTRS);\n// Elements whose content should not be traversed/preserved, if the elements themselves are invalid.\n//\n// Typically, `<invalid>Some content</invalid>` would traverse (and in this case preserve)\n// `Some content`, but strip `invalid-element` opening/closing tags. For some elements, though, we\n// don't want to preserve the content, if the elements themselves are going to be removed.\nconst SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet('script,style,template');\n/**\n * SanitizingHtmlSerializer serializes a DOM fragment, stripping out any unsafe elements and unsafe\n * attributes.\n */\nclass SanitizingHtmlSerializer {\n    constructor() {\n        // Explicitly track if something was stripped, to avoid accidentally warning of sanitization just\n        // because characters were re-encoded.\n        this.sanitizedSomething = false;\n        this.buf = [];\n    }\n    sanitizeChildren(el) {\n        // This cannot use a TreeWalker, as it has to run on Angular's various DOM adapters.\n        // However this code never accesses properties off of `document` before deleting its contents\n        // again, so it shouldn't be vulnerable to DOM clobbering.\n        let current = el.firstChild;\n        let traverseContent = true;\n        while (current) {\n            if (current.nodeType === Node.ELEMENT_NODE) {\n                traverseContent = this.startElement(current);\n            }\n            else if (current.nodeType === Node.TEXT_NODE) {\n                this.chars(current.nodeValue);\n            }\n            else {\n                // Strip non-element, non-text nodes.\n                this.sanitizedSomething = true;\n            }\n            if (traverseContent && current.firstChild) {\n                current = current.firstChild;\n                continue;\n            }\n            while (current) {\n                // Leaving the element. Walk up and to the right, closing tags as we go.\n                if (current.nodeType === Node.ELEMENT_NODE) {\n                    this.endElement(current);\n                }\n                let next = this.checkClobberedElement(current, current.nextSibling);\n                if (next) {\n                    current = next;\n                    break;\n                }\n                current = this.checkClobberedElement(current, current.parentNode);\n            }\n        }\n        return this.buf.join('');\n    }\n    /**\n     * Sanitizes an opening element tag (if valid) and returns whether the element's contents should\n     * be traversed. Element content must always be traversed (even if the element itself is not\n     * valid/safe), unless the element is one of `SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS`.\n     *\n     * @param element The element to sanitize.\n     * @return True if the element's contents should be traversed.\n     */\n    startElement(element) {\n        const tagName = element.nodeName.toLowerCase();\n        if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {\n            this.sanitizedSomething = true;\n            return !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);\n        }\n        this.buf.push('<');\n        this.buf.push(tagName);\n        const elAttrs = element.attributes;\n        for (let i = 0; i < elAttrs.length; i++) {\n            const elAttr = elAttrs.item(i);\n            const attrName = elAttr.name;\n            const lower = attrName.toLowerCase();\n            if (!VALID_ATTRS.hasOwnProperty(lower)) {\n                this.sanitizedSomething = true;\n                continue;\n            }\n            let value = elAttr.value;\n            // TODO(martinprobst): Special case image URIs for data:image/...\n            if (URI_ATTRS[lower])\n                value = _sanitizeUrl(value);\n            this.buf.push(' ', attrName, '=\"', encodeEntities(value), '\"');\n        }\n        this.buf.push('>');\n        return true;\n    }\n    endElement(current) {\n        const tagName = current.nodeName.toLowerCase();\n        if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {\n            this.buf.push('</');\n            this.buf.push(tagName);\n            this.buf.push('>');\n        }\n    }\n    chars(chars) {\n        this.buf.push(encodeEntities(chars));\n    }\n    checkClobberedElement(node, nextNode) {\n        if (nextNode &&\n            (node.compareDocumentPosition(nextNode) &\n                Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) {\n            throw new Error(`Failed to sanitize html because the element is clobbered: ${node.outerHTML}`);\n        }\n        return nextNode;\n    }\n}\n// Regular Expressions for parsing tags and attributes\nconst SURROGATE_PAIR_REGEXP = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n// ! to ~ is the ASCII range.\nconst NON_ALPHANUMERIC_REGEXP = /([^\\#-~ |!])/g;\n/**\n * Escapes all potentially dangerous characters, so that the\n * resulting string can be safely inserted into attribute or\n * element text.\n * @param value\n */\nfunction encodeEntities(value) {\n    return value.replace(/&/g, '&amp;')\n        .replace(SURROGATE_PAIR_REGEXP, function (match) {\n        const hi = match.charCodeAt(0);\n        const low = match.charCodeAt(1);\n        return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';\n    })\n        .replace(NON_ALPHANUMERIC_REGEXP, function (match) {\n        return '&#' + match.charCodeAt(0) + ';';\n    })\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;');\n}\nlet inertBodyHelper;\n/**\n * Sanitizes the given unsafe, untrusted HTML fragment, and returns HTML text that is safe to add to\n * the DOM in a browser environment.\n */\nfunction _sanitizeHtml(defaultDoc, unsafeHtmlInput) {\n    let inertBodyElement = null;\n    try {\n        inertBodyHelper = inertBodyHelper || getInertBodyHelper(defaultDoc);\n        // Make sure unsafeHtml is actually a string (TypeScript types are not enforced at runtime).\n        let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';\n        inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);\n        // mXSS protection. Repeatedly parse the document to make sure it stabilizes, so that a browser\n        // trying to auto-correct incorrect HTML cannot cause formerly inert HTML to become dangerous.\n        let mXSSAttempts = 5;\n        let parsedHtml = unsafeHtml;\n        do {\n            if (mXSSAttempts === 0) {\n                throw new Error('Failed to sanitize html because the input is unstable');\n            }\n            mXSSAttempts--;\n            unsafeHtml = parsedHtml;\n            parsedHtml = inertBodyElement.innerHTML;\n            inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);\n        } while (unsafeHtml !== parsedHtml);\n        const sanitizer = new SanitizingHtmlSerializer();\n        const safeHtml = sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement) || inertBodyElement);\n        if ((typeof ngDevMode === 'undefined' || ngDevMode) && sanitizer.sanitizedSomething) {\n            console.warn(`WARNING: sanitizing HTML stripped some content, see ${XSS_SECURITY_URL}`);\n        }\n        return trustedHTMLFromString(safeHtml);\n    }\n    finally {\n        // In case anything goes wrong, clear out inertElement to reset the entire DOM structure.\n        if (inertBodyElement) {\n            const parent = getTemplateContent(inertBodyElement) || inertBodyElement;\n            while (parent.firstChild) {\n                parent.removeChild(parent.firstChild);\n            }\n        }\n    }\n}\nfunction getTemplateContent(el) {\n    return 'content' in el /** Microsoft/TypeScript#21517 */ && isTemplateElement(el) ?\n        el.content :\n        null;\n}\nfunction isTemplateElement(el) {\n    return el.nodeType === Node.ELEMENT_NODE && el.nodeName === 'TEMPLATE';\n}\n\n/**\n * A SecurityContext marks a location that has dangerous security implications, e.g. a DOM property\n * like `innerHTML` that could cause Cross Site Scripting (XSS) security bugs when improperly\n * handled.\n *\n * See DomSanitizer for more details on security in Angular applications.\n *\n * @publicApi\n */\nvar SecurityContext;\n(function (SecurityContext) {\n    SecurityContext[SecurityContext[\"NONE\"] = 0] = \"NONE\";\n    SecurityContext[SecurityContext[\"HTML\"] = 1] = \"HTML\";\n    SecurityContext[SecurityContext[\"STYLE\"] = 2] = \"STYLE\";\n    SecurityContext[SecurityContext[\"SCRIPT\"] = 3] = \"SCRIPT\";\n    SecurityContext[SecurityContext[\"URL\"] = 4] = \"URL\";\n    SecurityContext[SecurityContext[\"RESOURCE_URL\"] = 5] = \"RESOURCE_URL\";\n})(SecurityContext || (SecurityContext = {}));\n\n/**\n * An `html` sanitizer which converts untrusted `html` **string** into trusted string by removing\n * dangerous content.\n *\n * This method parses the `html` and locates potentially dangerous content (such as urls and\n * javascript) and removes it.\n *\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustHtml}.\n *\n * @param unsafeHtml untrusted `html`, typically from the user.\n * @returns `html` string which is safe to display to user, because all of the dangerous javascript\n * and urls have been removed.\n *\n * @codeGenApi\n */\nfunction ɵɵsanitizeHtml(unsafeHtml) {\n    const sanitizer = getSanitizer();\n    if (sanitizer) {\n        return trustedHTMLFromStringBypass(sanitizer.sanitize(SecurityContext.HTML, unsafeHtml) || '');\n    }\n    if (allowSanitizationBypassAndThrow(unsafeHtml, \"HTML\" /* BypassType.Html */)) {\n        return trustedHTMLFromStringBypass(unwrapSafeValue(unsafeHtml));\n    }\n    return _sanitizeHtml(getDocument(), renderStringify(unsafeHtml));\n}\n/**\n * A `style` sanitizer which converts untrusted `style` **string** into trusted string by removing\n * dangerous content.\n *\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustStyle}.\n *\n * @param unsafeStyle untrusted `style`, typically from the user.\n * @returns `style` string which is safe to bind to the `style` properties.\n *\n * @codeGenApi\n */\nfunction ɵɵsanitizeStyle(unsafeStyle) {\n    const sanitizer = getSanitizer();\n    if (sanitizer) {\n        return sanitizer.sanitize(SecurityContext.STYLE, unsafeStyle) || '';\n    }\n    if (allowSanitizationBypassAndThrow(unsafeStyle, \"Style\" /* BypassType.Style */)) {\n        return unwrapSafeValue(unsafeStyle);\n    }\n    return renderStringify(unsafeStyle);\n}\n/**\n * A `url` sanitizer which converts untrusted `url` **string** into trusted string by removing\n * dangerous\n * content.\n *\n * This method parses the `url` and locates potentially dangerous content (such as javascript) and\n * removes it.\n *\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustUrl}.\n *\n * @param unsafeUrl untrusted `url`, typically from the user.\n * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because\n * all of the dangerous javascript has been removed.\n *\n * @codeGenApi\n */\nfunction ɵɵsanitizeUrl(unsafeUrl) {\n    const sanitizer = getSanitizer();\n    if (sanitizer) {\n        return sanitizer.sanitize(SecurityContext.URL, unsafeUrl) || '';\n    }\n    if (allowSanitizationBypassAndThrow(unsafeUrl, \"URL\" /* BypassType.Url */)) {\n        return unwrapSafeValue(unsafeUrl);\n    }\n    return _sanitizeUrl(renderStringify(unsafeUrl));\n}\n/**\n * A `url` sanitizer which only lets trusted `url`s through.\n *\n * This passes only `url`s marked trusted by calling {@link bypassSanitizationTrustResourceUrl}.\n *\n * @param unsafeResourceUrl untrusted `url`, typically from the user.\n * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because\n * only trusted `url`s have been allowed to pass.\n *\n * @codeGenApi\n */\nfunction ɵɵsanitizeResourceUrl(unsafeResourceUrl) {\n    const sanitizer = getSanitizer();\n    if (sanitizer) {\n        return trustedScriptURLFromStringBypass(sanitizer.sanitize(SecurityContext.RESOURCE_URL, unsafeResourceUrl) || '');\n    }\n    if (allowSanitizationBypassAndThrow(unsafeResourceUrl, \"ResourceURL\" /* BypassType.ResourceUrl */)) {\n        return trustedScriptURLFromStringBypass(unwrapSafeValue(unsafeResourceUrl));\n    }\n    throw new RuntimeError(904 /* RuntimeErrorCode.UNSAFE_VALUE_IN_RESOURCE_URL */, ngDevMode && `unsafe value used in a resource URL context (see ${XSS_SECURITY_URL})`);\n}\n/**\n * A `script` sanitizer which only lets trusted javascript through.\n *\n * This passes only `script`s marked trusted by calling {@link\n * bypassSanitizationTrustScript}.\n *\n * @param unsafeScript untrusted `script`, typically from the user.\n * @returns `url` string which is safe to bind to the `<script>` element such as `<img src>`,\n * because only trusted `scripts` have been allowed to pass.\n *\n * @codeGenApi\n */\nfunction ɵɵsanitizeScript(unsafeScript) {\n    const sanitizer = getSanitizer();\n    if (sanitizer) {\n        return trustedScriptFromStringBypass(sanitizer.sanitize(SecurityContext.SCRIPT, unsafeScript) || '');\n    }\n    if (allowSanitizationBypassAndThrow(unsafeScript, \"Script\" /* BypassType.Script */)) {\n        return trustedScriptFromStringBypass(unwrapSafeValue(unsafeScript));\n    }\n    throw new RuntimeError(905 /* RuntimeErrorCode.UNSAFE_VALUE_IN_SCRIPT */, ngDevMode && 'unsafe value used in a script context');\n}\n/**\n * A template tag function for promoting the associated constant literal to a\n * TrustedHTML. Interpolation is explicitly not allowed.\n *\n * @param html constant template literal containing trusted HTML.\n * @returns TrustedHTML wrapping `html`.\n *\n * @security This is a security-sensitive function and should only be used to\n * convert constant values of attributes and properties found in\n * application-provided Angular templates to TrustedHTML.\n *\n * @codeGenApi\n */\nfunction ɵɵtrustConstantHtml(html) {\n    // The following runtime check ensures that the function was called as a\n    // template tag (e.g. ɵɵtrustConstantHtml`content`), without any interpolation\n    // (e.g. not ɵɵtrustConstantHtml`content ${variable}`). A TemplateStringsArray\n    // is an array with a `raw` property that is also an array. The associated\n    // template literal has no interpolation if and only if the length of the\n    // TemplateStringsArray is 1.\n    if (ngDevMode && (!Array.isArray(html) || !Array.isArray(html.raw) || html.length !== 1)) {\n        throw new Error(`Unexpected interpolation in trusted HTML constant: ${html.join('?')}`);\n    }\n    return trustedHTMLFromString(html[0]);\n}\n/**\n * A template tag function for promoting the associated constant literal to a\n * TrustedScriptURL. Interpolation is explicitly not allowed.\n *\n * @param url constant template literal containing a trusted script URL.\n * @returns TrustedScriptURL wrapping `url`.\n *\n * @security This is a security-sensitive function and should only be used to\n * convert constant values of attributes and properties found in\n * application-provided Angular templates to TrustedScriptURL.\n *\n * @codeGenApi\n */\nfunction ɵɵtrustConstantResourceUrl(url) {\n    // The following runtime check ensures that the function was called as a\n    // template tag (e.g. ɵɵtrustConstantResourceUrl`content`), without any\n    // interpolation (e.g. not ɵɵtrustConstantResourceUrl`content ${variable}`). A\n    // TemplateStringsArray is an array with a `raw` property that is also an\n    // array. The associated template literal has no interpolation if and only if\n    // the length of the TemplateStringsArray is 1.\n    if (ngDevMode && (!Array.isArray(url) || !Array.isArray(url.raw) || url.length !== 1)) {\n        throw new Error(`Unexpected interpolation in trusted URL constant: ${url.join('?')}`);\n    }\n    return trustedScriptURLFromString(url[0]);\n}\n/**\n * Detects which sanitizer to use for URL property, based on tag name and prop name.\n *\n * The rules are based on the RESOURCE_URL context config from\n * `packages/compiler/src/schema/dom_security_schema.ts`.\n * If tag and prop names don't match Resource URL schema, use URL sanitizer.\n */\nfunction getUrlSanitizer(tag, prop) {\n    if ((prop === 'src' &&\n        (tag === 'embed' || tag === 'frame' || tag === 'iframe' || tag === 'media' ||\n            tag === 'script')) ||\n        (prop === 'href' && (tag === 'base' || tag === 'link'))) {\n        return ɵɵsanitizeResourceUrl;\n    }\n    return ɵɵsanitizeUrl;\n}\n/**\n * Sanitizes URL, selecting sanitizer function based on tag and property names.\n *\n * This function is used in case we can't define security context at compile time, when only prop\n * name is available. This happens when we generate host bindings for Directives/Components. The\n * host element is unknown at compile time, so we defer calculation of specific sanitizer to\n * runtime.\n *\n * @param unsafeUrl untrusted `url`, typically from the user.\n * @param tag target element tag name.\n * @param prop name of the property that contains the value.\n * @returns `url` string which is safe to bind.\n *\n * @codeGenApi\n */\nfunction ɵɵsanitizeUrlOrResourceUrl(unsafeUrl, tag, prop) {\n    return getUrlSanitizer(tag, prop)(unsafeUrl);\n}\nfunction validateAgainstEventProperties(name) {\n    if (name.toLowerCase().startsWith('on')) {\n        const errorMessage = `Binding to event property '${name}' is disallowed for security reasons, ` +\n            `please use (${name.slice(2)})=...` +\n            `\\nIf '${name}' is a directive input, make sure the directive is imported by the` +\n            ` current module.`;\n        throw new RuntimeError(306 /* RuntimeErrorCode.INVALID_EVENT_BINDING */, errorMessage);\n    }\n}\nfunction validateAgainstEventAttributes(name) {\n    if (name.toLowerCase().startsWith('on')) {\n        const errorMessage = `Binding to event attribute '${name}' is disallowed for security reasons, ` +\n            `please use (${name.slice(2)})=...`;\n        throw new RuntimeError(306 /* RuntimeErrorCode.INVALID_EVENT_BINDING */, errorMessage);\n    }\n}\nfunction getSanitizer() {\n    const lView = getLView();\n    return lView && lView[ENVIRONMENT].sanitizer;\n}\n\n/**\n * Create a `StateKey<T>` that can be used to store value of type T with `TransferState`.\n *\n * Example:\n *\n * ```\n * const COUNTER_KEY = makeStateKey<number>('counter');\n * let value = 10;\n *\n * transferState.set(COUNTER_KEY, value);\n * ```\n *\n * @publicApi\n */\nfunction makeStateKey(key) {\n    return key;\n}\nfunction initTransferState() {\n    const transferState = new TransferState();\n    if (inject$1(PLATFORM_ID) === 'browser') {\n        transferState.store = retrieveTransferredState(getDocument(), inject$1(APP_ID));\n    }\n    return transferState;\n}\n/**\n * A key value store that is transferred from the application on the server side to the application\n * on the client side.\n *\n * The `TransferState` is available as an injectable token.\n * On the client, just inject this token using DI and use it, it will be lazily initialized.\n * On the server it's already included if `renderApplication` function is used. Otherwise, import\n * the `ServerTransferStateModule` module to make the `TransferState` available.\n *\n * The values in the store are serialized/deserialized using JSON.stringify/JSON.parse. So only\n * boolean, number, string, null and non-class objects will be serialized and deserialized in a\n * non-lossy manner.\n *\n * @publicApi\n */\nclass TransferState {\n    constructor() {\n        /** @internal */\n        this.store = {};\n        this.onSerializeCallbacks = {};\n    }\n    /** @nocollapse */\n    static { this.ɵprov = \n    /** @pureOrBreakMyCode */ ɵɵdefineInjectable({\n        token: TransferState,\n        providedIn: 'root',\n        factory: initTransferState,\n    }); }\n    /**\n     * Get the value corresponding to a key. Return `defaultValue` if key is not found.\n     */\n    get(key, defaultValue) {\n        return this.store[key] !== undefined ? this.store[key] : defaultValue;\n    }\n    /**\n     * Set the value corresponding to a key.\n     */\n    set(key, value) {\n        this.store[key] = value;\n    }\n    /**\n     * Remove a key from the store.\n     */\n    remove(key) {\n        delete this.store[key];\n    }\n    /**\n     * Test whether a key exists in the store.\n     */\n    hasKey(key) {\n        return this.store.hasOwnProperty(key);\n    }\n    /**\n     * Indicates whether the state is empty.\n     */\n    get isEmpty() {\n        return Object.keys(this.store).length === 0;\n    }\n    /**\n     * Register a callback to provide the value for a key when `toJson` is called.\n     */\n    onSerialize(key, callback) {\n        this.onSerializeCallbacks[key] = callback;\n    }\n    /**\n     * Serialize the current state of the store to JSON.\n     */\n    toJson() {\n        // Call the onSerialize callbacks and put those values into the store.\n        for (const key in this.onSerializeCallbacks) {\n            if (this.onSerializeCallbacks.hasOwnProperty(key)) {\n                try {\n                    this.store[key] = this.onSerializeCallbacks[key]();\n                }\n                catch (e) {\n                    console.warn('Exception in onSerialize callback: ', e);\n                }\n            }\n        }\n        // Escape script tag to avoid break out of <script> tag in serialized output.\n        // Encoding of `<` is the same behaviour as G3 script_builders.\n        return JSON.stringify(this.store).replace(/</g, '\\\\u003C');\n    }\n}\nfunction retrieveTransferredState(doc, appId) {\n    // Locate the script tag with the JSON data transferred from the server.\n    // The id of the script tag is set to the Angular appId + 'state'.\n    const script = doc.getElementById(appId + '-state');\n    if (script?.textContent) {\n        try {\n            // Avoid using any here as it triggers lint errors in google3 (any is not allowed).\n            // Decoding of `<` is done of the box by browsers and node.js, same behaviour as G3\n            // script_builders.\n            return JSON.parse(script.textContent);\n        }\n        catch (e) {\n            console.warn('Exception while restoring TransferState for app ' + appId, e);\n        }\n    }\n    return {};\n}\n\n/** Encodes that the node lookup should start from the host node of this component. */\nconst REFERENCE_NODE_HOST = 'h';\n/** Encodes that the node lookup should start from the document body node. */\nconst REFERENCE_NODE_BODY = 'b';\n/**\n * Describes navigation steps that the runtime logic need to perform,\n * starting from a given (known) element.\n */\nvar NodeNavigationStep;\n(function (NodeNavigationStep) {\n    NodeNavigationStep[\"FirstChild\"] = \"f\";\n    NodeNavigationStep[\"NextSibling\"] = \"n\";\n})(NodeNavigationStep || (NodeNavigationStep = {}));\n/**\n * Keys within serialized view data structure to represent various\n * parts. See the `SerializedView` interface below for additional information.\n */\nconst ELEMENT_CONTAINERS = 'e';\nconst TEMPLATES = 't';\nconst CONTAINERS = 'c';\nconst MULTIPLIER = 'x';\nconst NUM_ROOT_NODES = 'r';\nconst TEMPLATE_ID = 'i'; // as it's also an \"id\"\nconst NODES = 'n';\nconst DISCONNECTED_NODES = 'd';\n\n/**\n * The name of the key used in the TransferState collection,\n * where hydration information is located.\n */\nconst TRANSFER_STATE_TOKEN_ID = '__ɵnghData__';\n/**\n * Lookup key used to reference DOM hydration data (ngh) in `TransferState`.\n */\nconst NGH_DATA_KEY = makeStateKey(TRANSFER_STATE_TOKEN_ID);\n/**\n * The name of the attribute that would be added to host component\n * nodes and contain a reference to a particular slot in transferred\n * state that contains the necessary hydration info for this component.\n */\nconst NGH_ATTR_NAME = 'ngh';\n/**\n * Marker used in a comment node to ensure hydration content integrity\n */\nconst SSR_CONTENT_INTEGRITY_MARKER = 'nghm';\n/**\n * Reference to a function that reads `ngh` attribute value from a given RNode\n * and retrieves hydration information from the TransferState using that value\n * as an index. Returns `null` by default, when hydration is not enabled.\n *\n * @param rNode Component's host element.\n * @param injector Injector that this component has access to.\n * @param isRootView Specifies whether we trying to read hydration info for the root view.\n */\nlet _retrieveHydrationInfoImpl = (rNode, injector, isRootView) => null;\nfunction retrieveHydrationInfoImpl(rNode, injector, isRootView = false) {\n    let nghAttrValue = rNode.getAttribute(NGH_ATTR_NAME);\n    if (nghAttrValue == null)\n        return null;\n    // For cases when a root component also acts as an anchor node for a ViewContainerRef\n    // (for example, when ViewContainerRef is injected in a root component), there is a need\n    // to serialize information about the component itself, as well as an LContainer that\n    // represents this ViewContainerRef. Effectively, we need to serialize 2 pieces of info:\n    // (1) hydration info for the root component itself and (2) hydration info for the\n    // ViewContainerRef instance (an LContainer). Each piece of information is included into\n    // the hydration data (in the TransferState object) separately, thus we end up with 2 ids.\n    // Since we only have 1 root element, we encode both bits of info into a single string:\n    // ids are separated by the `|` char (e.g. `10|25`, where `10` is the ngh for a component view\n    // and 25 is the `ngh` for a root view which holds LContainer).\n    const [componentViewNgh, rootViewNgh] = nghAttrValue.split('|');\n    nghAttrValue = isRootView ? rootViewNgh : componentViewNgh;\n    if (!nghAttrValue)\n        return null;\n    // We've read one of the ngh ids, keep the remaining one, so that\n    // we can set it back on the DOM element.\n    const remainingNgh = isRootView ? componentViewNgh : (rootViewNgh ? `|${rootViewNgh}` : '');\n    let data = {};\n    // An element might have an empty `ngh` attribute value (e.g. `<comp ngh=\"\" />`),\n    // which means that no special annotations are required. Do not attempt to read\n    // from the TransferState in this case.\n    if (nghAttrValue !== '') {\n        const transferState = injector.get(TransferState, null, { optional: true });\n        if (transferState !== null) {\n            const nghData = transferState.get(NGH_DATA_KEY, []);\n            // The nghAttrValue is always a number referencing an index\n            // in the hydration TransferState data.\n            data = nghData[Number(nghAttrValue)];\n            // If the `ngh` attribute exists and has a non-empty value,\n            // the hydration info *must* be present in the TransferState.\n            // If there is no data for some reasons, this is an error.\n            ngDevMode && assertDefined(data, 'Unable to retrieve hydration info from the TransferState.');\n        }\n    }\n    const dehydratedView = {\n        data,\n        firstChild: rNode.firstChild ?? null,\n    };\n    if (isRootView) {\n        // If there is hydration info present for the root view, it means that there was\n        // a ViewContainerRef injected in the root component. The root component host element\n        // acted as an anchor node in this scenario. As a result, the DOM nodes that represent\n        // embedded views in this ViewContainerRef are located as siblings to the host node,\n        // i.e. `<app-root /><#VIEW1><#VIEW2>...<!--container-->`. In this case, the current\n        // node becomes the first child of this root view and the next sibling is the first\n        // element in the DOM segment.\n        dehydratedView.firstChild = rNode;\n        // We use `0` here, since this is the slot (right after the HEADER_OFFSET)\n        // where a component LView or an LContainer is located in a root LView.\n        setSegmentHead(dehydratedView, 0, rNode.nextSibling);\n    }\n    if (remainingNgh) {\n        // If we have only used one of the ngh ids, store the remaining one\n        // back on this RNode.\n        rNode.setAttribute(NGH_ATTR_NAME, remainingNgh);\n    }\n    else {\n        // The `ngh` attribute is cleared from the DOM node now\n        // that the data has been retrieved for all indices.\n        rNode.removeAttribute(NGH_ATTR_NAME);\n    }\n    // Note: don't check whether this node was claimed for hydration,\n    // because this node might've been previously claimed while processing\n    // template instructions.\n    ngDevMode && markRNodeAsClaimedByHydration(rNode, /* checkIfAlreadyClaimed */ false);\n    ngDevMode && ngDevMode.hydratedComponents++;\n    return dehydratedView;\n}\n/**\n * Sets the implementation for the `retrieveHydrationInfo` function.\n */\nfunction enableRetrieveHydrationInfoImpl() {\n    _retrieveHydrationInfoImpl = retrieveHydrationInfoImpl;\n}\n/**\n * Retrieves hydration info by reading the value from the `ngh` attribute\n * and accessing a corresponding slot in TransferState storage.\n */\nfunction retrieveHydrationInfo(rNode, injector, isRootView = false) {\n    return _retrieveHydrationInfoImpl(rNode, injector, isRootView);\n}\n/**\n * Retrieves the necessary object from a given ViewRef to serialize:\n *  - an LView for component views\n *  - an LContainer for cases when component acts as a ViewContainerRef anchor\n *  - `null` in case of an embedded view\n */\nfunction getLNodeForHydration(viewRef) {\n    // Reading an internal field from `ViewRef` instance.\n    let lView = viewRef._lView;\n    const tView = lView[TVIEW];\n    // A registered ViewRef might represent an instance of an\n    // embedded view, in which case we do not need to annotate it.\n    if (tView.type === 2 /* TViewType.Embedded */) {\n        return null;\n    }\n    // Check if it's a root view and if so, retrieve component's\n    // LView from the first slot after the header.\n    if (isRootView(lView)) {\n        lView = lView[HEADER_OFFSET];\n    }\n    return lView;\n}\nfunction getTextNodeContent(node) {\n    return node.textContent?.replace(/\\s/gm, '');\n}\n/**\n * Restores text nodes and separators into the DOM that were lost during SSR\n * serialization. The hydration process replaces empty text nodes and text\n * nodes that are immediately adjacent to other text nodes with comment nodes\n * that this method filters on to restore those missing nodes that the\n * hydration process is expecting to be present.\n *\n * @param node The app's root HTML Element\n */\nfunction processTextNodeMarkersBeforeHydration(node) {\n    const doc = getDocument();\n    const commentNodesIterator = doc.createNodeIterator(node, NodeFilter.SHOW_COMMENT, {\n        acceptNode(node) {\n            const content = getTextNodeContent(node);\n            const isTextNodeMarker = content === \"ngetn\" /* TextNodeMarker.EmptyNode */ || content === \"ngtns\" /* TextNodeMarker.Separator */;\n            return isTextNodeMarker ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;\n        }\n    });\n    let currentNode;\n    // We cannot modify the DOM while using the commentIterator,\n    // because it throws off the iterator state.\n    // So we collect all marker nodes first and then follow up with\n    // applying the changes to the DOM: either inserting an empty node\n    // or just removing the marker if it was used as a separator.\n    const nodes = [];\n    while (currentNode = commentNodesIterator.nextNode()) {\n        nodes.push(currentNode);\n    }\n    for (const node of nodes) {\n        if (node.textContent === \"ngetn\" /* TextNodeMarker.EmptyNode */) {\n            node.replaceWith(doc.createTextNode(''));\n        }\n        else {\n            node.remove();\n        }\n    }\n}\n/**\n * Marks a node as \"claimed\" by hydration process.\n * This is needed to make assessments in tests whether\n * the hydration process handled all nodes.\n */\nfunction markRNodeAsClaimedByHydration(node, checkIfAlreadyClaimed = true) {\n    if (!ngDevMode) {\n        throw new Error('Calling `markRNodeAsClaimedByHydration` in prod mode ' +\n            'is not supported and likely a mistake.');\n    }\n    if (checkIfAlreadyClaimed && isRNodeClaimedForHydration(node)) {\n        throw new Error('Trying to claim a node, which was claimed already.');\n    }\n    node.__claimed = true;\n    ngDevMode.hydratedNodes++;\n}\nfunction isRNodeClaimedForHydration(node) {\n    return !!node.__claimed;\n}\nfunction setSegmentHead(hydrationInfo, index, node) {\n    hydrationInfo.segmentHeads ??= {};\n    hydrationInfo.segmentHeads[index] = node;\n}\nfunction getSegmentHead(hydrationInfo, index) {\n    return hydrationInfo.segmentHeads?.[index] ?? null;\n}\n/**\n * Returns the size of an <ng-container>, using either the information\n * serialized in `ELEMENT_CONTAINERS` (element container size) or by\n * computing the sum of root nodes in all dehydrated views in a given\n * container (in case this `<ng-container>` was also used as a view\n * container host node, e.g. <ng-container *ngIf>).\n */\nfunction getNgContainerSize(hydrationInfo, index) {\n    const data = hydrationInfo.data;\n    let size = data[ELEMENT_CONTAINERS]?.[index] ?? null;\n    // If there is no serialized information available in the `ELEMENT_CONTAINERS` slot,\n    // check if we have info about view containers at this location (e.g.\n    // `<ng-container *ngIf>`) and use container size as a number of root nodes in this\n    // element container.\n    if (size === null && data[CONTAINERS]?.[index]) {\n        size = calcSerializedContainerSize(hydrationInfo, index);\n    }\n    return size;\n}\nfunction getSerializedContainerViews(hydrationInfo, index) {\n    return hydrationInfo.data[CONTAINERS]?.[index] ?? null;\n}\n/**\n * Computes the size of a serialized container (the number of root nodes)\n * by calculating the sum of root nodes in all dehydrated views in this container.\n */\nfunction calcSerializedContainerSize(hydrationInfo, index) {\n    const views = getSerializedContainerViews(hydrationInfo, index) ?? [];\n    let numNodes = 0;\n    for (let view of views) {\n        numNodes += view[NUM_ROOT_NODES] * (view[MULTIPLIER] ?? 1);\n    }\n    return numNodes;\n}\n/**\n * Checks whether a node is annotated as \"disconnected\", i.e. not present\n * in the DOM at serialization time. We should not attempt hydration for\n * such nodes and instead, use a regular \"creation mode\".\n */\nfunction isDisconnectedNode(hydrationInfo, index) {\n    // Check if we are processing disconnected info for the first time.\n    if (typeof hydrationInfo.disconnectedNodes === 'undefined') {\n        const nodeIds = hydrationInfo.data[DISCONNECTED_NODES];\n        hydrationInfo.disconnectedNodes = nodeIds ? (new Set(nodeIds)) : null;\n    }\n    return !!hydrationInfo.disconnectedNodes?.has(index);\n}\n\n/**\n * Represents a component created by a `ComponentFactory`.\n * Provides access to the component instance and related objects,\n * and provides the means of destroying the instance.\n *\n * @publicApi\n */\nclass ComponentRef$1 {\n}\n/**\n * Base class for a factory that can create a component dynamically.\n * Instantiate a factory for a given type of component with `resolveComponentFactory()`.\n * Use the resulting `ComponentFactory.create()` method to create a component of that type.\n *\n * @see [Dynamic Components](guide/dynamic-component-loader)\n *\n * @publicApi\n *\n * @deprecated Angular no longer requires Component factories. Please use other APIs where\n *     Component class can be used directly.\n */\nclass ComponentFactory$1 {\n}\n\nfunction noComponentFactoryError(component) {\n    const error = Error(`No component factory found for ${stringify(component)}.`);\n    error[ERROR_COMPONENT] = component;\n    return error;\n}\nconst ERROR_COMPONENT = 'ngComponent';\nfunction getComponent$1(error) {\n    return error[ERROR_COMPONENT];\n}\nclass _NullComponentFactoryResolver {\n    resolveComponentFactory(component) {\n        throw noComponentFactoryError(component);\n    }\n}\n/**\n * A simple registry that maps `Components` to generated `ComponentFactory` classes\n * that can be used to create instances of components.\n * Use to obtain the factory for a given component type,\n * then use the factory's `create()` method to create a component of that type.\n *\n * Note: since v13, dynamic component creation via\n * [`ViewContainerRef.createComponent`](api/core/ViewContainerRef#createComponent)\n * does **not** require resolving component factory: component class can be used directly.\n *\n * @publicApi\n *\n * @deprecated Angular no longer requires Component factories. Please use other APIs where\n *     Component class can be used directly.\n */\nclass ComponentFactoryResolver$1 {\n    static { this.NULL = ( /* @__PURE__ */new _NullComponentFactoryResolver()); }\n}\n\n/**\n * Creates an ElementRef from the most recent node.\n *\n * @returns The ElementRef instance to use\n */\nfunction injectElementRef() {\n    return createElementRef(getCurrentTNode(), getLView());\n}\n/**\n * Creates an ElementRef given a node.\n *\n * @param tNode The node for which you'd like an ElementRef\n * @param lView The view to which the node belongs\n * @returns The ElementRef instance to use\n */\nfunction createElementRef(tNode, lView) {\n    return new ElementRef(getNativeByTNode(tNode, lView));\n}\n/**\n * A wrapper around a native element inside of a View.\n *\n * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM\n * element.\n *\n * @security Permitting direct access to the DOM can make your application more vulnerable to\n * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the\n * [Security Guide](https://g.co/ng/security).\n *\n * @publicApi\n */\n// Note: We don't expose things like `Injector`, `ViewContainer`, ... here,\n// i.e. users have to ask for what they need. With that, we can build better analysis tools\n// and could do better codegen in the future.\nclass ElementRef {\n    constructor(nativeElement) {\n        this.nativeElement = nativeElement;\n    }\n    /**\n     * @internal\n     * @nocollapse\n     */\n    static { this.__NG_ELEMENT_ID__ = injectElementRef; }\n}\n/**\n * Unwraps `ElementRef` and return the `nativeElement`.\n *\n * @param value value to unwrap\n * @returns `nativeElement` if `ElementRef` otherwise returns value as is.\n */\nfunction unwrapElementRef(value) {\n    return value instanceof ElementRef ? value.nativeElement : value;\n}\n\n/**\n * Creates and initializes a custom renderer that implements the `Renderer2` base class.\n *\n * @publicApi\n */\nclass RendererFactory2 {\n}\n/**\n * Extend this base class to implement custom rendering. By default, Angular\n * renders a template into DOM. You can use custom rendering to intercept\n * rendering calls, or to render to something other than DOM.\n *\n * Create your custom renderer using `RendererFactory2`.\n *\n * Use a custom renderer to bypass Angular's templating and\n * make custom UI changes that can't be expressed declaratively.\n * For example if you need to set a property or an attribute whose name is\n * not statically known, use the `setProperty()` or\n * `setAttribute()` method.\n *\n * @publicApi\n */\nclass Renderer2 {\n    constructor() {\n        /**\n         * If null or undefined, the view engine won't call it.\n         * This is used as a performance optimization for production mode.\n         */\n        this.destroyNode = null;\n    }\n    /**\n     * @internal\n     * @nocollapse\n     */\n    static { this.__NG_ELEMENT_ID__ = () => injectRenderer2(); }\n}\n/** Injects a Renderer2 for the current component. */\nfunction injectRenderer2() {\n    // We need the Renderer to be based on the component that it's being injected into, however since\n    // DI happens before we've entered its view, `getLView` will return the parent view instead.\n    const lView = getLView();\n    const tNode = getCurrentTNode();\n    const nodeAtIndex = getComponentLViewByIndex(tNode.index, lView);\n    return (isLView(nodeAtIndex) ? nodeAtIndex : lView)[RENDERER];\n}\n\n/**\n * Sanitizer is used by the views to sanitize potentially dangerous values.\n *\n * @publicApi\n */\nclass Sanitizer {\n    /** @nocollapse */\n    static { this.ɵprov = ɵɵdefineInjectable({\n        token: Sanitizer,\n        providedIn: 'root',\n        factory: () => null,\n    }); }\n}\n\n/**\n * @description Represents the version of Angular\n *\n * @publicApi\n */\nclass Version {\n    constructor(full) {\n        this.full = full;\n        this.major = full.split('.')[0];\n        this.minor = full.split('.')[1];\n        this.patch = full.split('.').slice(2).join('.');\n    }\n}\n/**\n * @publicApi\n */\nconst VERSION = new Version('16.2.6');\n\n// This default value is when checking the hierarchy for a token.\n//\n// It means both:\n// - the token is not provided by the current injector,\n// - only the element injectors should be checked (ie do not check module injectors\n//\n//          mod1\n//         /\n//       el1   mod2\n//         \\  /\n//         el2\n//\n// When requesting el2.injector.get(token), we should check in the following order and return the\n// first found value:\n// - el2.injector.get(token, default)\n// - el1.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) -> do not check the module\n// - mod2.injector.get(token, default)\nconst NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};\n\nconst ERROR_ORIGINAL_ERROR = 'ngOriginalError';\nfunction wrappedError(message, originalError) {\n    const msg = `${message} caused by: ${originalError instanceof Error ? originalError.message : originalError}`;\n    const error = Error(msg);\n    error[ERROR_ORIGINAL_ERROR] = originalError;\n    return error;\n}\nfunction getOriginalError(error) {\n    return error[ERROR_ORIGINAL_ERROR];\n}\n\n/**\n * Provides a hook for centralized exception handling.\n *\n * The default implementation of `ErrorHandler` prints error messages to the `console`. To\n * intercept error handling, write a custom exception handler that replaces this default as\n * appropriate for your app.\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * class MyErrorHandler implements ErrorHandler {\n *   handleError(error) {\n *     // do something with the exception\n *   }\n * }\n *\n * @NgModule({\n *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]\n * })\n * class MyModule {}\n * ```\n *\n * @publicApi\n */\nclass ErrorHandler {\n    constructor() {\n        /**\n         * @internal\n         */\n        this._console = console;\n    }\n    handleError(error) {\n        const originalError = this._findOriginalError(error);\n        this._console.error('ERROR', error);\n        if (originalError) {\n            this._console.error('ORIGINAL ERROR', originalError);\n        }\n    }\n    /** @internal */\n    _findOriginalError(error) {\n        let e = error && getOriginalError(error);\n        while (e && getOriginalError(e)) {\n            e = getOriginalError(e);\n        }\n        return e || null;\n    }\n}\n\n/**\n * `DestroyRef` lets you set callbacks to run for any cleanup or destruction behavior.\n * The scope of this destruction depends on where `DestroyRef` is injected. If `DestroyRef`\n * is injected in a component or directive, the callbacks run when that component or\n * directive is destroyed. Otherwise the callbacks run when a corresponding injector is destroyed.\n *\n * @publicApi\n */\nclass DestroyRef {\n    /**\n     * @internal\n     * @nocollapse\n     */\n    static { this.__NG_ELEMENT_ID__ = injectDestroyRef; }\n    /**\n     * @internal\n     * @nocollapse\n     */\n    static { this.__NG_ENV_ID__ = (injector) => injector; }\n}\nclass NodeInjectorDestroyRef extends DestroyRef {\n    constructor(_lView) {\n        super();\n        this._lView = _lView;\n    }\n    onDestroy(callback) {\n        storeLViewOnDestroy(this._lView, callback);\n        return () => removeLViewOnDestroy(this._lView, callback);\n    }\n}\nfunction injectDestroyRef() {\n    return new NodeInjectorDestroyRef(getLView());\n}\n\n/// <reference types=\"rxjs\" />\nclass EventEmitter_ extends Subject {\n    constructor(isAsync = false) {\n        super();\n        this.__isAsync = isAsync;\n    }\n    emit(value) {\n        super.next(value);\n    }\n    subscribe(observerOrNext, error, complete) {\n        let nextFn = observerOrNext;\n        let errorFn = error || (() => null);\n        let completeFn = complete;\n        if (observerOrNext && typeof observerOrNext === 'object') {\n            const observer = observerOrNext;\n            nextFn = observer.next?.bind(observer);\n            errorFn = observer.error?.bind(observer);\n            completeFn = observer.complete?.bind(observer);\n        }\n        if (this.__isAsync) {\n            errorFn = _wrapInTimeout(errorFn);\n            if (nextFn) {\n                nextFn = _wrapInTimeout(nextFn);\n            }\n            if (completeFn) {\n                completeFn = _wrapInTimeout(completeFn);\n            }\n        }\n        const sink = super.subscribe({ next: nextFn, error: errorFn, complete: completeFn });\n        if (observerOrNext instanceof Subscription) {\n            observerOrNext.add(sink);\n        }\n        return sink;\n    }\n}\nfunction _wrapInTimeout(fn) {\n    return (value) => {\n        setTimeout(fn, undefined, value);\n    };\n}\n/**\n * @publicApi\n */\nconst EventEmitter = EventEmitter_;\n\nfunction noop(...args) {\n    // Do nothing.\n}\n\nfunction getNativeRequestAnimationFrame() {\n    // Note: the `getNativeRequestAnimationFrame` is used in the `NgZone` class, but we cannot use the\n    // `inject` function. The `NgZone` instance may be created manually, and thus the injection\n    // context will be unavailable. This might be enough to check whether `requestAnimationFrame` is\n    // available because otherwise, we'll fall back to `setTimeout`.\n    const isBrowser = typeof _global['requestAnimationFrame'] === 'function';\n    // Note: `requestAnimationFrame` is unavailable when the code runs in the Node.js environment. We\n    // use `setTimeout` because no changes are required other than checking if the current platform is\n    // the browser. `setTimeout` is a well-established API that is available in both environments.\n    // `requestAnimationFrame` is used in the browser to coalesce event tasks since event tasks are\n    // usually executed within the same rendering frame (but this is more implementation details of\n    // browsers).\n    let nativeRequestAnimationFrame = _global[isBrowser ? 'requestAnimationFrame' : 'setTimeout'];\n    let nativeCancelAnimationFrame = _global[isBrowser ? 'cancelAnimationFrame' : 'clearTimeout'];\n    if (typeof Zone !== 'undefined' && nativeRequestAnimationFrame && nativeCancelAnimationFrame) {\n        // Note: zone.js sets original implementations on patched APIs behind the\n        // `__zone_symbol__OriginalDelegate` key (see `attachOriginToPatched`). Given the following\n        // example: `window.requestAnimationFrame.__zone_symbol__OriginalDelegate`; this would return an\n        // unpatched implementation of the `requestAnimationFrame`, which isn't intercepted by the\n        // Angular zone. We use the unpatched implementation to avoid another change detection when\n        // coalescing tasks.\n        const unpatchedRequestAnimationFrame = nativeRequestAnimationFrame[Zone.__symbol__('OriginalDelegate')];\n        if (unpatchedRequestAnimationFrame) {\n            nativeRequestAnimationFrame = unpatchedRequestAnimationFrame;\n        }\n        const unpatchedCancelAnimationFrame = nativeCancelAnimationFrame[Zone.__symbol__('OriginalDelegate')];\n        if (unpatchedCancelAnimationFrame) {\n            nativeCancelAnimationFrame = unpatchedCancelAnimationFrame;\n        }\n    }\n    return { nativeRequestAnimationFrame, nativeCancelAnimationFrame };\n}\n\nclass AsyncStackTaggingZoneSpec {\n    constructor(namePrefix, consoleAsyncStackTaggingImpl = console) {\n        this.name = 'asyncStackTagging for ' + namePrefix;\n        this.createTask = consoleAsyncStackTaggingImpl?.createTask ?? (() => null);\n    }\n    onScheduleTask(delegate, _current, target, task) {\n        task.consoleTask = this.createTask(`Zone - ${task.source || task.type}`);\n        return delegate.scheduleTask(target, task);\n    }\n    onInvokeTask(delegate, _currentZone, targetZone, task, applyThis, applyArgs) {\n        let ret;\n        if (task.consoleTask) {\n            ret = task.consoleTask.run(() => delegate.invokeTask(targetZone, task, applyThis, applyArgs));\n        }\n        else {\n            ret = delegate.invokeTask(targetZone, task, applyThis, applyArgs);\n        }\n        return ret;\n    }\n}\n\n/**\n * An injectable service for executing work inside or outside of the Angular zone.\n *\n * The most common use of this service is to optimize performance when starting a work consisting of\n * one or more asynchronous tasks that don't require UI updates or error handling to be handled by\n * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks\n * can reenter the Angular zone via {@link #run}.\n *\n * <!-- TODO: add/fix links to:\n *   - docs explaining zones and the use of zones in Angular and change-detection\n *   - link to runOutsideAngular/run (throughout this file!)\n *   -->\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * import {Component, NgZone} from '@angular/core';\n * import {NgIf} from '@angular/common';\n *\n * @Component({\n *   selector: 'ng-zone-demo',\n *   template: `\n *     <h2>Demo: NgZone</h2>\n *\n *     <p>Progress: {{progress}}%</p>\n *     <p *ngIf=\"progress >= 100\">Done processing {{label}} of Angular zone!</p>\n *\n *     <button (click)=\"processWithinAngularZone()\">Process within Angular zone</button>\n *     <button (click)=\"processOutsideOfAngularZone()\">Process outside of Angular zone</button>\n *   `,\n * })\n * export class NgZoneDemo {\n *   progress: number = 0;\n *   label: string;\n *\n *   constructor(private _ngZone: NgZone) {}\n *\n *   // Loop inside the Angular zone\n *   // so the UI DOES refresh after each setTimeout cycle\n *   processWithinAngularZone() {\n *     this.label = 'inside';\n *     this.progress = 0;\n *     this._increaseProgress(() => console.log('Inside Done!'));\n *   }\n *\n *   // Loop outside of the Angular zone\n *   // so the UI DOES NOT refresh after each setTimeout cycle\n *   processOutsideOfAngularZone() {\n *     this.label = 'outside';\n *     this.progress = 0;\n *     this._ngZone.runOutsideAngular(() => {\n *       this._increaseProgress(() => {\n *         // reenter the Angular zone and display done\n *         this._ngZone.run(() => { console.log('Outside Done!'); });\n *       });\n *     });\n *   }\n *\n *   _increaseProgress(doneCallback: () => void) {\n *     this.progress += 1;\n *     console.log(`Current progress: ${this.progress}%`);\n *\n *     if (this.progress < 100) {\n *       window.setTimeout(() => this._increaseProgress(doneCallback), 10);\n *     } else {\n *       doneCallback();\n *     }\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nclass NgZone {\n    constructor({ enableLongStackTrace = false, shouldCoalesceEventChangeDetection = false, shouldCoalesceRunChangeDetection = false }) {\n        this.hasPendingMacrotasks = false;\n        this.hasPendingMicrotasks = false;\n        /**\n         * Whether there are no outstanding microtasks or macrotasks.\n         */\n        this.isStable = true;\n        /**\n         * Notifies when code enters Angular Zone. This gets fired first on VM Turn.\n         */\n        this.onUnstable = new EventEmitter(false);\n        /**\n         * Notifies when there is no more microtasks enqueued in the current VM Turn.\n         * This is a hint for Angular to do change detection, which may enqueue more microtasks.\n         * For this reason this event can fire multiple times per VM Turn.\n         */\n        this.onMicrotaskEmpty = new EventEmitter(false);\n        /**\n         * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which\n         * implies we are about to relinquish VM turn.\n         * This event gets called just once.\n         */\n        this.onStable = new EventEmitter(false);\n        /**\n         * Notifies that an error has been delivered.\n         */\n        this.onError = new EventEmitter(false);\n        if (typeof Zone == 'undefined') {\n            throw new RuntimeError(908 /* RuntimeErrorCode.MISSING_ZONEJS */, ngDevMode && `In this configuration Angular requires Zone.js`);\n        }\n        Zone.assertZonePatched();\n        const self = this;\n        self._nesting = 0;\n        self._outer = self._inner = Zone.current;\n        // AsyncStackTaggingZoneSpec provides `linked stack traces` to show\n        // where the async operation is scheduled. For more details, refer\n        // to this article, https://developer.chrome.com/blog/devtools-better-angular-debugging/\n        // And we only import this AsyncStackTaggingZoneSpec in development mode,\n        // in the production mode, the AsyncStackTaggingZoneSpec will be tree shaken away.\n        if (ngDevMode) {\n            self._inner = self._inner.fork(new AsyncStackTaggingZoneSpec('Angular'));\n        }\n        if (Zone['TaskTrackingZoneSpec']) {\n            self._inner = self._inner.fork(new Zone['TaskTrackingZoneSpec']);\n        }\n        if (enableLongStackTrace && Zone['longStackTraceZoneSpec']) {\n            self._inner = self._inner.fork(Zone['longStackTraceZoneSpec']);\n        }\n        // if shouldCoalesceRunChangeDetection is true, all tasks including event tasks will be\n        // coalesced, so shouldCoalesceEventChangeDetection option is not necessary and can be skipped.\n        self.shouldCoalesceEventChangeDetection =\n            !shouldCoalesceRunChangeDetection && shouldCoalesceEventChangeDetection;\n        self.shouldCoalesceRunChangeDetection = shouldCoalesceRunChangeDetection;\n        self.lastRequestAnimationFrameId = -1;\n        self.nativeRequestAnimationFrame = getNativeRequestAnimationFrame().nativeRequestAnimationFrame;\n        forkInnerZoneWithAngularBehavior(self);\n    }\n    /**\n      This method checks whether the method call happens within an Angular Zone instance.\n    */\n    static isInAngularZone() {\n        // Zone needs to be checked, because this method might be called even when NoopNgZone is used.\n        return typeof Zone !== 'undefined' && Zone.current.get('isAngularZone') === true;\n    }\n    /**\n      Assures that the method is called within the Angular Zone, otherwise throws an error.\n    */\n    static assertInAngularZone() {\n        if (!NgZone.isInAngularZone()) {\n            throw new RuntimeError(909 /* RuntimeErrorCode.UNEXPECTED_ZONE_STATE */, ngDevMode && 'Expected to be in Angular Zone, but it is not!');\n        }\n    }\n    /**\n      Assures that the method is called outside of the Angular Zone, otherwise throws an error.\n    */\n    static assertNotInAngularZone() {\n        if (NgZone.isInAngularZone()) {\n            throw new RuntimeError(909 /* RuntimeErrorCode.UNEXPECTED_ZONE_STATE */, ngDevMode && 'Expected to not be in Angular Zone, but it is!');\n        }\n    }\n    /**\n     * Executes the `fn` function synchronously within the Angular zone and returns value returned by\n     * the function.\n     *\n     * Running functions via `run` allows you to reenter Angular zone from a task that was executed\n     * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\n     *\n     * Any future tasks or microtasks scheduled from within this function will continue executing from\n     * within the Angular zone.\n     *\n     * If a synchronous error happens it will be rethrown and not reported via `onError`.\n     */\n    run(fn, applyThis, applyArgs) {\n        return this._inner.run(fn, applyThis, applyArgs);\n    }\n    /**\n     * Executes the `fn` function synchronously within the Angular zone as a task and returns value\n     * returned by the function.\n     *\n     * Running functions via `run` allows you to reenter Angular zone from a task that was executed\n     * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\n     *\n     * Any future tasks or microtasks scheduled from within this function will continue executing from\n     * within the Angular zone.\n     *\n     * If a synchronous error happens it will be rethrown and not reported via `onError`.\n     */\n    runTask(fn, applyThis, applyArgs, name) {\n        const zone = this._inner;\n        const task = zone.scheduleEventTask('NgZoneEvent: ' + name, fn, EMPTY_PAYLOAD, noop, noop);\n        try {\n            return zone.runTask(task, applyThis, applyArgs);\n        }\n        finally {\n            zone.cancelTask(task);\n        }\n    }\n    /**\n     * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not\n     * rethrown.\n     */\n    runGuarded(fn, applyThis, applyArgs) {\n        return this._inner.runGuarded(fn, applyThis, applyArgs);\n    }\n    /**\n     * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by\n     * the function.\n     *\n     * Running functions via {@link #runOutsideAngular} allows you to escape Angular's zone and do\n     * work that\n     * doesn't trigger Angular change-detection or is subject to Angular's error handling.\n     *\n     * Any future tasks or microtasks scheduled from within this function will continue executing from\n     * outside of the Angular zone.\n     *\n     * Use {@link #run} to reenter the Angular zone and do work that updates the application model.\n     */\n    runOutsideAngular(fn) {\n        return this._outer.run(fn);\n    }\n}\nconst EMPTY_PAYLOAD = {};\nfunction checkStable(zone) {\n    // TODO: @JiaLiPassion, should check zone.isCheckStableRunning to prevent\n    // re-entry. The case is:\n    //\n    // @Component({...})\n    // export class AppComponent {\n    // constructor(private ngZone: NgZone) {\n    //   this.ngZone.onStable.subscribe(() => {\n    //     this.ngZone.run(() => console.log('stable'););\n    //   });\n    // }\n    //\n    // The onStable subscriber run another function inside ngZone\n    // which causes `checkStable()` re-entry.\n    // But this fix causes some issues in g3, so this fix will be\n    // launched in another PR.\n    if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {\n        try {\n            zone._nesting++;\n            zone.onMicrotaskEmpty.emit(null);\n        }\n        finally {\n            zone._nesting--;\n            if (!zone.hasPendingMicrotasks) {\n                try {\n                    zone.runOutsideAngular(() => zone.onStable.emit(null));\n                }\n                finally {\n                    zone.isStable = true;\n                }\n            }\n        }\n    }\n}\nfunction delayChangeDetectionForEvents(zone) {\n    /**\n     * We also need to check _nesting here\n     * Consider the following case with shouldCoalesceRunChangeDetection = true\n     *\n     * ngZone.run(() => {});\n     * ngZone.run(() => {});\n     *\n     * We want the two `ngZone.run()` only trigger one change detection\n     * when shouldCoalesceRunChangeDetection is true.\n     * And because in this case, change detection run in async way(requestAnimationFrame),\n     * so we also need to check the _nesting here to prevent multiple\n     * change detections.\n     */\n    if (zone.isCheckStableRunning || zone.lastRequestAnimationFrameId !== -1) {\n        return;\n    }\n    zone.lastRequestAnimationFrameId = zone.nativeRequestAnimationFrame.call(_global, () => {\n        // This is a work around for https://github.com/angular/angular/issues/36839.\n        // The core issue is that when event coalescing is enabled it is possible for microtasks\n        // to get flushed too early (As is the case with `Promise.then`) between the\n        // coalescing eventTasks.\n        //\n        // To workaround this we schedule a \"fake\" eventTask before we process the\n        // coalescing eventTasks. The benefit of this is that the \"fake\" container eventTask\n        //  will prevent the microtasks queue from getting drained in between the coalescing\n        // eventTask execution.\n        if (!zone.fakeTopEventTask) {\n            zone.fakeTopEventTask = Zone.root.scheduleEventTask('fakeTopEventTask', () => {\n                zone.lastRequestAnimationFrameId = -1;\n                updateMicroTaskStatus(zone);\n                zone.isCheckStableRunning = true;\n                checkStable(zone);\n                zone.isCheckStableRunning = false;\n            }, undefined, () => { }, () => { });\n        }\n        zone.fakeTopEventTask.invoke();\n    });\n    updateMicroTaskStatus(zone);\n}\nfunction forkInnerZoneWithAngularBehavior(zone) {\n    const delayChangeDetectionForEventsDelegate = () => {\n        delayChangeDetectionForEvents(zone);\n    };\n    zone._inner = zone._inner.fork({\n        name: 'angular',\n        properties: { 'isAngularZone': true },\n        onInvokeTask: (delegate, current, target, task, applyThis, applyArgs) => {\n            if (shouldBeIgnoredByZone(applyArgs)) {\n                return delegate.invokeTask(target, task, applyThis, applyArgs);\n            }\n            try {\n                onEnter(zone);\n                return delegate.invokeTask(target, task, applyThis, applyArgs);\n            }\n            finally {\n                if ((zone.shouldCoalesceEventChangeDetection && task.type === 'eventTask') ||\n                    zone.shouldCoalesceRunChangeDetection) {\n                    delayChangeDetectionForEventsDelegate();\n                }\n                onLeave(zone);\n            }\n        },\n        onInvoke: (delegate, current, target, callback, applyThis, applyArgs, source) => {\n            try {\n                onEnter(zone);\n                return delegate.invoke(target, callback, applyThis, applyArgs, source);\n            }\n            finally {\n                if (zone.shouldCoalesceRunChangeDetection) {\n                    delayChangeDetectionForEventsDelegate();\n                }\n                onLeave(zone);\n            }\n        },\n        onHasTask: (delegate, current, target, hasTaskState) => {\n            delegate.hasTask(target, hasTaskState);\n            if (current === target) {\n                // We are only interested in hasTask events which originate from our zone\n                // (A child hasTask event is not interesting to us)\n                if (hasTaskState.change == 'microTask') {\n                    zone._hasPendingMicrotasks = hasTaskState.microTask;\n                    updateMicroTaskStatus(zone);\n                    checkStable(zone);\n                }\n                else if (hasTaskState.change == 'macroTask') {\n                    zone.hasPendingMacrotasks = hasTaskState.macroTask;\n                }\n            }\n        },\n        onHandleError: (delegate, current, target, error) => {\n            delegate.handleError(target, error);\n            zone.runOutsideAngular(() => zone.onError.emit(error));\n            return false;\n        }\n    });\n}\nfunction updateMicroTaskStatus(zone) {\n    if (zone._hasPendingMicrotasks ||\n        ((zone.shouldCoalesceEventChangeDetection || zone.shouldCoalesceRunChangeDetection) &&\n            zone.lastRequestAnimationFrameId !== -1)) {\n        zone.hasPendingMicrotasks = true;\n    }\n    else {\n        zone.hasPendingMicrotasks = false;\n    }\n}\nfunction onEnter(zone) {\n    zone._nesting++;\n    if (zone.isStable) {\n        zone.isStable = false;\n        zone.onUnstable.emit(null);\n    }\n}\nfunction onLeave(zone) {\n    zone._nesting--;\n    checkStable(zone);\n}\n/**\n * Provides a noop implementation of `NgZone` which does nothing. This zone requires explicit calls\n * to framework to perform rendering.\n */\nclass NoopNgZone {\n    constructor() {\n        this.hasPendingMicrotasks = false;\n        this.hasPendingMacrotasks = false;\n        this.isStable = true;\n        this.onUnstable = new EventEmitter();\n        this.onMicrotaskEmpty = new EventEmitter();\n        this.onStable = new EventEmitter();\n        this.onError = new EventEmitter();\n    }\n    run(fn, applyThis, applyArgs) {\n        return fn.apply(applyThis, applyArgs);\n    }\n    runGuarded(fn, applyThis, applyArgs) {\n        return fn.apply(applyThis, applyArgs);\n    }\n    runOutsideAngular(fn) {\n        return fn();\n    }\n    runTask(fn, applyThis, applyArgs, name) {\n        return fn.apply(applyThis, applyArgs);\n    }\n}\n/**\n * Token used to drive ApplicationRef.isStable\n *\n * TODO: This should be moved entirely to NgZone (as a breaking change) so it can be tree-shakeable\n * for `NoopNgZone` which is always just an `Observable` of `true`. Additionally, we should consider\n * whether the property on `NgZone` should be `Observable` or `Signal`.\n */\nconst ZONE_IS_STABLE_OBSERVABLE = new InjectionToken(ngDevMode ? 'isStable Observable' : '', {\n    providedIn: 'root',\n    // TODO(atscott): Replace this with a suitable default like `new\n    // BehaviorSubject(true).asObservable`. Again, long term this won't exist on ApplicationRef at\n    // all but until we can remove it, we need a default value zoneless.\n    factory: isStableFactory,\n});\nfunction isStableFactory() {\n    const zone = inject$1(NgZone);\n    let _stable = true;\n    const isCurrentlyStable = new Observable((observer) => {\n        _stable = zone.isStable && !zone.hasPendingMacrotasks && !zone.hasPendingMicrotasks;\n        zone.runOutsideAngular(() => {\n            observer.next(_stable);\n            observer.complete();\n        });\n    });\n    const isStable = new Observable((observer) => {\n        // Create the subscription to onStable outside the Angular Zone so that\n        // the callback is run outside the Angular Zone.\n        let stableSub;\n        zone.runOutsideAngular(() => {\n            stableSub = zone.onStable.subscribe(() => {\n                NgZone.assertNotInAngularZone();\n                // Check whether there are no pending macro/micro tasks in the next tick\n                // to allow for NgZone to update the state.\n                queueMicrotask(() => {\n                    if (!_stable && !zone.hasPendingMacrotasks && !zone.hasPendingMicrotasks) {\n                        _stable = true;\n                        observer.next(true);\n                    }\n                });\n            });\n        });\n        const unstableSub = zone.onUnstable.subscribe(() => {\n            NgZone.assertInAngularZone();\n            if (_stable) {\n                _stable = false;\n                zone.runOutsideAngular(() => {\n                    observer.next(false);\n                });\n            }\n        });\n        return () => {\n            stableSub.unsubscribe();\n            unstableSub.unsubscribe();\n        };\n    });\n    return merge$1(isCurrentlyStable, isStable.pipe(share()));\n}\nfunction shouldBeIgnoredByZone(applyArgs) {\n    if (!Array.isArray(applyArgs)) {\n        return false;\n    }\n    // We should only ever get 1 arg passed through to invokeTask.\n    // Short circuit here incase that behavior changes.\n    if (applyArgs.length !== 1) {\n        return false;\n    }\n    // Prevent triggering change detection when the __ignore_ng_zone__ flag is detected.\n    return applyArgs[0].data?.['__ignore_ng_zone__'] === true;\n}\n\n// Public API for Zone\n\n/**\n * Register a callback to be invoked each time the application\n * finishes rendering.\n *\n * Note that the callback will run\n * - in the order it was registered\n * - once per render\n * - on browser platforms only\n *\n * <div class=\"alert is-important\">\n *\n * Components are not guaranteed to be [hydrated](guide/hydration) before the callback runs.\n * You must use caution when directly reading or writing the DOM and layout.\n *\n * </div>\n *\n * @param callback A callback function to register\n *\n * @usageNotes\n *\n * Use `afterRender` to read or write the DOM after each render.\n *\n * ### Example\n * ```ts\n * @Component({\n *   selector: 'my-cmp',\n *   template: `<span #content>{{ ... }}</span>`,\n * })\n * export class MyComponent {\n *   @ViewChild('content') contentRef: ElementRef;\n *\n *   constructor() {\n *     afterRender(() => {\n *       console.log('content height: ' + this.contentRef.nativeElement.scrollHeight);\n *     });\n *   }\n * }\n * ```\n *\n * @developerPreview\n */\nfunction afterRender(callback, options) {\n    !options && assertInInjectionContext(afterRender);\n    const injector = options?.injector ?? inject$1(Injector);\n    if (!isPlatformBrowser(injector)) {\n        return { destroy() { } };\n    }\n    let destroy;\n    const unregisterFn = injector.get(DestroyRef).onDestroy(() => destroy?.());\n    const afterRenderEventManager = injector.get(AfterRenderEventManager);\n    // Lazily initialize the handler implementation, if necessary. This is so that it can be\n    // tree-shaken if `afterRender` and `afterNextRender` aren't used.\n    const callbackHandler = afterRenderEventManager.handler ??= new AfterRenderCallbackHandlerImpl();\n    const ngZone = injector.get(NgZone);\n    const errorHandler = injector.get(ErrorHandler, null, { optional: true });\n    const instance = new AfterRenderCallback(ngZone, errorHandler, callback);\n    destroy = () => {\n        callbackHandler.unregister(instance);\n        unregisterFn();\n    };\n    callbackHandler.register(instance);\n    return { destroy };\n}\n/**\n * Register a callback to be invoked the next time the application\n * finishes rendering.\n *\n * Note that the callback will run\n * - in the order it was registered\n * - on browser platforms only\n *\n * <div class=\"alert is-important\">\n *\n * Components are not guaranteed to be [hydrated](guide/hydration) before the callback runs.\n * You must use caution when directly reading or writing the DOM and layout.\n *\n * </div>\n *\n * @param callback A callback function to register\n *\n * @usageNotes\n *\n * Use `afterNextRender` to read or write the DOM once,\n * for example to initialize a non-Angular library.\n *\n * ### Example\n * ```ts\n * @Component({\n *   selector: 'my-chart-cmp',\n *   template: `<div #chart>{{ ... }}</div>`,\n * })\n * export class MyChartCmp {\n *   @ViewChild('chart') chartRef: ElementRef;\n *   chart: MyChart|null;\n *\n *   constructor() {\n *     afterNextRender(() => {\n *       this.chart = new MyChart(this.chartRef.nativeElement);\n *     });\n *   }\n * }\n * ```\n *\n * @developerPreview\n */\nfunction afterNextRender(callback, options) {\n    !options && assertInInjectionContext(afterNextRender);\n    const injector = options?.injector ?? inject$1(Injector);\n    if (!isPlatformBrowser(injector)) {\n        return { destroy() { } };\n    }\n    let destroy;\n    const unregisterFn = injector.get(DestroyRef).onDestroy(() => destroy?.());\n    const afterRenderEventManager = injector.get(AfterRenderEventManager);\n    // Lazily initialize the handler implementation, if necessary. This is so that it can be\n    // tree-shaken if `afterRender` and `afterNextRender` aren't used.\n    const callbackHandler = afterRenderEventManager.handler ??= new AfterRenderCallbackHandlerImpl();\n    const ngZone = injector.get(NgZone);\n    const errorHandler = injector.get(ErrorHandler, null, { optional: true });\n    const instance = new AfterRenderCallback(ngZone, errorHandler, () => {\n        destroy?.();\n        callback();\n    });\n    destroy = () => {\n        callbackHandler.unregister(instance);\n        unregisterFn();\n    };\n    callbackHandler.register(instance);\n    return { destroy };\n}\n/**\n * A wrapper around a function to be used as an after render callback.\n */\nclass AfterRenderCallback {\n    constructor(zone, errorHandler, callbackFn) {\n        this.zone = zone;\n        this.errorHandler = errorHandler;\n        this.callbackFn = callbackFn;\n    }\n    invoke() {\n        try {\n            this.zone.runOutsideAngular(this.callbackFn);\n        }\n        catch (err) {\n            this.errorHandler?.handleError(err);\n        }\n    }\n}\n/**\n * Core functionality for `afterRender` and `afterNextRender`. Kept separate from\n * `AfterRenderEventManager` for tree-shaking.\n */\nclass AfterRenderCallbackHandlerImpl {\n    constructor() {\n        this.executingCallbacks = false;\n        this.callbacks = new Set();\n        this.deferredCallbacks = new Set();\n    }\n    validateBegin() {\n        if (this.executingCallbacks) {\n            throw new RuntimeError(102 /* RuntimeErrorCode.RECURSIVE_APPLICATION_RENDER */, ngDevMode &&\n                'A new render operation began before the previous operation ended. ' +\n                    'Did you trigger change detection from afterRender or afterNextRender?');\n        }\n    }\n    register(callback) {\n        // If we're currently running callbacks, new callbacks should be deferred\n        // until the next render operation.\n        const target = this.executingCallbacks ? this.deferredCallbacks : this.callbacks;\n        target.add(callback);\n    }\n    unregister(callback) {\n        this.callbacks.delete(callback);\n        this.deferredCallbacks.delete(callback);\n    }\n    execute() {\n        this.executingCallbacks = true;\n        for (const callback of this.callbacks) {\n            callback.invoke();\n        }\n        this.executingCallbacks = false;\n        for (const callback of this.deferredCallbacks) {\n            this.callbacks.add(callback);\n        }\n        this.deferredCallbacks.clear();\n    }\n    destroy() {\n        this.callbacks.clear();\n        this.deferredCallbacks.clear();\n    }\n}\n/**\n * Implements core timing for `afterRender` and `afterNextRender` events.\n * Delegates to an optional `AfterRenderCallbackHandler` for implementation.\n */\nclass AfterRenderEventManager {\n    constructor() {\n        this.renderDepth = 0;\n        /* @internal */\n        this.handler = null;\n    }\n    /**\n     * Mark the beginning of a render operation (i.e. CD cycle).\n     * Throws if called while executing callbacks.\n     */\n    begin() {\n        this.handler?.validateBegin();\n        this.renderDepth++;\n    }\n    /**\n     * Mark the end of a render operation. Callbacks will be\n     * executed if there are no more pending operations.\n     */\n    end() {\n        ngDevMode && assertGreaterThan(this.renderDepth, 0, 'renderDepth must be greater than 0');\n        this.renderDepth--;\n        if (this.renderDepth === 0) {\n            this.handler?.execute();\n        }\n    }\n    ngOnDestroy() {\n        this.handler?.destroy();\n        this.handler = null;\n    }\n    /** @nocollapse */\n    static { this.ɵprov = ɵɵdefineInjectable({\n        token: AfterRenderEventManager,\n        providedIn: 'root',\n        factory: () => new AfterRenderEventManager(),\n    }); }\n}\n\n/**\n * Marks current view and all ancestors dirty.\n *\n * Returns the root view because it is found as a byproduct of marking the view tree\n * dirty, and can be used by methods that consume markViewDirty() to easily schedule\n * change detection. Otherwise, such methods would need to traverse up the view tree\n * an additional time to get the root view and schedule a tick on it.\n *\n * @param lView The starting LView to mark dirty\n * @returns the root LView\n */\nfunction markViewDirty(lView) {\n    while (lView) {\n        lView[FLAGS] |= 64 /* LViewFlags.Dirty */;\n        const parent = getLViewParent(lView);\n        // Stop traversing up as soon as you find a root view that wasn't attached to any container\n        if (isRootView(lView) && !parent) {\n            return lView;\n        }\n        // continue otherwise\n        lView = parent;\n    }\n    return null;\n}\n\n/**\n * Internal token that specifies whether DOM reuse logic\n * during hydration is enabled.\n */\nconst IS_HYDRATION_DOM_REUSE_ENABLED = new InjectionToken((typeof ngDevMode === 'undefined' || !!ngDevMode) ? 'IS_HYDRATION_DOM_REUSE_ENABLED' : '');\n// By default (in client rendering mode), we remove all the contents\n// of the host element and render an application after that.\nconst PRESERVE_HOST_CONTENT_DEFAULT = false;\n/**\n * Internal token that indicates whether host element content should be\n * retained during the bootstrap.\n */\nconst PRESERVE_HOST_CONTENT = new InjectionToken((typeof ngDevMode === 'undefined' || !!ngDevMode) ? 'PRESERVE_HOST_CONTENT' : '', {\n    providedIn: 'root',\n    factory: () => PRESERVE_HOST_CONTENT_DEFAULT,\n});\n\nfunction normalizeDebugBindingName(name) {\n    // Attribute names with `$` (eg `x-y$`) are valid per spec, but unsupported by some browsers\n    name = camelCaseToDashCase(name.replace(/[$@]/g, '_'));\n    return `ng-reflect-${name}`;\n}\nconst CAMEL_CASE_REGEXP = /([A-Z])/g;\nfunction camelCaseToDashCase(input) {\n    return input.replace(CAMEL_CASE_REGEXP, (...m) => '-' + m[1].toLowerCase());\n}\nfunction normalizeDebugBindingValue(value) {\n    try {\n        // Limit the size of the value as otherwise the DOM just gets polluted.\n        return value != null ? value.toString().slice(0, 30) : value;\n    }\n    catch (e) {\n        return '[ERROR] Exception while trying to serialize the value';\n    }\n}\n\n/**\n * The max length of the string representation of a value in an error message\n */\nconst VALUE_STRING_LENGTH_LIMIT = 200;\n/** Verifies that a given type is a Standalone Component. */\nfunction assertStandaloneComponentType(type) {\n    assertComponentDef(type);\n    const componentDef = getComponentDef$1(type);\n    if (!componentDef.standalone) {\n        throw new RuntimeError(907 /* RuntimeErrorCode.TYPE_IS_NOT_STANDALONE */, `The ${stringifyForError(type)} component is not marked as standalone, ` +\n            `but Angular expects to have a standalone component here. ` +\n            `Please make sure the ${stringifyForError(type)} component has ` +\n            `the \\`standalone: true\\` flag in the decorator.`);\n    }\n}\n/** Verifies whether a given type is a component */\nfunction assertComponentDef(type) {\n    if (!getComponentDef$1(type)) {\n        throw new RuntimeError(906 /* RuntimeErrorCode.MISSING_GENERATED_DEF */, `The ${stringifyForError(type)} is not an Angular component, ` +\n            `make sure it has the \\`@Component\\` decorator.`);\n    }\n}\n/** Called when there are multiple component selectors that match a given node */\nfunction throwMultipleComponentError(tNode, first, second) {\n    throw new RuntimeError(-300 /* RuntimeErrorCode.MULTIPLE_COMPONENTS_MATCH */, `Multiple components match node with tagname ${tNode.value}: ` +\n        `${stringifyForError(first)} and ` +\n        `${stringifyForError(second)}`);\n}\n/** Throws an ExpressionChangedAfterChecked error if checkNoChanges mode is on. */\nfunction throwErrorIfNoChangesMode(creationMode, oldValue, currValue, propName, lView) {\n    const hostComponentDef = getDeclarationComponentDef(lView);\n    const componentClassName = hostComponentDef?.type?.name;\n    const field = propName ? ` for '${propName}'` : '';\n    let msg = `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value${field}: '${formatValue(oldValue)}'. Current value: '${formatValue(currValue)}'.${componentClassName ? ` Expression location: ${componentClassName} component` : ''}`;\n    if (creationMode) {\n        msg +=\n            ` It seems like the view has been created after its parent and its children have been dirty checked.` +\n                ` Has it been created in a change detection hook?`;\n    }\n    throw new RuntimeError(-100 /* RuntimeErrorCode.EXPRESSION_CHANGED_AFTER_CHECKED */, msg);\n}\nfunction formatValue(value) {\n    let strValue = String(value);\n    // JSON.stringify will throw on circular references\n    try {\n        if (Array.isArray(value) || strValue === '[object Object]') {\n            strValue = JSON.stringify(value);\n        }\n    }\n    catch (error) {\n    }\n    return strValue.length > VALUE_STRING_LENGTH_LIMIT ?\n        (strValue.substring(0, VALUE_STRING_LENGTH_LIMIT) + '…') :\n        strValue;\n}\nfunction constructDetailsForInterpolation(lView, rootIndex, expressionIndex, meta, changedValue) {\n    const [propName, prefix, ...chunks] = meta.split(INTERPOLATION_DELIMITER);\n    let oldValue = prefix, newValue = prefix;\n    for (let i = 0; i < chunks.length; i++) {\n        const slotIdx = rootIndex + i;\n        oldValue += `${lView[slotIdx]}${chunks[i]}`;\n        newValue += `${slotIdx === expressionIndex ? changedValue : lView[slotIdx]}${chunks[i]}`;\n    }\n    return { propName, oldValue, newValue };\n}\n/**\n * Constructs an object that contains details for the ExpressionChangedAfterItHasBeenCheckedError:\n * - property name (for property bindings or interpolations)\n * - old and new values, enriched using information from metadata\n *\n * More information on the metadata storage format can be found in `storePropertyBindingMetadata`\n * function description.\n */\nfunction getExpressionChangedErrorDetails(lView, bindingIndex, oldValue, newValue) {\n    const tData = lView[TVIEW].data;\n    const metadata = tData[bindingIndex];\n    if (typeof metadata === 'string') {\n        // metadata for property interpolation\n        if (metadata.indexOf(INTERPOLATION_DELIMITER) > -1) {\n            return constructDetailsForInterpolation(lView, bindingIndex, bindingIndex, metadata, newValue);\n        }\n        // metadata for property binding\n        return { propName: metadata, oldValue, newValue };\n    }\n    // metadata is not available for this expression, check if this expression is a part of the\n    // property interpolation by going from the current binding index left and look for a string that\n    // contains INTERPOLATION_DELIMITER, the layout in tView.data for this case will look like this:\n    // [..., 'id�Prefix � and � suffix', null, null, null, ...]\n    if (metadata === null) {\n        let idx = bindingIndex - 1;\n        while (typeof tData[idx] !== 'string' && tData[idx + 1] === null) {\n            idx--;\n        }\n        const meta = tData[idx];\n        if (typeof meta === 'string') {\n            const matches = meta.match(new RegExp(INTERPOLATION_DELIMITER, 'g'));\n            // first interpolation delimiter separates property name from interpolation parts (in case of\n            // property interpolations), so we subtract one from total number of found delimiters\n            if (matches && (matches.length - 1) > bindingIndex - idx) {\n                return constructDetailsForInterpolation(lView, idx, bindingIndex, meta, newValue);\n            }\n        }\n    }\n    return { propName: undefined, oldValue, newValue };\n}\n\nlet currentConsumer = null;\nfunction setLViewForConsumer(node, lView) {\n    (typeof ngDevMode === 'undefined' || ngDevMode) &&\n        assertEqual(node.lView, null, 'Consumer already associated with a view.');\n    node.lView = lView;\n}\n/**\n * Create a new template consumer pointing at the specified LView.\n * Sometimes, a previously created consumer may be reused, in order to save on allocations. In that\n * case, the LView will be updated.\n */\nfunction getReactiveLViewConsumer(lView, slot) {\n    return lView[slot] ?? getOrCreateCurrentLViewConsumer();\n}\n/**\n * Assigns the `currentTemplateContext` to its LView's `REACTIVE_CONSUMER` slot if there are tracked\n * producers.\n *\n * The presence of producers means that a signal was read while the consumer was the active\n * consumer.\n *\n * If no producers are present, we do not assign the current template context. This also means we\n * can just reuse the template context for the next LView.\n */\nfunction commitLViewConsumerIfHasProducers(lView, slot) {\n    const consumer = getOrCreateCurrentLViewConsumer();\n    if (!consumer.producerNode?.length) {\n        return;\n    }\n    lView[slot] = currentConsumer;\n    consumer.lView = lView;\n    currentConsumer = createLViewConsumer();\n}\nconst REACTIVE_LVIEW_CONSUMER_NODE = {\n    ...REACTIVE_NODE,\n    consumerIsAlwaysLive: true,\n    consumerMarkedDirty: (node) => {\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n            assertDefined(node.lView, 'Updating a signal during template or host binding execution is not allowed.');\n        markViewDirty(node.lView);\n    },\n    lView: null,\n};\nfunction createLViewConsumer() {\n    return Object.create(REACTIVE_LVIEW_CONSUMER_NODE);\n}\nfunction getOrCreateCurrentLViewConsumer() {\n    currentConsumer ??= createLViewConsumer();\n    return currentConsumer;\n}\n\n/** A special value which designates that a value has not changed. */\nconst NO_CHANGE = (typeof ngDevMode === 'undefined' || ngDevMode) ? { __brand__: 'NO_CHANGE' } : {};\n\n/**\n * Advances to an element for later binding instructions.\n *\n * Used in conjunction with instructions like {@link property} to act on elements with specified\n * indices, for example those created with {@link element} or {@link elementStart}.\n *\n * ```ts\n * (rf: RenderFlags, ctx: any) => {\n *   if (rf & 1) {\n *     text(0, 'Hello');\n *     text(1, 'Goodbye')\n *     element(2, 'div');\n *   }\n *   if (rf & 2) {\n *     advance(2); // Advance twice to the <div>.\n *     property('title', 'test');\n *   }\n *  }\n * ```\n * @param delta Number of elements to advance forwards by.\n *\n * @codeGenApi\n */\nfunction ɵɵadvance(delta) {\n    ngDevMode && assertGreaterThan(delta, 0, 'Can only advance forward');\n    selectIndexInternal(getTView(), getLView(), getSelectedIndex() + delta, !!ngDevMode && isInCheckNoChangesMode());\n}\nfunction selectIndexInternal(tView, lView, index, checkNoChangesMode) {\n    ngDevMode && assertIndexInDeclRange(lView, index);\n    // Flush the initial hooks for elements in the view that have been added up to this point.\n    // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n    if (!checkNoChangesMode) {\n        const hooksInitPhaseCompleted = (lView[FLAGS] & 3 /* LViewFlags.InitPhaseStateMask */) === 3 /* InitPhaseState.InitPhaseCompleted */;\n        if (hooksInitPhaseCompleted) {\n            const preOrderCheckHooks = tView.preOrderCheckHooks;\n            if (preOrderCheckHooks !== null) {\n                executeCheckHooks(lView, preOrderCheckHooks, index);\n            }\n        }\n        else {\n            const preOrderHooks = tView.preOrderHooks;\n            if (preOrderHooks !== null) {\n                executeInitAndCheckHooks(lView, preOrderHooks, 0 /* InitPhaseState.OnInitHooksToBeRun */, index);\n            }\n        }\n    }\n    // We must set the selected index *after* running the hooks, because hooks may have side-effects\n    // that cause other template functions to run, thus updating the selected index, which is global\n    // state. If we run `setSelectedIndex` *before* we run the hooks, in some cases the selected index\n    // will be altered by the time we leave the `ɵɵadvance` instruction.\n    setSelectedIndex(index);\n}\n\nfunction ɵɵdirectiveInject(token, flags = InjectFlags.Default) {\n    const lView = getLView();\n    // Fall back to inject() if view hasn't been created. This situation can happen in tests\n    // if inject utilities are used before bootstrapping.\n    if (lView === null) {\n        // Verify that we will not get into infinite loop.\n        ngDevMode && assertInjectImplementationNotEqual(ɵɵdirectiveInject);\n        return ɵɵinject(token, flags);\n    }\n    const tNode = getCurrentTNode();\n    const value = getOrCreateInjectable(tNode, lView, resolveForwardRef(token), flags);\n    ngDevMode && emitInjectEvent(token, value, flags);\n    return value;\n}\n/**\n * Throws an error indicating that a factory function could not be generated by the compiler for a\n * particular class.\n *\n * This instruction allows the actual error message to be optimized away when ngDevMode is turned\n * off, saving bytes of generated code while still providing a good experience in dev mode.\n *\n * The name of the class is not mentioned here, but will be in the generated factory function name\n * and thus in the stack trace.\n *\n * @codeGenApi\n */\nfunction ɵɵinvalidFactory() {\n    const msg = ngDevMode ? `This constructor was not compatible with Dependency Injection.` : 'invalid';\n    throw new Error(msg);\n}\n\n/**\n * Invoke `HostBindingsFunction`s for view.\n *\n * This methods executes `TView.hostBindingOpCodes`. It is used to execute the\n * `HostBindingsFunction`s associated with the current `LView`.\n *\n * @param tView Current `TView`.\n * @param lView Current `LView`.\n */\nfunction processHostBindingOpCodes(tView, lView) {\n    const hostBindingOpCodes = tView.hostBindingOpCodes;\n    if (hostBindingOpCodes === null)\n        return;\n    const consumer = getReactiveLViewConsumer(lView, REACTIVE_HOST_BINDING_CONSUMER);\n    try {\n        for (let i = 0; i < hostBindingOpCodes.length; i++) {\n            const opCode = hostBindingOpCodes[i];\n            if (opCode < 0) {\n                // Negative numbers are element indexes.\n                setSelectedIndex(~opCode);\n            }\n            else {\n                // Positive numbers are NumberTuple which store bindingRootIndex and directiveIndex.\n                const directiveIdx = opCode;\n                const bindingRootIndx = hostBindingOpCodes[++i];\n                const hostBindingFn = hostBindingOpCodes[++i];\n                setBindingRootForHostBindings(bindingRootIndx, directiveIdx);\n                consumer.dirty = false;\n                const prevConsumer = consumerBeforeComputation(consumer);\n                try {\n                    const context = lView[directiveIdx];\n                    hostBindingFn(2 /* RenderFlags.Update */, context);\n                }\n                finally {\n                    consumerAfterComputation(consumer, prevConsumer);\n                }\n            }\n        }\n    }\n    finally {\n        if (lView[REACTIVE_HOST_BINDING_CONSUMER] === null) {\n            commitLViewConsumerIfHasProducers(lView, REACTIVE_HOST_BINDING_CONSUMER);\n        }\n        setSelectedIndex(-1);\n    }\n}\nfunction createLView(parentLView, tView, context, flags, host, tHostNode, environment, renderer, injector, embeddedViewInjector, hydrationInfo) {\n    const lView = tView.blueprint.slice();\n    lView[HOST] = host;\n    lView[FLAGS] = flags | 4 /* LViewFlags.CreationMode */ | 128 /* LViewFlags.Attached */ | 8 /* LViewFlags.FirstLViewPass */;\n    if (embeddedViewInjector !== null ||\n        (parentLView && (parentLView[FLAGS] & 2048 /* LViewFlags.HasEmbeddedViewInjector */))) {\n        lView[FLAGS] |= 2048 /* LViewFlags.HasEmbeddedViewInjector */;\n    }\n    resetPreOrderHookFlags(lView);\n    ngDevMode && tView.declTNode && parentLView && assertTNodeForLView(tView.declTNode, parentLView);\n    lView[PARENT] = lView[DECLARATION_VIEW] = parentLView;\n    lView[CONTEXT] = context;\n    lView[ENVIRONMENT] = (environment || parentLView && parentLView[ENVIRONMENT]);\n    ngDevMode && assertDefined(lView[ENVIRONMENT], 'LViewEnvironment is required');\n    lView[RENDERER] = (renderer || parentLView && parentLView[RENDERER]);\n    ngDevMode && assertDefined(lView[RENDERER], 'Renderer is required');\n    lView[INJECTOR$1] = injector || parentLView && parentLView[INJECTOR$1] || null;\n    lView[T_HOST] = tHostNode;\n    lView[ID] = getUniqueLViewId();\n    lView[HYDRATION] = hydrationInfo;\n    lView[EMBEDDED_VIEW_INJECTOR] = embeddedViewInjector;\n    ngDevMode &&\n        assertEqual(tView.type == 2 /* TViewType.Embedded */ ? parentLView !== null : true, true, 'Embedded views must have parentLView');\n    lView[DECLARATION_COMPONENT_VIEW] =\n        tView.type == 2 /* TViewType.Embedded */ ? parentLView[DECLARATION_COMPONENT_VIEW] : lView;\n    return lView;\n}\nfunction getOrCreateTNode(tView, index, type, name, attrs) {\n    ngDevMode && index !== 0 && // 0 are bogus nodes and they are OK. See `createContainerRef` in\n        // `view_engine_compatibility` for additional context.\n        assertGreaterThanOrEqual(index, HEADER_OFFSET, 'TNodes can\\'t be in the LView header.');\n    // Keep this function short, so that the VM will inline it.\n    ngDevMode && assertPureTNodeType(type);\n    let tNode = tView.data[index];\n    if (tNode === null) {\n        tNode = createTNodeAtIndex(tView, index, type, name, attrs);\n        if (isInI18nBlock()) {\n            // If we are in i18n block then all elements should be pre declared through `Placeholder`\n            // See `TNodeType.Placeholder` and `LFrame.inI18n` for more context.\n            // If the `TNode` was not pre-declared than it means it was not mentioned which means it was\n            // removed, so we mark it as detached.\n            tNode.flags |= 32 /* TNodeFlags.isDetached */;\n        }\n    }\n    else if (tNode.type & 64 /* TNodeType.Placeholder */) {\n        tNode.type = type;\n        tNode.value = name;\n        tNode.attrs = attrs;\n        const parent = getCurrentParentTNode();\n        tNode.injectorIndex = parent === null ? -1 : parent.injectorIndex;\n        ngDevMode && assertTNodeForTView(tNode, tView);\n        ngDevMode && assertEqual(index, tNode.index, 'Expecting same index');\n    }\n    setCurrentTNode(tNode, true);\n    return tNode;\n}\nfunction createTNodeAtIndex(tView, index, type, name, attrs) {\n    const currentTNode = getCurrentTNodePlaceholderOk();\n    const isParent = isCurrentTNodeParent();\n    const parent = isParent ? currentTNode : currentTNode && currentTNode.parent;\n    // Parents cannot cross component boundaries because components will be used in multiple places.\n    const tNode = tView.data[index] =\n        createTNode(tView, parent, type, index, name, attrs);\n    // Assign a pointer to the first child node of a given view. The first node is not always the one\n    // at index 0, in case of i18n, index 0 can be the instruction `i18nStart` and the first node has\n    // the index 1 or more, so we can't just check node index.\n    if (tView.firstChild === null) {\n        tView.firstChild = tNode;\n    }\n    if (currentTNode !== null) {\n        if (isParent) {\n            // FIXME(misko): This logic looks unnecessarily complicated. Could we simplify?\n            if (currentTNode.child == null && tNode.parent !== null) {\n                // We are in the same view, which means we are adding content node to the parent view.\n                currentTNode.child = tNode;\n            }\n        }\n        else {\n            if (currentTNode.next === null) {\n                // In the case of i18n the `currentTNode` may already be linked, in which case we don't want\n                // to break the links which i18n created.\n                currentTNode.next = tNode;\n                tNode.prev = currentTNode;\n            }\n        }\n    }\n    return tNode;\n}\n/**\n * When elements are created dynamically after a view blueprint is created (e.g. through\n * i18nApply()), we need to adjust the blueprint for future\n * template passes.\n *\n * @param tView `TView` associated with `LView`\n * @param lView The `LView` containing the blueprint to adjust\n * @param numSlotsToAlloc The number of slots to alloc in the LView, should be >0\n * @param initialValue Initial value to store in blueprint\n */\nfunction allocExpando(tView, lView, numSlotsToAlloc, initialValue) {\n    if (numSlotsToAlloc === 0)\n        return -1;\n    if (ngDevMode) {\n        assertFirstCreatePass(tView);\n        assertSame(tView, lView[TVIEW], '`LView` must be associated with `TView`!');\n        assertEqual(tView.data.length, lView.length, 'Expecting LView to be same size as TView');\n        assertEqual(tView.data.length, tView.blueprint.length, 'Expecting Blueprint to be same size as TView');\n        assertFirstUpdatePass(tView);\n    }\n    const allocIdx = lView.length;\n    for (let i = 0; i < numSlotsToAlloc; i++) {\n        lView.push(initialValue);\n        tView.blueprint.push(initialValue);\n        tView.data.push(null);\n    }\n    return allocIdx;\n}\nfunction executeTemplate(tView, lView, templateFn, rf, context) {\n    const consumer = getReactiveLViewConsumer(lView, REACTIVE_TEMPLATE_CONSUMER);\n    const prevSelectedIndex = getSelectedIndex();\n    const isUpdatePhase = rf & 2 /* RenderFlags.Update */;\n    try {\n        setSelectedIndex(-1);\n        if (isUpdatePhase && lView.length > HEADER_OFFSET) {\n            // When we're updating, inherently select 0 so we don't\n            // have to generate that instruction for most update blocks.\n            selectIndexInternal(tView, lView, HEADER_OFFSET, !!ngDevMode && isInCheckNoChangesMode());\n        }\n        const preHookType = isUpdatePhase ? 2 /* ProfilerEvent.TemplateUpdateStart */ : 0 /* ProfilerEvent.TemplateCreateStart */;\n        profiler(preHookType, context);\n        const effectiveConsumer = isUpdatePhase ? consumer : null;\n        const prevConsumer = consumerBeforeComputation(effectiveConsumer);\n        try {\n            if (effectiveConsumer !== null) {\n                effectiveConsumer.dirty = false;\n            }\n            templateFn(rf, context);\n        }\n        finally {\n            consumerAfterComputation(effectiveConsumer, prevConsumer);\n        }\n    }\n    finally {\n        if (isUpdatePhase && lView[REACTIVE_TEMPLATE_CONSUMER] === null) {\n            commitLViewConsumerIfHasProducers(lView, REACTIVE_TEMPLATE_CONSUMER);\n        }\n        setSelectedIndex(prevSelectedIndex);\n        const postHookType = isUpdatePhase ? 3 /* ProfilerEvent.TemplateUpdateEnd */ : 1 /* ProfilerEvent.TemplateCreateEnd */;\n        profiler(postHookType, context);\n    }\n}\n//////////////////////////\n//// Element\n//////////////////////////\nfunction executeContentQueries(tView, tNode, lView) {\n    if (isContentQueryHost(tNode)) {\n        const prevConsumer = setActiveConsumer(null);\n        try {\n            const start = tNode.directiveStart;\n            const end = tNode.directiveEnd;\n            for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {\n                const def = tView.data[directiveIndex];\n                if (def.contentQueries) {\n                    def.contentQueries(1 /* RenderFlags.Create */, lView[directiveIndex], directiveIndex);\n                }\n            }\n        }\n        finally {\n            setActiveConsumer(prevConsumer);\n        }\n    }\n}\n/**\n * Creates directive instances.\n */\nfunction createDirectivesInstances(tView, lView, tNode) {\n    if (!getBindingsEnabled())\n        return;\n    instantiateAllDirectives(tView, lView, tNode, getNativeByTNode(tNode, lView));\n    if ((tNode.flags & 64 /* TNodeFlags.hasHostBindings */) === 64 /* TNodeFlags.hasHostBindings */) {\n        invokeDirectivesHostBindings(tView, lView, tNode);\n    }\n}\n/**\n * Takes a list of local names and indices and pushes the resolved local variable values\n * to LView in the same order as they are loaded in the template with load().\n */\nfunction saveResolvedLocalsInData(viewData, tNode, localRefExtractor = getNativeByTNode) {\n    const localNames = tNode.localNames;\n    if (localNames !== null) {\n        let localIndex = tNode.index + 1;\n        for (let i = 0; i < localNames.length; i += 2) {\n            const index = localNames[i + 1];\n            const value = index === -1 ?\n                localRefExtractor(tNode, viewData) :\n                viewData[index];\n            viewData[localIndex++] = value;\n        }\n    }\n}\n/**\n * Gets TView from a template function or creates a new TView\n * if it doesn't already exist.\n *\n * @param def ComponentDef\n * @returns TView\n */\nfunction getOrCreateComponentTView(def) {\n    const tView = def.tView;\n    // Create a TView if there isn't one, or recreate it if the first create pass didn't\n    // complete successfully since we can't know for sure whether it's in a usable shape.\n    if (tView === null || tView.incompleteFirstPass) {\n        // Declaration node here is null since this function is called when we dynamically create a\n        // component and hence there is no declaration.\n        const declTNode = null;\n        return def.tView = createTView(1 /* TViewType.Component */, declTNode, def.template, def.decls, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery, def.schemas, def.consts, def.id);\n    }\n    return tView;\n}\n/**\n * Creates a TView instance\n *\n * @param type Type of `TView`.\n * @param declTNode Declaration location of this `TView`.\n * @param templateFn Template function\n * @param decls The number of nodes, local refs, and pipes in this template\n * @param directives Registry of directives for this view\n * @param pipes Registry of pipes for this view\n * @param viewQuery View queries for this view\n * @param schemas Schemas for this view\n * @param consts Constants for this view\n */\nfunction createTView(type, declTNode, templateFn, decls, vars, directives, pipes, viewQuery, schemas, constsOrFactory, ssrId) {\n    ngDevMode && ngDevMode.tView++;\n    const bindingStartIndex = HEADER_OFFSET + decls;\n    // This length does not yet contain host bindings from child directives because at this point,\n    // we don't know which directives are active on this template. As soon as a directive is matched\n    // that has a host binding, we will update the blueprint with that def's hostVars count.\n    const initialViewLength = bindingStartIndex + vars;\n    const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);\n    const consts = typeof constsOrFactory === 'function' ? constsOrFactory() : constsOrFactory;\n    const tView = blueprint[TVIEW] = {\n        type: type,\n        blueprint: blueprint,\n        template: templateFn,\n        queries: null,\n        viewQuery: viewQuery,\n        declTNode: declTNode,\n        data: blueprint.slice().fill(null, bindingStartIndex),\n        bindingStartIndex: bindingStartIndex,\n        expandoStartIndex: initialViewLength,\n        hostBindingOpCodes: null,\n        firstCreatePass: true,\n        firstUpdatePass: true,\n        staticViewQueries: false,\n        staticContentQueries: false,\n        preOrderHooks: null,\n        preOrderCheckHooks: null,\n        contentHooks: null,\n        contentCheckHooks: null,\n        viewHooks: null,\n        viewCheckHooks: null,\n        destroyHooks: null,\n        cleanup: null,\n        contentQueries: null,\n        components: null,\n        directiveRegistry: typeof directives === 'function' ? directives() : directives,\n        pipeRegistry: typeof pipes === 'function' ? pipes() : pipes,\n        firstChild: null,\n        schemas: schemas,\n        consts: consts,\n        incompleteFirstPass: false,\n        ssrId,\n    };\n    if (ngDevMode) {\n        // For performance reasons it is important that the tView retains the same shape during runtime.\n        // (To make sure that all of the code is monomorphic.) For this reason we seal the object to\n        // prevent class transitions.\n        Object.seal(tView);\n    }\n    return tView;\n}\nfunction createViewBlueprint(bindingStartIndex, initialViewLength) {\n    const blueprint = [];\n    for (let i = 0; i < initialViewLength; i++) {\n        blueprint.push(i < bindingStartIndex ? null : NO_CHANGE);\n    }\n    return blueprint;\n}\n/**\n * Locates the host native element, used for bootstrapping existing nodes into rendering pipeline.\n *\n * @param renderer the renderer used to locate the element.\n * @param elementOrSelector Render element or CSS selector to locate the element.\n * @param encapsulation View Encapsulation defined for component that requests host element.\n * @param injector Root view injector instance.\n */\nfunction locateHostElement(renderer, elementOrSelector, encapsulation, injector) {\n    // Note: we use default value for the `PRESERVE_HOST_CONTENT` here even though it's a\n    // tree-shakable one (providedIn:'root'). This code path can be triggered during dynamic\n    // component creation (after calling ViewContainerRef.createComponent) when an injector\n    // instance can be provided. The injector instance might be disconnected from the main DI\n    // tree, thus the `PRESERVE_HOST_CONTENT` would not be able to instantiate. In this case, the\n    // default value will be used.\n    const preserveHostContent = injector.get(PRESERVE_HOST_CONTENT, PRESERVE_HOST_CONTENT_DEFAULT);\n    // When using native Shadow DOM, do not clear host element to allow native slot\n    // projection.\n    const preserveContent = preserveHostContent || encapsulation === ViewEncapsulation.ShadowDom;\n    const rootElement = renderer.selectRootElement(elementOrSelector, preserveContent);\n    applyRootElementTransform(rootElement);\n    return rootElement;\n}\n/**\n * Applies any root element transformations that are needed. If hydration is enabled,\n * this will process corrupted text nodes.\n *\n * @param rootElement the app root HTML Element\n */\nfunction applyRootElementTransform(rootElement) {\n    _applyRootElementTransformImpl(rootElement);\n}\n/**\n * Reference to a function that applies transformations to the root HTML element\n * of an app. When hydration is enabled, this processes any corrupt text nodes\n * so they are properly hydratable on the client.\n *\n * @param rootElement the app root HTML Element\n */\nlet _applyRootElementTransformImpl = (rootElement) => null;\n/**\n * Processes text node markers before hydration begins. This replaces any special comment\n * nodes that were added prior to serialization are swapped out to restore proper text\n * nodes before hydration.\n *\n * @param rootElement the app root HTML Element\n */\nfunction applyRootElementTransformImpl(rootElement) {\n    if (hasSkipHydrationAttrOnRElement(rootElement)) {\n        // Handle a situation when the `ngSkipHydration` attribute is applied\n        // to the root node of an application. In this case, we should clear\n        // the contents and render everything from scratch.\n        clearElementContents(rootElement);\n    }\n    else {\n        processTextNodeMarkersBeforeHydration(rootElement);\n    }\n}\n/**\n * Sets the implementation for the `applyRootElementTransform` function.\n */\nfunction enableApplyRootElementTransformImpl() {\n    _applyRootElementTransformImpl = applyRootElementTransformImpl;\n}\n/**\n * Saves context for this cleanup function in LView.cleanupInstances.\n *\n * On the first template pass, saves in TView:\n * - Cleanup function\n * - Index of context we just saved in LView.cleanupInstances\n */\nfunction storeCleanupWithContext(tView, lView, context, cleanupFn) {\n    const lCleanup = getOrCreateLViewCleanup(lView);\n    // Historically the `storeCleanupWithContext` was used to register both framework-level and\n    // user-defined cleanup callbacks, but over time those two types of cleanups were separated.\n    // This dev mode checks assures that user-level cleanup callbacks are _not_ stored in data\n    // structures reserved for framework-specific hooks.\n    ngDevMode &&\n        assertDefined(context, 'Cleanup context is mandatory when registering framework-level destroy hooks');\n    lCleanup.push(context);\n    if (tView.firstCreatePass) {\n        getOrCreateTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);\n    }\n    else {\n        // Make sure that no new framework-level cleanup functions are registered after the first\n        // template pass is done (and TView data structures are meant to fully constructed).\n        if (ngDevMode) {\n            Object.freeze(getOrCreateTViewCleanup(tView));\n        }\n    }\n}\nfunction createTNode(tView, tParent, type, index, value, attrs) {\n    ngDevMode && index !== 0 && // 0 are bogus nodes and they are OK. See `createContainerRef` in\n        // `view_engine_compatibility` for additional context.\n        assertGreaterThanOrEqual(index, HEADER_OFFSET, 'TNodes can\\'t be in the LView header.');\n    ngDevMode && assertNotSame(attrs, undefined, '\\'undefined\\' is not valid value for \\'attrs\\'');\n    ngDevMode && ngDevMode.tNode++;\n    ngDevMode && tParent && assertTNodeForTView(tParent, tView);\n    let injectorIndex = tParent ? tParent.injectorIndex : -1;\n    let flags = 0;\n    if (isInSkipHydrationBlock$1()) {\n        flags |= 128 /* TNodeFlags.inSkipHydrationBlock */;\n    }\n    const tNode = {\n        type,\n        index,\n        insertBeforeIndex: null,\n        injectorIndex,\n        directiveStart: -1,\n        directiveEnd: -1,\n        directiveStylingLast: -1,\n        componentOffset: -1,\n        propertyBindings: null,\n        flags,\n        providerIndexes: 0,\n        value: value,\n        attrs: attrs,\n        mergedAttrs: null,\n        localNames: null,\n        initialInputs: undefined,\n        inputs: null,\n        outputs: null,\n        tView: null,\n        next: null,\n        prev: null,\n        projectionNext: null,\n        child: null,\n        parent: tParent,\n        projection: null,\n        styles: null,\n        stylesWithoutHost: null,\n        residualStyles: undefined,\n        classes: null,\n        classesWithoutHost: null,\n        residualClasses: undefined,\n        classBindings: 0,\n        styleBindings: 0,\n    };\n    if (ngDevMode) {\n        // For performance reasons it is important that the tNode retains the same shape during runtime.\n        // (To make sure that all of the code is monomorphic.) For this reason we seal the object to\n        // prevent class transitions.\n        Object.seal(tNode);\n    }\n    return tNode;\n}\n/**\n * Generates the `PropertyAliases` data structure from the provided input/output mapping.\n * @param aliasMap Input/output mapping from the directive definition.\n * @param directiveIndex Index of the directive.\n * @param propertyAliases Object in which to store the results.\n * @param hostDirectiveAliasMap Object used to alias or filter out properties for host directives.\n * If the mapping is provided, it'll act as an allowlist, as well as a mapping of what public\n * name inputs/outputs should be exposed under.\n */\nfunction generatePropertyAliases(aliasMap, directiveIndex, propertyAliases, hostDirectiveAliasMap) {\n    for (let publicName in aliasMap) {\n        if (aliasMap.hasOwnProperty(publicName)) {\n            propertyAliases = propertyAliases === null ? {} : propertyAliases;\n            const internalName = aliasMap[publicName];\n            // If there are no host directive mappings, we want to remap using the alias map from the\n            // definition itself. If there is an alias map, it has two functions:\n            // 1. It serves as an allowlist of bindings that are exposed by the host directives. Only the\n            // ones inside the host directive map will be exposed on the host.\n            // 2. The public name of the property is aliased using the host directive alias map, rather\n            // than the alias map from the definition.\n            if (hostDirectiveAliasMap === null) {\n                addPropertyAlias(propertyAliases, directiveIndex, publicName, internalName);\n            }\n            else if (hostDirectiveAliasMap.hasOwnProperty(publicName)) {\n                addPropertyAlias(propertyAliases, directiveIndex, hostDirectiveAliasMap[publicName], internalName);\n            }\n        }\n    }\n    return propertyAliases;\n}\nfunction addPropertyAlias(propertyAliases, directiveIndex, publicName, internalName) {\n    if (propertyAliases.hasOwnProperty(publicName)) {\n        propertyAliases[publicName].push(directiveIndex, internalName);\n    }\n    else {\n        propertyAliases[publicName] = [directiveIndex, internalName];\n    }\n}\n/**\n * Initializes data structures required to work with directive inputs and outputs.\n * Initialization is done for all directives matched on a given TNode.\n */\nfunction initializeInputAndOutputAliases(tView, tNode, hostDirectiveDefinitionMap) {\n    ngDevMode && assertFirstCreatePass(tView);\n    const start = tNode.directiveStart;\n    const end = tNode.directiveEnd;\n    const tViewData = tView.data;\n    const tNodeAttrs = tNode.attrs;\n    const inputsFromAttrs = [];\n    let inputsStore = null;\n    let outputsStore = null;\n    for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {\n        const directiveDef = tViewData[directiveIndex];\n        const aliasData = hostDirectiveDefinitionMap ? hostDirectiveDefinitionMap.get(directiveDef) : null;\n        const aliasedInputs = aliasData ? aliasData.inputs : null;\n        const aliasedOutputs = aliasData ? aliasData.outputs : null;\n        inputsStore =\n            generatePropertyAliases(directiveDef.inputs, directiveIndex, inputsStore, aliasedInputs);\n        outputsStore =\n            generatePropertyAliases(directiveDef.outputs, directiveIndex, outputsStore, aliasedOutputs);\n        // Do not use unbound attributes as inputs to structural directives, since structural\n        // directive inputs can only be set using microsyntax (e.g. `<div *dir=\"exp\">`).\n        // TODO(FW-1930): microsyntax expressions may also contain unbound/static attributes, which\n        // should be set for inline templates.\n        const initialInputs = (inputsStore !== null && tNodeAttrs !== null && !isInlineTemplate(tNode)) ?\n            generateInitialInputs(inputsStore, directiveIndex, tNodeAttrs) :\n            null;\n        inputsFromAttrs.push(initialInputs);\n    }\n    if (inputsStore !== null) {\n        if (inputsStore.hasOwnProperty('class')) {\n            tNode.flags |= 8 /* TNodeFlags.hasClassInput */;\n        }\n        if (inputsStore.hasOwnProperty('style')) {\n            tNode.flags |= 16 /* TNodeFlags.hasStyleInput */;\n        }\n    }\n    tNode.initialInputs = inputsFromAttrs;\n    tNode.inputs = inputsStore;\n    tNode.outputs = outputsStore;\n}\n/**\n * Mapping between attributes names that don't correspond to their element property names.\n *\n * Performance note: this function is written as a series of if checks (instead of, say, a property\n * object lookup) for performance reasons - the series of `if` checks seems to be the fastest way of\n * mapping property names. Do NOT change without benchmarking.\n *\n * Note: this mapping has to be kept in sync with the equally named mapping in the template\n * type-checking machinery of ngtsc.\n */\nfunction mapPropName(name) {\n    if (name === 'class')\n        return 'className';\n    if (name === 'for')\n        return 'htmlFor';\n    if (name === 'formaction')\n        return 'formAction';\n    if (name === 'innerHtml')\n        return 'innerHTML';\n    if (name === 'readonly')\n        return 'readOnly';\n    if (name === 'tabindex')\n        return 'tabIndex';\n    return name;\n}\nfunction elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, nativeOnly) {\n    ngDevMode && assertNotSame(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');\n    const element = getNativeByTNode(tNode, lView);\n    let inputData = tNode.inputs;\n    let dataValue;\n    if (!nativeOnly && inputData != null && (dataValue = inputData[propName])) {\n        setInputsForProperty(tView, lView, dataValue, propName, value);\n        if (isComponentHost(tNode))\n            markDirtyIfOnPush(lView, tNode.index);\n        if (ngDevMode) {\n            setNgReflectProperties(lView, element, tNode.type, dataValue, value);\n        }\n    }\n    else if (tNode.type & 3 /* TNodeType.AnyRNode */) {\n        propName = mapPropName(propName);\n        if (ngDevMode) {\n            validateAgainstEventProperties(propName);\n            if (!isPropertyValid(element, propName, tNode.value, tView.schemas)) {\n                handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);\n            }\n            ngDevMode.rendererSetProperty++;\n        }\n        // It is assumed that the sanitizer is only added when the compiler determines that the\n        // property is risky, so sanitization can be done without further checks.\n        value = sanitizer != null ? sanitizer(value, tNode.value || '', propName) : value;\n        renderer.setProperty(element, propName, value);\n    }\n    else if (tNode.type & 12 /* TNodeType.AnyContainer */) {\n        // If the node is a container and the property didn't\n        // match any of the inputs or schemas we should throw.\n        if (ngDevMode && !matchingSchemas(tView.schemas, tNode.value)) {\n            handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);\n        }\n    }\n}\n/** If node is an OnPush component, marks its LView dirty. */\nfunction markDirtyIfOnPush(lView, viewIndex) {\n    ngDevMode && assertLView(lView);\n    const childComponentLView = getComponentLViewByIndex(viewIndex, lView);\n    if (!(childComponentLView[FLAGS] & 16 /* LViewFlags.CheckAlways */)) {\n        childComponentLView[FLAGS] |= 64 /* LViewFlags.Dirty */;\n    }\n}\nfunction setNgReflectProperty(lView, element, type, attrName, value) {\n    const renderer = lView[RENDERER];\n    attrName = normalizeDebugBindingName(attrName);\n    const debugValue = normalizeDebugBindingValue(value);\n    if (type & 3 /* TNodeType.AnyRNode */) {\n        if (value == null) {\n            renderer.removeAttribute(element, attrName);\n        }\n        else {\n            renderer.setAttribute(element, attrName, debugValue);\n        }\n    }\n    else {\n        const textContent = escapeCommentText(`bindings=${JSON.stringify({ [attrName]: debugValue }, null, 2)}`);\n        renderer.setValue(element, textContent);\n    }\n}\nfunction setNgReflectProperties(lView, element, type, dataValue, value) {\n    if (type & (3 /* TNodeType.AnyRNode */ | 4 /* TNodeType.Container */)) {\n        /**\n         * dataValue is an array containing runtime input or output names for the directives:\n         * i+0: directive instance index\n         * i+1: privateName\n         *\n         * e.g. [0, 'change', 'change-minified']\n         * we want to set the reflected property with the privateName: dataValue[i+1]\n         */\n        for (let i = 0; i < dataValue.length; i += 2) {\n            setNgReflectProperty(lView, element, type, dataValue[i + 1], value);\n        }\n    }\n}\n/**\n * Resolve the matched directives on a node.\n */\nfunction resolveDirectives(tView, lView, tNode, localRefs) {\n    // Please make sure to have explicit type for `exportsMap`. Inferred type triggers bug in\n    // tsickle.\n    ngDevMode && assertFirstCreatePass(tView);\n    if (getBindingsEnabled()) {\n        const exportsMap = localRefs === null ? null : { '': -1 };\n        const matchResult = findDirectiveDefMatches(tView, tNode);\n        let directiveDefs;\n        let hostDirectiveDefs;\n        if (matchResult === null) {\n            directiveDefs = hostDirectiveDefs = null;\n        }\n        else {\n            [directiveDefs, hostDirectiveDefs] = matchResult;\n        }\n        if (directiveDefs !== null) {\n            initializeDirectives(tView, lView, tNode, directiveDefs, exportsMap, hostDirectiveDefs);\n        }\n        if (exportsMap)\n            cacheMatchingLocalNames(tNode, localRefs, exportsMap);\n    }\n    // Merge the template attrs last so that they have the highest priority.\n    tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);\n}\n/** Initializes the data structures necessary for a list of directives to be instantiated. */\nfunction initializeDirectives(tView, lView, tNode, directives, exportsMap, hostDirectiveDefs) {\n    ngDevMode && assertFirstCreatePass(tView);\n    // Publishes the directive types to DI so they can be injected. Needs to\n    // happen in a separate pass before the TNode flags have been initialized.\n    for (let i = 0; i < directives.length; i++) {\n        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, directives[i].type);\n    }\n    initTNodeFlags(tNode, tView.data.length, directives.length);\n    // When the same token is provided by several directives on the same node, some rules apply in\n    // the viewEngine:\n    // - viewProviders have priority over providers\n    // - the last directive in NgModule.declarations has priority over the previous one\n    // So to match these rules, the order in which providers are added in the arrays is very\n    // important.\n    for (let i = 0; i < directives.length; i++) {\n        const def = directives[i];\n        if (def.providersResolver)\n            def.providersResolver(def);\n    }\n    let preOrderHooksFound = false;\n    let preOrderCheckHooksFound = false;\n    let directiveIdx = allocExpando(tView, lView, directives.length, null);\n    ngDevMode &&\n        assertSame(directiveIdx, tNode.directiveStart, 'TNode.directiveStart should point to just allocated space');\n    for (let i = 0; i < directives.length; i++) {\n        const def = directives[i];\n        // Merge the attrs in the order of matches. This assumes that the first directive is the\n        // component itself, so that the component has the least priority.\n        tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);\n        configureViewWithDirective(tView, tNode, lView, directiveIdx, def);\n        saveNameToExportMap(directiveIdx, def, exportsMap);\n        if (def.contentQueries !== null)\n            tNode.flags |= 4 /* TNodeFlags.hasContentQuery */;\n        if (def.hostBindings !== null || def.hostAttrs !== null || def.hostVars !== 0)\n            tNode.flags |= 64 /* TNodeFlags.hasHostBindings */;\n        const lifeCycleHooks = def.type.prototype;\n        // Only push a node index into the preOrderHooks array if this is the first\n        // pre-order hook found on this node.\n        if (!preOrderHooksFound &&\n            (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngOnInit || lifeCycleHooks.ngDoCheck)) {\n            // We will push the actual hook function into this array later during dir instantiation.\n            // We cannot do it now because we must ensure hooks are registered in the same\n            // order that directives are created (i.e. injection order).\n            (tView.preOrderHooks ??= []).push(tNode.index);\n            preOrderHooksFound = true;\n        }\n        if (!preOrderCheckHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngDoCheck)) {\n            (tView.preOrderCheckHooks ??= []).push(tNode.index);\n            preOrderCheckHooksFound = true;\n        }\n        directiveIdx++;\n    }\n    initializeInputAndOutputAliases(tView, tNode, hostDirectiveDefs);\n}\n/**\n * Add `hostBindings` to the `TView.hostBindingOpCodes`.\n *\n * @param tView `TView` to which the `hostBindings` should be added.\n * @param tNode `TNode` the element which contains the directive\n * @param directiveIdx Directive index in view.\n * @param directiveVarsIdx Where will the directive's vars be stored\n * @param def `ComponentDef`/`DirectiveDef`, which contains the `hostVars`/`hostBindings` to add.\n */\nfunction registerHostBindingOpCodes(tView, tNode, directiveIdx, directiveVarsIdx, def) {\n    ngDevMode && assertFirstCreatePass(tView);\n    const hostBindings = def.hostBindings;\n    if (hostBindings) {\n        let hostBindingOpCodes = tView.hostBindingOpCodes;\n        if (hostBindingOpCodes === null) {\n            hostBindingOpCodes = tView.hostBindingOpCodes = [];\n        }\n        const elementIndx = ~tNode.index;\n        if (lastSelectedElementIdx(hostBindingOpCodes) != elementIndx) {\n            // Conditionally add select element so that we are more efficient in execution.\n            // NOTE: this is strictly not necessary and it trades code size for runtime perf.\n            // (We could just always add it.)\n            hostBindingOpCodes.push(elementIndx);\n        }\n        hostBindingOpCodes.push(directiveIdx, directiveVarsIdx, hostBindings);\n    }\n}\n/**\n * Returns the last selected element index in the `HostBindingOpCodes`\n *\n * For perf reasons we don't need to update the selected element index in `HostBindingOpCodes` only\n * if it changes. This method returns the last index (or '0' if not found.)\n *\n * Selected element index are only the ones which are negative.\n */\nfunction lastSelectedElementIdx(hostBindingOpCodes) {\n    let i = hostBindingOpCodes.length;\n    while (i > 0) {\n        const value = hostBindingOpCodes[--i];\n        if (typeof value === 'number' && value < 0) {\n            return value;\n        }\n    }\n    return 0;\n}\n/**\n * Instantiate all the directives that were previously resolved on the current node.\n */\nfunction instantiateAllDirectives(tView, lView, tNode, native) {\n    const start = tNode.directiveStart;\n    const end = tNode.directiveEnd;\n    // The component view needs to be created before creating the node injector\n    // since it is used to inject some special symbols like `ChangeDetectorRef`.\n    if (isComponentHost(tNode)) {\n        ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */);\n        addComponentLogic(lView, tNode, tView.data[start + tNode.componentOffset]);\n    }\n    if (!tView.firstCreatePass) {\n        getOrCreateNodeInjectorForNode(tNode, lView);\n    }\n    attachPatchData(native, lView);\n    const initialInputs = tNode.initialInputs;\n    for (let i = start; i < end; i++) {\n        const def = tView.data[i];\n        const directive = getNodeInjectable(lView, tView, i, tNode);\n        attachPatchData(directive, lView);\n        if (initialInputs !== null) {\n            setInputsFromAttrs(lView, i - start, directive, def, tNode, initialInputs);\n        }\n        if (isComponentDef(def)) {\n            const componentView = getComponentLViewByIndex(tNode.index, lView);\n            componentView[CONTEXT] = getNodeInjectable(lView, tView, i, tNode);\n        }\n    }\n}\nfunction invokeDirectivesHostBindings(tView, lView, tNode) {\n    const start = tNode.directiveStart;\n    const end = tNode.directiveEnd;\n    const elementIndex = tNode.index;\n    const currentDirectiveIndex = getCurrentDirectiveIndex();\n    try {\n        setSelectedIndex(elementIndex);\n        for (let dirIndex = start; dirIndex < end; dirIndex++) {\n            const def = tView.data[dirIndex];\n            const directive = lView[dirIndex];\n            setCurrentDirectiveIndex(dirIndex);\n            if (def.hostBindings !== null || def.hostVars !== 0 || def.hostAttrs !== null) {\n                invokeHostBindingsInCreationMode(def, directive);\n            }\n        }\n    }\n    finally {\n        setSelectedIndex(-1);\n        setCurrentDirectiveIndex(currentDirectiveIndex);\n    }\n}\n/**\n * Invoke the host bindings in creation mode.\n *\n * @param def `DirectiveDef` which may contain the `hostBindings` function.\n * @param directive Instance of directive.\n */\nfunction invokeHostBindingsInCreationMode(def, directive) {\n    if (def.hostBindings !== null) {\n        def.hostBindings(1 /* RenderFlags.Create */, directive);\n    }\n}\n/**\n * Matches the current node against all available selectors.\n * If a component is matched (at most one), it is returned in first position in the array.\n */\nfunction findDirectiveDefMatches(tView, tNode) {\n    ngDevMode && assertFirstCreatePass(tView);\n    ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 12 /* TNodeType.AnyContainer */);\n    const registry = tView.directiveRegistry;\n    let matches = null;\n    let hostDirectiveDefs = null;\n    if (registry) {\n        for (let i = 0; i < registry.length; i++) {\n            const def = registry[i];\n            if (isNodeMatchingSelectorList(tNode, def.selectors, /* isProjectionMode */ false)) {\n                matches || (matches = []);\n                if (isComponentDef(def)) {\n                    if (ngDevMode) {\n                        assertTNodeType(tNode, 2 /* TNodeType.Element */, `\"${tNode.value}\" tags cannot be used as component hosts. ` +\n                            `Please use a different tag to activate the ${stringify(def.type)} component.`);\n                        if (isComponentHost(tNode)) {\n                            throwMultipleComponentError(tNode, matches.find(isComponentDef).type, def.type);\n                        }\n                    }\n                    // Components are inserted at the front of the matches array so that their lifecycle\n                    // hooks run before any directive lifecycle hooks. This appears to be for ViewEngine\n                    // compatibility. This logic doesn't make sense with host directives, because it\n                    // would allow the host directives to undo any overrides the host may have made.\n                    // To handle this case, the host directives of components are inserted at the beginning\n                    // of the array, followed by the component. As such, the insertion order is as follows:\n                    // 1. Host directives belonging to the selector-matched component.\n                    // 2. Selector-matched component.\n                    // 3. Host directives belonging to selector-matched directives.\n                    // 4. Selector-matched directives.\n                    if (def.findHostDirectiveDefs !== null) {\n                        const hostDirectiveMatches = [];\n                        hostDirectiveDefs = hostDirectiveDefs || new Map();\n                        def.findHostDirectiveDefs(def, hostDirectiveMatches, hostDirectiveDefs);\n                        // Add all host directives declared on this component, followed by the component itself.\n                        // Host directives should execute first so the host has a chance to override changes\n                        // to the DOM made by them.\n                        matches.unshift(...hostDirectiveMatches, def);\n                        // Component is offset starting from the beginning of the host directives array.\n                        const componentOffset = hostDirectiveMatches.length;\n                        markAsComponentHost(tView, tNode, componentOffset);\n                    }\n                    else {\n                        // No host directives on this component, just add the\n                        // component def to the beginning of the matches.\n                        matches.unshift(def);\n                        markAsComponentHost(tView, tNode, 0);\n                    }\n                }\n                else {\n                    // Append any host directives to the matches first.\n                    hostDirectiveDefs = hostDirectiveDefs || new Map();\n                    def.findHostDirectiveDefs?.(def, matches, hostDirectiveDefs);\n                    matches.push(def);\n                }\n            }\n        }\n    }\n    return matches === null ? null : [matches, hostDirectiveDefs];\n}\n/**\n * Marks a given TNode as a component's host. This consists of:\n * - setting the component offset on the TNode.\n * - storing index of component's host element so it will be queued for view refresh during CD.\n */\nfunction markAsComponentHost(tView, hostTNode, componentOffset) {\n    ngDevMode && assertFirstCreatePass(tView);\n    ngDevMode && assertGreaterThan(componentOffset, -1, 'componentOffset must be great than -1');\n    hostTNode.componentOffset = componentOffset;\n    (tView.components ??= []).push(hostTNode.index);\n}\n/** Caches local names and their matching directive indices for query and template lookups. */\nfunction cacheMatchingLocalNames(tNode, localRefs, exportsMap) {\n    if (localRefs) {\n        const localNames = tNode.localNames = [];\n        // Local names must be stored in tNode in the same order that localRefs are defined\n        // in the template to ensure the data is loaded in the same slots as their refs\n        // in the template (for template queries).\n        for (let i = 0; i < localRefs.length; i += 2) {\n            const index = exportsMap[localRefs[i + 1]];\n            if (index == null)\n                throw new RuntimeError(-301 /* RuntimeErrorCode.EXPORT_NOT_FOUND */, ngDevMode && `Export of name '${localRefs[i + 1]}' not found!`);\n            localNames.push(localRefs[i], index);\n        }\n    }\n}\n/**\n * Builds up an export map as directives are created, so local refs can be quickly mapped\n * to their directive instances.\n */\nfunction saveNameToExportMap(directiveIdx, def, exportsMap) {\n    if (exportsMap) {\n        if (def.exportAs) {\n            for (let i = 0; i < def.exportAs.length; i++) {\n                exportsMap[def.exportAs[i]] = directiveIdx;\n            }\n        }\n        if (isComponentDef(def))\n            exportsMap[''] = directiveIdx;\n    }\n}\n/**\n * Initializes the flags on the current node, setting all indices to the initial index,\n * the directive count to 0, and adding the isComponent flag.\n * @param index the initial index\n */\nfunction initTNodeFlags(tNode, index, numberOfDirectives) {\n    ngDevMode &&\n        assertNotEqual(numberOfDirectives, tNode.directiveEnd - tNode.directiveStart, 'Reached the max number of directives');\n    tNode.flags |= 1 /* TNodeFlags.isDirectiveHost */;\n    // When the first directive is created on a node, save the index\n    tNode.directiveStart = index;\n    tNode.directiveEnd = index + numberOfDirectives;\n    tNode.providerIndexes = index;\n}\n/**\n * Setup directive for instantiation.\n *\n * We need to create a `NodeInjectorFactory` which is then inserted in both the `Blueprint` as well\n * as `LView`. `TView` gets the `DirectiveDef`.\n *\n * @param tView `TView`\n * @param tNode `TNode`\n * @param lView `LView`\n * @param directiveIndex Index where the directive will be stored in the Expando.\n * @param def `DirectiveDef`\n */\nfunction configureViewWithDirective(tView, tNode, lView, directiveIndex, def) {\n    ngDevMode &&\n        assertGreaterThanOrEqual(directiveIndex, HEADER_OFFSET, 'Must be in Expando section');\n    tView.data[directiveIndex] = def;\n    const directiveFactory = def.factory || (def.factory = getFactoryDef(def.type, true));\n    // Even though `directiveFactory` will already be using `ɵɵdirectiveInject` in its generated code,\n    // we also want to support `inject()` directly from the directive constructor context so we set\n    // `ɵɵdirectiveInject` as the inject implementation here too.\n    const nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), ɵɵdirectiveInject);\n    tView.blueprint[directiveIndex] = nodeInjectorFactory;\n    lView[directiveIndex] = nodeInjectorFactory;\n    registerHostBindingOpCodes(tView, tNode, directiveIndex, allocExpando(tView, lView, def.hostVars, NO_CHANGE), def);\n}\nfunction addComponentLogic(lView, hostTNode, def) {\n    const native = getNativeByTNode(hostTNode, lView);\n    const tView = getOrCreateComponentTView(def);\n    // Only component views should be added to the view tree directly. Embedded views are\n    // accessed through their containers because they may be removed / re-added later.\n    const rendererFactory = lView[ENVIRONMENT].rendererFactory;\n    let lViewFlags = 16 /* LViewFlags.CheckAlways */;\n    if (def.signals) {\n        lViewFlags = 4096 /* LViewFlags.SignalView */;\n    }\n    else if (def.onPush) {\n        lViewFlags = 64 /* LViewFlags.Dirty */;\n    }\n    const componentView = addToViewTree(lView, createLView(lView, tView, null, lViewFlags, native, hostTNode, null, rendererFactory.createRenderer(native, def), null, null, null));\n    // Component view will always be created before any injected LContainers,\n    // so this is a regular element, wrap it with the component view\n    lView[hostTNode.index] = componentView;\n}\nfunction elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace) {\n    if (ngDevMode) {\n        assertNotSame(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');\n        validateAgainstEventAttributes(name);\n        assertTNodeType(tNode, 2 /* TNodeType.Element */, `Attempted to set attribute \\`${name}\\` on a container node. ` +\n            `Host bindings are not valid on ng-container or ng-template.`);\n    }\n    const element = getNativeByTNode(tNode, lView);\n    setElementAttribute(lView[RENDERER], element, namespace, tNode.value, name, value, sanitizer);\n}\nfunction setElementAttribute(renderer, element, namespace, tagName, name, value, sanitizer) {\n    if (value == null) {\n        ngDevMode && ngDevMode.rendererRemoveAttribute++;\n        renderer.removeAttribute(element, name, namespace);\n    }\n    else {\n        ngDevMode && ngDevMode.rendererSetAttribute++;\n        const strValue = sanitizer == null ? renderStringify(value) : sanitizer(value, tagName || '', name);\n        renderer.setAttribute(element, name, strValue, namespace);\n    }\n}\n/**\n * Sets initial input properties on directive instances from attribute data\n *\n * @param lView Current LView that is being processed.\n * @param directiveIndex Index of the directive in directives array\n * @param instance Instance of the directive on which to set the initial inputs\n * @param def The directive def that contains the list of inputs\n * @param tNode The static data for this node\n */\nfunction setInputsFromAttrs(lView, directiveIndex, instance, def, tNode, initialInputData) {\n    const initialInputs = initialInputData[directiveIndex];\n    if (initialInputs !== null) {\n        for (let i = 0; i < initialInputs.length;) {\n            const publicName = initialInputs[i++];\n            const privateName = initialInputs[i++];\n            const value = initialInputs[i++];\n            writeToDirectiveInput(def, instance, publicName, privateName, value);\n            if (ngDevMode) {\n                const nativeElement = getNativeByTNode(tNode, lView);\n                setNgReflectProperty(lView, nativeElement, tNode.type, privateName, value);\n            }\n        }\n    }\n}\nfunction writeToDirectiveInput(def, instance, publicName, privateName, value) {\n    const prevConsumer = setActiveConsumer(null);\n    try {\n        const inputTransforms = def.inputTransforms;\n        if (inputTransforms !== null && inputTransforms.hasOwnProperty(privateName)) {\n            value = inputTransforms[privateName].call(instance, value);\n        }\n        if (def.setInput !== null) {\n            def.setInput(instance, value, publicName, privateName);\n        }\n        else {\n            instance[privateName] = value;\n        }\n    }\n    finally {\n        setActiveConsumer(prevConsumer);\n    }\n}\n/**\n * Generates initialInputData for a node and stores it in the template's static storage\n * so subsequent template invocations don't have to recalculate it.\n *\n * initialInputData is an array containing values that need to be set as input properties\n * for directives on this node, but only once on creation. We need this array to support\n * the case where you set an @Input property of a directive using attribute-like syntax.\n * e.g. if you have a `name` @Input, you can set it once like this:\n *\n * <my-component name=\"Bess\"></my-component>\n *\n * @param inputs Input alias map that was generated from the directive def inputs.\n * @param directiveIndex Index of the directive that is currently being processed.\n * @param attrs Static attrs on this node.\n */\nfunction generateInitialInputs(inputs, directiveIndex, attrs) {\n    let inputsToStore = null;\n    let i = 0;\n    while (i < attrs.length) {\n        const attrName = attrs[i];\n        if (attrName === 0 /* AttributeMarker.NamespaceURI */) {\n            // We do not allow inputs on namespaced attributes.\n            i += 4;\n            continue;\n        }\n        else if (attrName === 5 /* AttributeMarker.ProjectAs */) {\n            // Skip over the `ngProjectAs` value.\n            i += 2;\n            continue;\n        }\n        // If we hit any other attribute markers, we're done anyway. None of those are valid inputs.\n        if (typeof attrName === 'number')\n            break;\n        if (inputs.hasOwnProperty(attrName)) {\n            if (inputsToStore === null)\n                inputsToStore = [];\n            // Find the input's public name from the input store. Note that we can be found easier\n            // through the directive def, but we want to do it using the inputs store so that it can\n            // account for host directive aliases.\n            const inputConfig = inputs[attrName];\n            for (let j = 0; j < inputConfig.length; j += 2) {\n                if (inputConfig[j] === directiveIndex) {\n                    inputsToStore.push(attrName, inputConfig[j + 1], attrs[i + 1]);\n                    // A directive can't have multiple inputs with the same name so we can break here.\n                    break;\n                }\n            }\n        }\n        i += 2;\n    }\n    return inputsToStore;\n}\n//////////////////////////\n//// ViewContainer & View\n//////////////////////////\n/**\n * Creates a LContainer, either from a container instruction, or for a ViewContainerRef.\n *\n * @param hostNative The host element for the LContainer\n * @param hostTNode The host TNode for the LContainer\n * @param currentView The parent view of the LContainer\n * @param native The native comment element\n * @param isForViewContainerRef Optional a flag indicating the ViewContainerRef case\n * @returns LContainer\n */\nfunction createLContainer(hostNative, currentView, native, tNode) {\n    ngDevMode && assertLView(currentView);\n    const lContainer = [\n        hostNative,\n        true,\n        false,\n        currentView,\n        null,\n        0,\n        tNode,\n        native,\n        null,\n        null,\n        null, // dehydrated views\n    ];\n    ngDevMode &&\n        assertEqual(lContainer.length, CONTAINER_HEADER_OFFSET, 'Should allocate correct number of slots for LContainer header.');\n    return lContainer;\n}\n/** Refreshes all content queries declared by directives in a given view */\nfunction refreshContentQueries(tView, lView) {\n    const contentQueries = tView.contentQueries;\n    if (contentQueries !== null) {\n        for (let i = 0; i < contentQueries.length; i += 2) {\n            const queryStartIdx = contentQueries[i];\n            const directiveDefIdx = contentQueries[i + 1];\n            if (directiveDefIdx !== -1) {\n                const directiveDef = tView.data[directiveDefIdx];\n                ngDevMode && assertDefined(directiveDef, 'DirectiveDef not found.');\n                ngDevMode &&\n                    assertDefined(directiveDef.contentQueries, 'contentQueries function should be defined');\n                setCurrentQueryIndex(queryStartIdx);\n                directiveDef.contentQueries(2 /* RenderFlags.Update */, lView[directiveDefIdx], directiveDefIdx);\n            }\n        }\n    }\n}\n/**\n * Adds LView or LContainer to the end of the current view tree.\n *\n * This structure will be used to traverse through nested views to remove listeners\n * and call onDestroy callbacks.\n *\n * @param lView The view where LView or LContainer should be added\n * @param adjustedHostIndex Index of the view's host node in LView[], adjusted for header\n * @param lViewOrLContainer The LView or LContainer to add to the view tree\n * @returns The state passed in\n */\nfunction addToViewTree(lView, lViewOrLContainer) {\n    // TODO(benlesh/misko): This implementation is incorrect, because it always adds the LContainer\n    // to the end of the queue, which means if the developer retrieves the LContainers from RNodes out\n    // of order, the change detection will run out of order, as the act of retrieving the the\n    // LContainer from the RNode is what adds it to the queue.\n    if (lView[CHILD_HEAD]) {\n        lView[CHILD_TAIL][NEXT] = lViewOrLContainer;\n    }\n    else {\n        lView[CHILD_HEAD] = lViewOrLContainer;\n    }\n    lView[CHILD_TAIL] = lViewOrLContainer;\n    return lViewOrLContainer;\n}\n///////////////////////////////\n//// Change detection\n///////////////////////////////\nfunction executeViewQueryFn(flags, viewQueryFn, component) {\n    ngDevMode && assertDefined(viewQueryFn, 'View queries function to execute must be defined.');\n    setCurrentQueryIndex(0);\n    const prevConsumer = setActiveConsumer(null);\n    try {\n        viewQueryFn(flags, component);\n    }\n    finally {\n        setActiveConsumer(prevConsumer);\n    }\n}\n///////////////////////////////\n//// Bindings & interpolations\n///////////////////////////////\n/**\n * Stores meta-data for a property binding to be used by TestBed's `DebugElement.properties`.\n *\n * In order to support TestBed's `DebugElement.properties` we need to save, for each binding:\n * - a bound property name;\n * - a static parts of interpolated strings;\n *\n * A given property metadata is saved at the binding's index in the `TView.data` (in other words, a\n * property binding metadata will be stored in `TView.data` at the same index as a bound value in\n * `LView`). Metadata are represented as `INTERPOLATION_DELIMITER`-delimited string with the\n * following format:\n * - `propertyName` for bound properties;\n * - `propertyName�prefix�interpolation_static_part1�..interpolation_static_partN�suffix` for\n * interpolated properties.\n *\n * @param tData `TData` where meta-data will be saved;\n * @param tNode `TNode` that is a target of the binding;\n * @param propertyName bound property name;\n * @param bindingIndex binding index in `LView`\n * @param interpolationParts static interpolation parts (for property interpolations)\n */\nfunction storePropertyBindingMetadata(tData, tNode, propertyName, bindingIndex, ...interpolationParts) {\n    // Binding meta-data are stored only the first time a given property instruction is processed.\n    // Since we don't have a concept of the \"first update pass\" we need to check for presence of the\n    // binding meta-data to decide if one should be stored (or if was stored already).\n    if (tData[bindingIndex] === null) {\n        if (tNode.inputs == null || !tNode.inputs[propertyName]) {\n            const propBindingIdxs = tNode.propertyBindings || (tNode.propertyBindings = []);\n            propBindingIdxs.push(bindingIndex);\n            let bindingMetadata = propertyName;\n            if (interpolationParts.length > 0) {\n                bindingMetadata +=\n                    INTERPOLATION_DELIMITER + interpolationParts.join(INTERPOLATION_DELIMITER);\n            }\n            tData[bindingIndex] = bindingMetadata;\n        }\n    }\n}\nfunction getOrCreateLViewCleanup(view) {\n    // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n    return view[CLEANUP] || (view[CLEANUP] = []);\n}\nfunction getOrCreateTViewCleanup(tView) {\n    return tView.cleanup || (tView.cleanup = []);\n}\n/**\n * There are cases where the sub component's renderer needs to be included\n * instead of the current renderer (see the componentSyntheticHost* instructions).\n */\nfunction loadComponentRenderer(currentDef, tNode, lView) {\n    // TODO(FW-2043): the `currentDef` is null when host bindings are invoked while creating root\n    // component (see packages/core/src/render3/component.ts). This is not consistent with the process\n    // of creating inner components, when current directive index is available in the state. In order\n    // to avoid relying on current def being `null` (thus special-casing root component creation), the\n    // process of creating root component should be unified with the process of creating inner\n    // components.\n    if (currentDef === null || isComponentDef(currentDef)) {\n        lView = unwrapLView(lView[tNode.index]);\n    }\n    return lView[RENDERER];\n}\n/** Handles an error thrown in an LView. */\nfunction handleError(lView, error) {\n    const injector = lView[INJECTOR$1];\n    const errorHandler = injector ? injector.get(ErrorHandler, null) : null;\n    errorHandler && errorHandler.handleError(error);\n}\n/**\n * Set the inputs of directives at the current node to corresponding value.\n *\n * @param tView The current TView\n * @param lView the `LView` which contains the directives.\n * @param inputs mapping between the public \"input\" name and privately-known,\n *        possibly minified, property names to write to.\n * @param value Value to set.\n */\nfunction setInputsForProperty(tView, lView, inputs, publicName, value) {\n    for (let i = 0; i < inputs.length;) {\n        const index = inputs[i++];\n        const privateName = inputs[i++];\n        const instance = lView[index];\n        ngDevMode && assertIndexInRange(lView, index);\n        const def = tView.data[index];\n        writeToDirectiveInput(def, instance, publicName, privateName, value);\n    }\n}\n/**\n * Updates a text binding at a given index in a given LView.\n */\nfunction textBindingInternal(lView, index, value) {\n    ngDevMode && assertString(value, 'Value should be a string');\n    ngDevMode && assertNotSame(value, NO_CHANGE, 'value should not be NO_CHANGE');\n    ngDevMode && assertIndexInRange(lView, index);\n    const element = getNativeByIndex(index, lView);\n    ngDevMode && assertDefined(element, 'native element should exist');\n    updateTextNode(lView[RENDERER], element, value);\n}\n\nfunction renderComponent(hostLView, componentHostIdx) {\n    ngDevMode && assertEqual(isCreationMode(hostLView), true, 'Should be run in creation mode');\n    const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);\n    const componentTView = componentView[TVIEW];\n    syncViewWithBlueprint(componentTView, componentView);\n    const hostRNode = componentView[HOST];\n    // Populate an LView with hydration info retrieved from the DOM via TransferState.\n    if (hostRNode !== null && componentView[HYDRATION] === null) {\n        componentView[HYDRATION] = retrieveHydrationInfo(hostRNode, componentView[INJECTOR$1]);\n    }\n    renderView(componentTView, componentView, componentView[CONTEXT]);\n}\n/**\n * Syncs an LView instance with its blueprint if they have gotten out of sync.\n *\n * Typically, blueprints and their view instances should always be in sync, so the loop here\n * will be skipped. However, consider this case of two components side-by-side:\n *\n * App template:\n * ```\n * <comp></comp>\n * <comp></comp>\n * ```\n *\n * The following will happen:\n * 1. App template begins processing.\n * 2. First <comp> is matched as a component and its LView is created.\n * 3. Second <comp> is matched as a component and its LView is created.\n * 4. App template completes processing, so it's time to check child templates.\n * 5. First <comp> template is checked. It has a directive, so its def is pushed to blueprint.\n * 6. Second <comp> template is checked. Its blueprint has been updated by the first\n * <comp> template, but its LView was created before this update, so it is out of sync.\n *\n * Note that embedded views inside ngFor loops will never be out of sync because these views\n * are processed as soon as they are created.\n *\n * @param tView The `TView` that contains the blueprint for syncing\n * @param lView The view to sync\n */\nfunction syncViewWithBlueprint(tView, lView) {\n    for (let i = lView.length; i < tView.blueprint.length; i++) {\n        lView.push(tView.blueprint[i]);\n    }\n}\n/**\n * Processes a view in the creation mode. This includes a number of steps in a specific order:\n * - creating view query functions (if any);\n * - executing a template function in the creation mode;\n * - updating static queries (if any);\n * - creating child components defined in a given view.\n */\nfunction renderView(tView, lView, context) {\n    ngDevMode && assertEqual(isCreationMode(lView), true, 'Should be run in creation mode');\n    enterView(lView);\n    try {\n        const viewQuery = tView.viewQuery;\n        if (viewQuery !== null) {\n            executeViewQueryFn(1 /* RenderFlags.Create */, viewQuery, context);\n        }\n        // Execute a template associated with this view, if it exists. A template function might not be\n        // defined for the root component views.\n        const templateFn = tView.template;\n        if (templateFn !== null) {\n            executeTemplate(tView, lView, templateFn, 1 /* RenderFlags.Create */, context);\n        }\n        // This needs to be set before children are processed to support recursive components.\n        // This must be set to false immediately after the first creation run because in an\n        // ngFor loop, all the views will be created together before update mode runs and turns\n        // off firstCreatePass. If we don't set it here, instances will perform directive\n        // matching, etc again and again.\n        if (tView.firstCreatePass) {\n            tView.firstCreatePass = false;\n        }\n        // We resolve content queries specifically marked as `static` in creation mode. Dynamic\n        // content queries are resolved during change detection (i.e. update mode), after embedded\n        // views are refreshed (see block above).\n        if (tView.staticContentQueries) {\n            refreshContentQueries(tView, lView);\n        }\n        // We must materialize query results before child components are processed\n        // in case a child component has projected a container. The LContainer needs\n        // to exist so the embedded views are properly attached by the container.\n        if (tView.staticViewQueries) {\n            executeViewQueryFn(2 /* RenderFlags.Update */, tView.viewQuery, context);\n        }\n        // Render child component views.\n        const components = tView.components;\n        if (components !== null) {\n            renderChildComponents(lView, components);\n        }\n    }\n    catch (error) {\n        // If we didn't manage to get past the first template pass due to\n        // an error, mark the view as corrupted so we can try to recover.\n        if (tView.firstCreatePass) {\n            tView.incompleteFirstPass = true;\n            tView.firstCreatePass = false;\n        }\n        throw error;\n    }\n    finally {\n        lView[FLAGS] &= ~4 /* LViewFlags.CreationMode */;\n        leaveView();\n    }\n}\n/** Renders child components in the current view (creation mode). */\nfunction renderChildComponents(hostLView, components) {\n    for (let i = 0; i < components.length; i++) {\n        renderComponent(hostLView, components[i]);\n    }\n}\n\n/**\n * Tracks all effects registered within a given application and runs them via `flush`.\n */\nclass EffectManager {\n    constructor() {\n        this.all = new Set();\n        this.queue = new Map();\n    }\n    create(effectFn, destroyRef, allowSignalWrites) {\n        const zone = (typeof Zone === 'undefined') ? null : Zone.current;\n        const w = watch(effectFn, (watch) => {\n            if (!this.all.has(watch)) {\n                return;\n            }\n            this.queue.set(watch, zone);\n        }, allowSignalWrites);\n        this.all.add(w);\n        // Effects start dirty.\n        w.notify();\n        let unregisterOnDestroy;\n        const destroy = () => {\n            w.cleanup();\n            unregisterOnDestroy?.();\n            this.all.delete(w);\n            this.queue.delete(w);\n        };\n        unregisterOnDestroy = destroyRef?.onDestroy(destroy);\n        return {\n            destroy,\n        };\n    }\n    flush() {\n        if (this.queue.size === 0) {\n            return;\n        }\n        for (const [watch, zone] of this.queue) {\n            this.queue.delete(watch);\n            if (zone) {\n                zone.run(() => watch.run());\n            }\n            else {\n                watch.run();\n            }\n        }\n    }\n    get isQueueEmpty() {\n        return this.queue.size === 0;\n    }\n    /** @nocollapse */\n    static { this.ɵprov = ɵɵdefineInjectable({\n        token: EffectManager,\n        providedIn: 'root',\n        factory: () => new EffectManager(),\n    }); }\n}\n/**\n * Create a global `Effect` for the given reactive function.\n *\n * @developerPreview\n */\nfunction effect(effectFn, options) {\n    !options?.injector && assertInInjectionContext(effect);\n    const injector = options?.injector ?? inject$1(Injector);\n    const effectManager = injector.get(EffectManager);\n    const destroyRef = options?.manualCleanup !== true ? injector.get(DestroyRef) : null;\n    return effectManager.create(effectFn, destroyRef, !!options?.allowSignalWrites);\n}\n\n/**\n * Compute the static styling (class/style) from `TAttributes`.\n *\n * This function should be called during `firstCreatePass` only.\n *\n * @param tNode The `TNode` into which the styling information should be loaded.\n * @param attrs `TAttributes` containing the styling information.\n * @param writeToHost Where should the resulting static styles be written?\n *   - `false` Write to `TNode.stylesWithoutHost` / `TNode.classesWithoutHost`\n *   - `true` Write to `TNode.styles` / `TNode.classes`\n */\nfunction computeStaticStyling(tNode, attrs, writeToHost) {\n    ngDevMode &&\n        assertFirstCreatePass(getTView(), 'Expecting to be called in first template pass only');\n    let styles = writeToHost ? tNode.styles : null;\n    let classes = writeToHost ? tNode.classes : null;\n    let mode = 0;\n    if (attrs !== null) {\n        for (let i = 0; i < attrs.length; i++) {\n            const value = attrs[i];\n            if (typeof value === 'number') {\n                mode = value;\n            }\n            else if (mode == 1 /* AttributeMarker.Classes */) {\n                classes = concatStringsWithSpace(classes, value);\n            }\n            else if (mode == 2 /* AttributeMarker.Styles */) {\n                const style = value;\n                const styleValue = attrs[++i];\n                styles = concatStringsWithSpace(styles, style + ': ' + styleValue + ';');\n            }\n        }\n    }\n    writeToHost ? tNode.styles = styles : tNode.stylesWithoutHost = styles;\n    writeToHost ? tNode.classes = classes : tNode.classesWithoutHost = classes;\n}\n\nfunction collectNativeNodes(tView, lView, tNode, result, isProjection = false) {\n    while (tNode !== null) {\n        ngDevMode &&\n            assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 12 /* TNodeType.AnyContainer */ | 16 /* TNodeType.Projection */ | 32 /* TNodeType.Icu */);\n        const lNode = lView[tNode.index];\n        if (lNode !== null) {\n            result.push(unwrapRNode(lNode));\n        }\n        // A given lNode can represent either a native node or a LContainer (when it is a host of a\n        // ViewContainerRef). When we find a LContainer we need to descend into it to collect root nodes\n        // from the views in this container.\n        if (isLContainer(lNode)) {\n            collectNativeNodesInLContainer(lNode, result);\n        }\n        const tNodeType = tNode.type;\n        if (tNodeType & 8 /* TNodeType.ElementContainer */) {\n            collectNativeNodes(tView, lView, tNode.child, result);\n        }\n        else if (tNodeType & 32 /* TNodeType.Icu */) {\n            const nextRNode = icuContainerIterate(tNode, lView);\n            let rNode;\n            while (rNode = nextRNode()) {\n                result.push(rNode);\n            }\n        }\n        else if (tNodeType & 16 /* TNodeType.Projection */) {\n            const nodesInSlot = getProjectionNodes(lView, tNode);\n            if (Array.isArray(nodesInSlot)) {\n                result.push(...nodesInSlot);\n            }\n            else {\n                const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);\n                ngDevMode && assertParentView(parentView);\n                collectNativeNodes(parentView[TVIEW], parentView, nodesInSlot, result, true);\n            }\n        }\n        tNode = isProjection ? tNode.projectionNext : tNode.next;\n    }\n    return result;\n}\n/**\n * Collects all root nodes in all views in a given LContainer.\n */\nfunction collectNativeNodesInLContainer(lContainer, result) {\n    for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n        const lViewInAContainer = lContainer[i];\n        const lViewFirstChildTNode = lViewInAContainer[TVIEW].firstChild;\n        if (lViewFirstChildTNode !== null) {\n            collectNativeNodes(lViewInAContainer[TVIEW], lViewInAContainer, lViewFirstChildTNode, result);\n        }\n    }\n    // When an LContainer is created, the anchor (comment) node is:\n    // - (1) either reused in case of an ElementContainer (<ng-container>)\n    // - (2) or a new comment node is created\n    // In the first case, the anchor comment node would be added to the final\n    // list by the code in the `collectNativeNodes` function\n    // (see the `result.push(unwrapRNode(lNode))` line), but the second\n    // case requires extra handling: the anchor node needs to be added to the\n    // final list manually. See additional information in the `createAnchorNode`\n    // function in the `view_container_ref.ts`.\n    //\n    // In the first case, the same reference would be stored in the `NATIVE`\n    // and `HOST` slots in an LContainer. Otherwise, this is the second case and\n    // we should add an element to the final list.\n    if (lContainer[NATIVE] !== lContainer[HOST]) {\n        result.push(lContainer[NATIVE]);\n    }\n}\n\nfunction detectChangesInternal(tView, lView, context, notifyErrorHandler = true) {\n    const environment = lView[ENVIRONMENT];\n    const rendererFactory = environment.rendererFactory;\n    const afterRenderEventManager = environment.afterRenderEventManager;\n    // Check no changes mode is a dev only mode used to verify that bindings have not changed\n    // since they were assigned. We do not want to invoke renderer factory functions in that mode\n    // to avoid any possible side-effects.\n    const checkNoChangesMode = !!ngDevMode && isInCheckNoChangesMode();\n    if (!checkNoChangesMode) {\n        rendererFactory.begin?.();\n        afterRenderEventManager?.begin();\n    }\n    try {\n        refreshView(tView, lView, tView.template, context);\n    }\n    catch (error) {\n        if (notifyErrorHandler) {\n            handleError(lView, error);\n        }\n        throw error;\n    }\n    finally {\n        if (!checkNoChangesMode) {\n            rendererFactory.end?.();\n            // One final flush of the effects queue to catch any effects created in `ngAfterViewInit` or\n            // other post-order hooks.\n            environment.effectManager?.flush();\n            // Invoke all callbacks registered via `after*Render`, if needed.\n            afterRenderEventManager?.end();\n        }\n    }\n}\nfunction checkNoChangesInternal(tView, lView, context, notifyErrorHandler = true) {\n    setIsInCheckNoChangesMode(true);\n    try {\n        detectChangesInternal(tView, lView, context, notifyErrorHandler);\n    }\n    finally {\n        setIsInCheckNoChangesMode(false);\n    }\n}\n/**\n * Synchronously perform change detection on a component (and possibly its sub-components).\n *\n * This function triggers change detection in a synchronous way on a component.\n *\n * @param component The component which the change detection should be performed on.\n */\nfunction detectChanges(component) {\n    const view = getComponentViewByInstance(component);\n    detectChangesInternal(view[TVIEW], view, component);\n}\n/**\n * Processes a view in update mode. This includes a number of steps in a specific order:\n * - executing a template function in update mode;\n * - executing hooks;\n * - refreshing queries;\n * - setting host bindings;\n * - refreshing child (embedded and component) views.\n */\nfunction refreshView(tView, lView, templateFn, context) {\n    ngDevMode && assertEqual(isCreationMode(lView), false, 'Should be run in update mode');\n    const flags = lView[FLAGS];\n    if ((flags & 256 /* LViewFlags.Destroyed */) === 256 /* LViewFlags.Destroyed */)\n        return;\n    // Check no changes mode is a dev only mode used to verify that bindings have not changed\n    // since they were assigned. We do not want to execute lifecycle hooks in that mode.\n    const isInCheckNoChangesPass = ngDevMode && isInCheckNoChangesMode();\n    !isInCheckNoChangesPass && lView[ENVIRONMENT].effectManager?.flush();\n    enterView(lView);\n    try {\n        resetPreOrderHookFlags(lView);\n        setBindingIndex(tView.bindingStartIndex);\n        if (templateFn !== null) {\n            executeTemplate(tView, lView, templateFn, 2 /* RenderFlags.Update */, context);\n        }\n        const hooksInitPhaseCompleted = (flags & 3 /* LViewFlags.InitPhaseStateMask */) === 3 /* InitPhaseState.InitPhaseCompleted */;\n        // execute pre-order hooks (OnInit, OnChanges, DoCheck)\n        // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n        if (!isInCheckNoChangesPass) {\n            if (hooksInitPhaseCompleted) {\n                const preOrderCheckHooks = tView.preOrderCheckHooks;\n                if (preOrderCheckHooks !== null) {\n                    executeCheckHooks(lView, preOrderCheckHooks, null);\n                }\n            }\n            else {\n                const preOrderHooks = tView.preOrderHooks;\n                if (preOrderHooks !== null) {\n                    executeInitAndCheckHooks(lView, preOrderHooks, 0 /* InitPhaseState.OnInitHooksToBeRun */, null);\n                }\n                incrementInitPhaseFlags(lView, 0 /* InitPhaseState.OnInitHooksToBeRun */);\n            }\n        }\n        // First mark transplanted views that are declared in this lView as needing a refresh at their\n        // insertion points. This is needed to avoid the situation where the template is defined in this\n        // `LView` but its declaration appears after the insertion component.\n        markTransplantedViewsForRefresh(lView);\n        detectChangesInEmbeddedViews(lView, 2 /* ChangeDetectionMode.BugToForceRefreshAndIgnoreViewFlags */);\n        // Content query results must be refreshed before content hooks are called.\n        if (tView.contentQueries !== null) {\n            refreshContentQueries(tView, lView);\n        }\n        // execute content hooks (AfterContentInit, AfterContentChecked)\n        // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n        if (!isInCheckNoChangesPass) {\n            if (hooksInitPhaseCompleted) {\n                const contentCheckHooks = tView.contentCheckHooks;\n                if (contentCheckHooks !== null) {\n                    executeCheckHooks(lView, contentCheckHooks);\n                }\n            }\n            else {\n                const contentHooks = tView.contentHooks;\n                if (contentHooks !== null) {\n                    executeInitAndCheckHooks(lView, contentHooks, 1 /* InitPhaseState.AfterContentInitHooksToBeRun */);\n                }\n                incrementInitPhaseFlags(lView, 1 /* InitPhaseState.AfterContentInitHooksToBeRun */);\n            }\n        }\n        processHostBindingOpCodes(tView, lView);\n        // Refresh child component views.\n        const components = tView.components;\n        if (components !== null) {\n            detectChangesInChildComponents(lView, components, 0 /* ChangeDetectionMode.Global */);\n        }\n        // View queries must execute after refreshing child components because a template in this view\n        // could be inserted in a child component. If the view query executes before child component\n        // refresh, the template might not yet be inserted.\n        const viewQuery = tView.viewQuery;\n        if (viewQuery !== null) {\n            executeViewQueryFn(2 /* RenderFlags.Update */, viewQuery, context);\n        }\n        // execute view hooks (AfterViewInit, AfterViewChecked)\n        // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n        if (!isInCheckNoChangesPass) {\n            if (hooksInitPhaseCompleted) {\n                const viewCheckHooks = tView.viewCheckHooks;\n                if (viewCheckHooks !== null) {\n                    executeCheckHooks(lView, viewCheckHooks);\n                }\n            }\n            else {\n                const viewHooks = tView.viewHooks;\n                if (viewHooks !== null) {\n                    executeInitAndCheckHooks(lView, viewHooks, 2 /* InitPhaseState.AfterViewInitHooksToBeRun */);\n                }\n                incrementInitPhaseFlags(lView, 2 /* InitPhaseState.AfterViewInitHooksToBeRun */);\n            }\n        }\n        if (tView.firstUpdatePass === true) {\n            // We need to make sure that we only flip the flag on successful `refreshView` only\n            // Don't do this in `finally` block.\n            // If we did this in `finally` block then an exception could block the execution of styling\n            // instructions which in turn would be unable to insert themselves into the styling linked\n            // list. The result of this would be that if the exception would not be throw on subsequent CD\n            // the styling would be unable to process it data and reflect to the DOM.\n            tView.firstUpdatePass = false;\n        }\n        // Do not reset the dirty state when running in check no changes mode. We don't want components\n        // to behave differently depending on whether check no changes is enabled or not. For example:\n        // Marking an OnPush component as dirty from within the `ngAfterViewInit` hook in order to\n        // refresh a `NgClass` binding should work. If we would reset the dirty state in the check\n        // no changes cycle, the component would be not be dirty for the next update pass. This would\n        // be different in production mode where the component dirty state is not reset.\n        if (!isInCheckNoChangesPass) {\n            lView[FLAGS] &= ~(64 /* LViewFlags.Dirty */ | 8 /* LViewFlags.FirstLViewPass */);\n        }\n        clearViewRefreshFlag(lView);\n    }\n    finally {\n        leaveView();\n    }\n}\n/**\n * Goes over embedded views (ones created through ViewContainerRef APIs) and refreshes\n * them by executing an associated template function.\n */\nfunction detectChangesInEmbeddedViews(lView, mode) {\n    for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {\n        for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n            const embeddedLView = lContainer[i];\n            detectChangesInView(embeddedLView, mode);\n        }\n    }\n}\n/**\n * Mark transplanted views as needing to be refreshed at their insertion points.\n *\n * @param lView The `LView` that may have transplanted views.\n */\nfunction markTransplantedViewsForRefresh(lView) {\n    for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {\n        if (!lContainer[HAS_TRANSPLANTED_VIEWS])\n            continue;\n        const movedViews = lContainer[MOVED_VIEWS];\n        ngDevMode && assertDefined(movedViews, 'Transplanted View flags set but missing MOVED_VIEWS');\n        for (let i = 0; i < movedViews.length; i++) {\n            const movedLView = movedViews[i];\n            const insertionLContainer = movedLView[PARENT];\n            ngDevMode && assertLContainer(insertionLContainer);\n            markViewForRefresh(movedLView);\n        }\n    }\n}\n/**\n * Detects changes in a component by entering the component view and processing its bindings,\n * queries, etc. if it is CheckAlways, OnPush and Dirty, etc.\n *\n * @param componentHostIdx  Element index in LView[] (adjusted for HEADER_OFFSET)\n */\nfunction detectChangesInComponent(hostLView, componentHostIdx, mode) {\n    ngDevMode && assertEqual(isCreationMode(hostLView), false, 'Should be run in update mode');\n    const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);\n    detectChangesInView(componentView, mode);\n}\n/**\n * Visits a view as part of change detection traversal.\n *\n * - If the view is detached, no additional traversal happens.\n *\n * The view is refreshed if:\n * - If the view is CheckAlways or Dirty and ChangeDetectionMode is `Global`\n * - If the view has the `RefreshTransplantedView` flag\n *\n * The view is not refreshed, but descendants are traversed in `ChangeDetectionMode.Targeted` if the\n * view has a non-zero TRANSPLANTED_VIEWS_TO_REFRESH counter.\n *\n */\nfunction detectChangesInView(lView, mode) {\n    if (!viewAttachedToChangeDetector(lView)) {\n        return;\n    }\n    const tView = lView[TVIEW];\n    const flags = lView[FLAGS];\n    if ((flags & (16 /* LViewFlags.CheckAlways */ | 64 /* LViewFlags.Dirty */) &&\n        mode === 0 /* ChangeDetectionMode.Global */) ||\n        flags & 1024 /* LViewFlags.RefreshView */ ||\n        mode === 2 /* ChangeDetectionMode.BugToForceRefreshAndIgnoreViewFlags */) {\n        refreshView(tView, lView, tView.template, lView[CONTEXT]);\n    }\n    else if (lView[DESCENDANT_VIEWS_TO_REFRESH] > 0) {\n        detectChangesInEmbeddedViews(lView, 1 /* ChangeDetectionMode.Targeted */);\n        const components = tView.components;\n        if (components !== null) {\n            detectChangesInChildComponents(lView, components, 1 /* ChangeDetectionMode.Targeted */);\n        }\n    }\n}\n/** Refreshes child components in the current view (update mode). */\nfunction detectChangesInChildComponents(hostLView, components, mode) {\n    for (let i = 0; i < components.length; i++) {\n        detectChangesInComponent(hostLView, components[i], mode);\n    }\n}\n\nclass ViewRef {\n    get rootNodes() {\n        const lView = this._lView;\n        const tView = lView[TVIEW];\n        return collectNativeNodes(tView, lView, tView.firstChild, []);\n    }\n    constructor(\n    /**\n     * This represents `LView` associated with the component when ViewRef is a ChangeDetectorRef.\n     *\n     * When ViewRef is created for a dynamic component, this also represents the `LView` for the\n     * component.\n     *\n     * For a \"regular\" ViewRef created for an embedded view, this is the `LView` for the embedded\n     * view.\n     *\n     * @internal\n     */\n    _lView, \n    /**\n     * This represents the `LView` associated with the point where `ChangeDetectorRef` was\n     * requested.\n     *\n     * This may be different from `_lView` if the `_cdRefInjectingView` is an embedded view.\n     */\n    _cdRefInjectingView) {\n        this._lView = _lView;\n        this._cdRefInjectingView = _cdRefInjectingView;\n        this._appRef = null;\n        this._attachedToViewContainer = false;\n    }\n    get context() {\n        return this._lView[CONTEXT];\n    }\n    set context(value) {\n        this._lView[CONTEXT] = value;\n    }\n    get destroyed() {\n        return (this._lView[FLAGS] & 256 /* LViewFlags.Destroyed */) === 256 /* LViewFlags.Destroyed */;\n    }\n    destroy() {\n        if (this._appRef) {\n            this._appRef.detachView(this);\n        }\n        else if (this._attachedToViewContainer) {\n            const parent = this._lView[PARENT];\n            if (isLContainer(parent)) {\n                const viewRefs = parent[VIEW_REFS];\n                const index = viewRefs ? viewRefs.indexOf(this) : -1;\n                if (index > -1) {\n                    ngDevMode &&\n                        assertEqual(index, parent.indexOf(this._lView) - CONTAINER_HEADER_OFFSET, 'An attached view should be in the same position within its container as its ViewRef in the VIEW_REFS array.');\n                    detachView(parent, index);\n                    removeFromArray(viewRefs, index);\n                }\n            }\n            this._attachedToViewContainer = false;\n        }\n        destroyLView(this._lView[TVIEW], this._lView);\n    }\n    onDestroy(callback) {\n        storeLViewOnDestroy(this._lView, callback);\n    }\n    /**\n     * Marks a view and all of its ancestors dirty.\n     *\n     * This can be used to ensure an {@link ChangeDetectionStrategy#OnPush} component is\n     * checked when it needs to be re-rendered but the two normal triggers haven't marked it\n     * dirty (i.e. inputs haven't changed and events haven't fired in the view).\n     *\n     * <!-- TODO: Add a link to a chapter on OnPush components -->\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * ```typescript\n     * @Component({\n     *   selector: 'app-root',\n     *   template: `Number of ticks: {{numberOfTicks}}`\n     *   changeDetection: ChangeDetectionStrategy.OnPush,\n     * })\n     * class AppComponent {\n     *   numberOfTicks = 0;\n     *\n     *   constructor(private ref: ChangeDetectorRef) {\n     *     setInterval(() => {\n     *       this.numberOfTicks++;\n     *       // the following is required, otherwise the view will not be updated\n     *       this.ref.markForCheck();\n     *     }, 1000);\n     *   }\n     * }\n     * ```\n     */\n    markForCheck() {\n        markViewDirty(this._cdRefInjectingView || this._lView);\n    }\n    /**\n     * Detaches the view from the change detection tree.\n     *\n     * Detached views will not be checked during change detection runs until they are\n     * re-attached, even if they are dirty. `detach` can be used in combination with\n     * {@link ChangeDetectorRef#detectChanges} to implement local change\n     * detection checks.\n     *\n     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * The following example defines a component with a large list of readonly data.\n     * Imagine the data changes constantly, many times per second. For performance reasons,\n     * we want to check and update the list every five seconds. We can do that by detaching\n     * the component's change detector and doing a local check every five seconds.\n     *\n     * ```typescript\n     * class DataProvider {\n     *   // in a real application the returned data will be different every time\n     *   get data() {\n     *     return [1,2,3,4,5];\n     *   }\n     * }\n     *\n     * @Component({\n     *   selector: 'giant-list',\n     *   template: `\n     *     <li *ngFor=\"let d of dataProvider.data\">Data {{d}}</li>\n     *   `,\n     * })\n     * class GiantList {\n     *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {\n     *     ref.detach();\n     *     setInterval(() => {\n     *       this.ref.detectChanges();\n     *     }, 5000);\n     *   }\n     * }\n     *\n     * @Component({\n     *   selector: 'app',\n     *   providers: [DataProvider],\n     *   template: `\n     *     <giant-list><giant-list>\n     *   `,\n     * })\n     * class App {\n     * }\n     * ```\n     */\n    detach() {\n        this._lView[FLAGS] &= ~128 /* LViewFlags.Attached */;\n    }\n    /**\n     * Re-attaches a view to the change detection tree.\n     *\n     * This can be used to re-attach views that were previously detached from the tree\n     * using {@link ChangeDetectorRef#detach}. Views are attached to the tree by default.\n     *\n     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * The following example creates a component displaying `live` data. The component will detach\n     * its change detector from the main change detector tree when the component's live property\n     * is set to false.\n     *\n     * ```typescript\n     * class DataProvider {\n     *   data = 1;\n     *\n     *   constructor() {\n     *     setInterval(() => {\n     *       this.data = this.data * 2;\n     *     }, 500);\n     *   }\n     * }\n     *\n     * @Component({\n     *   selector: 'live-data',\n     *   inputs: ['live'],\n     *   template: 'Data: {{dataProvider.data}}'\n     * })\n     * class LiveData {\n     *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}\n     *\n     *   set live(value) {\n     *     if (value) {\n     *       this.ref.reattach();\n     *     } else {\n     *       this.ref.detach();\n     *     }\n     *   }\n     * }\n     *\n     * @Component({\n     *   selector: 'app-root',\n     *   providers: [DataProvider],\n     *   template: `\n     *     Live Update: <input type=\"checkbox\" [(ngModel)]=\"live\">\n     *     <live-data [live]=\"live\"><live-data>\n     *   `,\n     * })\n     * class AppComponent {\n     *   live = true;\n     * }\n     * ```\n     */\n    reattach() {\n        this._lView[FLAGS] |= 128 /* LViewFlags.Attached */;\n    }\n    /**\n     * Checks the view and its children.\n     *\n     * This can also be used in combination with {@link ChangeDetectorRef#detach} to implement\n     * local change detection checks.\n     *\n     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * The following example defines a component with a large list of readonly data.\n     * Imagine, the data changes constantly, many times per second. For performance reasons,\n     * we want to check and update the list every five seconds.\n     *\n     * We can do that by detaching the component's change detector and doing a local change detection\n     * check every five seconds.\n     *\n     * See {@link ChangeDetectorRef#detach} for more information.\n     */\n    detectChanges() {\n        detectChangesInternal(this._lView[TVIEW], this._lView, this.context);\n    }\n    /**\n     * Checks the change detector and its children, and throws if any changes are detected.\n     *\n     * This is used in development mode to verify that running change detection doesn't\n     * introduce other changes.\n     */\n    checkNoChanges() {\n        if (ngDevMode) {\n            checkNoChangesInternal(this._lView[TVIEW], this._lView, this.context);\n        }\n    }\n    attachToViewContainerRef() {\n        if (this._appRef) {\n            throw new RuntimeError(902 /* RuntimeErrorCode.VIEW_ALREADY_ATTACHED */, ngDevMode && 'This view is already attached directly to the ApplicationRef!');\n        }\n        this._attachedToViewContainer = true;\n    }\n    detachFromAppRef() {\n        this._appRef = null;\n        detachViewFromDOM(this._lView[TVIEW], this._lView);\n    }\n    attachToAppRef(appRef) {\n        if (this._attachedToViewContainer) {\n            throw new RuntimeError(902 /* RuntimeErrorCode.VIEW_ALREADY_ATTACHED */, ngDevMode && 'This view is already attached to a ViewContainer!');\n        }\n        this._appRef = appRef;\n    }\n}\n/** @internal */\nclass RootViewRef extends ViewRef {\n    constructor(_view) {\n        super(_view);\n        this._view = _view;\n    }\n    detectChanges() {\n        const lView = this._view;\n        const tView = lView[TVIEW];\n        const context = lView[CONTEXT];\n        detectChangesInternal(tView, lView, context, false);\n    }\n    checkNoChanges() {\n        if (ngDevMode) {\n            const lView = this._view;\n            const tView = lView[TVIEW];\n            const context = lView[CONTEXT];\n            checkNoChangesInternal(tView, lView, context, false);\n        }\n    }\n    get context() {\n        return null;\n    }\n}\n\nclass ComponentFactoryResolver extends ComponentFactoryResolver$1 {\n    /**\n     * @param ngModule The NgModuleRef to which all resolved factories are bound.\n     */\n    constructor(ngModule) {\n        super();\n        this.ngModule = ngModule;\n    }\n    resolveComponentFactory(component) {\n        ngDevMode && assertComponentType(component);\n        const componentDef = getComponentDef$1(component);\n        return new ComponentFactory(componentDef, this.ngModule);\n    }\n}\nfunction toRefArray(map) {\n    const array = [];\n    for (let nonMinified in map) {\n        if (map.hasOwnProperty(nonMinified)) {\n            const minified = map[nonMinified];\n            array.push({ propName: minified, templateName: nonMinified });\n        }\n    }\n    return array;\n}\nfunction getNamespace(elementName) {\n    const name = elementName.toLowerCase();\n    return name === 'svg' ? SVG_NAMESPACE : (name === 'math' ? MATH_ML_NAMESPACE : null);\n}\n/**\n * Injector that looks up a value using a specific injector, before falling back to the module\n * injector. Used primarily when creating components or embedded views dynamically.\n */\nclass ChainedInjector {\n    constructor(injector, parentInjector) {\n        this.injector = injector;\n        this.parentInjector = parentInjector;\n    }\n    get(token, notFoundValue, flags) {\n        flags = convertToBitFlags(flags);\n        const value = this.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, flags);\n        if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR ||\n            notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {\n            // Return the value from the root element injector when\n            // - it provides it\n            //   (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\n            // - the module injector should not be checked\n            //   (notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\n            return value;\n        }\n        return this.parentInjector.get(token, notFoundValue, flags);\n    }\n}\n/**\n * ComponentFactory interface implementation.\n */\nclass ComponentFactory extends ComponentFactory$1 {\n    get inputs() {\n        const componentDef = this.componentDef;\n        const inputTransforms = componentDef.inputTransforms;\n        const refArray = toRefArray(componentDef.inputs);\n        if (inputTransforms !== null) {\n            for (const input of refArray) {\n                if (inputTransforms.hasOwnProperty(input.propName)) {\n                    input.transform = inputTransforms[input.propName];\n                }\n            }\n        }\n        return refArray;\n    }\n    get outputs() {\n        return toRefArray(this.componentDef.outputs);\n    }\n    /**\n     * @param componentDef The component definition.\n     * @param ngModule The NgModuleRef to which the factory is bound.\n     */\n    constructor(componentDef, ngModule) {\n        super();\n        this.componentDef = componentDef;\n        this.ngModule = ngModule;\n        this.componentType = componentDef.type;\n        this.selector = stringifyCSSSelectorList(componentDef.selectors);\n        this.ngContentSelectors =\n            componentDef.ngContentSelectors ? componentDef.ngContentSelectors : [];\n        this.isBoundToModule = !!ngModule;\n    }\n    create(injector, projectableNodes, rootSelectorOrNode, environmentInjector) {\n        environmentInjector = environmentInjector || this.ngModule;\n        let realEnvironmentInjector = environmentInjector instanceof EnvironmentInjector ?\n            environmentInjector :\n            environmentInjector?.injector;\n        if (realEnvironmentInjector && this.componentDef.getStandaloneInjector !== null) {\n            realEnvironmentInjector = this.componentDef.getStandaloneInjector(realEnvironmentInjector) ||\n                realEnvironmentInjector;\n        }\n        const rootViewInjector = realEnvironmentInjector ? new ChainedInjector(injector, realEnvironmentInjector) : injector;\n        const rendererFactory = rootViewInjector.get(RendererFactory2, null);\n        if (rendererFactory === null) {\n            throw new RuntimeError(407 /* RuntimeErrorCode.RENDERER_NOT_FOUND */, ngDevMode &&\n                'Angular was not able to inject a renderer (RendererFactory2). ' +\n                    'Likely this is due to a broken DI hierarchy. ' +\n                    'Make sure that any injector used to create this component has a correct parent.');\n        }\n        const sanitizer = rootViewInjector.get(Sanitizer, null);\n        const effectManager = rootViewInjector.get(EffectManager, null);\n        const afterRenderEventManager = rootViewInjector.get(AfterRenderEventManager, null);\n        const environment = {\n            rendererFactory,\n            sanitizer,\n            effectManager,\n            afterRenderEventManager,\n        };\n        const hostRenderer = rendererFactory.createRenderer(null, this.componentDef);\n        // Determine a tag name used for creating host elements when this component is created\n        // dynamically. Default to 'div' if this component did not specify any tag name in its selector.\n        const elementName = this.componentDef.selectors[0][0] || 'div';\n        const hostRNode = rootSelectorOrNode ?\n            locateHostElement(hostRenderer, rootSelectorOrNode, this.componentDef.encapsulation, rootViewInjector) :\n            createElementNode(hostRenderer, elementName, getNamespace(elementName));\n        // Signal components use the granular \"RefreshView\"  for change detection\n        const signalFlags = (4096 /* LViewFlags.SignalView */ | 512 /* LViewFlags.IsRoot */);\n        // Non-signal components use the traditional \"CheckAlways or OnPush/Dirty\" change detection\n        const nonSignalFlags = this.componentDef.onPush ? 64 /* LViewFlags.Dirty */ | 512 /* LViewFlags.IsRoot */ :\n            16 /* LViewFlags.CheckAlways */ | 512 /* LViewFlags.IsRoot */;\n        const rootFlags = this.componentDef.signals ? signalFlags : nonSignalFlags;\n        let hydrationInfo = null;\n        if (hostRNode !== null) {\n            hydrationInfo = retrieveHydrationInfo(hostRNode, rootViewInjector, true /* isRootView */);\n        }\n        // Create the root view. Uses empty TView and ContentTemplate.\n        const rootTView = createTView(0 /* TViewType.Root */, null, null, 1, 0, null, null, null, null, null, null);\n        const rootLView = createLView(null, rootTView, null, rootFlags, null, null, environment, hostRenderer, rootViewInjector, null, hydrationInfo);\n        // rootView is the parent when bootstrapping\n        // TODO(misko): it looks like we are entering view here but we don't really need to as\n        // `renderView` does that. However as the code is written it is needed because\n        // `createRootComponentView` and `createRootComponent` both read global state. Fixing those\n        // issues would allow us to drop this.\n        enterView(rootLView);\n        let component;\n        let tElementNode;\n        try {\n            const rootComponentDef = this.componentDef;\n            let rootDirectives;\n            let hostDirectiveDefs = null;\n            if (rootComponentDef.findHostDirectiveDefs) {\n                rootDirectives = [];\n                hostDirectiveDefs = new Map();\n                rootComponentDef.findHostDirectiveDefs(rootComponentDef, rootDirectives, hostDirectiveDefs);\n                rootDirectives.push(rootComponentDef);\n            }\n            else {\n                rootDirectives = [rootComponentDef];\n            }\n            const hostTNode = createRootComponentTNode(rootLView, hostRNode);\n            const componentView = createRootComponentView(hostTNode, hostRNode, rootComponentDef, rootDirectives, rootLView, environment, hostRenderer);\n            tElementNode = getTNode(rootTView, HEADER_OFFSET);\n            // TODO(crisbeto): in practice `hostRNode` should always be defined, but there are some tests\n            // where the renderer is mocked out and `undefined` is returned. We should update the tests so\n            // that this check can be removed.\n            if (hostRNode) {\n                setRootNodeAttributes(hostRenderer, rootComponentDef, hostRNode, rootSelectorOrNode);\n            }\n            if (projectableNodes !== undefined) {\n                projectNodes(tElementNode, this.ngContentSelectors, projectableNodes);\n            }\n            // TODO: should LifecycleHooksFeature and other host features be generated by the compiler and\n            // executed here?\n            // Angular 5 reference: https://stackblitz.com/edit/lifecycle-hooks-vcref\n            component = createRootComponent(componentView, rootComponentDef, rootDirectives, hostDirectiveDefs, rootLView, [LifecycleHooksFeature]);\n            renderView(rootTView, rootLView, null);\n        }\n        finally {\n            leaveView();\n        }\n        return new ComponentRef(this.componentType, component, createElementRef(tElementNode, rootLView), rootLView, tElementNode);\n    }\n}\n/**\n * Represents an instance of a Component created via a {@link ComponentFactory}.\n *\n * `ComponentRef` provides access to the Component Instance as well other objects related to this\n * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}\n * method.\n *\n */\nclass ComponentRef extends ComponentRef$1 {\n    constructor(componentType, instance, location, _rootLView, _tNode) {\n        super();\n        this.location = location;\n        this._rootLView = _rootLView;\n        this._tNode = _tNode;\n        this.previousInputValues = null;\n        this.instance = instance;\n        this.hostView = this.changeDetectorRef = new RootViewRef(_rootLView);\n        this.componentType = componentType;\n    }\n    setInput(name, value) {\n        const inputData = this._tNode.inputs;\n        let dataValue;\n        if (inputData !== null && (dataValue = inputData[name])) {\n            this.previousInputValues ??= new Map();\n            // Do not set the input if it is the same as the last value\n            // This behavior matches `bindingUpdated` when binding inputs in templates.\n            if (this.previousInputValues.has(name) &&\n                Object.is(this.previousInputValues.get(name), value)) {\n                return;\n            }\n            const lView = this._rootLView;\n            setInputsForProperty(lView[TVIEW], lView, dataValue, name, value);\n            this.previousInputValues.set(name, value);\n            const childComponentLView = getComponentLViewByIndex(this._tNode.index, lView);\n            markViewDirty(childComponentLView);\n        }\n        else {\n            if (ngDevMode) {\n                const cmpNameForError = stringifyForError(this.componentType);\n                let message = `Can't set value of the '${name}' input on the '${cmpNameForError}' component. `;\n                message += `Make sure that the '${name}' property is annotated with @Input() or a mapped @Input('${name}') exists.`;\n                reportUnknownPropertyError(message);\n            }\n        }\n    }\n    get injector() {\n        return new NodeInjector(this._tNode, this._rootLView);\n    }\n    destroy() {\n        this.hostView.destroy();\n    }\n    onDestroy(callback) {\n        this.hostView.onDestroy(callback);\n    }\n}\n/** Creates a TNode that can be used to instantiate a root component. */\nfunction createRootComponentTNode(lView, rNode) {\n    const tView = lView[TVIEW];\n    const index = HEADER_OFFSET;\n    ngDevMode && assertIndexInRange(lView, index);\n    lView[index] = rNode;\n    // '#host' is added here as we don't know the real host DOM name (we don't want to read it) and at\n    // the same time we want to communicate the debug `TNode` that this is a special `TNode`\n    // representing a host element.\n    return getOrCreateTNode(tView, index, 2 /* TNodeType.Element */, '#host', null);\n}\n/**\n * Creates the root component view and the root component node.\n *\n * @param hostRNode Render host element.\n * @param rootComponentDef ComponentDef\n * @param rootView The parent view where the host node is stored\n * @param rendererFactory Factory to be used for creating child renderers.\n * @param hostRenderer The current renderer\n * @param sanitizer The sanitizer, if provided\n *\n * @returns Component view created\n */\nfunction createRootComponentView(tNode, hostRNode, rootComponentDef, rootDirectives, rootView, environment, hostRenderer) {\n    const tView = rootView[TVIEW];\n    applyRootComponentStyling(rootDirectives, tNode, hostRNode, hostRenderer);\n    // Hydration info is on the host element and needs to be retrieved\n    // and passed to the component LView.\n    let hydrationInfo = null;\n    if (hostRNode !== null) {\n        hydrationInfo = retrieveHydrationInfo(hostRNode, rootView[INJECTOR$1]);\n    }\n    const viewRenderer = environment.rendererFactory.createRenderer(hostRNode, rootComponentDef);\n    let lViewFlags = 16 /* LViewFlags.CheckAlways */;\n    if (rootComponentDef.signals) {\n        lViewFlags = 4096 /* LViewFlags.SignalView */;\n    }\n    else if (rootComponentDef.onPush) {\n        lViewFlags = 64 /* LViewFlags.Dirty */;\n    }\n    const componentView = createLView(rootView, getOrCreateComponentTView(rootComponentDef), null, lViewFlags, rootView[tNode.index], tNode, environment, viewRenderer, null, null, hydrationInfo);\n    if (tView.firstCreatePass) {\n        markAsComponentHost(tView, tNode, rootDirectives.length - 1);\n    }\n    addToViewTree(rootView, componentView);\n    // Store component view at node index, with node as the HOST\n    return rootView[tNode.index] = componentView;\n}\n/** Sets up the styling information on a root component. */\nfunction applyRootComponentStyling(rootDirectives, tNode, rNode, hostRenderer) {\n    for (const def of rootDirectives) {\n        tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);\n    }\n    if (tNode.mergedAttrs !== null) {\n        computeStaticStyling(tNode, tNode.mergedAttrs, true);\n        if (rNode !== null) {\n            setupStaticAttributes(hostRenderer, rNode, tNode);\n        }\n    }\n}\n/**\n * Creates a root component and sets it up with features and host bindings.Shared by\n * renderComponent() and ViewContainerRef.createComponent().\n */\nfunction createRootComponent(componentView, rootComponentDef, rootDirectives, hostDirectiveDefs, rootLView, hostFeatures) {\n    const rootTNode = getCurrentTNode();\n    ngDevMode && assertDefined(rootTNode, 'tNode should have been already created');\n    const tView = rootLView[TVIEW];\n    const native = getNativeByTNode(rootTNode, rootLView);\n    initializeDirectives(tView, rootLView, rootTNode, rootDirectives, null, hostDirectiveDefs);\n    for (let i = 0; i < rootDirectives.length; i++) {\n        const directiveIndex = rootTNode.directiveStart + i;\n        const directiveInstance = getNodeInjectable(rootLView, tView, directiveIndex, rootTNode);\n        attachPatchData(directiveInstance, rootLView);\n    }\n    invokeDirectivesHostBindings(tView, rootLView, rootTNode);\n    if (native) {\n        attachPatchData(native, rootLView);\n    }\n    // We're guaranteed for the `componentOffset` to be positive here\n    // since a root component always matches a component def.\n    ngDevMode &&\n        assertGreaterThan(rootTNode.componentOffset, -1, 'componentOffset must be great than -1');\n    const component = getNodeInjectable(rootLView, tView, rootTNode.directiveStart + rootTNode.componentOffset, rootTNode);\n    componentView[CONTEXT] = rootLView[CONTEXT] = component;\n    if (hostFeatures !== null) {\n        for (const feature of hostFeatures) {\n            feature(component, rootComponentDef);\n        }\n    }\n    // We want to generate an empty QueryList for root content queries for backwards\n    // compatibility with ViewEngine.\n    executeContentQueries(tView, rootTNode, componentView);\n    return component;\n}\n/** Sets the static attributes on a root component. */\nfunction setRootNodeAttributes(hostRenderer, componentDef, hostRNode, rootSelectorOrNode) {\n    if (rootSelectorOrNode) {\n        setUpAttributes(hostRenderer, hostRNode, ['ng-version', VERSION.full]);\n    }\n    else {\n        // If host element is created as a part of this function call (i.e. `rootSelectorOrNode`\n        // is not defined), also apply attributes and classes extracted from component selector.\n        // Extract attributes and classes from the first selector only to match VE behavior.\n        const { attrs, classes } = extractAttrsAndClassesFromSelector(componentDef.selectors[0]);\n        if (attrs) {\n            setUpAttributes(hostRenderer, hostRNode, attrs);\n        }\n        if (classes && classes.length > 0) {\n            writeDirectClass(hostRenderer, hostRNode, classes.join(' '));\n        }\n    }\n}\n/** Projects the `projectableNodes` that were specified when creating a root component. */\nfunction projectNodes(tNode, ngContentSelectors, projectableNodes) {\n    const projection = tNode.projection = [];\n    for (let i = 0; i < ngContentSelectors.length; i++) {\n        const nodesforSlot = projectableNodes[i];\n        // Projectable nodes can be passed as array of arrays or an array of iterables (ngUpgrade\n        // case). Here we do normalize passed data structure to be an array of arrays to avoid\n        // complex checks down the line.\n        // We also normalize the length of the passed in projectable nodes (to match the number of\n        // <ng-container> slots defined by a component).\n        projection.push(nodesforSlot != null ? Array.from(nodesforSlot) : null);\n    }\n}\n/**\n * Used to enable lifecycle hooks on the root component.\n *\n * Include this feature when calling `renderComponent` if the root component\n * you are rendering has lifecycle hooks defined. Otherwise, the hooks won't\n * be called properly.\n *\n * Example:\n *\n * ```\n * renderComponent(AppComponent, {hostFeatures: [LifecycleHooksFeature]});\n * ```\n */\nfunction LifecycleHooksFeature() {\n    const tNode = getCurrentTNode();\n    ngDevMode && assertDefined(tNode, 'TNode is required');\n    registerPostOrderHooks(getLView()[TVIEW], tNode);\n}\n\nfunction getSuperType(type) {\n    return Object.getPrototypeOf(type.prototype).constructor;\n}\n/**\n * Merges the definition from a super class to a sub class.\n * @param definition The definition that is a SubClass of another directive of component\n *\n * @codeGenApi\n */\nfunction ɵɵInheritDefinitionFeature(definition) {\n    let superType = getSuperType(definition.type);\n    let shouldInheritFields = true;\n    const inheritanceChain = [definition];\n    while (superType) {\n        let superDef = undefined;\n        if (isComponentDef(definition)) {\n            // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n            superDef = superType.ɵcmp || superType.ɵdir;\n        }\n        else {\n            if (superType.ɵcmp) {\n                throw new RuntimeError(903 /* RuntimeErrorCode.INVALID_INHERITANCE */, ngDevMode &&\n                    `Directives cannot inherit Components. Directive ${stringifyForError(definition.type)} is attempting to extend component ${stringifyForError(superType)}`);\n            }\n            // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n            superDef = superType.ɵdir;\n        }\n        if (superDef) {\n            if (shouldInheritFields) {\n                inheritanceChain.push(superDef);\n                // Some fields in the definition may be empty, if there were no values to put in them that\n                // would've justified object creation. Unwrap them if necessary.\n                const writeableDef = definition;\n                writeableDef.inputs = maybeUnwrapEmpty(definition.inputs);\n                writeableDef.inputTransforms = maybeUnwrapEmpty(definition.inputTransforms);\n                writeableDef.declaredInputs = maybeUnwrapEmpty(definition.declaredInputs);\n                writeableDef.outputs = maybeUnwrapEmpty(definition.outputs);\n                // Merge hostBindings\n                const superHostBindings = superDef.hostBindings;\n                superHostBindings && inheritHostBindings(definition, superHostBindings);\n                // Merge queries\n                const superViewQuery = superDef.viewQuery;\n                const superContentQueries = superDef.contentQueries;\n                superViewQuery && inheritViewQuery(definition, superViewQuery);\n                superContentQueries && inheritContentQueries(definition, superContentQueries);\n                // Merge inputs and outputs\n                fillProperties(definition.inputs, superDef.inputs);\n                fillProperties(definition.declaredInputs, superDef.declaredInputs);\n                fillProperties(definition.outputs, superDef.outputs);\n                if (superDef.inputTransforms !== null) {\n                    if (writeableDef.inputTransforms === null) {\n                        writeableDef.inputTransforms = {};\n                    }\n                    fillProperties(writeableDef.inputTransforms, superDef.inputTransforms);\n                }\n                // Merge animations metadata.\n                // If `superDef` is a Component, the `data` field is present (defaults to an empty object).\n                if (isComponentDef(superDef) && superDef.data.animation) {\n                    // If super def is a Component, the `definition` is also a Component, since Directives can\n                    // not inherit Components (we throw an error above and cannot reach this code).\n                    const defData = definition.data;\n                    defData.animation = (defData.animation || []).concat(superDef.data.animation);\n                }\n            }\n            // Run parent features\n            const features = superDef.features;\n            if (features) {\n                for (let i = 0; i < features.length; i++) {\n                    const feature = features[i];\n                    if (feature && feature.ngInherit) {\n                        feature(definition);\n                    }\n                    // If `InheritDefinitionFeature` is a part of the current `superDef`, it means that this\n                    // def already has all the necessary information inherited from its super class(es), so we\n                    // can stop merging fields from super classes. However we need to iterate through the\n                    // prototype chain to look for classes that might contain other \"features\" (like\n                    // NgOnChanges), which we should invoke for the original `definition`. We set the\n                    // `shouldInheritFields` flag to indicate that, essentially skipping fields inheritance\n                    // logic and only invoking functions from the \"features\" list.\n                    if (feature === ɵɵInheritDefinitionFeature) {\n                        shouldInheritFields = false;\n                    }\n                }\n            }\n        }\n        superType = Object.getPrototypeOf(superType);\n    }\n    mergeHostAttrsAcrossInheritance(inheritanceChain);\n}\n/**\n * Merge the `hostAttrs` and `hostVars` from the inherited parent to the base class.\n *\n * @param inheritanceChain A list of `WritableDefs` starting at the top most type and listing\n * sub-types in order. For each type take the `hostAttrs` and `hostVars` and merge it with the child\n * type.\n */\nfunction mergeHostAttrsAcrossInheritance(inheritanceChain) {\n    let hostVars = 0;\n    let hostAttrs = null;\n    // We process the inheritance order from the base to the leaves here.\n    for (let i = inheritanceChain.length - 1; i >= 0; i--) {\n        const def = inheritanceChain[i];\n        // For each `hostVars`, we need to add the superclass amount.\n        def.hostVars = (hostVars += def.hostVars);\n        // for each `hostAttrs` we need to merge it with superclass.\n        def.hostAttrs =\n            mergeHostAttrs(def.hostAttrs, hostAttrs = mergeHostAttrs(hostAttrs, def.hostAttrs));\n    }\n}\nfunction maybeUnwrapEmpty(value) {\n    if (value === EMPTY_OBJ) {\n        return {};\n    }\n    else if (value === EMPTY_ARRAY) {\n        return [];\n    }\n    else {\n        return value;\n    }\n}\nfunction inheritViewQuery(definition, superViewQuery) {\n    const prevViewQuery = definition.viewQuery;\n    if (prevViewQuery) {\n        definition.viewQuery = (rf, ctx) => {\n            superViewQuery(rf, ctx);\n            prevViewQuery(rf, ctx);\n        };\n    }\n    else {\n        definition.viewQuery = superViewQuery;\n    }\n}\nfunction inheritContentQueries(definition, superContentQueries) {\n    const prevContentQueries = definition.contentQueries;\n    if (prevContentQueries) {\n        definition.contentQueries = (rf, ctx, directiveIndex) => {\n            superContentQueries(rf, ctx, directiveIndex);\n            prevContentQueries(rf, ctx, directiveIndex);\n        };\n    }\n    else {\n        definition.contentQueries = superContentQueries;\n    }\n}\nfunction inheritHostBindings(definition, superHostBindings) {\n    const prevHostBindings = definition.hostBindings;\n    if (prevHostBindings) {\n        definition.hostBindings = (rf, ctx) => {\n            superHostBindings(rf, ctx);\n            prevHostBindings(rf, ctx);\n        };\n    }\n    else {\n        definition.hostBindings = superHostBindings;\n    }\n}\n\n/**\n * Fields which exist on either directive or component definitions, and need to be copied from\n * parent to child classes by the `ɵɵCopyDefinitionFeature`.\n */\nconst COPY_DIRECTIVE_FIELDS = [\n    // The child class should use the providers of its parent.\n    'providersResolver',\n    // Not listed here are any fields which are handled by the `ɵɵInheritDefinitionFeature`, such\n    // as inputs, outputs, and host binding functions.\n];\n/**\n * Fields which exist only on component definitions, and need to be copied from parent to child\n * classes by the `ɵɵCopyDefinitionFeature`.\n *\n * The type here allows any field of `ComponentDef` which is not also a property of `DirectiveDef`,\n * since those should go in `COPY_DIRECTIVE_FIELDS` above.\n */\nconst COPY_COMPONENT_FIELDS = [\n    // The child class should use the template function of its parent, including all template\n    // semantics.\n    'template',\n    'decls',\n    'consts',\n    'vars',\n    'onPush',\n    'ngContentSelectors',\n    // The child class should use the CSS styles of its parent, including all styling semantics.\n    'styles',\n    'encapsulation',\n    // The child class should be checked by the runtime in the same way as its parent.\n    'schemas',\n];\n/**\n * Copies the fields not handled by the `ɵɵInheritDefinitionFeature` from the supertype of a\n * definition.\n *\n * This exists primarily to support ngcc migration of an existing View Engine pattern, where an\n * entire decorator is inherited from a parent to a child class. When ngcc detects this case, it\n * generates a skeleton definition on the child class, and applies this feature.\n *\n * The `ɵɵCopyDefinitionFeature` then copies any needed fields from the parent class' definition,\n * including things like the component template function.\n *\n * @param definition The definition of a child class which inherits from a parent class with its\n * own definition.\n *\n * @codeGenApi\n */\nfunction ɵɵCopyDefinitionFeature(definition) {\n    let superType = getSuperType(definition.type);\n    let superDef = undefined;\n    if (isComponentDef(definition)) {\n        // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n        superDef = superType.ɵcmp;\n    }\n    else {\n        // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n        superDef = superType.ɵdir;\n    }\n    // Needed because `definition` fields are readonly.\n    const defAny = definition;\n    // Copy over any fields that apply to either directives or components.\n    for (const field of COPY_DIRECTIVE_FIELDS) {\n        defAny[field] = superDef[field];\n    }\n    if (isComponentDef(superDef)) {\n        // Copy over any component-specific fields.\n        for (const field of COPY_COMPONENT_FIELDS) {\n            defAny[field] = superDef[field];\n        }\n    }\n}\n\n/**\n * This feature adds the host directives behavior to a directive definition by patching a\n * function onto it. The expectation is that the runtime will invoke the function during\n * directive matching.\n *\n * For example:\n * ```ts\n * class ComponentWithHostDirective {\n *   static ɵcmp = defineComponent({\n *    type: ComponentWithHostDirective,\n *    features: [ɵɵHostDirectivesFeature([\n *      SimpleHostDirective,\n *      {directive: AdvancedHostDirective, inputs: ['foo: alias'], outputs: ['bar']},\n *    ])]\n *  });\n * }\n * ```\n *\n * @codeGenApi\n */\nfunction ɵɵHostDirectivesFeature(rawHostDirectives) {\n    return (definition) => {\n        definition.findHostDirectiveDefs = findHostDirectiveDefs;\n        definition.hostDirectives =\n            (Array.isArray(rawHostDirectives) ? rawHostDirectives : rawHostDirectives()).map(dir => {\n                return typeof dir === 'function' ?\n                    { directive: resolveForwardRef(dir), inputs: EMPTY_OBJ, outputs: EMPTY_OBJ } :\n                    {\n                        directive: resolveForwardRef(dir.directive),\n                        inputs: bindingArrayToMap(dir.inputs),\n                        outputs: bindingArrayToMap(dir.outputs)\n                    };\n            });\n    };\n}\nfunction findHostDirectiveDefs(currentDef, matchedDefs, hostDirectiveDefs) {\n    if (currentDef.hostDirectives !== null) {\n        for (const hostDirectiveConfig of currentDef.hostDirectives) {\n            const hostDirectiveDef = getDirectiveDef(hostDirectiveConfig.directive);\n            if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                validateHostDirective(hostDirectiveConfig, hostDirectiveDef, matchedDefs);\n            }\n            // We need to patch the `declaredInputs` so that\n            // `ngOnChanges` can map the properties correctly.\n            patchDeclaredInputs(hostDirectiveDef.declaredInputs, hostDirectiveConfig.inputs);\n            // Host directives execute before the host so that its host bindings can be overwritten.\n            findHostDirectiveDefs(hostDirectiveDef, matchedDefs, hostDirectiveDefs);\n            hostDirectiveDefs.set(hostDirectiveDef, hostDirectiveConfig);\n            matchedDefs.push(hostDirectiveDef);\n        }\n    }\n}\n/**\n * Converts an array in the form of `['publicName', 'alias', 'otherPublicName', 'otherAlias']` into\n * a map in the form of `{publicName: 'alias', otherPublicName: 'otherAlias'}`.\n */\nfunction bindingArrayToMap(bindings) {\n    if (bindings === undefined || bindings.length === 0) {\n        return EMPTY_OBJ;\n    }\n    const result = {};\n    for (let i = 0; i < bindings.length; i += 2) {\n        result[bindings[i]] = bindings[i + 1];\n    }\n    return result;\n}\n/**\n * `ngOnChanges` has some leftover legacy ViewEngine behavior where the keys inside the\n * `SimpleChanges` event refer to the *declared* name of the input, not its public name or its\n * minified name. E.g. in `@Input('alias') foo: string`, the name in the `SimpleChanges` object\n * will always be `foo`, and not `alias` or the minified name of `foo` in apps using property\n * minification.\n *\n * This is achieved through the `DirectiveDef.declaredInputs` map that is constructed when the\n * definition is declared. When a property is written to the directive instance, the\n * `NgOnChangesFeature` will try to remap the property name being written to using the\n * `declaredInputs`.\n *\n * Since the host directive input remapping happens during directive matching, `declaredInputs`\n * won't contain the new alias that the input is available under. This function addresses the\n * issue by patching the host directive aliases to the `declaredInputs`. There is *not* a risk of\n * this patching accidentally introducing new inputs to the host directive, because `declaredInputs`\n * is used *only* by the `NgOnChangesFeature` when determining what name is used in the\n * `SimpleChanges` object which won't be reached if an input doesn't exist.\n */\nfunction patchDeclaredInputs(declaredInputs, exposedInputs) {\n    for (const publicName in exposedInputs) {\n        if (exposedInputs.hasOwnProperty(publicName)) {\n            const remappedPublicName = exposedInputs[publicName];\n            const privateName = declaredInputs[publicName];\n            // We *technically* shouldn't be able to hit this case because we can't have multiple\n            // inputs on the same property and we have validations against conflicting aliases in\n            // `validateMappings`. If we somehow did, it would lead to `ngOnChanges` being invoked\n            // with the wrong name so we have a non-user-friendly assertion here just in case.\n            if ((typeof ngDevMode === 'undefined' || ngDevMode) &&\n                declaredInputs.hasOwnProperty(remappedPublicName)) {\n                assertEqual(declaredInputs[remappedPublicName], declaredInputs[publicName], `Conflicting host directive input alias ${publicName}.`);\n            }\n            declaredInputs[remappedPublicName] = privateName;\n        }\n    }\n}\n/**\n * Verifies that the host directive has been configured correctly.\n * @param hostDirectiveConfig Host directive configuration object.\n * @param directiveDef Directive definition of the host directive.\n * @param matchedDefs Directives that have been matched so far.\n */\nfunction validateHostDirective(hostDirectiveConfig, directiveDef, matchedDefs) {\n    const type = hostDirectiveConfig.directive;\n    if (directiveDef === null) {\n        if (getComponentDef$1(type) !== null) {\n            throw new RuntimeError(310 /* RuntimeErrorCode.HOST_DIRECTIVE_COMPONENT */, `Host directive ${type.name} cannot be a component.`);\n        }\n        throw new RuntimeError(307 /* RuntimeErrorCode.HOST_DIRECTIVE_UNRESOLVABLE */, `Could not resolve metadata for host directive ${type.name}. ` +\n            `Make sure that the ${type.name} class is annotated with an @Directive decorator.`);\n    }\n    if (!directiveDef.standalone) {\n        throw new RuntimeError(308 /* RuntimeErrorCode.HOST_DIRECTIVE_NOT_STANDALONE */, `Host directive ${directiveDef.type.name} must be standalone.`);\n    }\n    if (matchedDefs.indexOf(directiveDef) > -1) {\n        throw new RuntimeError(309 /* RuntimeErrorCode.DUPLICATE_DIRECTITVE */, `Directive ${directiveDef.type.name} matches multiple times on the same element. ` +\n            `Directives can only match an element once.`);\n    }\n    validateMappings('input', directiveDef, hostDirectiveConfig.inputs);\n    validateMappings('output', directiveDef, hostDirectiveConfig.outputs);\n}\n/**\n * Checks that the host directive inputs/outputs configuration is valid.\n * @param bindingType Kind of binding that is being validated. Used in the error message.\n * @param def Definition of the host directive that is being validated against.\n * @param hostDirectiveBindings Host directive mapping object that shold be validated.\n */\nfunction validateMappings(bindingType, def, hostDirectiveBindings) {\n    const className = def.type.name;\n    const bindings = bindingType === 'input' ? def.inputs : def.outputs;\n    for (const publicName in hostDirectiveBindings) {\n        if (hostDirectiveBindings.hasOwnProperty(publicName)) {\n            if (!bindings.hasOwnProperty(publicName)) {\n                throw new RuntimeError(311 /* RuntimeErrorCode.HOST_DIRECTIVE_UNDEFINED_BINDING */, `Directive ${className} does not have an ${bindingType} with a public name of ${publicName}.`);\n            }\n            const remappedPublicName = hostDirectiveBindings[publicName];\n            if (bindings.hasOwnProperty(remappedPublicName) && remappedPublicName !== publicName &&\n                bindings[remappedPublicName] !== publicName) {\n                throw new RuntimeError(312 /* RuntimeErrorCode.HOST_DIRECTIVE_CONFLICTING_ALIAS */, `Cannot alias ${bindingType} ${publicName} of host directive ${className} to ${remappedPublicName}, because it already has a different ${bindingType} with the same public name.`);\n            }\n        }\n    }\n}\n\n/**\n * Decorates the directive definition with support for input transform functions.\n *\n * If the directive uses inheritance, the feature should be included before the\n * `InheritDefinitionFeature` to ensure that the `inputTransforms` field is populated.\n *\n * @codeGenApi\n */\nfunction ɵɵInputTransformsFeature(definition) {\n    const inputs = definition.inputConfig;\n    const inputTransforms = {};\n    for (const minifiedKey in inputs) {\n        if (inputs.hasOwnProperty(minifiedKey)) {\n            // Note: the private names are used for the keys, rather than the public ones, because public\n            // names can be re-aliased in host directives which would invalidate the lookup.\n            const value = inputs[minifiedKey];\n            if (Array.isArray(value) && value[2]) {\n                inputTransforms[minifiedKey] = value[2];\n            }\n        }\n    }\n    definition.inputTransforms =\n        inputTransforms;\n}\n\nfunction isIterable(obj) {\n    return obj !== null && typeof obj === 'object' && obj[Symbol.iterator] !== undefined;\n}\nfunction isListLikeIterable(obj) {\n    if (!isJsObject(obj))\n        return false;\n    return Array.isArray(obj) ||\n        (!(obj instanceof Map) && // JS Map are iterables but return entries as [k, v]\n            Symbol.iterator in obj); // JS Iterable have a Symbol.iterator prop\n}\nfunction areIterablesEqual(a, b, comparator) {\n    const iterator1 = a[Symbol.iterator]();\n    const iterator2 = b[Symbol.iterator]();\n    while (true) {\n        const item1 = iterator1.next();\n        const item2 = iterator2.next();\n        if (item1.done && item2.done)\n            return true;\n        if (item1.done || item2.done)\n            return false;\n        if (!comparator(item1.value, item2.value))\n            return false;\n    }\n}\nfunction iterateListLike(obj, fn) {\n    if (Array.isArray(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n            fn(obj[i]);\n        }\n    }\n    else {\n        const iterator = obj[Symbol.iterator]();\n        let item;\n        while (!((item = iterator.next()).done)) {\n            fn(item.value);\n        }\n    }\n}\nfunction isJsObject(o) {\n    return o !== null && (typeof o === 'function' || typeof o === 'object');\n}\n\nfunction devModeEqual(a, b) {\n    const isListLikeIterableA = isListLikeIterable(a);\n    const isListLikeIterableB = isListLikeIterable(b);\n    if (isListLikeIterableA && isListLikeIterableB) {\n        return areIterablesEqual(a, b, devModeEqual);\n    }\n    else {\n        const isAObject = a && (typeof a === 'object' || typeof a === 'function');\n        const isBObject = b && (typeof b === 'object' || typeof b === 'function');\n        if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {\n            return true;\n        }\n        else {\n            return Object.is(a, b);\n        }\n    }\n}\n\n// TODO(misko): consider inlining\n/** Updates binding and returns the value. */\nfunction updateBinding(lView, bindingIndex, value) {\n    return lView[bindingIndex] = value;\n}\n/** Gets the current binding value. */\nfunction getBinding(lView, bindingIndex) {\n    ngDevMode && assertIndexInRange(lView, bindingIndex);\n    ngDevMode &&\n        assertNotSame(lView[bindingIndex], NO_CHANGE, 'Stored value should never be NO_CHANGE.');\n    return lView[bindingIndex];\n}\n/**\n * Updates binding if changed, then returns whether it was updated.\n *\n * This function also checks the `CheckNoChangesMode` and throws if changes are made.\n * Some changes (Objects/iterables) during `CheckNoChangesMode` are exempt to comply with VE\n * behavior.\n *\n * @param lView current `LView`\n * @param bindingIndex The binding in the `LView` to check\n * @param value New value to check against `lView[bindingIndex]`\n * @returns `true` if the bindings has changed. (Throws if binding has changed during\n *          `CheckNoChangesMode`)\n */\nfunction bindingUpdated(lView, bindingIndex, value) {\n    ngDevMode && assertNotSame(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');\n    ngDevMode &&\n        assertLessThan(bindingIndex, lView.length, `Slot should have been initialized to NO_CHANGE`);\n    const oldValue = lView[bindingIndex];\n    if (Object.is(oldValue, value)) {\n        return false;\n    }\n    else {\n        if (ngDevMode && isInCheckNoChangesMode()) {\n            // View engine didn't report undefined values as changed on the first checkNoChanges pass\n            // (before the change detection was run).\n            const oldValueToCompare = oldValue !== NO_CHANGE ? oldValue : undefined;\n            if (!devModeEqual(oldValueToCompare, value)) {\n                const details = getExpressionChangedErrorDetails(lView, bindingIndex, oldValueToCompare, value);\n                throwErrorIfNoChangesMode(oldValue === NO_CHANGE, details.oldValue, details.newValue, details.propName, lView);\n            }\n            // There was a change, but the `devModeEqual` decided that the change is exempt from an error.\n            // For this reason we exit as if no change. The early exit is needed to prevent the changed\n            // value to be written into `LView` (If we would write the new value that we would not see it\n            // as change on next CD.)\n            return false;\n        }\n        lView[bindingIndex] = value;\n        return true;\n    }\n}\n/** Updates 2 bindings if changed, then returns whether either was updated. */\nfunction bindingUpdated2(lView, bindingIndex, exp1, exp2) {\n    const different = bindingUpdated(lView, bindingIndex, exp1);\n    return bindingUpdated(lView, bindingIndex + 1, exp2) || different;\n}\n/** Updates 3 bindings if changed, then returns whether any was updated. */\nfunction bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) {\n    const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);\n    return bindingUpdated(lView, bindingIndex + 2, exp3) || different;\n}\n/** Updates 4 bindings if changed, then returns whether any was updated. */\nfunction bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) {\n    const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);\n    return bindingUpdated2(lView, bindingIndex + 2, exp3, exp4) || different;\n}\n\n/**\n * Updates the value of or removes a bound attribute on an Element.\n *\n * Used in the case of `[attr.title]=\"value\"`\n *\n * @param name name The name of the attribute.\n * @param value value The attribute is removed when value is `null` or `undefined`.\n *                  Otherwise the attribute value is set to the stringified value.\n * @param sanitizer An optional function used to sanitize the value.\n * @param namespace Optional namespace to use when setting the attribute.\n *\n * @codeGenApi\n */\nfunction ɵɵattribute(name, value, sanitizer, namespace) {\n    const lView = getLView();\n    const bindingIndex = nextBindingIndex();\n    if (bindingUpdated(lView, bindingIndex, value)) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace);\n        ngDevMode && storePropertyBindingMetadata(tView.data, tNode, 'attr.' + name, bindingIndex);\n    }\n    return ɵɵattribute;\n}\n\n/**\n * Create interpolation bindings with a variable number of expressions.\n *\n * If there are 1 to 8 expressions `interpolation1()` to `interpolation8()` should be used instead.\n * Those are faster because there is no need to create an array of expressions and iterate over it.\n *\n * `values`:\n * - has static text at even indexes,\n * - has evaluated expressions at odd indexes.\n *\n * Returns the concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nfunction interpolationV(lView, values) {\n    ngDevMode && assertLessThan(2, values.length, 'should have at least 3 values');\n    ngDevMode && assertEqual(values.length % 2, 1, 'should have an odd number of values');\n    let isBindingUpdated = false;\n    let bindingIndex = getBindingIndex();\n    for (let i = 1; i < values.length; i += 2) {\n        // Check if bindings (odd indexes) have changed\n        isBindingUpdated = bindingUpdated(lView, bindingIndex++, values[i]) || isBindingUpdated;\n    }\n    setBindingIndex(bindingIndex);\n    if (!isBindingUpdated) {\n        return NO_CHANGE;\n    }\n    // Build the updated content\n    let content = values[0];\n    for (let i = 1; i < values.length; i += 2) {\n        content += renderStringify(values[i]) + values[i + 1];\n    }\n    return content;\n}\n/**\n * Creates an interpolation binding with 1 expression.\n *\n * @param prefix static value used for concatenation only.\n * @param v0 value checked for change.\n * @param suffix static value used for concatenation only.\n */\nfunction interpolation1(lView, prefix, v0, suffix) {\n    const different = bindingUpdated(lView, nextBindingIndex(), v0);\n    return different ? prefix + renderStringify(v0) + suffix : NO_CHANGE;\n}\n/**\n * Creates an interpolation binding with 2 expressions.\n */\nfunction interpolation2(lView, prefix, v0, i0, v1, suffix) {\n    const bindingIndex = getBindingIndex();\n    const different = bindingUpdated2(lView, bindingIndex, v0, v1);\n    incrementBindingIndex(2);\n    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + suffix : NO_CHANGE;\n}\n/**\n * Creates an interpolation binding with 3 expressions.\n */\nfunction interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix) {\n    const bindingIndex = getBindingIndex();\n    const different = bindingUpdated3(lView, bindingIndex, v0, v1, v2);\n    incrementBindingIndex(3);\n    return different ?\n        prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + suffix :\n        NO_CHANGE;\n}\n/**\n * Create an interpolation binding with 4 expressions.\n */\nfunction interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {\n    const bindingIndex = getBindingIndex();\n    const different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n    incrementBindingIndex(4);\n    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 +\n        renderStringify(v2) + i2 + renderStringify(v3) + suffix :\n        NO_CHANGE;\n}\n/**\n * Creates an interpolation binding with 5 expressions.\n */\nfunction interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {\n    const bindingIndex = getBindingIndex();\n    let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n    different = bindingUpdated(lView, bindingIndex + 4, v4) || different;\n    incrementBindingIndex(5);\n    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 +\n        renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + suffix :\n        NO_CHANGE;\n}\n/**\n * Creates an interpolation binding with 6 expressions.\n */\nfunction interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {\n    const bindingIndex = getBindingIndex();\n    let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n    different = bindingUpdated2(lView, bindingIndex + 4, v4, v5) || different;\n    incrementBindingIndex(6);\n    return different ?\n        prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 +\n            renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + suffix :\n        NO_CHANGE;\n}\n/**\n * Creates an interpolation binding with 7 expressions.\n */\nfunction interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {\n    const bindingIndex = getBindingIndex();\n    let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n    different = bindingUpdated3(lView, bindingIndex + 4, v4, v5, v6) || different;\n    incrementBindingIndex(7);\n    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 +\n        renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 +\n        renderStringify(v5) + i5 + renderStringify(v6) + suffix :\n        NO_CHANGE;\n}\n/**\n * Creates an interpolation binding with 8 expressions.\n */\nfunction interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {\n    const bindingIndex = getBindingIndex();\n    let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n    different = bindingUpdated4(lView, bindingIndex + 4, v4, v5, v6, v7) || different;\n    incrementBindingIndex(8);\n    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 +\n        renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 +\n        renderStringify(v5) + i5 + renderStringify(v6) + i6 + renderStringify(v7) + suffix :\n        NO_CHANGE;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate1('title', 'prefix', v0, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵattributeInterpolate1(attrName, prefix, v0, suffix, sanitizer, namespace) {\n    const lView = getLView();\n    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tNode = getSelectedTNode();\n        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n        ngDevMode &&\n            storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 1, prefix, suffix);\n    }\n    return ɵɵattributeInterpolate1;\n}\n/**\n *\n * Update an interpolated attribute on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate2('title', 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵattributeInterpolate2(attrName, prefix, v0, i0, v1, suffix, sanitizer, namespace) {\n    const lView = getLView();\n    const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tNode = getSelectedTNode();\n        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n        ngDevMode &&\n            storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 2, prefix, i0, suffix);\n    }\n    return ɵɵattributeInterpolate2;\n}\n/**\n *\n * Update an interpolated attribute on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate3(\n * 'title', 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵattributeInterpolate3(attrName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer, namespace) {\n    const lView = getLView();\n    const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tNode = getSelectedTNode();\n        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n        ngDevMode &&\n            storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 3, prefix, i0, i1, suffix);\n    }\n    return ɵɵattributeInterpolate3;\n}\n/**\n *\n * Update an interpolated attribute on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate4(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵattributeInterpolate4(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer, namespace) {\n    const lView = getLView();\n    const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tNode = getSelectedTNode();\n        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n        ngDevMode &&\n            storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);\n    }\n    return ɵɵattributeInterpolate4;\n}\n/**\n *\n * Update an interpolated attribute on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate5(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵattributeInterpolate5(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer, namespace) {\n    const lView = getLView();\n    const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tNode = getSelectedTNode();\n        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n        ngDevMode &&\n            storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);\n    }\n    return ɵɵattributeInterpolate5;\n}\n/**\n *\n * Update an interpolated attribute on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate6(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵattributeInterpolate6(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer, namespace) {\n    const lView = getLView();\n    const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tNode = getSelectedTNode();\n        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n        ngDevMode &&\n            storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);\n    }\n    return ɵɵattributeInterpolate6;\n}\n/**\n *\n * Update an interpolated attribute on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate7(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵattributeInterpolate7(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer, namespace) {\n    const lView = getLView();\n    const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tNode = getSelectedTNode();\n        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n        ngDevMode &&\n            storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5, suffix);\n    }\n    return ɵɵattributeInterpolate7;\n}\n/**\n *\n * Update an interpolated attribute on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate8(\n *  'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵattributeInterpolate8(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer, namespace) {\n    const lView = getLView();\n    const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tNode = getSelectedTNode();\n        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n        ngDevMode &&\n            storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6, suffix);\n    }\n    return ɵɵattributeInterpolate8;\n}\n/**\n * Update an interpolated attribute on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolateV(\n *  'title', ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * @param attrName The name of the attribute to update.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵattributeInterpolateV(attrName, values, sanitizer, namespace) {\n    const lView = getLView();\n    const interpolated = interpolationV(lView, values);\n    if (interpolated !== NO_CHANGE) {\n        const tNode = getSelectedTNode();\n        elementAttributeInternal(tNode, lView, attrName, interpolated, sanitizer, namespace);\n        if (ngDevMode) {\n            const interpolationInBetween = [values[0]]; // prefix\n            for (let i = 2; i < values.length; i += 2) {\n                interpolationInBetween.push(values[i]);\n            }\n            storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);\n        }\n    }\n    return ɵɵattributeInterpolateV;\n}\n\nconst AT_THIS_LOCATION = '<-- AT THIS LOCATION';\n/**\n * Retrieves a user friendly string for a given TNodeType for use in\n * friendly error messages\n *\n * @param tNodeType\n * @returns\n */\nfunction getFriendlyStringFromTNodeType(tNodeType) {\n    switch (tNodeType) {\n        case 4 /* TNodeType.Container */:\n            return 'view container';\n        case 2 /* TNodeType.Element */:\n            return 'element';\n        case 8 /* TNodeType.ElementContainer */:\n            return 'ng-container';\n        case 32 /* TNodeType.Icu */:\n            return 'icu';\n        case 64 /* TNodeType.Placeholder */:\n            return 'i18n';\n        case 16 /* TNodeType.Projection */:\n            return 'projection';\n        case 1 /* TNodeType.Text */:\n            return 'text';\n        default:\n            // This should not happen as we cover all possible TNode types above.\n            return '<unknown>';\n    }\n}\n/**\n * Validates that provided nodes match during the hydration process.\n */\nfunction validateMatchingNode(node, nodeType, tagName, lView, tNode, isViewContainerAnchor = false) {\n    if (!node ||\n        (node.nodeType !== nodeType ||\n            (node.nodeType === Node.ELEMENT_NODE &&\n                node.tagName.toLowerCase() !== tagName?.toLowerCase()))) {\n        const expectedNode = shortRNodeDescription(nodeType, tagName, null);\n        let header = `During hydration Angular expected ${expectedNode} but `;\n        const hostComponentDef = getDeclarationComponentDef(lView);\n        const componentClassName = hostComponentDef?.type?.name;\n        const expected = `Angular expected this DOM:\\n\\n${describeExpectedDom(lView, tNode, isViewContainerAnchor)}\\n\\n`;\n        let actual = '';\n        if (!node) {\n            // No node found during hydration.\n            header += `the node was not found.\\n\\n`;\n        }\n        else {\n            const actualNode = shortRNodeDescription(node.nodeType, node.tagName ?? null, node.textContent ?? null);\n            header += `found ${actualNode}.\\n\\n`;\n            actual = `Actual DOM is:\\n\\n${describeDomFromNode(node)}\\n\\n`;\n        }\n        const footer = getHydrationErrorFooter(componentClassName);\n        const message = header + expected + actual + getHydrationAttributeNote() + footer;\n        throw new RuntimeError(-500 /* RuntimeErrorCode.HYDRATION_NODE_MISMATCH */, message);\n    }\n}\n/**\n * Validates that a given node has sibling nodes\n */\nfunction validateSiblingNodeExists(node) {\n    validateNodeExists(node);\n    if (!node.nextSibling) {\n        const header = 'During hydration Angular expected more sibling nodes to be present.\\n\\n';\n        const actual = `Actual DOM is:\\n\\n${describeDomFromNode(node)}\\n\\n`;\n        const footer = getHydrationErrorFooter();\n        const message = header + actual + footer;\n        throw new RuntimeError(-501 /* RuntimeErrorCode.HYDRATION_MISSING_SIBLINGS */, message);\n    }\n}\n/**\n * Validates that a node exists or throws\n */\nfunction validateNodeExists(node, lView = null, tNode = null) {\n    if (!node) {\n        const header = 'During hydration, Angular expected an element to be present at this location.\\n\\n';\n        let expected = '';\n        let footer = '';\n        if (lView !== null && tNode !== null) {\n            expected = `${describeExpectedDom(lView, tNode, false)}\\n\\n`;\n            footer = getHydrationErrorFooter();\n        }\n        throw new RuntimeError(-502 /* RuntimeErrorCode.HYDRATION_MISSING_NODE */, header + expected + footer);\n    }\n}\n/**\n * Builds the hydration error message when a node is not found\n *\n * @param lView the LView where the node exists\n * @param tNode the TNode\n */\nfunction nodeNotFoundError(lView, tNode) {\n    const header = 'During serialization, Angular was unable to find an element in the DOM:\\n\\n';\n    const expected = `${describeExpectedDom(lView, tNode, false)}\\n\\n`;\n    const footer = getHydrationErrorFooter();\n    throw new RuntimeError(-502 /* RuntimeErrorCode.HYDRATION_MISSING_NODE */, header + expected + footer);\n}\n/**\n * Builds a hydration error message when a node is not found at a path location\n *\n * @param host the Host Node\n * @param path the path to the node\n */\nfunction nodeNotFoundAtPathError(host, path) {\n    const header = `During hydration Angular was unable to locate a node ` +\n        `using the \"${path}\" path, starting from the ${describeRNode(host)} node.\\n\\n`;\n    const footer = getHydrationErrorFooter();\n    throw new RuntimeError(-502 /* RuntimeErrorCode.HYDRATION_MISSING_NODE */, header + footer);\n}\n/**\n * Builds the hydration error message in the case that dom nodes are created outside of\n * the Angular context and are being used as projected nodes\n *\n * @param lView the LView\n * @param tNode the TNode\n * @returns an error\n */\nfunction unsupportedProjectionOfDomNodes(rNode) {\n    const header = 'During serialization, Angular detected DOM nodes ' +\n        'that were created outside of Angular context and provided as projectable nodes ' +\n        '(likely via `ViewContainerRef.createComponent` or `createComponent` APIs). ' +\n        'Hydration is not supported for such cases, consider refactoring the code to avoid ' +\n        'this pattern or using `ngSkipHydration` on the host element of the component.\\n\\n';\n    const actual = `${describeDomFromNode(rNode)}\\n\\n`;\n    const message = header + actual + getHydrationAttributeNote();\n    return new RuntimeError(-503 /* RuntimeErrorCode.UNSUPPORTED_PROJECTION_DOM_NODES */, message);\n}\n/**\n * Builds the hydration error message in the case that ngSkipHydration was used on a\n * node that is not a component host element or host binding\n *\n * @param rNode the HTML Element\n * @returns an error\n */\nfunction invalidSkipHydrationHost(rNode) {\n    const header = 'The `ngSkipHydration` flag is applied on a node ' +\n        'that doesn\\'t act as a component host. Hydration can be ' +\n        'skipped only on per-component basis.\\n\\n';\n    const actual = `${describeDomFromNode(rNode)}\\n\\n`;\n    const footer = 'Please move the `ngSkipHydration` attribute to the component host element.\\n\\n';\n    const message = header + actual + footer;\n    return new RuntimeError(-504 /* RuntimeErrorCode.INVALID_SKIP_HYDRATION_HOST */, message);\n}\n// Stringification methods\n/**\n * Stringifies a given TNode's attributes\n *\n * @param tNode a provided TNode\n * @returns string\n */\nfunction stringifyTNodeAttrs(tNode) {\n    const results = [];\n    if (tNode.attrs) {\n        for (let i = 0; i < tNode.attrs.length;) {\n            const attrName = tNode.attrs[i++];\n            // Once we reach the first flag, we know that the list of\n            // attributes is over.\n            if (typeof attrName == 'number') {\n                break;\n            }\n            const attrValue = tNode.attrs[i++];\n            results.push(`${attrName}=\"${shorten(attrValue)}\"`);\n        }\n    }\n    return results.join(' ');\n}\n/**\n * The list of internal attributes that should be filtered out while\n * producing an error message.\n */\nconst internalAttrs = new Set(['ngh', 'ng-version', 'ng-server-context']);\n/**\n * Stringifies an HTML Element's attributes\n *\n * @param rNode an HTML Element\n * @returns string\n */\nfunction stringifyRNodeAttrs(rNode) {\n    const results = [];\n    for (let i = 0; i < rNode.attributes.length; i++) {\n        const attr = rNode.attributes[i];\n        if (internalAttrs.has(attr.name))\n            continue;\n        results.push(`${attr.name}=\"${shorten(attr.value)}\"`);\n    }\n    return results.join(' ');\n}\n// Methods for Describing the DOM\n/**\n * Converts a tNode to a helpful readable string value for use in error messages\n *\n * @param tNode a given TNode\n * @param innerContent the content of the node\n * @returns string\n */\nfunction describeTNode(tNode, innerContent = '…') {\n    switch (tNode.type) {\n        case 1 /* TNodeType.Text */:\n            const content = tNode.value ? `(${tNode.value})` : '';\n            return `#text${content}`;\n        case 2 /* TNodeType.Element */:\n            const attrs = stringifyTNodeAttrs(tNode);\n            const tag = tNode.value.toLowerCase();\n            return `<${tag}${attrs ? ' ' + attrs : ''}>${innerContent}</${tag}>`;\n        case 8 /* TNodeType.ElementContainer */:\n            return '<!-- ng-container -->';\n        case 4 /* TNodeType.Container */:\n            return '<!-- container -->';\n        default:\n            const typeAsString = getFriendlyStringFromTNodeType(tNode.type);\n            return `#node(${typeAsString})`;\n    }\n}\n/**\n * Converts an RNode to a helpful readable string value for use in error messages\n *\n * @param rNode a given RNode\n * @param innerContent the content of the node\n * @returns string\n */\nfunction describeRNode(rNode, innerContent = '…') {\n    const node = rNode;\n    switch (node.nodeType) {\n        case Node.ELEMENT_NODE:\n            const tag = node.tagName.toLowerCase();\n            const attrs = stringifyRNodeAttrs(node);\n            return `<${tag}${attrs ? ' ' + attrs : ''}>${innerContent}</${tag}>`;\n        case Node.TEXT_NODE:\n            const content = node.textContent ? shorten(node.textContent) : '';\n            return `#text${content ? `(${content})` : ''}`;\n        case Node.COMMENT_NODE:\n            return `<!-- ${shorten(node.textContent ?? '')} -->`;\n        default:\n            return `#node(${node.nodeType})`;\n    }\n}\n/**\n * Builds the string containing the expected DOM present given the LView and TNode\n * values for a readable error message\n *\n * @param lView the lView containing the DOM\n * @param tNode the tNode\n * @param isViewContainerAnchor boolean\n * @returns string\n */\nfunction describeExpectedDom(lView, tNode, isViewContainerAnchor) {\n    const spacer = '  ';\n    let content = '';\n    if (tNode.prev) {\n        content += spacer + '…\\n';\n        content += spacer + describeTNode(tNode.prev) + '\\n';\n    }\n    else if (tNode.type && tNode.type & 12 /* TNodeType.AnyContainer */) {\n        content += spacer + '…\\n';\n    }\n    if (isViewContainerAnchor) {\n        content += spacer + describeTNode(tNode) + '\\n';\n        content += spacer + `<!-- container -->  ${AT_THIS_LOCATION}\\n`;\n    }\n    else {\n        content += spacer + describeTNode(tNode) + `  ${AT_THIS_LOCATION}\\n`;\n    }\n    content += spacer + '…\\n';\n    const parentRNode = tNode.type ? getParentRElement(lView[TVIEW], tNode, lView) : null;\n    if (parentRNode) {\n        content = describeRNode(parentRNode, '\\n' + content);\n    }\n    return content;\n}\n/**\n * Builds the string containing the DOM present around a given RNode for a\n * readable error message\n *\n * @param node the RNode\n * @returns string\n */\nfunction describeDomFromNode(node) {\n    const spacer = '  ';\n    let content = '';\n    const currentNode = node;\n    if (currentNode.previousSibling) {\n        content += spacer + '…\\n';\n        content += spacer + describeRNode(currentNode.previousSibling) + '\\n';\n    }\n    content += spacer + describeRNode(currentNode) + `  ${AT_THIS_LOCATION}\\n`;\n    if (node.nextSibling) {\n        content += spacer + '…\\n';\n    }\n    if (node.parentNode) {\n        content = describeRNode(currentNode.parentNode, '\\n' + content);\n    }\n    return content;\n}\n/**\n * Shortens the description of a given RNode by its type for readability\n *\n * @param nodeType the type of node\n * @param tagName the node tag name\n * @param textContent the text content in the node\n * @returns string\n */\nfunction shortRNodeDescription(nodeType, tagName, textContent) {\n    switch (nodeType) {\n        case Node.ELEMENT_NODE:\n            return `<${tagName.toLowerCase()}>`;\n        case Node.TEXT_NODE:\n            const content = textContent ? ` (with the \"${shorten(textContent)}\" content)` : '';\n            return `a text node${content}`;\n        case Node.COMMENT_NODE:\n            return 'a comment node';\n        default:\n            return `#node(nodeType=${nodeType})`;\n    }\n}\n/**\n * Builds the footer hydration error message\n *\n * @param componentClassName the name of the component class\n * @returns string\n */\nfunction getHydrationErrorFooter(componentClassName) {\n    const componentInfo = componentClassName ? `the \"${componentClassName}\"` : 'corresponding';\n    return `To fix this problem:\\n` +\n        `  * check ${componentInfo} component for hydration-related issues\\n` +\n        `  * check to see if your template has valid HTML structure\\n` +\n        `  * or skip hydration by adding the \\`ngSkipHydration\\` attribute ` +\n        `to its host node in a template\\n\\n`;\n}\n/**\n * An attribute related note for hydration errors\n */\nfunction getHydrationAttributeNote() {\n    return 'Note: attributes are only displayed to better represent the DOM' +\n        ' but have no effect on hydration mismatches.\\n\\n';\n}\n// Node string utility functions\n/**\n * Strips all newlines out of a given string\n *\n * @param input a string to be cleared of new line characters\n * @returns\n */\nfunction stripNewlines(input) {\n    return input.replace(/\\s+/gm, '');\n}\n/**\n * Reduces a string down to a maximum length of characters with ellipsis for readability\n *\n * @param input a string input\n * @param maxLength a maximum length in characters\n * @returns string\n */\nfunction shorten(input, maxLength = 50) {\n    if (!input) {\n        return '';\n    }\n    input = stripNewlines(input);\n    return input.length > maxLength ? `${input.substring(0, maxLength - 1)}…` : input;\n}\n\n/**\n * Regexp that extracts a reference node information from the compressed node location.\n * The reference node is represented as either:\n *  - a number which points to an LView slot\n *  - the `b` char which indicates that the lookup should start from the `document.body`\n *  - the `h` char to start lookup from the component host node (`lView[HOST]`)\n */\nconst REF_EXTRACTOR_REGEXP = new RegExp(`^(\\\\d+)*(${REFERENCE_NODE_BODY}|${REFERENCE_NODE_HOST})*(.*)`);\n/**\n * Helper function that takes a reference node location and a set of navigation steps\n * (from the reference node) to a target node and outputs a string that represents\n * a location.\n *\n * For example, given: referenceNode = 'b' (body) and path = ['firstChild', 'firstChild',\n * 'nextSibling'], the function returns: `bf2n`.\n */\nfunction compressNodeLocation(referenceNode, path) {\n    const result = [referenceNode];\n    for (const segment of path) {\n        const lastIdx = result.length - 1;\n        if (lastIdx > 0 && result[lastIdx - 1] === segment) {\n            // An empty string in a count slot represents 1 occurrence of an instruction.\n            const value = (result[lastIdx] || 1);\n            result[lastIdx] = value + 1;\n        }\n        else {\n            // Adding a new segment to the path.\n            // Using an empty string in a counter field to avoid encoding `1`s\n            // into the path, since they are implicit (e.g. `f1n1` vs `fn`), so\n            // it's enough to have a single char in this case.\n            result.push(segment, '');\n        }\n    }\n    return result.join('');\n}\n/**\n * Helper function that reverts the `compressNodeLocation` and transforms a given\n * string into an array where at 0th position there is a reference node info and\n * after that it contains information (in pairs) about a navigation step and the\n * number of repetitions.\n *\n * For example, the path like 'bf2n' will be transformed to:\n * ['b', 'firstChild', 2, 'nextSibling', 1].\n *\n * This information is later consumed by the code that navigates the DOM to find\n * a given node by its location.\n */\nfunction decompressNodeLocation(path) {\n    const matches = path.match(REF_EXTRACTOR_REGEXP);\n    const [_, refNodeId, refNodeName, rest] = matches;\n    // If a reference node is represented by an index, transform it to a number.\n    const ref = refNodeId ? parseInt(refNodeId, 10) : refNodeName;\n    const steps = [];\n    // Match all segments in a path.\n    for (const [_, step, count] of rest.matchAll(/(f|n)(\\d*)/g)) {\n        const repeat = parseInt(count, 10) || 1;\n        steps.push(step, repeat);\n    }\n    return [ref, ...steps];\n}\n\n/** Whether current TNode is a first node in an <ng-container>. */\nfunction isFirstElementInNgContainer(tNode) {\n    return !tNode.prev && tNode.parent?.type === 8 /* TNodeType.ElementContainer */;\n}\n/** Returns an instruction index (subtracting HEADER_OFFSET). */\nfunction getNoOffsetIndex(tNode) {\n    return tNode.index - HEADER_OFFSET;\n}\n/**\n * Locate a node in DOM tree that corresponds to a given TNode.\n *\n * @param hydrationInfo The hydration annotation data\n * @param tView the current tView\n * @param lView the current lView\n * @param tNode the current tNode\n * @returns an RNode that represents a given tNode\n */\nfunction locateNextRNode(hydrationInfo, tView, lView, tNode) {\n    let native = null;\n    const noOffsetIndex = getNoOffsetIndex(tNode);\n    const nodes = hydrationInfo.data[NODES];\n    if (nodes?.[noOffsetIndex]) {\n        // We know the exact location of the node.\n        native = locateRNodeByPath(nodes[noOffsetIndex], lView);\n    }\n    else if (tView.firstChild === tNode) {\n        // We create a first node in this view, so we use a reference\n        // to the first child in this DOM segment.\n        native = hydrationInfo.firstChild;\n    }\n    else {\n        // Locate a node based on a previous sibling or a parent node.\n        const previousTNodeParent = tNode.prev === null;\n        const previousTNode = (tNode.prev ?? tNode.parent);\n        ngDevMode &&\n            assertDefined(previousTNode, 'Unexpected state: current TNode does not have a connection ' +\n                'to the previous node or a parent node.');\n        if (isFirstElementInNgContainer(tNode)) {\n            const noOffsetParentIndex = getNoOffsetIndex(tNode.parent);\n            native = getSegmentHead(hydrationInfo, noOffsetParentIndex);\n        }\n        else {\n            let previousRElement = getNativeByTNode(previousTNode, lView);\n            if (previousTNodeParent) {\n                native = previousRElement.firstChild;\n            }\n            else {\n                // If the previous node is an element, but it also has container info,\n                // this means that we are processing a node like `<div #vcrTarget>`, which is\n                // represented in the DOM as `<div></div>...<!--container-->`.\n                // In this case, there are nodes *after* this element and we need to skip\n                // all of them to reach an element that we are looking for.\n                const noOffsetPrevSiblingIndex = getNoOffsetIndex(previousTNode);\n                const segmentHead = getSegmentHead(hydrationInfo, noOffsetPrevSiblingIndex);\n                if (previousTNode.type === 2 /* TNodeType.Element */ && segmentHead) {\n                    const numRootNodesToSkip = calcSerializedContainerSize(hydrationInfo, noOffsetPrevSiblingIndex);\n                    // `+1` stands for an anchor comment node after all the views in this container.\n                    const nodesToSkip = numRootNodesToSkip + 1;\n                    // First node after this segment.\n                    native = siblingAfter(nodesToSkip, segmentHead);\n                }\n                else {\n                    native = previousRElement.nextSibling;\n                }\n            }\n        }\n    }\n    return native;\n}\n/**\n * Skips over a specified number of nodes and returns the next sibling node after that.\n */\nfunction siblingAfter(skip, from) {\n    let currentNode = from;\n    for (let i = 0; i < skip; i++) {\n        ngDevMode && validateSiblingNodeExists(currentNode);\n        currentNode = currentNode.nextSibling;\n    }\n    return currentNode;\n}\n/**\n * Helper function to produce a string representation of the navigation steps\n * (in terms of `nextSibling` and `firstChild` navigations). Used in error\n * messages in dev mode.\n */\nfunction stringifyNavigationInstructions(instructions) {\n    const container = [];\n    for (let i = 0; i < instructions.length; i += 2) {\n        const step = instructions[i];\n        const repeat = instructions[i + 1];\n        for (let r = 0; r < repeat; r++) {\n            container.push(step === NodeNavigationStep.FirstChild ? 'firstChild' : 'nextSibling');\n        }\n    }\n    return container.join('.');\n}\n/**\n * Helper function that navigates from a starting point node (the `from` node)\n * using provided set of navigation instructions (within `path` argument).\n */\nfunction navigateToNode(from, instructions) {\n    let node = from;\n    for (let i = 0; i < instructions.length; i += 2) {\n        const step = instructions[i];\n        const repeat = instructions[i + 1];\n        for (let r = 0; r < repeat; r++) {\n            if (ngDevMode && !node) {\n                throw nodeNotFoundAtPathError(from, stringifyNavigationInstructions(instructions));\n            }\n            switch (step) {\n                case NodeNavigationStep.FirstChild:\n                    node = node.firstChild;\n                    break;\n                case NodeNavigationStep.NextSibling:\n                    node = node.nextSibling;\n                    break;\n            }\n        }\n    }\n    if (ngDevMode && !node) {\n        throw nodeNotFoundAtPathError(from, stringifyNavigationInstructions(instructions));\n    }\n    return node;\n}\n/**\n * Locates an RNode given a set of navigation instructions (which also contains\n * a starting point node info).\n */\nfunction locateRNodeByPath(path, lView) {\n    const [referenceNode, ...navigationInstructions] = decompressNodeLocation(path);\n    let ref;\n    if (referenceNode === REFERENCE_NODE_HOST) {\n        ref = lView[DECLARATION_COMPONENT_VIEW][HOST];\n    }\n    else if (referenceNode === REFERENCE_NODE_BODY) {\n        ref = ɵɵresolveBody(lView[DECLARATION_COMPONENT_VIEW][HOST]);\n    }\n    else {\n        const parentElementId = Number(referenceNode);\n        ref = unwrapRNode(lView[parentElementId + HEADER_OFFSET]);\n    }\n    return navigateToNode(ref, navigationInstructions);\n}\n/**\n * Generate a list of DOM navigation operations to get from node `start` to node `finish`.\n *\n * Note: assumes that node `start` occurs before node `finish` in an in-order traversal of the DOM\n * tree. That is, we should be able to get from `start` to `finish` purely by using `.firstChild`\n * and `.nextSibling` operations.\n */\nfunction navigateBetween(start, finish) {\n    if (start === finish) {\n        return [];\n    }\n    else if (start.parentElement == null || finish.parentElement == null) {\n        return null;\n    }\n    else if (start.parentElement === finish.parentElement) {\n        return navigateBetweenSiblings(start, finish);\n    }\n    else {\n        // `finish` is a child of its parent, so the parent will always have a child.\n        const parent = finish.parentElement;\n        const parentPath = navigateBetween(start, parent);\n        const childPath = navigateBetween(parent.firstChild, finish);\n        if (!parentPath || !childPath)\n            return null;\n        return [\n            // First navigate to `finish`'s parent\n            ...parentPath,\n            // Then to its first child.\n            NodeNavigationStep.FirstChild,\n            // And finally from that node to `finish` (maybe a no-op if we're already there).\n            ...childPath,\n        ];\n    }\n}\n/**\n * Calculates a path between 2 sibling nodes (generates a number of `NextSibling` navigations).\n * Returns `null` if no such path exists between the given nodes.\n */\nfunction navigateBetweenSiblings(start, finish) {\n    const nav = [];\n    let node = null;\n    for (node = start; node != null && node !== finish; node = node.nextSibling) {\n        nav.push(NodeNavigationStep.NextSibling);\n    }\n    // If the `node` becomes `null` or `undefined` at the end, that means that we\n    // didn't find the `end` node, thus return `null` (which would trigger serialization\n    // error to be produced).\n    return node == null ? null : nav;\n}\n/**\n * Calculates a path between 2 nodes in terms of `nextSibling` and `firstChild`\n * navigations:\n * - the `from` node is a known node, used as an starting point for the lookup\n *   (the `fromNodeName` argument is a string representation of the node).\n * - the `to` node is a node that the runtime logic would be looking up,\n *   using the path generated by this function.\n */\nfunction calcPathBetween(from, to, fromNodeName) {\n    const path = navigateBetween(from, to);\n    return path === null ? null : compressNodeLocation(fromNodeName, path);\n}\n/**\n * Invoked at serialization time (on the server) when a set of navigation\n * instructions needs to be generated for a TNode.\n */\nfunction calcPathForNode(tNode, lView) {\n    const parentTNode = tNode.parent;\n    let parentIndex;\n    let parentRNode;\n    let referenceNodeName;\n    if (parentTNode === null || !(parentTNode.type & 3 /* TNodeType.AnyRNode */)) {\n        // If there is no parent TNode or a parent TNode does not represent an RNode\n        // (i.e. not a DOM node), use component host element as a reference node.\n        parentIndex = referenceNodeName = REFERENCE_NODE_HOST;\n        parentRNode = lView[DECLARATION_COMPONENT_VIEW][HOST];\n    }\n    else {\n        // Use parent TNode as a reference node.\n        parentIndex = parentTNode.index;\n        parentRNode = unwrapRNode(lView[parentIndex]);\n        referenceNodeName = renderStringify(parentIndex - HEADER_OFFSET);\n    }\n    let rNode = unwrapRNode(lView[tNode.index]);\n    if (tNode.type & 12 /* TNodeType.AnyContainer */) {\n        // For <ng-container> nodes, instead of serializing a reference\n        // to the anchor comment node, serialize a location of the first\n        // DOM element. Paired with the container size (serialized as a part\n        // of `ngh.containers`), it should give enough information for runtime\n        // to hydrate nodes in this container.\n        const firstRNode = getFirstNativeNode(lView, tNode);\n        // If container is not empty, use a reference to the first element,\n        // otherwise, rNode would point to an anchor comment node.\n        if (firstRNode) {\n            rNode = firstRNode;\n        }\n    }\n    let path = calcPathBetween(parentRNode, rNode, referenceNodeName);\n    if (path === null && parentRNode !== rNode) {\n        // Searching for a path between elements within a host node failed.\n        // Trying to find a path to an element starting from the `document.body` instead.\n        //\n        // Important note: this type of reference is relatively unstable, since Angular\n        // may not be able to control parts of the page that the runtime logic navigates\n        // through. This is mostly needed to cover \"portals\" use-case (like menus, dialog boxes,\n        // etc), where nodes are content-projected (including direct DOM manipulations) outside\n        // of the host node. The better solution is to provide APIs to work with \"portals\",\n        // at which point this code path would not be needed.\n        const body = parentRNode.ownerDocument.body;\n        path = calcPathBetween(body, rNode, REFERENCE_NODE_BODY);\n        if (path === null) {\n            // If the path is still empty, it's likely that this node is detached and\n            // won't be found during hydration.\n            throw nodeNotFoundError(lView, tNode);\n        }\n    }\n    return path;\n}\n\nfunction templateFirstCreatePass(index, tView, lView, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex) {\n    ngDevMode && assertFirstCreatePass(tView);\n    ngDevMode && ngDevMode.firstCreatePass++;\n    const tViewConsts = tView.consts;\n    // TODO(pk): refactor getOrCreateTNode to have the \"create\" only version\n    const tNode = getOrCreateTNode(tView, index, 4 /* TNodeType.Container */, tagName || null, getConstant(tViewConsts, attrsIndex));\n    resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));\n    registerPostOrderHooks(tView, tNode);\n    const embeddedTView = tNode.tView = createTView(2 /* TViewType.Embedded */, tNode, templateFn, decls, vars, tView.directiveRegistry, tView.pipeRegistry, null, tView.schemas, tViewConsts, null /* ssrId */);\n    if (tView.queries !== null) {\n        tView.queries.template(tView, tNode);\n        embeddedTView.queries = tView.queries.embeddedTView(tNode);\n    }\n    return tNode;\n}\n/**\n * Creates an LContainer for an ng-template (dynamically-inserted view), e.g.\n *\n * <ng-template #foo>\n *    <div></div>\n * </ng-template>\n *\n * @param index The index of the container in the data array\n * @param templateFn Inline template\n * @param decls The number of nodes, local refs, and pipes for this template\n * @param vars The number of bindings for this template\n * @param tagName The name of the container element, if applicable\n * @param attrsIndex Index of template attributes in the `consts` array.\n * @param localRefs Index of the local references in the `consts` array.\n * @param localRefExtractor A function which extracts local-refs values from the template.\n *        Defaults to the current element associated with the local-ref.\n *\n * @codeGenApi\n */\nfunction ɵɵtemplate(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {\n    const lView = getLView();\n    const tView = getTView();\n    const adjustedIndex = index + HEADER_OFFSET;\n    const tNode = tView.firstCreatePass ? templateFirstCreatePass(adjustedIndex, tView, lView, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex) :\n        tView.data[adjustedIndex];\n    setCurrentTNode(tNode, false);\n    const comment = _locateOrCreateContainerAnchor(tView, lView, tNode, index);\n    if (wasLastNodeCreated()) {\n        appendChild(tView, lView, comment, tNode);\n    }\n    attachPatchData(comment, lView);\n    addToViewTree(lView, lView[adjustedIndex] = createLContainer(comment, lView, comment, tNode));\n    if (isDirectiveHost(tNode)) {\n        createDirectivesInstances(tView, lView, tNode);\n    }\n    if (localRefsIndex != null) {\n        saveResolvedLocalsInData(lView, tNode, localRefExtractor);\n    }\n}\nlet _locateOrCreateContainerAnchor = createContainerAnchorImpl;\n/**\n * Regular creation mode for LContainers and their anchor (comment) nodes.\n */\nfunction createContainerAnchorImpl(tView, lView, tNode, index) {\n    lastNodeWasCreated(true);\n    return lView[RENDERER].createComment(ngDevMode ? 'container' : '');\n}\n/**\n * Enables hydration code path (to lookup existing elements in DOM)\n * in addition to the regular creation mode for LContainers and their\n * anchor (comment) nodes.\n */\nfunction locateOrCreateContainerAnchorImpl(tView, lView, tNode, index) {\n    const hydrationInfo = lView[HYDRATION];\n    const isNodeCreationMode = !hydrationInfo || isInSkipHydrationBlock$1() || isDisconnectedNode(hydrationInfo, index);\n    lastNodeWasCreated(isNodeCreationMode);\n    // Regular creation mode.\n    if (isNodeCreationMode) {\n        return createContainerAnchorImpl(tView, lView, tNode, index);\n    }\n    const ssrId = hydrationInfo.data[TEMPLATES]?.[index] ?? null;\n    // Apply `ssrId` value to the underlying TView if it was not previously set.\n    //\n    // There might be situations when the same component is present in a template\n    // multiple times and some instances are opted-out of using hydration via\n    // `ngSkipHydration` attribute. In this scenario, at the time a TView is created,\n    // the `ssrId` might be `null` (if the first component is opted-out of hydration).\n    // The code below makes sure that the `ssrId` is applied to the TView if it's still\n    // `null` and verifies we never try to override it with a different value.\n    if (ssrId !== null && tNode.tView !== null) {\n        if (tNode.tView.ssrId === null) {\n            tNode.tView.ssrId = ssrId;\n        }\n        else {\n            ngDevMode &&\n                assertEqual(tNode.tView.ssrId, ssrId, 'Unexpected value of the `ssrId` for this TView');\n        }\n    }\n    // Hydration mode, looking up existing elements in DOM.\n    const currentRNode = locateNextRNode(hydrationInfo, tView, lView, tNode);\n    ngDevMode && validateNodeExists(currentRNode, lView, tNode);\n    setSegmentHead(hydrationInfo, index, currentRNode);\n    const viewContainerSize = calcSerializedContainerSize(hydrationInfo, index);\n    const comment = siblingAfter(viewContainerSize, currentRNode);\n    if (ngDevMode) {\n        validateMatchingNode(comment, Node.COMMENT_NODE, null, lView, tNode);\n        markRNodeAsClaimedByHydration(comment);\n    }\n    return comment;\n}\nfunction enableLocateOrCreateContainerAnchorImpl() {\n    _locateOrCreateContainerAnchor = locateOrCreateContainerAnchorImpl;\n}\n\n/** Store a value in the `data` at a given `index`. */\nfunction store(tView, lView, index, value) {\n    // We don't store any static data for local variables, so the first time\n    // we see the template, we should store as null to avoid a sparse array\n    if (index >= tView.data.length) {\n        tView.data[index] = null;\n        tView.blueprint[index] = null;\n    }\n    lView[index] = value;\n}\n/**\n * Retrieves a local reference from the current contextViewData.\n *\n * If the reference to retrieve is in a parent view, this instruction is used in conjunction\n * with a nextContext() call, which walks up the tree and updates the contextViewData instance.\n *\n * @param index The index of the local ref in contextViewData.\n *\n * @codeGenApi\n */\nfunction ɵɵreference(index) {\n    const contextLView = getContextLView();\n    return load(contextLView, HEADER_OFFSET + index);\n}\n\n/**\n * Update a property on a selected element.\n *\n * Operates on the element selected by index via the {@link select} instruction.\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled\n *\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n * @returns This function returns itself so that it may be chained\n * (e.g. `property('name', ctx.name)('title', ctx.title)`)\n *\n * @codeGenApi\n */\nfunction ɵɵproperty(propName, value, sanitizer) {\n    const lView = getLView();\n    const bindingIndex = nextBindingIndex();\n    if (bindingUpdated(lView, bindingIndex, value)) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, false);\n        ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);\n    }\n    return ɵɵproperty;\n}\n/**\n * Given `<div style=\"...\" my-dir>` and `MyDir` with `@Input('style')` we need to write to\n * directive input.\n */\nfunction setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased) {\n    const inputs = tNode.inputs;\n    const property = isClassBased ? 'class' : 'style';\n    // We support both 'class' and `className` hence the fallback.\n    setInputsForProperty(tView, lView, inputs[property], property, value);\n}\n\nfunction elementStartFirstCreatePass(index, tView, lView, name, attrsIndex, localRefsIndex) {\n    ngDevMode && assertFirstCreatePass(tView);\n    ngDevMode && ngDevMode.firstCreatePass++;\n    const tViewConsts = tView.consts;\n    const attrs = getConstant(tViewConsts, attrsIndex);\n    const tNode = getOrCreateTNode(tView, index, 2 /* TNodeType.Element */, name, attrs);\n    resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));\n    if (tNode.attrs !== null) {\n        computeStaticStyling(tNode, tNode.attrs, false);\n    }\n    if (tNode.mergedAttrs !== null) {\n        computeStaticStyling(tNode, tNode.mergedAttrs, true);\n    }\n    if (tView.queries !== null) {\n        tView.queries.elementStart(tView, tNode);\n    }\n    return tNode;\n}\n/**\n * Create DOM element. The instruction must later be followed by `elementEnd()` call.\n *\n * @param index Index of the element in the LView array\n * @param name Name of the DOM Node\n * @param attrsIndex Index of the element's attributes in the `consts` array.\n * @param localRefsIndex Index of the element's local references in the `consts` array.\n * @returns This function returns itself so that it may be chained.\n *\n * Attributes and localRefs are passed as an array of strings where elements with an even index\n * hold an attribute name and elements with an odd index hold an attribute value, ex.:\n * ['id', 'warning5', 'class', 'alert']\n *\n * @codeGenApi\n */\nfunction ɵɵelementStart(index, name, attrsIndex, localRefsIndex) {\n    const lView = getLView();\n    const tView = getTView();\n    const adjustedIndex = HEADER_OFFSET + index;\n    ngDevMode &&\n        assertEqual(getBindingIndex(), tView.bindingStartIndex, 'elements should be created before any bindings');\n    ngDevMode && assertIndexInRange(lView, adjustedIndex);\n    const renderer = lView[RENDERER];\n    const tNode = tView.firstCreatePass ?\n        elementStartFirstCreatePass(adjustedIndex, tView, lView, name, attrsIndex, localRefsIndex) :\n        tView.data[adjustedIndex];\n    const native = _locateOrCreateElementNode(tView, lView, tNode, renderer, name, index);\n    lView[adjustedIndex] = native;\n    const hasDirectives = isDirectiveHost(tNode);\n    if (ngDevMode && tView.firstCreatePass) {\n        validateElementIsKnown(native, lView, tNode.value, tView.schemas, hasDirectives);\n    }\n    setCurrentTNode(tNode, true);\n    setupStaticAttributes(renderer, native, tNode);\n    if ((tNode.flags & 32 /* TNodeFlags.isDetached */) !== 32 /* TNodeFlags.isDetached */ && wasLastNodeCreated()) {\n        // In the i18n case, the translation may have removed this element, so only add it if it is not\n        // detached. See `TNodeType.Placeholder` and `LFrame.inI18n` for more context.\n        appendChild(tView, lView, native, tNode);\n    }\n    // any immediate children of a component or template container must be pre-emptively\n    // monkey-patched with the component view data so that the element can be inspected\n    // later on using any element discovery utility methods (see `element_discovery.ts`)\n    if (getElementDepthCount() === 0) {\n        attachPatchData(native, lView);\n    }\n    increaseElementDepthCount();\n    if (hasDirectives) {\n        createDirectivesInstances(tView, lView, tNode);\n        executeContentQueries(tView, tNode, lView);\n    }\n    if (localRefsIndex !== null) {\n        saveResolvedLocalsInData(lView, tNode);\n    }\n    return ɵɵelementStart;\n}\n/**\n * Mark the end of the element.\n * @returns This function returns itself so that it may be chained.\n *\n * @codeGenApi\n */\nfunction ɵɵelementEnd() {\n    let currentTNode = getCurrentTNode();\n    ngDevMode && assertDefined(currentTNode, 'No parent node to close.');\n    if (isCurrentTNodeParent()) {\n        setCurrentTNodeAsNotParent();\n    }\n    else {\n        ngDevMode && assertHasParent(getCurrentTNode());\n        currentTNode = currentTNode.parent;\n        setCurrentTNode(currentTNode, false);\n    }\n    const tNode = currentTNode;\n    ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */);\n    if (isSkipHydrationRootTNode(tNode)) {\n        leaveSkipHydrationBlock();\n    }\n    decreaseElementDepthCount();\n    const tView = getTView();\n    if (tView.firstCreatePass) {\n        registerPostOrderHooks(tView, currentTNode);\n        if (isContentQueryHost(currentTNode)) {\n            tView.queries.elementEnd(currentTNode);\n        }\n    }\n    if (tNode.classesWithoutHost != null && hasClassInput(tNode)) {\n        setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.classesWithoutHost, true);\n    }\n    if (tNode.stylesWithoutHost != null && hasStyleInput(tNode)) {\n        setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.stylesWithoutHost, false);\n    }\n    return ɵɵelementEnd;\n}\n/**\n * Creates an empty element using {@link elementStart} and {@link elementEnd}\n *\n * @param index Index of the element in the data array\n * @param name Name of the DOM Node\n * @param attrsIndex Index of the element's attributes in the `consts` array.\n * @param localRefsIndex Index of the element's local references in the `consts` array.\n * @returns This function returns itself so that it may be chained.\n *\n * @codeGenApi\n */\nfunction ɵɵelement(index, name, attrsIndex, localRefsIndex) {\n    ɵɵelementStart(index, name, attrsIndex, localRefsIndex);\n    ɵɵelementEnd();\n    return ɵɵelement;\n}\nlet _locateOrCreateElementNode = (tView, lView, tNode, renderer, name, index) => {\n    lastNodeWasCreated(true);\n    return createElementNode(renderer, name, getNamespace$1());\n};\n/**\n * Enables hydration code path (to lookup existing elements in DOM)\n * in addition to the regular creation mode of element nodes.\n */\nfunction locateOrCreateElementNodeImpl(tView, lView, tNode, renderer, name, index) {\n    const hydrationInfo = lView[HYDRATION];\n    const isNodeCreationMode = !hydrationInfo || isInSkipHydrationBlock$1() || isDisconnectedNode(hydrationInfo, index);\n    lastNodeWasCreated(isNodeCreationMode);\n    // Regular creation mode.\n    if (isNodeCreationMode) {\n        return createElementNode(renderer, name, getNamespace$1());\n    }\n    // Hydration mode, looking up an existing element in DOM.\n    const native = locateNextRNode(hydrationInfo, tView, lView, tNode);\n    ngDevMode && validateMatchingNode(native, Node.ELEMENT_NODE, name, lView, tNode);\n    ngDevMode && markRNodeAsClaimedByHydration(native);\n    // This element might also be an anchor of a view container.\n    if (getSerializedContainerViews(hydrationInfo, index)) {\n        // Important note: this element acts as an anchor, but it's **not** a part\n        // of the embedded view, so we start the segment **after** this element, taking\n        // a reference to the next sibling. For example, the following template:\n        // `<div #vcrTarget>` is represented in the DOM as `<div></div>...<!--container-->`,\n        // so while processing a `<div>` instruction, point to the next sibling as a\n        // start of a segment.\n        ngDevMode && validateNodeExists(native.nextSibling, lView, tNode);\n        setSegmentHead(hydrationInfo, index, native.nextSibling);\n    }\n    // Checks if the skip hydration attribute is present during hydration so we know to\n    // skip attempting to hydrate this block. We check both TNode and RElement for an\n    // attribute: the RElement case is needed for i18n cases, when we add it to host\n    // elements during the annotation phase (after all internal data structures are setup).\n    if (hydrationInfo &&\n        (hasSkipHydrationAttrOnTNode(tNode) || hasSkipHydrationAttrOnRElement(native))) {\n        if (isComponentHost(tNode)) {\n            enterSkipHydrationBlock(tNode);\n            // Since this isn't hydratable, we need to empty the node\n            // so there's no duplicate content after render\n            clearElementContents(native);\n            ngDevMode && ngDevMode.componentsSkippedHydration++;\n        }\n        else if (ngDevMode) {\n            // If this is not a component host, throw an error.\n            // Hydration can be skipped on per-component basis only.\n            throw invalidSkipHydrationHost(native);\n        }\n    }\n    return native;\n}\nfunction enableLocateOrCreateElementNodeImpl() {\n    _locateOrCreateElementNode = locateOrCreateElementNodeImpl;\n}\n\nfunction elementContainerStartFirstCreatePass(index, tView, lView, attrsIndex, localRefsIndex) {\n    ngDevMode && ngDevMode.firstCreatePass++;\n    const tViewConsts = tView.consts;\n    const attrs = getConstant(tViewConsts, attrsIndex);\n    const tNode = getOrCreateTNode(tView, index, 8 /* TNodeType.ElementContainer */, 'ng-container', attrs);\n    // While ng-container doesn't necessarily support styling, we use the style context to identify\n    // and execute directives on the ng-container.\n    if (attrs !== null) {\n        computeStaticStyling(tNode, attrs, true);\n    }\n    const localRefs = getConstant(tViewConsts, localRefsIndex);\n    resolveDirectives(tView, lView, tNode, localRefs);\n    if (tView.queries !== null) {\n        tView.queries.elementStart(tView, tNode);\n    }\n    return tNode;\n}\n/**\n * Creates a logical container for other nodes (<ng-container>) backed by a comment node in the DOM.\n * The instruction must later be followed by `elementContainerEnd()` call.\n *\n * @param index Index of the element in the LView array\n * @param attrsIndex Index of the container attributes in the `consts` array.\n * @param localRefsIndex Index of the container's local references in the `consts` array.\n * @returns This function returns itself so that it may be chained.\n *\n * Even if this instruction accepts a set of attributes no actual attribute values are propagated to\n * the DOM (as a comment node can't have attributes). Attributes are here only for directive\n * matching purposes and setting initial inputs of directives.\n *\n * @codeGenApi\n */\nfunction ɵɵelementContainerStart(index, attrsIndex, localRefsIndex) {\n    const lView = getLView();\n    const tView = getTView();\n    const adjustedIndex = index + HEADER_OFFSET;\n    ngDevMode && assertIndexInRange(lView, adjustedIndex);\n    ngDevMode &&\n        assertEqual(getBindingIndex(), tView.bindingStartIndex, 'element containers should be created before any bindings');\n    const tNode = tView.firstCreatePass ?\n        elementContainerStartFirstCreatePass(adjustedIndex, tView, lView, attrsIndex, localRefsIndex) :\n        tView.data[adjustedIndex];\n    setCurrentTNode(tNode, true);\n    const comment = _locateOrCreateElementContainerNode(tView, lView, tNode, index);\n    lView[adjustedIndex] = comment;\n    if (wasLastNodeCreated()) {\n        appendChild(tView, lView, comment, tNode);\n    }\n    attachPatchData(comment, lView);\n    if (isDirectiveHost(tNode)) {\n        createDirectivesInstances(tView, lView, tNode);\n        executeContentQueries(tView, tNode, lView);\n    }\n    if (localRefsIndex != null) {\n        saveResolvedLocalsInData(lView, tNode);\n    }\n    return ɵɵelementContainerStart;\n}\n/**\n * Mark the end of the <ng-container>.\n * @returns This function returns itself so that it may be chained.\n *\n * @codeGenApi\n */\nfunction ɵɵelementContainerEnd() {\n    let currentTNode = getCurrentTNode();\n    const tView = getTView();\n    if (isCurrentTNodeParent()) {\n        setCurrentTNodeAsNotParent();\n    }\n    else {\n        ngDevMode && assertHasParent(currentTNode);\n        currentTNode = currentTNode.parent;\n        setCurrentTNode(currentTNode, false);\n    }\n    ngDevMode && assertTNodeType(currentTNode, 8 /* TNodeType.ElementContainer */);\n    if (tView.firstCreatePass) {\n        registerPostOrderHooks(tView, currentTNode);\n        if (isContentQueryHost(currentTNode)) {\n            tView.queries.elementEnd(currentTNode);\n        }\n    }\n    return ɵɵelementContainerEnd;\n}\n/**\n * Creates an empty logical container using {@link elementContainerStart}\n * and {@link elementContainerEnd}\n *\n * @param index Index of the element in the LView array\n * @param attrsIndex Index of the container attributes in the `consts` array.\n * @param localRefsIndex Index of the container's local references in the `consts` array.\n * @returns This function returns itself so that it may be chained.\n *\n * @codeGenApi\n */\nfunction ɵɵelementContainer(index, attrsIndex, localRefsIndex) {\n    ɵɵelementContainerStart(index, attrsIndex, localRefsIndex);\n    ɵɵelementContainerEnd();\n    return ɵɵelementContainer;\n}\nlet _locateOrCreateElementContainerNode = (tView, lView, tNode, index) => {\n    lastNodeWasCreated(true);\n    return createCommentNode(lView[RENDERER], ngDevMode ? 'ng-container' : '');\n};\n/**\n * Enables hydration code path (to lookup existing elements in DOM)\n * in addition to the regular creation mode of comment nodes that\n * represent <ng-container>'s anchor.\n */\nfunction locateOrCreateElementContainerNode(tView, lView, tNode, index) {\n    let comment;\n    const hydrationInfo = lView[HYDRATION];\n    const isNodeCreationMode = !hydrationInfo || isInSkipHydrationBlock$1();\n    lastNodeWasCreated(isNodeCreationMode);\n    // Regular creation mode.\n    if (isNodeCreationMode) {\n        return createCommentNode(lView[RENDERER], ngDevMode ? 'ng-container' : '');\n    }\n    // Hydration mode, looking up existing elements in DOM.\n    const currentRNode = locateNextRNode(hydrationInfo, tView, lView, tNode);\n    ngDevMode && validateNodeExists(currentRNode, lView, tNode);\n    const ngContainerSize = getNgContainerSize(hydrationInfo, index);\n    ngDevMode &&\n        assertNumber(ngContainerSize, 'Unexpected state: hydrating an <ng-container>, ' +\n            'but no hydration info is available.');\n    setSegmentHead(hydrationInfo, index, currentRNode);\n    comment = siblingAfter(ngContainerSize, currentRNode);\n    if (ngDevMode) {\n        validateMatchingNode(comment, Node.COMMENT_NODE, null, lView, tNode);\n        markRNodeAsClaimedByHydration(comment);\n    }\n    return comment;\n}\nfunction enableLocateOrCreateElementContainerNodeImpl() {\n    _locateOrCreateElementContainerNode = locateOrCreateElementContainerNode;\n}\n\n/**\n * Returns the current OpaqueViewState instance.\n *\n * Used in conjunction with the restoreView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n *\n * @codeGenApi\n */\nfunction ɵɵgetCurrentView() {\n    return getLView();\n}\n\n/**\n * Determine if the argument is shaped like a Promise\n */\nfunction isPromise(obj) {\n    // allow any Promise/A+ compliant thenable.\n    // It's up to the caller to ensure that obj.then conforms to the spec\n    return !!obj && typeof obj.then === 'function';\n}\n/**\n * Determine if the argument is a Subscribable\n */\nfunction isSubscribable(obj) {\n    return !!obj && typeof obj.subscribe === 'function';\n}\n\n/**\n * Adds an event listener to the current node.\n *\n * If an output exists on one of the node's directives, it also subscribes to the output\n * and saves the subscription for later cleanup.\n *\n * @param eventName Name of the event\n * @param listenerFn The function to be called when event emits\n * @param useCapture Whether or not to use capture in event listener - this argument is a reminder\n *     from the Renderer3 infrastructure and should be removed from the instruction arguments\n * @param eventTargetResolver Function that returns global target information in case this listener\n * should be attached to a global object like window, document or body\n *\n * @codeGenApi\n */\nfunction ɵɵlistener(eventName, listenerFn, useCapture, eventTargetResolver) {\n    const lView = getLView();\n    const tView = getTView();\n    const tNode = getCurrentTNode();\n    listenerInternal(tView, lView, lView[RENDERER], tNode, eventName, listenerFn, eventTargetResolver);\n    return ɵɵlistener;\n}\n/**\n * Registers a synthetic host listener (e.g. `(@foo.start)`) on a component or directive.\n *\n * This instruction is for compatibility purposes and is designed to ensure that a\n * synthetic host listener (e.g. `@HostListener('@foo.start')`) properly gets rendered\n * in the component's renderer. Normally all host listeners are evaluated with the\n * parent component's renderer, but, in the case of animation @triggers, they need\n * to be evaluated with the sub component's renderer (because that's where the\n * animation triggers are defined).\n *\n * Do not use this instruction as a replacement for `listener`. This instruction\n * only exists to ensure compatibility with the ViewEngine's host binding behavior.\n *\n * @param eventName Name of the event\n * @param listenerFn The function to be called when event emits\n * @param useCapture Whether or not to use capture in event listener\n * @param eventTargetResolver Function that returns global target information in case this listener\n * should be attached to a global object like window, document or body\n *\n * @codeGenApi\n */\nfunction ɵɵsyntheticHostListener(eventName, listenerFn) {\n    const tNode = getCurrentTNode();\n    const lView = getLView();\n    const tView = getTView();\n    const currentDef = getCurrentDirectiveDef(tView.data);\n    const renderer = loadComponentRenderer(currentDef, tNode, lView);\n    listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn);\n    return ɵɵsyntheticHostListener;\n}\n/**\n * A utility function that checks if a given element has already an event handler registered for an\n * event with a specified name. The TView.cleanup data structure is used to find out which events\n * are registered for a given element.\n */\nfunction findExistingListener(tView, lView, eventName, tNodeIdx) {\n    const tCleanup = tView.cleanup;\n    if (tCleanup != null) {\n        for (let i = 0; i < tCleanup.length - 1; i += 2) {\n            const cleanupEventName = tCleanup[i];\n            if (cleanupEventName === eventName && tCleanup[i + 1] === tNodeIdx) {\n                // We have found a matching event name on the same node but it might not have been\n                // registered yet, so we must explicitly verify entries in the LView cleanup data\n                // structures.\n                const lCleanup = lView[CLEANUP];\n                const listenerIdxInLCleanup = tCleanup[i + 2];\n                return lCleanup.length > listenerIdxInLCleanup ? lCleanup[listenerIdxInLCleanup] : null;\n            }\n            // TView.cleanup can have a mix of 4-elements entries (for event handler cleanups) or\n            // 2-element entries (for directive and queries destroy hooks). As such we can encounter\n            // blocks of 4 or 2 items in the tView.cleanup and this is why we iterate over 2 elements\n            // first and jump another 2 elements if we detect listeners cleanup (4 elements). Also check\n            // documentation of TView.cleanup for more details of this data structure layout.\n            if (typeof cleanupEventName === 'string') {\n                i += 2;\n            }\n        }\n    }\n    return null;\n}\nfunction listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn, eventTargetResolver) {\n    const isTNodeDirectiveHost = isDirectiveHost(tNode);\n    const firstCreatePass = tView.firstCreatePass;\n    const tCleanup = firstCreatePass && getOrCreateTViewCleanup(tView);\n    const context = lView[CONTEXT];\n    // When the ɵɵlistener instruction was generated and is executed we know that there is either a\n    // native listener or a directive output on this element. As such we we know that we will have to\n    // register a listener and store its cleanup function on LView.\n    const lCleanup = getOrCreateLViewCleanup(lView);\n    ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 12 /* TNodeType.AnyContainer */);\n    let processOutputs = true;\n    // Adding a native event listener is applicable when:\n    // - The corresponding TNode represents a DOM element.\n    // - The event target has a resolver (usually resulting in a global object,\n    //   such as `window` or `document`).\n    if ((tNode.type & 3 /* TNodeType.AnyRNode */) || eventTargetResolver) {\n        const native = getNativeByTNode(tNode, lView);\n        const target = eventTargetResolver ? eventTargetResolver(native) : native;\n        const lCleanupIndex = lCleanup.length;\n        const idxOrTargetGetter = eventTargetResolver ?\n            (_lView) => eventTargetResolver(unwrapRNode(_lView[tNode.index])) :\n            tNode.index;\n        // In order to match current behavior, native DOM event listeners must be added for all\n        // events (including outputs).\n        // There might be cases where multiple directives on the same element try to register an event\n        // handler function for the same event. In this situation we want to avoid registration of\n        // several native listeners as each registration would be intercepted by NgZone and\n        // trigger change detection. This would mean that a single user action would result in several\n        // change detections being invoked. To avoid this situation we want to have only one call to\n        // native handler registration (for the same element and same type of event).\n        //\n        // In order to have just one native event handler in presence of multiple handler functions,\n        // we just register a first handler function as a native event listener and then chain\n        // (coalesce) other handler functions on top of the first native handler function.\n        let existingListener = null;\n        // Please note that the coalescing described here doesn't happen for events specifying an\n        // alternative target (ex. (document:click)) - this is to keep backward compatibility with the\n        // view engine.\n        // Also, we don't have to search for existing listeners is there are no directives\n        // matching on a given node as we can't register multiple event handlers for the same event in\n        // a template (this would mean having duplicate attributes).\n        if (!eventTargetResolver && isTNodeDirectiveHost) {\n            existingListener = findExistingListener(tView, lView, eventName, tNode.index);\n        }\n        if (existingListener !== null) {\n            // Attach a new listener to coalesced listeners list, maintaining the order in which\n            // listeners are registered. For performance reasons, we keep a reference to the last\n            // listener in that list (in `__ngLastListenerFn__` field), so we can avoid going through\n            // the entire set each time we need to add a new listener.\n            const lastListenerFn = existingListener.__ngLastListenerFn__ || existingListener;\n            lastListenerFn.__ngNextListenerFn__ = listenerFn;\n            existingListener.__ngLastListenerFn__ = listenerFn;\n            processOutputs = false;\n        }\n        else {\n            listenerFn = wrapListener(tNode, lView, context, listenerFn, false /** preventDefault */);\n            const cleanupFn = renderer.listen(target, eventName, listenerFn);\n            ngDevMode && ngDevMode.rendererAddEventListener++;\n            lCleanup.push(listenerFn, cleanupFn);\n            tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, lCleanupIndex + 1);\n        }\n    }\n    else {\n        // Even if there is no native listener to add, we still need to wrap the listener so that OnPush\n        // ancestors are marked dirty when an event occurs.\n        listenerFn = wrapListener(tNode, lView, context, listenerFn, false /** preventDefault */);\n    }\n    // subscribe to directive outputs\n    const outputs = tNode.outputs;\n    let props;\n    if (processOutputs && outputs !== null && (props = outputs[eventName])) {\n        const propsLength = props.length;\n        if (propsLength) {\n            for (let i = 0; i < propsLength; i += 2) {\n                const index = props[i];\n                ngDevMode && assertIndexInRange(lView, index);\n                const minifiedName = props[i + 1];\n                const directiveInstance = lView[index];\n                const output = directiveInstance[minifiedName];\n                if (ngDevMode && !isSubscribable(output)) {\n                    throw new Error(`@Output ${minifiedName} not initialized in '${directiveInstance.constructor.name}'.`);\n                }\n                const subscription = output.subscribe(listenerFn);\n                const idx = lCleanup.length;\n                lCleanup.push(listenerFn, subscription);\n                tCleanup && tCleanup.push(eventName, tNode.index, idx, -(idx + 1));\n            }\n        }\n    }\n}\nfunction executeListenerWithErrorHandling(lView, context, listenerFn, e) {\n    try {\n        profiler(6 /* ProfilerEvent.OutputStart */, context, listenerFn);\n        // Only explicitly returning false from a listener should preventDefault\n        return listenerFn(e) !== false;\n    }\n    catch (error) {\n        handleError(lView, error);\n        return false;\n    }\n    finally {\n        profiler(7 /* ProfilerEvent.OutputEnd */, context, listenerFn);\n    }\n}\n/**\n * Wraps an event listener with a function that marks ancestors dirty and prevents default behavior,\n * if applicable.\n *\n * @param tNode The TNode associated with this listener\n * @param lView The LView that contains this listener\n * @param listenerFn The listener function to call\n * @param wrapWithPreventDefault Whether or not to prevent default behavior\n * (the procedural renderer does this already, so in those cases, we should skip)\n */\nfunction wrapListener(tNode, lView, context, listenerFn, wrapWithPreventDefault) {\n    // Note: we are performing most of the work in the listener function itself\n    // to optimize listener registration.\n    return function wrapListenerIn_markDirtyAndPreventDefault(e) {\n        // Ivy uses `Function` as a special token that allows us to unwrap the function\n        // so that it can be invoked programmatically by `DebugNode.triggerEventHandler`.\n        if (e === Function) {\n            return listenerFn;\n        }\n        // In order to be backwards compatible with View Engine, events on component host nodes\n        // must also mark the component view itself dirty (i.e. the view that it owns).\n        const startView = tNode.componentOffset > -1 ? getComponentLViewByIndex(tNode.index, lView) : lView;\n        markViewDirty(startView);\n        let result = executeListenerWithErrorHandling(lView, context, listenerFn, e);\n        // A just-invoked listener function might have coalesced listeners so we need to check for\n        // their presence and invoke as needed.\n        let nextListenerFn = wrapListenerIn_markDirtyAndPreventDefault.__ngNextListenerFn__;\n        while (nextListenerFn) {\n            // We should prevent default if any of the listeners explicitly return false\n            result = executeListenerWithErrorHandling(lView, context, nextListenerFn, e) && result;\n            nextListenerFn = nextListenerFn.__ngNextListenerFn__;\n        }\n        if (wrapWithPreventDefault && result === false) {\n            e.preventDefault();\n        }\n        return result;\n    };\n}\n\n/**\n * Retrieves a context at the level specified and saves it as the global, contextViewData.\n * Will get the next level up if level is not specified.\n *\n * This is used to save contexts of parent views so they can be bound in embedded views, or\n * in conjunction with reference() to bind a ref from a parent view.\n *\n * @param level The relative level of the view from which to grab context compared to contextVewData\n * @returns context\n *\n * @codeGenApi\n */\nfunction ɵɵnextContext(level = 1) {\n    return nextContextImpl(level);\n}\n\n/**\n * Checks a given node against matching projection slots and returns the\n * determined slot index. Returns \"null\" if no slot matched the given node.\n *\n * This function takes into account the parsed ngProjectAs selector from the\n * node's attributes. If present, it will check whether the ngProjectAs selector\n * matches any of the projection slot selectors.\n */\nfunction matchingProjectionSlotIndex(tNode, projectionSlots) {\n    let wildcardNgContentIndex = null;\n    const ngProjectAsAttrVal = getProjectAsAttrValue(tNode);\n    for (let i = 0; i < projectionSlots.length; i++) {\n        const slotValue = projectionSlots[i];\n        // The last wildcard projection slot should match all nodes which aren't matching\n        // any selector. This is necessary to be backwards compatible with view engine.\n        if (slotValue === '*') {\n            wildcardNgContentIndex = i;\n            continue;\n        }\n        // If we ran into an `ngProjectAs` attribute, we should match its parsed selector\n        // to the list of selectors, otherwise we fall back to matching against the node.\n        if (ngProjectAsAttrVal === null ?\n            isNodeMatchingSelectorList(tNode, slotValue, /* isProjectionMode */ true) :\n            isSelectorInSelectorList(ngProjectAsAttrVal, slotValue)) {\n            return i; // first matching selector \"captures\" a given node\n        }\n    }\n    return wildcardNgContentIndex;\n}\n/**\n * Instruction to distribute projectable nodes among <ng-content> occurrences in a given template.\n * It takes all the selectors from the entire component's template and decides where\n * each projected node belongs (it re-distributes nodes among \"buckets\" where each \"bucket\" is\n * backed by a selector).\n *\n * This function requires CSS selectors to be provided in 2 forms: parsed (by a compiler) and text,\n * un-parsed form.\n *\n * The parsed form is needed for efficient matching of a node against a given CSS selector.\n * The un-parsed, textual form is needed for support of the ngProjectAs attribute.\n *\n * Having a CSS selector in 2 different formats is not ideal, but alternatives have even more\n * drawbacks:\n * - having only a textual form would require runtime parsing of CSS selectors;\n * - we can't have only a parsed as we can't re-construct textual form from it (as entered by a\n * template author).\n *\n * @param projectionSlots? A collection of projection slots. A projection slot can be based\n *        on a parsed CSS selectors or set to the wildcard selector (\"*\") in order to match\n *        all nodes which do not match any selector. If not specified, a single wildcard\n *        selector projection slot will be defined.\n *\n * @codeGenApi\n */\nfunction ɵɵprojectionDef(projectionSlots) {\n    const componentNode = getLView()[DECLARATION_COMPONENT_VIEW][T_HOST];\n    if (!componentNode.projection) {\n        // If no explicit projection slots are defined, fall back to a single\n        // projection slot with the wildcard selector.\n        const numProjectionSlots = projectionSlots ? projectionSlots.length : 1;\n        const projectionHeads = componentNode.projection =\n            newArray(numProjectionSlots, null);\n        const tails = projectionHeads.slice();\n        let componentChild = componentNode.child;\n        while (componentChild !== null) {\n            const slotIndex = projectionSlots ? matchingProjectionSlotIndex(componentChild, projectionSlots) : 0;\n            if (slotIndex !== null) {\n                if (tails[slotIndex]) {\n                    tails[slotIndex].projectionNext = componentChild;\n                }\n                else {\n                    projectionHeads[slotIndex] = componentChild;\n                }\n                tails[slotIndex] = componentChild;\n            }\n            componentChild = componentChild.next;\n        }\n    }\n}\n/**\n * Inserts previously re-distributed projected nodes. This instruction must be preceded by a call\n * to the projectionDef instruction.\n *\n * @param nodeIndex\n * @param selectorIndex:\n *        - 0 when the selector is `*` (or unspecified as this is the default value),\n *        - 1 based index of the selector from the {@link projectionDef}\n *\n * @codeGenApi\n */\nfunction ɵɵprojection(nodeIndex, selectorIndex = 0, attrs) {\n    const lView = getLView();\n    const tView = getTView();\n    const tProjectionNode = getOrCreateTNode(tView, HEADER_OFFSET + nodeIndex, 16 /* TNodeType.Projection */, null, attrs || null);\n    // We can't use viewData[HOST_NODE] because projection nodes can be nested in embedded views.\n    if (tProjectionNode.projection === null)\n        tProjectionNode.projection = selectorIndex;\n    // `<ng-content>` has no content\n    setCurrentTNodeAsNotParent();\n    const hydrationInfo = lView[HYDRATION];\n    const isNodeCreationMode = !hydrationInfo || isInSkipHydrationBlock$1();\n    if (isNodeCreationMode &&\n        (tProjectionNode.flags & 32 /* TNodeFlags.isDetached */) !== 32 /* TNodeFlags.isDetached */) {\n        // re-distribution of projectable nodes is stored on a component's view level\n        applyProjection(tView, lView, tProjectionNode);\n    }\n}\n\n/**\n *\n * Update an interpolated property on an element with a lone bound value\n *\n * Used when the value passed to a property has 1 interpolated value in it, an no additional text\n * surrounds that interpolated value:\n *\n * ```html\n * <div title=\"{{v0}}\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate('title', v0);\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵpropertyInterpolate(propName, v0, sanitizer) {\n    ɵɵpropertyInterpolate1(propName, '', v0, '', sanitizer);\n    return ɵɵpropertyInterpolate;\n}\n/**\n *\n * Update an interpolated property on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate1('title', 'prefix', v0, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵpropertyInterpolate1(propName, prefix, v0, suffix, sanitizer) {\n    const lView = getLView();\n    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n        ngDevMode &&\n            storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 1, prefix, suffix);\n    }\n    return ɵɵpropertyInterpolate1;\n}\n/**\n *\n * Update an interpolated property on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate2('title', 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵpropertyInterpolate2(propName, prefix, v0, i0, v1, suffix, sanitizer) {\n    const lView = getLView();\n    const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n        ngDevMode &&\n            storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 2, prefix, i0, suffix);\n    }\n    return ɵɵpropertyInterpolate2;\n}\n/**\n *\n * Update an interpolated property on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate3(\n * 'title', 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵpropertyInterpolate3(propName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer) {\n    const lView = getLView();\n    const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n        ngDevMode &&\n            storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 3, prefix, i0, i1, suffix);\n    }\n    return ɵɵpropertyInterpolate3;\n}\n/**\n *\n * Update an interpolated property on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate4(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵpropertyInterpolate4(propName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer) {\n    const lView = getLView();\n    const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n        ngDevMode &&\n            storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);\n    }\n    return ɵɵpropertyInterpolate4;\n}\n/**\n *\n * Update an interpolated property on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate5(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵpropertyInterpolate5(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer) {\n    const lView = getLView();\n    const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n        ngDevMode &&\n            storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);\n    }\n    return ɵɵpropertyInterpolate5;\n}\n/**\n *\n * Update an interpolated property on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate6(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵpropertyInterpolate6(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer) {\n    const lView = getLView();\n    const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n        ngDevMode &&\n            storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);\n    }\n    return ɵɵpropertyInterpolate6;\n}\n/**\n *\n * Update an interpolated property on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate7(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵpropertyInterpolate7(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer) {\n    const lView = getLView();\n    const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n        ngDevMode &&\n            storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5, suffix);\n    }\n    return ɵɵpropertyInterpolate7;\n}\n/**\n *\n * Update an interpolated property on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate8(\n *  'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵpropertyInterpolate8(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer) {\n    const lView = getLView();\n    const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n        ngDevMode &&\n            storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6, suffix);\n    }\n    return ɵɵpropertyInterpolate8;\n}\n/**\n * Update an interpolated property on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolateV(\n *  'title', ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update.\n * @param values The collection of values and the strings in between those values, beginning with a\n * string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵpropertyInterpolateV(propName, values, sanitizer) {\n    const lView = getLView();\n    const interpolatedValue = interpolationV(lView, values);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n        if (ngDevMode) {\n            const interpolationInBetween = [values[0]]; // prefix\n            for (let i = 2; i < values.length; i += 2) {\n                interpolationInBetween.push(values[i]);\n            }\n            storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);\n        }\n    }\n    return ɵɵpropertyInterpolateV;\n}\n\nfunction toTStylingRange(prev, next) {\n    ngDevMode && assertNumberInRange(prev, 0, 32767 /* StylingRange.UNSIGNED_MASK */);\n    ngDevMode && assertNumberInRange(next, 0, 32767 /* StylingRange.UNSIGNED_MASK */);\n    return (prev << 17 /* StylingRange.PREV_SHIFT */ | next << 2 /* StylingRange.NEXT_SHIFT */);\n}\nfunction getTStylingRangePrev(tStylingRange) {\n    ngDevMode && assertNumber(tStylingRange, 'expected number');\n    return (tStylingRange >> 17 /* StylingRange.PREV_SHIFT */) & 32767 /* StylingRange.UNSIGNED_MASK */;\n}\nfunction getTStylingRangePrevDuplicate(tStylingRange) {\n    ngDevMode && assertNumber(tStylingRange, 'expected number');\n    return (tStylingRange & 2 /* StylingRange.PREV_DUPLICATE */) == 2 /* StylingRange.PREV_DUPLICATE */;\n}\nfunction setTStylingRangePrev(tStylingRange, previous) {\n    ngDevMode && assertNumber(tStylingRange, 'expected number');\n    ngDevMode && assertNumberInRange(previous, 0, 32767 /* StylingRange.UNSIGNED_MASK */);\n    return ((tStylingRange & ~4294836224 /* StylingRange.PREV_MASK */) | (previous << 17 /* StylingRange.PREV_SHIFT */));\n}\nfunction setTStylingRangePrevDuplicate(tStylingRange) {\n    ngDevMode && assertNumber(tStylingRange, 'expected number');\n    return (tStylingRange | 2 /* StylingRange.PREV_DUPLICATE */);\n}\nfunction getTStylingRangeNext(tStylingRange) {\n    ngDevMode && assertNumber(tStylingRange, 'expected number');\n    return (tStylingRange & 131068 /* StylingRange.NEXT_MASK */) >> 2 /* StylingRange.NEXT_SHIFT */;\n}\nfunction setTStylingRangeNext(tStylingRange, next) {\n    ngDevMode && assertNumber(tStylingRange, 'expected number');\n    ngDevMode && assertNumberInRange(next, 0, 32767 /* StylingRange.UNSIGNED_MASK */);\n    return ((tStylingRange & ~131068 /* StylingRange.NEXT_MASK */) | //\n        next << 2 /* StylingRange.NEXT_SHIFT */);\n}\nfunction getTStylingRangeNextDuplicate(tStylingRange) {\n    ngDevMode && assertNumber(tStylingRange, 'expected number');\n    return ((tStylingRange) & 1 /* StylingRange.NEXT_DUPLICATE */) === 1 /* StylingRange.NEXT_DUPLICATE */;\n}\nfunction setTStylingRangeNextDuplicate(tStylingRange) {\n    ngDevMode && assertNumber(tStylingRange, 'expected number');\n    return (tStylingRange | 1 /* StylingRange.NEXT_DUPLICATE */);\n}\nfunction getTStylingRangeTail(tStylingRange) {\n    ngDevMode && assertNumber(tStylingRange, 'expected number');\n    const next = getTStylingRangeNext(tStylingRange);\n    return next === 0 ? getTStylingRangePrev(tStylingRange) : next;\n}\n\n/**\n * NOTE: The word `styling` is used interchangeably as style or class styling.\n *\n * This file contains code to link styling instructions together so that they can be replayed in\n * priority order. The file exists because Ivy styling instruction execution order does not match\n * that of the priority order. The purpose of this code is to create a linked list so that the\n * instructions can be traversed in priority order when computing the styles.\n *\n * Assume we are dealing with the following code:\n * ```\n * @Component({\n *   template: `\n *     <my-cmp [style]=\" {color: '#001'} \"\n *             [style.color]=\" #002 \"\n *             dir-style-color-1\n *             dir-style-color-2> `\n * })\n * class ExampleComponent {\n *   static ngComp = ... {\n *     ...\n *     // Compiler ensures that `ɵɵstyleProp` is after `ɵɵstyleMap`\n *     ɵɵstyleMap({color: '#001'});\n *     ɵɵstyleProp('color', '#002');\n *     ...\n *   }\n * }\n *\n * @Directive({\n *   selector: `[dir-style-color-1]',\n * })\n * class Style1Directive {\n *   @HostBinding('style') style = {color: '#005'};\n *   @HostBinding('style.color') color = '#006';\n *\n *   static ngDir = ... {\n *     ...\n *     // Compiler ensures that `ɵɵstyleProp` is after `ɵɵstyleMap`\n *     ɵɵstyleMap({color: '#005'});\n *     ɵɵstyleProp('color', '#006');\n *     ...\n *   }\n * }\n *\n * @Directive({\n *   selector: `[dir-style-color-2]',\n * })\n * class Style2Directive {\n *   @HostBinding('style') style = {color: '#007'};\n *   @HostBinding('style.color') color = '#008';\n *\n *   static ngDir = ... {\n *     ...\n *     // Compiler ensures that `ɵɵstyleProp` is after `ɵɵstyleMap`\n *     ɵɵstyleMap({color: '#007'});\n *     ɵɵstyleProp('color', '#008');\n *     ...\n *   }\n * }\n *\n * @Directive({\n *   selector: `my-cmp',\n * })\n * class MyComponent {\n *   @HostBinding('style') style = {color: '#003'};\n *   @HostBinding('style.color') color = '#004';\n *\n *   static ngComp = ... {\n *     ...\n *     // Compiler ensures that `ɵɵstyleProp` is after `ɵɵstyleMap`\n *     ɵɵstyleMap({color: '#003'});\n *     ɵɵstyleProp('color', '#004');\n *     ...\n *   }\n * }\n * ```\n *\n * The Order of instruction execution is:\n *\n * NOTE: the comment binding location is for illustrative purposes only.\n *\n * ```\n * // Template: (ExampleComponent)\n *     ɵɵstyleMap({color: '#001'});   // Binding index: 10\n *     ɵɵstyleProp('color', '#002');  // Binding index: 12\n * // MyComponent\n *     ɵɵstyleMap({color: '#003'});   // Binding index: 20\n *     ɵɵstyleProp('color', '#004');  // Binding index: 22\n * // Style1Directive\n *     ɵɵstyleMap({color: '#005'});   // Binding index: 24\n *     ɵɵstyleProp('color', '#006');  // Binding index: 26\n * // Style2Directive\n *     ɵɵstyleMap({color: '#007'});   // Binding index: 28\n *     ɵɵstyleProp('color', '#008');  // Binding index: 30\n * ```\n *\n * The correct priority order of concatenation is:\n *\n * ```\n * // MyComponent\n *     ɵɵstyleMap({color: '#003'});   // Binding index: 20\n *     ɵɵstyleProp('color', '#004');  // Binding index: 22\n * // Style1Directive\n *     ɵɵstyleMap({color: '#005'});   // Binding index: 24\n *     ɵɵstyleProp('color', '#006');  // Binding index: 26\n * // Style2Directive\n *     ɵɵstyleMap({color: '#007'});   // Binding index: 28\n *     ɵɵstyleProp('color', '#008');  // Binding index: 30\n * // Template: (ExampleComponent)\n *     ɵɵstyleMap({color: '#001'});   // Binding index: 10\n *     ɵɵstyleProp('color', '#002');  // Binding index: 12\n * ```\n *\n * What color should be rendered?\n *\n * Once the items are correctly sorted in the list, the answer is simply the last item in the\n * concatenation list which is `#002`.\n *\n * To do so we keep a linked list of all of the bindings which pertain to this element.\n * Notice that the bindings are inserted in the order of execution, but the `TView.data` allows\n * us to traverse them in the order of priority.\n *\n * |Idx|`TView.data`|`LView`          | Notes\n * |---|------------|-----------------|--------------\n * |...|            |                 |\n * |10 |`null`      |`{color: '#001'}`| `ɵɵstyleMap('color', {color: '#001'})`\n * |11 |`30 | 12`   | ...             |\n * |12 |`color`     |`'#002'`         | `ɵɵstyleProp('color', '#002')`\n * |13 |`10 | 0`    | ...             |\n * |...|            |                 |\n * |20 |`null`      |`{color: '#003'}`| `ɵɵstyleMap('color', {color: '#003'})`\n * |21 |`0 | 22`    | ...             |\n * |22 |`color`     |`'#004'`         | `ɵɵstyleProp('color', '#004')`\n * |23 |`20 | 24`   | ...             |\n * |24 |`null`      |`{color: '#005'}`| `ɵɵstyleMap('color', {color: '#005'})`\n * |25 |`22 | 26`   | ...             |\n * |26 |`color`     |`'#006'`         | `ɵɵstyleProp('color', '#006')`\n * |27 |`24 | 28`   | ...             |\n * |28 |`null`      |`{color: '#007'}`| `ɵɵstyleMap('color', {color: '#007'})`\n * |29 |`26 | 30`   | ...             |\n * |30 |`color`     |`'#008'`         | `ɵɵstyleProp('color', '#008')`\n * |31 |`28 | 10`   | ...             |\n *\n * The above data structure allows us to re-concatenate the styling no matter which data binding\n * changes.\n *\n * NOTE: in addition to keeping track of next/previous index the `TView.data` also stores prev/next\n * duplicate bit. The duplicate bit if true says there either is a binding with the same name or\n * there is a map (which may contain the name). This information is useful in knowing if other\n * styles with higher priority need to be searched for overwrites.\n *\n * NOTE: See `should support example in 'tnode_linked_list.ts' documentation` in\n * `tnode_linked_list_spec.ts` for working example.\n */\nlet __unused_const_as_closure_does_not_like_standalone_comment_blocks__;\n/**\n * Insert new `tStyleValue` at `TData` and link existing style bindings such that we maintain linked\n * list of styles and compute the duplicate flag.\n *\n * Note: this function is executed during `firstUpdatePass` only to populate the `TView.data`.\n *\n * The function works by keeping track of `tStylingRange` which contains two pointers pointing to\n * the head/tail of the template portion of the styles.\n *  - if `isHost === false` (we are template) then insertion is at tail of `TStylingRange`\n *  - if `isHost === true` (we are host binding) then insertion is at head of `TStylingRange`\n *\n * @param tData The `TData` to insert into.\n * @param tNode `TNode` associated with the styling element.\n * @param tStylingKey See `TStylingKey`.\n * @param index location of where `tStyleValue` should be stored (and linked into list.)\n * @param isHostBinding `true` if the insertion is for a `hostBinding`. (insertion is in front of\n *               template.)\n * @param isClassBinding True if the associated `tStylingKey` as a `class` styling.\n *                       `tNode.classBindings` should be used (or `tNode.styleBindings` otherwise.)\n */\nfunction insertTStylingBinding(tData, tNode, tStylingKeyWithStatic, index, isHostBinding, isClassBinding) {\n    ngDevMode && assertFirstUpdatePass(getTView());\n    let tBindings = isClassBinding ? tNode.classBindings : tNode.styleBindings;\n    let tmplHead = getTStylingRangePrev(tBindings);\n    let tmplTail = getTStylingRangeNext(tBindings);\n    tData[index] = tStylingKeyWithStatic;\n    let isKeyDuplicateOfStatic = false;\n    let tStylingKey;\n    if (Array.isArray(tStylingKeyWithStatic)) {\n        // We are case when the `TStylingKey` contains static fields as well.\n        const staticKeyValueArray = tStylingKeyWithStatic;\n        tStylingKey = staticKeyValueArray[1]; // unwrap.\n        // We need to check if our key is present in the static so that we can mark it as duplicate.\n        if (tStylingKey === null ||\n            keyValueArrayIndexOf(staticKeyValueArray, tStylingKey) > 0) {\n            // tStylingKey is present in the statics, need to mark it as duplicate.\n            isKeyDuplicateOfStatic = true;\n        }\n    }\n    else {\n        tStylingKey = tStylingKeyWithStatic;\n    }\n    if (isHostBinding) {\n        // We are inserting host bindings\n        // If we don't have template bindings then `tail` is 0.\n        const hasTemplateBindings = tmplTail !== 0;\n        // This is important to know because that means that the `head` can't point to the first\n        // template bindings (there are none.) Instead the head points to the tail of the template.\n        if (hasTemplateBindings) {\n            // template head's \"prev\" will point to last host binding or to 0 if no host bindings yet\n            const previousNode = getTStylingRangePrev(tData[tmplHead + 1]);\n            tData[index + 1] = toTStylingRange(previousNode, tmplHead);\n            // if a host binding has already been registered, we need to update the next of that host\n            // binding to point to this one\n            if (previousNode !== 0) {\n                // We need to update the template-tail value to point to us.\n                tData[previousNode + 1] =\n                    setTStylingRangeNext(tData[previousNode + 1], index);\n            }\n            // The \"previous\" of the template binding head should point to this host binding\n            tData[tmplHead + 1] = setTStylingRangePrev(tData[tmplHead + 1], index);\n        }\n        else {\n            tData[index + 1] = toTStylingRange(tmplHead, 0);\n            // if a host binding has already been registered, we need to update the next of that host\n            // binding to point to this one\n            if (tmplHead !== 0) {\n                // We need to update the template-tail value to point to us.\n                tData[tmplHead + 1] = setTStylingRangeNext(tData[tmplHead + 1], index);\n            }\n            // if we don't have template, the head points to template-tail, and needs to be advanced.\n            tmplHead = index;\n        }\n    }\n    else {\n        // We are inserting in template section.\n        // We need to set this binding's \"previous\" to the current template tail\n        tData[index + 1] = toTStylingRange(tmplTail, 0);\n        ngDevMode &&\n            assertEqual(tmplHead !== 0 && tmplTail === 0, false, 'Adding template bindings after hostBindings is not allowed.');\n        if (tmplHead === 0) {\n            tmplHead = index;\n        }\n        else {\n            // We need to update the previous value \"next\" to point to this binding\n            tData[tmplTail + 1] = setTStylingRangeNext(tData[tmplTail + 1], index);\n        }\n        tmplTail = index;\n    }\n    // Now we need to update / compute the duplicates.\n    // Starting with our location search towards head (least priority)\n    if (isKeyDuplicateOfStatic) {\n        tData[index + 1] = setTStylingRangePrevDuplicate(tData[index + 1]);\n    }\n    markDuplicates(tData, tStylingKey, index, true, isClassBinding);\n    markDuplicates(tData, tStylingKey, index, false, isClassBinding);\n    markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding);\n    tBindings = toTStylingRange(tmplHead, tmplTail);\n    if (isClassBinding) {\n        tNode.classBindings = tBindings;\n    }\n    else {\n        tNode.styleBindings = tBindings;\n    }\n}\n/**\n * Look into the residual styling to see if the current `tStylingKey` is duplicate of residual.\n *\n * @param tNode `TNode` where the residual is stored.\n * @param tStylingKey `TStylingKey` to store.\n * @param tData `TData` associated with the current `LView`.\n * @param index location of where `tStyleValue` should be stored (and linked into list.)\n * @param isClassBinding True if the associated `tStylingKey` as a `class` styling.\n *                       `tNode.classBindings` should be used (or `tNode.styleBindings` otherwise.)\n */\nfunction markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding) {\n    const residual = isClassBinding ? tNode.residualClasses : tNode.residualStyles;\n    if (residual != null /* or undefined */ && typeof tStylingKey == 'string' &&\n        keyValueArrayIndexOf(residual, tStylingKey) >= 0) {\n        // We have duplicate in the residual so mark ourselves as duplicate.\n        tData[index + 1] = setTStylingRangeNextDuplicate(tData[index + 1]);\n    }\n}\n/**\n * Marks `TStyleValue`s as duplicates if another style binding in the list has the same\n * `TStyleValue`.\n *\n * NOTE: this function is intended to be called twice once with `isPrevDir` set to `true` and once\n * with it set to `false` to search both the previous as well as next items in the list.\n *\n * No duplicate case\n * ```\n *   [style.color]\n *   [style.width.px] <<- index\n *   [style.height.px]\n * ```\n *\n * In the above case adding `[style.width.px]` to the existing `[style.color]` produces no\n * duplicates because `width` is not found in any other part of the linked list.\n *\n * Duplicate case\n * ```\n *   [style.color]\n *   [style.width.em]\n *   [style.width.px] <<- index\n * ```\n * In the above case adding `[style.width.px]` will produce a duplicate with `[style.width.em]`\n * because `width` is found in the chain.\n *\n * Map case 1\n * ```\n *   [style.width.px]\n *   [style.color]\n *   [style]  <<- index\n * ```\n * In the above case adding `[style]` will produce a duplicate with any other bindings because\n * `[style]` is a Map and as such is fully dynamic and could produce `color` or `width`.\n *\n * Map case 2\n * ```\n *   [style]\n *   [style.width.px]\n *   [style.color]  <<- index\n * ```\n * In the above case adding `[style.color]` will produce a duplicate because there is already a\n * `[style]` binding which is a Map and as such is fully dynamic and could produce `color` or\n * `width`.\n *\n * NOTE: Once `[style]` (Map) is added into the system all things are mapped as duplicates.\n * NOTE: We use `style` as example, but same logic is applied to `class`es as well.\n *\n * @param tData `TData` where the linked list is stored.\n * @param tStylingKey `TStylingKeyPrimitive` which contains the value to compare to other keys in\n *        the linked list.\n * @param index Starting location in the linked list to search from\n * @param isPrevDir Direction.\n *        - `true` for previous (lower priority);\n *        - `false` for next (higher priority).\n */\nfunction markDuplicates(tData, tStylingKey, index, isPrevDir, isClassBinding) {\n    const tStylingAtIndex = tData[index + 1];\n    const isMap = tStylingKey === null;\n    let cursor = isPrevDir ? getTStylingRangePrev(tStylingAtIndex) : getTStylingRangeNext(tStylingAtIndex);\n    let foundDuplicate = false;\n    // We keep iterating as long as we have a cursor\n    // AND either:\n    // - we found what we are looking for, OR\n    // - we are a map in which case we have to continue searching even after we find what we were\n    //   looking for since we are a wild card and everything needs to be flipped to duplicate.\n    while (cursor !== 0 && (foundDuplicate === false || isMap)) {\n        ngDevMode && assertIndexInRange(tData, cursor);\n        const tStylingValueAtCursor = tData[cursor];\n        const tStyleRangeAtCursor = tData[cursor + 1];\n        if (isStylingMatch(tStylingValueAtCursor, tStylingKey)) {\n            foundDuplicate = true;\n            tData[cursor + 1] = isPrevDir ? setTStylingRangeNextDuplicate(tStyleRangeAtCursor) :\n                setTStylingRangePrevDuplicate(tStyleRangeAtCursor);\n        }\n        cursor = isPrevDir ? getTStylingRangePrev(tStyleRangeAtCursor) :\n            getTStylingRangeNext(tStyleRangeAtCursor);\n    }\n    if (foundDuplicate) {\n        // if we found a duplicate, than mark ourselves.\n        tData[index + 1] = isPrevDir ? setTStylingRangePrevDuplicate(tStylingAtIndex) :\n            setTStylingRangeNextDuplicate(tStylingAtIndex);\n    }\n}\n/**\n * Determines if two `TStylingKey`s are a match.\n *\n * When computing whether a binding contains a duplicate, we need to compare if the instruction\n * `TStylingKey` has a match.\n *\n * Here are examples of `TStylingKey`s which match given `tStylingKeyCursor` is:\n * - `color`\n *    - `color`    // Match another color\n *    - `null`     // That means that `tStylingKey` is a `classMap`/`styleMap` instruction\n *    - `['', 'color', 'other', true]` // wrapped `color` so match\n *    - `['', null, 'other', true]`       // wrapped `null` so match\n *    - `['', 'width', 'color', 'value']` // wrapped static value contains a match on `'color'`\n * - `null`       // `tStylingKeyCursor` always match as it is `classMap`/`styleMap` instruction\n *\n * @param tStylingKeyCursor\n * @param tStylingKey\n */\nfunction isStylingMatch(tStylingKeyCursor, tStylingKey) {\n    ngDevMode &&\n        assertNotEqual(Array.isArray(tStylingKey), true, 'Expected that \\'tStylingKey\\' has been unwrapped');\n    if (tStylingKeyCursor === null || // If the cursor is `null` it means that we have map at that\n        // location so we must assume that we have a match.\n        tStylingKey == null || // If `tStylingKey` is `null` then it is a map therefor assume that it\n        // contains a match.\n        (Array.isArray(tStylingKeyCursor) ? tStylingKeyCursor[1] : tStylingKeyCursor) ===\n            tStylingKey // If the keys match explicitly than we are a match.\n    ) {\n        return true;\n    }\n    else if (Array.isArray(tStylingKeyCursor) && typeof tStylingKey === 'string') {\n        // if we did not find a match, but `tStylingKeyCursor` is `KeyValueArray` that means cursor has\n        // statics and we need to check those as well.\n        return keyValueArrayIndexOf(tStylingKeyCursor, tStylingKey) >=\n            0; // see if we are matching the key\n    }\n    return false;\n}\n\n// Global state of the parser. (This makes parser non-reentrant, but that is not an issue)\nconst parserState = {\n    textEnd: 0,\n    key: 0,\n    keyEnd: 0,\n    value: 0,\n    valueEnd: 0,\n};\n/**\n * Retrieves the last parsed `key` of style.\n * @param text the text to substring the key from.\n */\nfunction getLastParsedKey(text) {\n    return text.substring(parserState.key, parserState.keyEnd);\n}\n/**\n * Retrieves the last parsed `value` of style.\n * @param text the text to substring the key from.\n */\nfunction getLastParsedValue(text) {\n    return text.substring(parserState.value, parserState.valueEnd);\n}\n/**\n * Initializes `className` string for parsing and parses the first token.\n *\n * This function is intended to be used in this format:\n * ```\n * for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {\n *   const key = getLastParsedKey();\n *   ...\n * }\n * ```\n * @param text `className` to parse\n * @returns index where the next invocation of `parseClassNameNext` should resume.\n */\nfunction parseClassName(text) {\n    resetParserState(text);\n    return parseClassNameNext(text, consumeWhitespace(text, 0, parserState.textEnd));\n}\n/**\n * Parses next `className` token.\n *\n * This function is intended to be used in this format:\n * ```\n * for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {\n *   const key = getLastParsedKey();\n *   ...\n * }\n * ```\n *\n * @param text `className` to parse\n * @param index where the parsing should resume.\n * @returns index where the next invocation of `parseClassNameNext` should resume.\n */\nfunction parseClassNameNext(text, index) {\n    const end = parserState.textEnd;\n    if (end === index) {\n        return -1;\n    }\n    index = parserState.keyEnd = consumeClassToken(text, parserState.key = index, end);\n    return consumeWhitespace(text, index, end);\n}\n/**\n * Initializes `cssText` string for parsing and parses the first key/values.\n *\n * This function is intended to be used in this format:\n * ```\n * for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i))) {\n *   const key = getLastParsedKey();\n *   const value = getLastParsedValue();\n *   ...\n * }\n * ```\n * @param text `cssText` to parse\n * @returns index where the next invocation of `parseStyleNext` should resume.\n */\nfunction parseStyle(text) {\n    resetParserState(text);\n    return parseStyleNext(text, consumeWhitespace(text, 0, parserState.textEnd));\n}\n/**\n * Parses the next `cssText` key/values.\n *\n * This function is intended to be used in this format:\n * ```\n * for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i))) {\n *   const key = getLastParsedKey();\n *   const value = getLastParsedValue();\n *   ...\n * }\n *\n * @param text `cssText` to parse\n * @param index where the parsing should resume.\n * @returns index where the next invocation of `parseStyleNext` should resume.\n */\nfunction parseStyleNext(text, startIndex) {\n    const end = parserState.textEnd;\n    let index = parserState.key = consumeWhitespace(text, startIndex, end);\n    if (end === index) {\n        // we reached an end so just quit\n        return -1;\n    }\n    index = parserState.keyEnd = consumeStyleKey(text, index, end);\n    index = consumeSeparator(text, index, end, 58 /* CharCode.COLON */);\n    index = parserState.value = consumeWhitespace(text, index, end);\n    index = parserState.valueEnd = consumeStyleValue(text, index, end);\n    return consumeSeparator(text, index, end, 59 /* CharCode.SEMI_COLON */);\n}\n/**\n * Reset the global state of the styling parser.\n * @param text The styling text to parse.\n */\nfunction resetParserState(text) {\n    parserState.key = 0;\n    parserState.keyEnd = 0;\n    parserState.value = 0;\n    parserState.valueEnd = 0;\n    parserState.textEnd = text.length;\n}\n/**\n * Returns index of next non-whitespace character.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index of next non-whitespace character (May be the same as `start` if no whitespace at\n *          that location.)\n */\nfunction consumeWhitespace(text, startIndex, endIndex) {\n    while (startIndex < endIndex && text.charCodeAt(startIndex) <= 32 /* CharCode.SPACE */) {\n        startIndex++;\n    }\n    return startIndex;\n}\n/**\n * Returns index of last char in class token.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after last char in class token.\n */\nfunction consumeClassToken(text, startIndex, endIndex) {\n    while (startIndex < endIndex && text.charCodeAt(startIndex) > 32 /* CharCode.SPACE */) {\n        startIndex++;\n    }\n    return startIndex;\n}\n/**\n * Consumes all of the characters belonging to style key and token.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after last style key character.\n */\nfunction consumeStyleKey(text, startIndex, endIndex) {\n    let ch;\n    while (startIndex < endIndex &&\n        ((ch = text.charCodeAt(startIndex)) === 45 /* CharCode.DASH */ || ch === 95 /* CharCode.UNDERSCORE */ ||\n            ((ch & -33 /* CharCode.UPPER_CASE */) >= 65 /* CharCode.A */ && (ch & -33 /* CharCode.UPPER_CASE */) <= 90 /* CharCode.Z */) ||\n            (ch >= 48 /* CharCode.ZERO */ && ch <= 57 /* CharCode.NINE */))) {\n        startIndex++;\n    }\n    return startIndex;\n}\n/**\n * Consumes all whitespace and the separator `:` after the style key.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after separator and surrounding whitespace.\n */\nfunction consumeSeparator(text, startIndex, endIndex, separator) {\n    startIndex = consumeWhitespace(text, startIndex, endIndex);\n    if (startIndex < endIndex) {\n        if (ngDevMode && text.charCodeAt(startIndex) !== separator) {\n            malformedStyleError(text, String.fromCharCode(separator), startIndex);\n        }\n        startIndex++;\n    }\n    return startIndex;\n}\n/**\n * Consumes style value honoring `url()` and `\"\"` text.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after last style value character.\n */\nfunction consumeStyleValue(text, startIndex, endIndex) {\n    let ch1 = -1; // 1st previous character\n    let ch2 = -1; // 2nd previous character\n    let ch3 = -1; // 3rd previous character\n    let i = startIndex;\n    let lastChIndex = i;\n    while (i < endIndex) {\n        const ch = text.charCodeAt(i++);\n        if (ch === 59 /* CharCode.SEMI_COLON */) {\n            return lastChIndex;\n        }\n        else if (ch === 34 /* CharCode.DOUBLE_QUOTE */ || ch === 39 /* CharCode.SINGLE_QUOTE */) {\n            lastChIndex = i = consumeQuotedText(text, ch, i, endIndex);\n        }\n        else if (startIndex ===\n            i - 4 && // We have seen only 4 characters so far \"URL(\" (Ignore \"foo_URL()\")\n            ch3 === 85 /* CharCode.U */ &&\n            ch2 === 82 /* CharCode.R */ && ch1 === 76 /* CharCode.L */ && ch === 40 /* CharCode.OPEN_PAREN */) {\n            lastChIndex = i = consumeQuotedText(text, 41 /* CharCode.CLOSE_PAREN */, i, endIndex);\n        }\n        else if (ch > 32 /* CharCode.SPACE */) {\n            // if we have a non-whitespace character then capture its location\n            lastChIndex = i;\n        }\n        ch3 = ch2;\n        ch2 = ch1;\n        ch1 = ch & -33 /* CharCode.UPPER_CASE */;\n    }\n    return lastChIndex;\n}\n/**\n * Consumes all of the quoted characters.\n *\n * @param text Text to scan\n * @param quoteCharCode CharCode of either `\"` or `'` quote or `)` for `url(...)`.\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after quoted characters.\n */\nfunction consumeQuotedText(text, quoteCharCode, startIndex, endIndex) {\n    let ch1 = -1; // 1st previous character\n    let index = startIndex;\n    while (index < endIndex) {\n        const ch = text.charCodeAt(index++);\n        if (ch == quoteCharCode && ch1 !== 92 /* CharCode.BACK_SLASH */) {\n            return index;\n        }\n        if (ch == 92 /* CharCode.BACK_SLASH */ && ch1 === 92 /* CharCode.BACK_SLASH */) {\n            // two back slashes cancel each other out. For example `\"\\\\\"` should properly end the\n            // quotation. (It should not assume that the last `\"` is escaped.)\n            ch1 = 0;\n        }\n        else {\n            ch1 = ch;\n        }\n    }\n    throw ngDevMode ? malformedStyleError(text, String.fromCharCode(quoteCharCode), endIndex) :\n        new Error();\n}\nfunction malformedStyleError(text, expecting, index) {\n    ngDevMode && assertEqual(typeof text === 'string', true, 'String expected here');\n    throw throwError(`Malformed style at location ${index} in string '` + text.substring(0, index) + '[>>' +\n        text.substring(index, index + 1) + '<<]' + text.slice(index + 1) +\n        `'. Expecting '${expecting}'.`);\n}\n\n/**\n * Update a style binding on an element with the provided value.\n *\n * If the style value is falsy then it will be removed from the element\n * (or assigned a different value depending if there are any styles placed\n * on the element with `styleMap` or any static styles that are\n * present from when the element was created with `styling`).\n *\n * Note that the styling element is updated as part of `stylingApply`.\n *\n * @param prop A valid CSS property.\n * @param value New value to write (`null` or an empty string to remove).\n * @param suffix Optional suffix. Used with scalar values to add unit such as `px`.\n *\n * Note that this will apply the provided style value to the host element if this function is called\n * within a host binding function.\n *\n * @codeGenApi\n */\nfunction ɵɵstyleProp(prop, value, suffix) {\n    checkStylingProperty(prop, value, suffix, false);\n    return ɵɵstyleProp;\n}\n/**\n * Update a class binding on an element with the provided value.\n *\n * This instruction is meant to handle the `[class.foo]=\"exp\"` case and,\n * therefore, the class binding itself must already be allocated using\n * `styling` within the creation block.\n *\n * @param prop A valid CSS class (only one).\n * @param value A true/false value which will turn the class on or off.\n *\n * Note that this will apply the provided class value to the host element if this function\n * is called within a host binding function.\n *\n * @codeGenApi\n */\nfunction ɵɵclassProp(className, value) {\n    checkStylingProperty(className, value, null, true);\n    return ɵɵclassProp;\n}\n/**\n * Update style bindings using an object literal on an element.\n *\n * This instruction is meant to apply styling via the `[style]=\"exp\"` template bindings.\n * When styles are applied to the element they will then be updated with respect to\n * any styles/classes set via `styleProp`. If any styles are set to falsy\n * then they will be removed from the element.\n *\n * Note that the styling instruction will not be applied until `stylingApply` is called.\n *\n * @param styles A key/value style map of the styles that will be applied to the given element.\n *        Any missing styles (that have already been applied to the element beforehand) will be\n *        removed (unset) from the element's styling.\n *\n * Note that this will apply the provided styleMap value to the host element if this function\n * is called within a host binding.\n *\n * @codeGenApi\n */\nfunction ɵɵstyleMap(styles) {\n    checkStylingMap(styleKeyValueArraySet, styleStringParser, styles, false);\n}\n/**\n * Parse text as style and add values to KeyValueArray.\n *\n * This code is pulled out to a separate function so that it can be tree shaken away if it is not\n * needed. It is only referenced from `ɵɵstyleMap`.\n *\n * @param keyValueArray KeyValueArray to add parsed values to.\n * @param text text to parse.\n */\nfunction styleStringParser(keyValueArray, text) {\n    for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i)) {\n        styleKeyValueArraySet(keyValueArray, getLastParsedKey(text), getLastParsedValue(text));\n    }\n}\n/**\n * Update class bindings using an object literal or class-string on an element.\n *\n * This instruction is meant to apply styling via the `[class]=\"exp\"` template bindings.\n * When classes are applied to the element they will then be updated with\n * respect to any styles/classes set via `classProp`. If any\n * classes are set to falsy then they will be removed from the element.\n *\n * Note that the styling instruction will not be applied until `stylingApply` is called.\n * Note that this will the provided classMap value to the host element if this function is called\n * within a host binding.\n *\n * @param classes A key/value map or string of CSS classes that will be added to the\n *        given element. Any missing classes (that have already been applied to the element\n *        beforehand) will be removed (unset) from the element's list of CSS classes.\n *\n * @codeGenApi\n */\nfunction ɵɵclassMap(classes) {\n    checkStylingMap(classKeyValueArraySet, classStringParser, classes, true);\n}\n/**\n * Parse text as class and add values to KeyValueArray.\n *\n * This code is pulled out to a separate function so that it can be tree shaken away if it is not\n * needed. It is only referenced from `ɵɵclassMap`.\n *\n * @param keyValueArray KeyValueArray to add parsed values to.\n * @param text text to parse.\n */\nfunction classStringParser(keyValueArray, text) {\n    for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {\n        keyValueArraySet(keyValueArray, getLastParsedKey(text), true);\n    }\n}\n/**\n * Common code between `ɵɵclassProp` and `ɵɵstyleProp`.\n *\n * @param prop property name.\n * @param value binding value.\n * @param suffix suffix for the property (e.g. `em` or `px`)\n * @param isClassBased `true` if `class` change (`false` if `style`)\n */\nfunction checkStylingProperty(prop, value, suffix, isClassBased) {\n    const lView = getLView();\n    const tView = getTView();\n    // Styling instructions use 2 slots per binding.\n    // 1. one for the value / TStylingKey\n    // 2. one for the intermittent-value / TStylingRange\n    const bindingIndex = incrementBindingIndex(2);\n    if (tView.firstUpdatePass) {\n        stylingFirstUpdatePass(tView, prop, bindingIndex, isClassBased);\n    }\n    if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {\n        const tNode = tView.data[getSelectedIndex()];\n        updateStyling(tView, tNode, lView, lView[RENDERER], prop, lView[bindingIndex + 1] = normalizeSuffix(value, suffix), isClassBased, bindingIndex);\n    }\n}\n/**\n * Common code between `ɵɵclassMap` and `ɵɵstyleMap`.\n *\n * @param keyValueArraySet (See `keyValueArraySet` in \"util/array_utils\") Gets passed in as a\n *        function so that `style` can be processed. This is done for tree shaking purposes.\n * @param stringParser Parser used to parse `value` if `string`. (Passed in as `style` and `class`\n *        have different parsers.)\n * @param value bound value from application\n * @param isClassBased `true` if `class` change (`false` if `style`)\n */\nfunction checkStylingMap(keyValueArraySet, stringParser, value, isClassBased) {\n    const tView = getTView();\n    const bindingIndex = incrementBindingIndex(2);\n    if (tView.firstUpdatePass) {\n        stylingFirstUpdatePass(tView, null, bindingIndex, isClassBased);\n    }\n    const lView = getLView();\n    if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {\n        // `getSelectedIndex()` should be here (rather than in instruction) so that it is guarded by the\n        // if so as not to read unnecessarily.\n        const tNode = tView.data[getSelectedIndex()];\n        if (hasStylingInputShadow(tNode, isClassBased) && !isInHostBindings(tView, bindingIndex)) {\n            if (ngDevMode) {\n                // verify that if we are shadowing then `TData` is appropriately marked so that we skip\n                // processing this binding in styling resolution.\n                const tStylingKey = tView.data[bindingIndex];\n                assertEqual(Array.isArray(tStylingKey) ? tStylingKey[1] : tStylingKey, false, 'Styling linked list shadow input should be marked as \\'false\\'');\n            }\n            // VE does not concatenate the static portion like we are doing here.\n            // Instead VE just ignores the static completely if dynamic binding is present.\n            // Because of locality we have already set the static portion because we don't know if there\n            // is a dynamic portion until later. If we would ignore the static portion it would look like\n            // the binding has removed it. This would confuse `[ngStyle]`/`[ngClass]` to do the wrong\n            // thing as it would think that the static portion was removed. For this reason we\n            // concatenate it so that `[ngStyle]`/`[ngClass]`  can continue to work on changed.\n            let staticPrefix = isClassBased ? tNode.classesWithoutHost : tNode.stylesWithoutHost;\n            ngDevMode && isClassBased === false && staticPrefix !== null &&\n                assertEqual(staticPrefix.endsWith(';'), true, 'Expecting static portion to end with \\';\\'');\n            if (staticPrefix !== null) {\n                // We want to make sure that falsy values of `value` become empty strings.\n                value = concatStringsWithSpace(staticPrefix, value ? value : '');\n            }\n            // Given `<div [style] my-dir>` such that `my-dir` has `@Input('style')`.\n            // This takes over the `[style]` binding. (Same for `[class]`)\n            setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased);\n        }\n        else {\n            updateStylingMap(tView, tNode, lView, lView[RENDERER], lView[bindingIndex + 1], lView[bindingIndex + 1] = toStylingKeyValueArray(keyValueArraySet, stringParser, value), isClassBased, bindingIndex);\n        }\n    }\n}\n/**\n * Determines when the binding is in `hostBindings` section\n *\n * @param tView Current `TView`\n * @param bindingIndex index of binding which we would like if it is in `hostBindings`\n */\nfunction isInHostBindings(tView, bindingIndex) {\n    // All host bindings are placed after the expando section.\n    return bindingIndex >= tView.expandoStartIndex;\n}\n/**\n * Collects the necessary information to insert the binding into a linked list of style bindings\n * using `insertTStylingBinding`.\n *\n * @param tView `TView` where the binding linked list will be stored.\n * @param tStylingKey Property/key of the binding.\n * @param bindingIndex Index of binding associated with the `prop`\n * @param isClassBased `true` if `class` change (`false` if `style`)\n */\nfunction stylingFirstUpdatePass(tView, tStylingKey, bindingIndex, isClassBased) {\n    ngDevMode && assertFirstUpdatePass(tView);\n    const tData = tView.data;\n    if (tData[bindingIndex + 1] === null) {\n        // The above check is necessary because we don't clear first update pass until first successful\n        // (no exception) template execution. This prevents the styling instruction from double adding\n        // itself to the list.\n        // `getSelectedIndex()` should be here (rather than in instruction) so that it is guarded by the\n        // if so as not to read unnecessarily.\n        const tNode = tData[getSelectedIndex()];\n        ngDevMode && assertDefined(tNode, 'TNode expected');\n        const isHostBindings = isInHostBindings(tView, bindingIndex);\n        if (hasStylingInputShadow(tNode, isClassBased) && tStylingKey === null && !isHostBindings) {\n            // `tStylingKey === null` implies that we are either `[style]` or `[class]` binding.\n            // If there is a directive which uses `@Input('style')` or `@Input('class')` than\n            // we need to neutralize this binding since that directive is shadowing it.\n            // We turn this into a noop by setting the key to `false`\n            tStylingKey = false;\n        }\n        tStylingKey = wrapInStaticStylingKey(tData, tNode, tStylingKey, isClassBased);\n        insertTStylingBinding(tData, tNode, tStylingKey, bindingIndex, isHostBindings, isClassBased);\n    }\n}\n/**\n * Adds static styling information to the binding if applicable.\n *\n * The linked list of styles not only stores the list and keys, but also stores static styling\n * information on some of the keys. This function determines if the key should contain the styling\n * information and computes it.\n *\n * See `TStylingStatic` for more details.\n *\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param stylingKey `TStylingKeyPrimitive` which may need to be wrapped into `TStylingKey`\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction wrapInStaticStylingKey(tData, tNode, stylingKey, isClassBased) {\n    const hostDirectiveDef = getCurrentDirectiveDef(tData);\n    let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;\n    if (hostDirectiveDef === null) {\n        // We are in template node.\n        // If template node already had styling instruction then it has already collected the static\n        // styling and there is no need to collect them again. We know that we are the first styling\n        // instruction because the `TNode.*Bindings` points to 0 (nothing has been inserted yet).\n        const isFirstStylingInstructionInTemplate = (isClassBased ? tNode.classBindings : tNode.styleBindings) === 0;\n        if (isFirstStylingInstructionInTemplate) {\n            // It would be nice to be able to get the statics from `mergeAttrs`, however, at this point\n            // they are already merged and it would not be possible to figure which property belongs where\n            // in the priority.\n            stylingKey = collectStylingFromDirectives(null, tData, tNode, stylingKey, isClassBased);\n            stylingKey = collectStylingFromTAttrs(stylingKey, tNode.attrs, isClassBased);\n            // We know that if we have styling binding in template we can't have residual.\n            residual = null;\n        }\n    }\n    else {\n        // We are in host binding node and there was no binding instruction in template node.\n        // This means that we need to compute the residual.\n        const directiveStylingLast = tNode.directiveStylingLast;\n        const isFirstStylingInstructionInHostBinding = directiveStylingLast === -1 || tData[directiveStylingLast] !== hostDirectiveDef;\n        if (isFirstStylingInstructionInHostBinding) {\n            stylingKey =\n                collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased);\n            if (residual === null) {\n                // - If `null` than either:\n                //    - Template styling instruction already ran and it has consumed the static\n                //      styling into its `TStylingKey` and so there is no need to update residual. Instead\n                //      we need to update the `TStylingKey` associated with the first template node\n                //      instruction. OR\n                //    - Some other styling instruction ran and determined that there are no residuals\n                let templateStylingKey = getTemplateHeadTStylingKey(tData, tNode, isClassBased);\n                if (templateStylingKey !== undefined && Array.isArray(templateStylingKey)) {\n                    // Only recompute if `templateStylingKey` had static values. (If no static value found\n                    // then there is nothing to do since this operation can only produce less static keys, not\n                    // more.)\n                    templateStylingKey = collectStylingFromDirectives(null, tData, tNode, templateStylingKey[1] /* unwrap previous statics */, isClassBased);\n                    templateStylingKey =\n                        collectStylingFromTAttrs(templateStylingKey, tNode.attrs, isClassBased);\n                    setTemplateHeadTStylingKey(tData, tNode, isClassBased, templateStylingKey);\n                }\n            }\n            else {\n                // We only need to recompute residual if it is not `null`.\n                // - If existing residual (implies there was no template styling). This means that some of\n                //   the statics may have moved from the residual to the `stylingKey` and so we have to\n                //   recompute.\n                // - If `undefined` this is the first time we are running.\n                residual = collectResidual(tData, tNode, isClassBased);\n            }\n        }\n    }\n    if (residual !== undefined) {\n        isClassBased ? (tNode.residualClasses = residual) : (tNode.residualStyles = residual);\n    }\n    return stylingKey;\n}\n/**\n * Retrieve the `TStylingKey` for the template styling instruction.\n *\n * This is needed since `hostBinding` styling instructions are inserted after the template\n * instruction. While the template instruction needs to update the residual in `TNode` the\n * `hostBinding` instructions need to update the `TStylingKey` of the template instruction because\n * the template instruction is downstream from the `hostBindings` instructions.\n *\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @return `TStylingKey` if found or `undefined` if not found.\n */\nfunction getTemplateHeadTStylingKey(tData, tNode, isClassBased) {\n    const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;\n    if (getTStylingRangeNext(bindings) === 0) {\n        // There does not seem to be a styling instruction in the `template`.\n        return undefined;\n    }\n    return tData[getTStylingRangePrev(bindings)];\n}\n/**\n * Update the `TStylingKey` of the first template instruction in `TNode`.\n *\n * Logically `hostBindings` styling instructions are of lower priority than that of the template.\n * However, they execute after the template styling instructions. This means that they get inserted\n * in front of the template styling instructions.\n *\n * If we have a template styling instruction and a new `hostBindings` styling instruction is\n * executed it means that it may need to steal static fields from the template instruction. This\n * method allows us to update the first template instruction `TStylingKey` with a new value.\n *\n * Assume:\n * ```\n * <div my-dir style=\"color: red\" [style.color]=\"tmplExp\"></div>\n *\n * @Directive({\n *   host: {\n *     'style': 'width: 100px',\n *     '[style.color]': 'dirExp',\n *   }\n * })\n * class MyDir {}\n * ```\n *\n * when `[style.color]=\"tmplExp\"` executes it creates this data structure.\n * ```\n *  ['', 'color', 'color', 'red', 'width', '100px'],\n * ```\n *\n * The reason for this is that the template instruction does not know if there are styling\n * instructions and must assume that there are none and must collect all of the static styling.\n * (both\n * `color' and 'width`)\n *\n * When `'[style.color]': 'dirExp',` executes we need to insert a new data into the linked list.\n * ```\n *  ['', 'color', 'width', '100px'],  // newly inserted\n *  ['', 'color', 'color', 'red', 'width', '100px'], // this is wrong\n * ```\n *\n * Notice that the template statics is now wrong as it incorrectly contains `width` so we need to\n * update it like so:\n * ```\n *  ['', 'color', 'width', '100px'],\n *  ['', 'color', 'color', 'red'],    // UPDATE\n * ```\n *\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @param tStylingKey New `TStylingKey` which is replacing the old one.\n */\nfunction setTemplateHeadTStylingKey(tData, tNode, isClassBased, tStylingKey) {\n    const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;\n    ngDevMode &&\n        assertNotEqual(getTStylingRangeNext(bindings), 0, 'Expecting to have at least one template styling binding.');\n    tData[getTStylingRangePrev(bindings)] = tStylingKey;\n}\n/**\n * Collect all static values after the current `TNode.directiveStylingLast` index.\n *\n * Collect the remaining styling information which has not yet been collected by an existing\n * styling instruction.\n *\n * @param tData `TData` where the `DirectiveDefs` are stored.\n * @param tNode `TNode` which contains the directive range.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction collectResidual(tData, tNode, isClassBased) {\n    let residual = undefined;\n    const directiveEnd = tNode.directiveEnd;\n    ngDevMode &&\n        assertNotEqual(tNode.directiveStylingLast, -1, 'By the time this function gets called at least one hostBindings-node styling instruction must have executed.');\n    // We add `1 + tNode.directiveStart` because we need to skip the current directive (as we are\n    // collecting things after the last `hostBindings` directive which had a styling instruction.)\n    for (let i = 1 + tNode.directiveStylingLast; i < directiveEnd; i++) {\n        const attrs = tData[i].hostAttrs;\n        residual = collectStylingFromTAttrs(residual, attrs, isClassBased);\n    }\n    return collectStylingFromTAttrs(residual, tNode.attrs, isClassBased);\n}\n/**\n * Collect the static styling information with lower priority than `hostDirectiveDef`.\n *\n * (This is opposite of residual styling.)\n *\n * @param hostDirectiveDef `DirectiveDef` for which we want to collect lower priority static\n *        styling. (Or `null` if template styling)\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param stylingKey Existing `TStylingKey` to update or wrap.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased) {\n    // We need to loop because there can be directives which have `hostAttrs` but don't have\n    // `hostBindings` so this loop catches up to the current directive..\n    let currentDirective = null;\n    const directiveEnd = tNode.directiveEnd;\n    let directiveStylingLast = tNode.directiveStylingLast;\n    if (directiveStylingLast === -1) {\n        directiveStylingLast = tNode.directiveStart;\n    }\n    else {\n        directiveStylingLast++;\n    }\n    while (directiveStylingLast < directiveEnd) {\n        currentDirective = tData[directiveStylingLast];\n        ngDevMode && assertDefined(currentDirective, 'expected to be defined');\n        stylingKey = collectStylingFromTAttrs(stylingKey, currentDirective.hostAttrs, isClassBased);\n        if (currentDirective === hostDirectiveDef)\n            break;\n        directiveStylingLast++;\n    }\n    if (hostDirectiveDef !== null) {\n        // we only advance the styling cursor if we are collecting data from host bindings.\n        // Template executes before host bindings and so if we would update the index,\n        // host bindings would not get their statics.\n        tNode.directiveStylingLast = directiveStylingLast;\n    }\n    return stylingKey;\n}\n/**\n * Convert `TAttrs` into `TStylingStatic`.\n *\n * @param stylingKey existing `TStylingKey` to update or wrap.\n * @param attrs `TAttributes` to process.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction collectStylingFromTAttrs(stylingKey, attrs, isClassBased) {\n    const desiredMarker = isClassBased ? 1 /* AttributeMarker.Classes */ : 2 /* AttributeMarker.Styles */;\n    let currentMarker = -1 /* AttributeMarker.ImplicitAttributes */;\n    if (attrs !== null) {\n        for (let i = 0; i < attrs.length; i++) {\n            const item = attrs[i];\n            if (typeof item === 'number') {\n                currentMarker = item;\n            }\n            else {\n                if (currentMarker === desiredMarker) {\n                    if (!Array.isArray(stylingKey)) {\n                        stylingKey = stylingKey === undefined ? [] : ['', stylingKey];\n                    }\n                    keyValueArraySet(stylingKey, item, isClassBased ? true : attrs[++i]);\n                }\n            }\n        }\n    }\n    return stylingKey === undefined ? null : stylingKey;\n}\n/**\n * Convert user input to `KeyValueArray`.\n *\n * This function takes user input which could be `string`, Object literal, or iterable and converts\n * it into a consistent representation. The output of this is `KeyValueArray` (which is an array\n * where\n * even indexes contain keys and odd indexes contain values for those keys).\n *\n * The advantage of converting to `KeyValueArray` is that we can perform diff in an input\n * independent\n * way.\n * (ie we can compare `foo bar` to `['bar', 'baz'] and determine a set of changes which need to be\n * applied)\n *\n * The fact that `KeyValueArray` is sorted is very important because it allows us to compute the\n * difference in linear fashion without the need to allocate any additional data.\n *\n * For example if we kept this as a `Map` we would have to iterate over previous `Map` to determine\n * which values need to be deleted, over the new `Map` to determine additions, and we would have to\n * keep additional `Map` to keep track of duplicates or items which have not yet been visited.\n *\n * @param keyValueArraySet (See `keyValueArraySet` in \"util/array_utils\") Gets passed in as a\n *        function so that `style` can be processed. This is done\n *        for tree shaking purposes.\n * @param stringParser The parser is passed in so that it will be tree shakable. See\n *        `styleStringParser` and `classStringParser`\n * @param value The value to parse/convert to `KeyValueArray`\n */\nfunction toStylingKeyValueArray(keyValueArraySet, stringParser, value) {\n    if (value == null /*|| value === undefined */ || value === '')\n        return EMPTY_ARRAY;\n    const styleKeyValueArray = [];\n    const unwrappedValue = unwrapSafeValue(value);\n    if (Array.isArray(unwrappedValue)) {\n        for (let i = 0; i < unwrappedValue.length; i++) {\n            keyValueArraySet(styleKeyValueArray, unwrappedValue[i], true);\n        }\n    }\n    else if (typeof unwrappedValue === 'object') {\n        for (const key in unwrappedValue) {\n            if (unwrappedValue.hasOwnProperty(key)) {\n                keyValueArraySet(styleKeyValueArray, key, unwrappedValue[key]);\n            }\n        }\n    }\n    else if (typeof unwrappedValue === 'string') {\n        stringParser(styleKeyValueArray, unwrappedValue);\n    }\n    else {\n        ngDevMode &&\n            throwError('Unsupported styling type ' + typeof unwrappedValue + ': ' + unwrappedValue);\n    }\n    return styleKeyValueArray;\n}\n/**\n * Set a `value` for a `key`.\n *\n * See: `keyValueArraySet` for details\n *\n * @param keyValueArray KeyValueArray to add to.\n * @param key Style key to add.\n * @param value The value to set.\n */\nfunction styleKeyValueArraySet(keyValueArray, key, value) {\n    keyValueArraySet(keyValueArray, key, unwrapSafeValue(value));\n}\n/**\n * Class-binding-specific function for setting the `value` for a `key`.\n *\n * See: `keyValueArraySet` for details\n *\n * @param keyValueArray KeyValueArray to add to.\n * @param key Style key to add.\n * @param value The value to set.\n */\nfunction classKeyValueArraySet(keyValueArray, key, value) {\n    // We use `classList.add` to eventually add the CSS classes to the DOM node. Any value passed into\n    // `add` is stringified and added to the `class` attribute, e.g. even null, undefined or numbers\n    // will be added. Stringify the key here so that our internal data structure matches the value in\n    // the DOM. The only exceptions are empty strings and strings that contain spaces for which\n    // the browser throws an error. We ignore such values, because the error is somewhat cryptic.\n    const stringKey = String(key);\n    if (stringKey !== '' && !stringKey.includes(' ')) {\n        keyValueArraySet(keyValueArray, stringKey, value);\n    }\n}\n/**\n * Update map based styling.\n *\n * Map based styling could be anything which contains more than one binding. For example `string`,\n * or object literal. Dealing with all of these types would complicate the logic so\n * instead this function expects that the complex input is first converted into normalized\n * `KeyValueArray`. The advantage of normalization is that we get the values sorted, which makes it\n * very cheap to compute deltas between the previous and current value.\n *\n * @param tView Associated `TView.data` contains the linked list of binding priorities.\n * @param tNode `TNode` where the binding is located.\n * @param lView `LView` contains the values associated with other styling binding at this `TNode`.\n * @param renderer Renderer to use if any updates.\n * @param oldKeyValueArray Previous value represented as `KeyValueArray`\n * @param newKeyValueArray Current value represented as `KeyValueArray`\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @param bindingIndex Binding index of the binding.\n */\nfunction updateStylingMap(tView, tNode, lView, renderer, oldKeyValueArray, newKeyValueArray, isClassBased, bindingIndex) {\n    if (oldKeyValueArray === NO_CHANGE) {\n        // On first execution the oldKeyValueArray is NO_CHANGE => treat it as empty KeyValueArray.\n        oldKeyValueArray = EMPTY_ARRAY;\n    }\n    let oldIndex = 0;\n    let newIndex = 0;\n    let oldKey = 0 < oldKeyValueArray.length ? oldKeyValueArray[0] : null;\n    let newKey = 0 < newKeyValueArray.length ? newKeyValueArray[0] : null;\n    while (oldKey !== null || newKey !== null) {\n        ngDevMode && assertLessThan(oldIndex, 999, 'Are we stuck in infinite loop?');\n        ngDevMode && assertLessThan(newIndex, 999, 'Are we stuck in infinite loop?');\n        const oldValue = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex + 1] : undefined;\n        const newValue = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex + 1] : undefined;\n        let setKey = null;\n        let setValue = undefined;\n        if (oldKey === newKey) {\n            // UPDATE: Keys are equal => new value is overwriting old value.\n            oldIndex += 2;\n            newIndex += 2;\n            if (oldValue !== newValue) {\n                setKey = newKey;\n                setValue = newValue;\n            }\n        }\n        else if (newKey === null || oldKey !== null && oldKey < newKey) {\n            // DELETE: oldKey key is missing or we did not find the oldKey in the newValue\n            // (because the keyValueArray is sorted and `newKey` is found later alphabetically).\n            // `\"background\" < \"color\"` so we need to delete `\"background\"` because it is not found in the\n            // new array.\n            oldIndex += 2;\n            setKey = oldKey;\n        }\n        else {\n            // CREATE: newKey's is earlier alphabetically than oldKey's (or no oldKey) => we have new key.\n            // `\"color\" > \"background\"` so we need to add `color` because it is in new array but not in\n            // old array.\n            ngDevMode && assertDefined(newKey, 'Expecting to have a valid key');\n            newIndex += 2;\n            setKey = newKey;\n            setValue = newValue;\n        }\n        if (setKey !== null) {\n            updateStyling(tView, tNode, lView, renderer, setKey, setValue, isClassBased, bindingIndex);\n        }\n        oldKey = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex] : null;\n        newKey = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex] : null;\n    }\n}\n/**\n * Update a simple (property name) styling.\n *\n * This function takes `prop` and updates the DOM to that value. The function takes the binding\n * value as well as binding priority into consideration to determine which value should be written\n * to DOM. (For example it may be determined that there is a higher priority overwrite which blocks\n * the DOM write, or if the value goes to `undefined` a lower priority overwrite may be consulted.)\n *\n * @param tView Associated `TView.data` contains the linked list of binding priorities.\n * @param tNode `TNode` where the binding is located.\n * @param lView `LView` contains the values associated with other styling binding at this `TNode`.\n * @param renderer Renderer to use if any updates.\n * @param prop Either style property name or a class name.\n * @param value Either style value for `prop` or `true`/`false` if `prop` is class.\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @param bindingIndex Binding index of the binding.\n */\nfunction updateStyling(tView, tNode, lView, renderer, prop, value, isClassBased, bindingIndex) {\n    if (!(tNode.type & 3 /* TNodeType.AnyRNode */)) {\n        // It is possible to have styling on non-elements (such as ng-container).\n        // This is rare, but it does happen. In such a case, just ignore the binding.\n        return;\n    }\n    const tData = tView.data;\n    const tRange = tData[bindingIndex + 1];\n    const higherPriorityValue = getTStylingRangeNextDuplicate(tRange) ?\n        findStylingValue(tData, tNode, lView, prop, getTStylingRangeNext(tRange), isClassBased) :\n        undefined;\n    if (!isStylingValuePresent(higherPriorityValue)) {\n        // We don't have a next duplicate, or we did not find a duplicate value.\n        if (!isStylingValuePresent(value)) {\n            // We should delete current value or restore to lower priority value.\n            if (getTStylingRangePrevDuplicate(tRange)) {\n                // We have a possible prev duplicate, let's retrieve it.\n                value = findStylingValue(tData, null, lView, prop, bindingIndex, isClassBased);\n            }\n        }\n        const rNode = getNativeByIndex(getSelectedIndex(), lView);\n        applyStyling(renderer, isClassBased, rNode, prop, value);\n    }\n}\n/**\n * Search for styling value with higher priority which is overwriting current value, or a\n * value of lower priority to which we should fall back if the value is `undefined`.\n *\n * When value is being applied at a location, related values need to be consulted.\n * - If there is a higher priority binding, we should be using that one instead.\n *   For example `<div  [style]=\"{color:exp1}\" [style.color]=\"exp2\">` change to `exp1`\n *   requires that we check `exp2` to see if it is set to value other than `undefined`.\n * - If there is a lower priority binding and we are changing to `undefined`\n *   For example `<div  [style]=\"{color:exp1}\" [style.color]=\"exp2\">` change to `exp2` to\n *   `undefined` requires that we check `exp1` (and static values) and use that as new value.\n *\n * NOTE: The styling stores two values.\n * 1. The raw value which came from the application is stored at `index + 0` location. (This value\n *    is used for dirty checking).\n * 2. The normalized value is stored at `index + 1`.\n *\n * @param tData `TData` used for traversing the priority.\n * @param tNode `TNode` to use for resolving static styling. Also controls search direction.\n *   - `TNode` search next and quit as soon as `isStylingValuePresent(value)` is true.\n *      If no value found consult `tNode.residualStyle`/`tNode.residualClass` for default value.\n *   - `null` search prev and go all the way to end. Return last value where\n *     `isStylingValuePresent(value)` is true.\n * @param lView `LView` used for retrieving the actual values.\n * @param prop Property which we are interested in.\n * @param index Starting index in the linked list of styling bindings where the search should start.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction findStylingValue(tData, tNode, lView, prop, index, isClassBased) {\n    // `TNode` to use for resolving static styling. Also controls search direction.\n    //   - `TNode` search next and quit as soon as `isStylingValuePresent(value)` is true.\n    //      If no value found consult `tNode.residualStyle`/`tNode.residualClass` for default value.\n    //   - `null` search prev and go all the way to end. Return last value where\n    //     `isStylingValuePresent(value)` is true.\n    const isPrevDirection = tNode === null;\n    let value = undefined;\n    while (index > 0) {\n        const rawKey = tData[index];\n        const containsStatics = Array.isArray(rawKey);\n        // Unwrap the key if we contain static values.\n        const key = containsStatics ? rawKey[1] : rawKey;\n        const isStylingMap = key === null;\n        let valueAtLViewIndex = lView[index + 1];\n        if (valueAtLViewIndex === NO_CHANGE) {\n            // In firstUpdatePass the styling instructions create a linked list of styling.\n            // On subsequent passes it is possible for a styling instruction to try to read a binding\n            // which\n            // has not yet executed. In that case we will find `NO_CHANGE` and we should assume that\n            // we have `undefined` (or empty array in case of styling-map instruction) instead. This\n            // allows the resolution to apply the value (which may later be overwritten when the\n            // binding actually executes.)\n            valueAtLViewIndex = isStylingMap ? EMPTY_ARRAY : undefined;\n        }\n        let currentValue = isStylingMap ? keyValueArrayGet(valueAtLViewIndex, prop) :\n            (key === prop ? valueAtLViewIndex : undefined);\n        if (containsStatics && !isStylingValuePresent(currentValue)) {\n            currentValue = keyValueArrayGet(rawKey, prop);\n        }\n        if (isStylingValuePresent(currentValue)) {\n            value = currentValue;\n            if (isPrevDirection) {\n                return value;\n            }\n        }\n        const tRange = tData[index + 1];\n        index = isPrevDirection ? getTStylingRangePrev(tRange) : getTStylingRangeNext(tRange);\n    }\n    if (tNode !== null) {\n        // in case where we are going in next direction AND we did not find anything, we need to\n        // consult residual styling\n        let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;\n        if (residual != null /** OR residual !=== undefined */) {\n            value = keyValueArrayGet(residual, prop);\n        }\n    }\n    return value;\n}\n/**\n * Determines if the binding value should be used (or if the value is 'undefined' and hence priority\n * resolution should be used.)\n *\n * @param value Binding style value.\n */\nfunction isStylingValuePresent(value) {\n    // Currently only `undefined` value is considered non-binding. That is `undefined` says I don't\n    // have an opinion as to what this binding should be and you should consult other bindings by\n    // priority to determine the valid value.\n    // This is extracted into a single function so that we have a single place to control this.\n    return value !== undefined;\n}\n/**\n * Normalizes and/or adds a suffix to the value.\n *\n * If value is `null`/`undefined` no suffix is added\n * @param value\n * @param suffix\n */\nfunction normalizeSuffix(value, suffix) {\n    if (value == null || value === '') {\n        // do nothing\n        // Do not add the suffix if the value is going to be empty.\n        // As it produce invalid CSS, which the browsers will automatically omit but Domino will not.\n        // Example: `\"left\": \"px;\"` instead of `\"left\": \"\"`.\n    }\n    else if (typeof suffix === 'string') {\n        value = value + suffix;\n    }\n    else if (typeof value === 'object') {\n        value = stringify(unwrapSafeValue(value));\n    }\n    return value;\n}\n/**\n * Tests if the `TNode` has input shadow.\n *\n * An input shadow is when a directive steals (shadows) the input by using `@Input('style')` or\n * `@Input('class')` as input.\n *\n * @param tNode `TNode` which we would like to see if it has shadow.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction hasStylingInputShadow(tNode, isClassBased) {\n    return (tNode.flags & (isClassBased ? 8 /* TNodeFlags.hasClassInput */ : 16 /* TNodeFlags.hasStyleInput */)) !== 0;\n}\n\n/**\n * Create static text node\n *\n * @param index Index of the node in the data array\n * @param value Static string value to write.\n *\n * @codeGenApi\n */\nfunction ɵɵtext(index, value = '') {\n    const lView = getLView();\n    const tView = getTView();\n    const adjustedIndex = index + HEADER_OFFSET;\n    ngDevMode &&\n        assertEqual(getBindingIndex(), tView.bindingStartIndex, 'text nodes should be created before any bindings');\n    ngDevMode && assertIndexInRange(lView, adjustedIndex);\n    const tNode = tView.firstCreatePass ?\n        getOrCreateTNode(tView, adjustedIndex, 1 /* TNodeType.Text */, value, null) :\n        tView.data[adjustedIndex];\n    const textNative = _locateOrCreateTextNode(tView, lView, tNode, value, index);\n    lView[adjustedIndex] = textNative;\n    if (wasLastNodeCreated()) {\n        appendChild(tView, lView, textNative, tNode);\n    }\n    // Text nodes are self closing.\n    setCurrentTNode(tNode, false);\n}\nlet _locateOrCreateTextNode = (tView, lView, tNode, value, index) => {\n    lastNodeWasCreated(true);\n    return createTextNode(lView[RENDERER], value);\n};\n/**\n * Enables hydration code path (to lookup existing elements in DOM)\n * in addition to the regular creation mode of text nodes.\n */\nfunction locateOrCreateTextNodeImpl(tView, lView, tNode, value, index) {\n    const hydrationInfo = lView[HYDRATION];\n    const isNodeCreationMode = !hydrationInfo || isInSkipHydrationBlock$1() || isDisconnectedNode(hydrationInfo, index);\n    lastNodeWasCreated(isNodeCreationMode);\n    // Regular creation mode.\n    if (isNodeCreationMode) {\n        return createTextNode(lView[RENDERER], value);\n    }\n    // Hydration mode, looking up an existing element in DOM.\n    const textNative = locateNextRNode(hydrationInfo, tView, lView, tNode);\n    ngDevMode && validateMatchingNode(textNative, Node.TEXT_NODE, null, lView, tNode);\n    ngDevMode && markRNodeAsClaimedByHydration(textNative);\n    return textNative;\n}\nfunction enableLocateOrCreateTextNodeImpl() {\n    _locateOrCreateTextNode = locateOrCreateTextNodeImpl;\n}\n\n/**\n *\n * Update text content with a lone bound value\n *\n * Used when a text node has 1 interpolated value in it, an no additional text\n * surrounds that interpolated value:\n *\n * ```html\n * <div>{{v0}}</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate(v0);\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction ɵɵtextInterpolate(v0) {\n    ɵɵtextInterpolate1('', v0, '');\n    return ɵɵtextInterpolate;\n}\n/**\n *\n * Update text content with single bound value surrounded by other text.\n *\n * Used when a text node has 1 interpolated value in it:\n *\n * ```html\n * <div>prefix{{v0}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate1('prefix', v0, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction ɵɵtextInterpolate1(prefix, v0, suffix) {\n    const lView = getLView();\n    const interpolated = interpolation1(lView, prefix, v0, suffix);\n    if (interpolated !== NO_CHANGE) {\n        textBindingInternal(lView, getSelectedIndex(), interpolated);\n    }\n    return ɵɵtextInterpolate1;\n}\n/**\n *\n * Update text content with 2 bound values surrounded by other text.\n *\n * Used when a text node has 2 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate2('prefix', v0, '-', v1, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction ɵɵtextInterpolate2(prefix, v0, i0, v1, suffix) {\n    const lView = getLView();\n    const interpolated = interpolation2(lView, prefix, v0, i0, v1, suffix);\n    if (interpolated !== NO_CHANGE) {\n        textBindingInternal(lView, getSelectedIndex(), interpolated);\n    }\n    return ɵɵtextInterpolate2;\n}\n/**\n *\n * Update text content with 3 bound values surrounded by other text.\n *\n * Used when a text node has 3 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate3(\n * 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction ɵɵtextInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {\n    const lView = getLView();\n    const interpolated = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n    if (interpolated !== NO_CHANGE) {\n        textBindingInternal(lView, getSelectedIndex(), interpolated);\n    }\n    return ɵɵtextInterpolate3;\n}\n/**\n *\n * Update text content with 4 bound values surrounded by other text.\n *\n * Used when a text node has 4 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate4(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see ɵɵtextInterpolateV\n * @codeGenApi\n */\nfunction ɵɵtextInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {\n    const lView = getLView();\n    const interpolated = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n    if (interpolated !== NO_CHANGE) {\n        textBindingInternal(lView, getSelectedIndex(), interpolated);\n    }\n    return ɵɵtextInterpolate4;\n}\n/**\n *\n * Update text content with 5 bound values surrounded by other text.\n *\n * Used when a text node has 5 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate5(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction ɵɵtextInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {\n    const lView = getLView();\n    const interpolated = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n    if (interpolated !== NO_CHANGE) {\n        textBindingInternal(lView, getSelectedIndex(), interpolated);\n    }\n    return ɵɵtextInterpolate5;\n}\n/**\n *\n * Update text content with 6 bound values surrounded by other text.\n *\n * Used when a text node has 6 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate6(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change. @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction ɵɵtextInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {\n    const lView = getLView();\n    const interpolated = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n    if (interpolated !== NO_CHANGE) {\n        textBindingInternal(lView, getSelectedIndex(), interpolated);\n    }\n    return ɵɵtextInterpolate6;\n}\n/**\n *\n * Update text content with 7 bound values surrounded by other text.\n *\n * Used when a text node has 7 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate7(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction ɵɵtextInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {\n    const lView = getLView();\n    const interpolated = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n    if (interpolated !== NO_CHANGE) {\n        textBindingInternal(lView, getSelectedIndex(), interpolated);\n    }\n    return ɵɵtextInterpolate7;\n}\n/**\n *\n * Update text content with 8 bound values surrounded by other text.\n *\n * Used when a text node has 8 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate8(\n *  'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction ɵɵtextInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {\n    const lView = getLView();\n    const interpolated = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n    if (interpolated !== NO_CHANGE) {\n        textBindingInternal(lView, getSelectedIndex(), interpolated);\n    }\n    return ɵɵtextInterpolate8;\n}\n/**\n * Update text content with 9 or more bound values other surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolateV(\n *  ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n *\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵtextInterpolateV(values) {\n    const lView = getLView();\n    const interpolated = interpolationV(lView, values);\n    if (interpolated !== NO_CHANGE) {\n        textBindingInternal(lView, getSelectedIndex(), interpolated);\n    }\n    return ɵɵtextInterpolateV;\n}\n\n/**\n *\n * Update an interpolated class on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate1('prefix', v0, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵclassMapInterpolate1(prefix, v0, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate2('prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵclassMapInterpolate2(prefix, v0, i0, v1, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate3(\n * 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵclassMapInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate4(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵclassMapInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate5(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵclassMapInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate6(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵclassMapInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate7(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵclassMapInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate8(\n *  'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵclassMapInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n * Update an interpolated class on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolateV(\n *  ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @codeGenApi\n */\nfunction ɵɵclassMapInterpolateV(values) {\n    const lView = getLView();\n    const interpolatedValue = interpolationV(lView, values);\n    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated style on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div style=\"key: {{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate1('key: ', v0, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵstyleMapInterpolate1(prefix, v0, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n    ɵɵstyleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate2('key: ', v0, '; key1: ', v1, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵstyleMapInterpolate2(prefix, v0, i0, v1, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n    ɵɵstyleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key2: {{v1}}; key2: {{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate3(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵstyleMapInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n    ɵɵstyleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate4(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵstyleMapInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n    ɵɵstyleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate5(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵstyleMapInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n    ɵɵstyleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}};\n *             key5: {{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate6(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵstyleMapInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n    ɵɵstyleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *             key6: {{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate7(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    '; key6: ', v6, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵstyleMapInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n    ɵɵstyleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *             key6: {{v6}}; key7: {{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate8(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    '; key6: ', v6, '; key7: ', v7, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵstyleMapInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n    ɵɵstyleMap(interpolatedValue);\n}\n/**\n * Update an interpolated style on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  class=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *         key6: {{v6}}; key7: {{v7}}; key8: {{v8}}; key9: {{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolateV(\n *    ['key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *     '; key6: ', v6, '; key7: ', v7, '; key8: ', v8, '; key9: ', v9, 'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '; key2: ', value1, '; key2: ', value2, ..., value99, 'suffix']`)\n * @codeGenApi\n */\nfunction ɵɵstyleMapInterpolateV(values) {\n    const lView = getLView();\n    const interpolatedValue = interpolationV(lView, values);\n    ɵɵstyleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style property on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate1(0, 'prefix', v0, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵstylePropInterpolate1(prop, prefix, v0, suffix, valueSuffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n    return ɵɵstylePropInterpolate1;\n}\n/**\n *\n * Update an interpolated style property on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate2(0, 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵstylePropInterpolate2(prop, prefix, v0, i0, v1, suffix, valueSuffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n    return ɵɵstylePropInterpolate2;\n}\n/**\n *\n * Update an interpolated style property on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate3(0, 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵstylePropInterpolate3(prop, prefix, v0, i0, v1, i1, v2, suffix, valueSuffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n    return ɵɵstylePropInterpolate3;\n}\n/**\n *\n * Update an interpolated style property on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate4(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵstylePropInterpolate4(prop, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, valueSuffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n    return ɵɵstylePropInterpolate4;\n}\n/**\n *\n * Update an interpolated style property on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate5(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵstylePropInterpolate5(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, valueSuffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n    return ɵɵstylePropInterpolate5;\n}\n/**\n *\n * Update an interpolated style property on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate6(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵstylePropInterpolate6(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, valueSuffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n    return ɵɵstylePropInterpolate6;\n}\n/**\n *\n * Update an interpolated style property on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate7(\n *    0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵstylePropInterpolate7(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, valueSuffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n    return ɵɵstylePropInterpolate7;\n}\n/**\n *\n * Update an interpolated style property on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate8(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6,\n * '-', v7, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵstylePropInterpolate8(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, valueSuffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n    return ɵɵstylePropInterpolate8;\n}\n/**\n * Update an interpolated style property on an element with 9 or more bound values surrounded by\n * text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\">\n * </div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolateV(\n *  0, ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`..\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵstylePropInterpolateV(prop, values, valueSuffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolationV(lView, values);\n    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n    return ɵɵstylePropInterpolateV;\n}\n\n/**\n * Update a property on a host element. Only applies to native node properties, not inputs.\n *\n * Operates on the element selected by index via the {@link select} instruction.\n *\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n * @returns This function returns itself so that it may be chained\n * (e.g. `property('name', ctx.name)('title', ctx.title)`)\n *\n * @codeGenApi\n */\nfunction ɵɵhostProperty(propName, value, sanitizer) {\n    const lView = getLView();\n    const bindingIndex = nextBindingIndex();\n    if (bindingUpdated(lView, bindingIndex, value)) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, true);\n        ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);\n    }\n    return ɵɵhostProperty;\n}\n/**\n * Updates a synthetic host binding (e.g. `[@foo]`) on a component or directive.\n *\n * This instruction is for compatibility purposes and is designed to ensure that a\n * synthetic host binding (e.g. `@HostBinding('@foo')`) properly gets rendered in\n * the component's renderer. Normally all host bindings are evaluated with the parent\n * component's renderer, but, in the case of animation @triggers, they need to be\n * evaluated with the sub component's renderer (because that's where the animation\n * triggers are defined).\n *\n * Do not use this instruction as a replacement for `elementProperty`. This instruction\n * only exists to ensure compatibility with the ViewEngine's host binding behavior.\n *\n * @param index The index of the element to update in the data array\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n *\n * @codeGenApi\n */\nfunction ɵɵsyntheticHostProperty(propName, value, sanitizer) {\n    const lView = getLView();\n    const bindingIndex = nextBindingIndex();\n    if (bindingUpdated(lView, bindingIndex, value)) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        const currentDef = getCurrentDirectiveDef(tView.data);\n        const renderer = loadComponentRenderer(currentDef, tNode, lView);\n        elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, true);\n        ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);\n    }\n    return ɵɵsyntheticHostProperty;\n}\n\n/**\n * NOTE: changes to the `ngI18nClosureMode` name must be synced with `compiler-cli/src/tooling.ts`.\n */\nif (typeof ngI18nClosureMode === 'undefined') {\n    // These property accesses can be ignored because ngI18nClosureMode will be set to false\n    // when optimizing code and the whole if statement will be dropped.\n    // Make sure to refer to ngI18nClosureMode as ['ngI18nClosureMode'] for closure.\n    // NOTE: we need to have it in IIFE so that the tree-shaker is happy.\n    (function () {\n        // tslint:disable-next-line:no-toplevel-property-access\n        _global['ngI18nClosureMode'] =\n            // TODO(FW-1250): validate that this actually, you know, works.\n            // tslint:disable-next-line:no-toplevel-property-access\n            typeof goog !== 'undefined' && typeof goog.getMsg === 'function';\n    })();\n}\n\n// THIS CODE IS GENERATED - DO NOT MODIFY.\nconst u = undefined;\nfunction plural(val) {\n    const n = val, i = Math.floor(Math.abs(val)), v = val.toString().replace(/^[^.]*\\.?/, '').length;\n    if (i === 1 && v === 0)\n        return 1;\n    return 5;\n}\nvar localeEn = [\"en\", [[\"a\", \"p\"], [\"AM\", \"PM\"], u], [[\"AM\", \"PM\"], u, u], [[\"S\", \"M\", \"T\", \"W\", \"T\", \"F\", \"S\"], [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"], [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"], [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\"]], u, [[\"J\", \"F\", \"M\", \"A\", \"M\", \"J\", \"J\", \"A\", \"S\", \"O\", \"N\", \"D\"], [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"], [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"]], u, [[\"B\", \"A\"], [\"BC\", \"AD\"], [\"Before Christ\", \"Anno Domini\"]], 0, [6, 0], [\"M/d/yy\", \"MMM d, y\", \"MMMM d, y\", \"EEEE, MMMM d, y\"], [\"h:mm a\", \"h:mm:ss a\", \"h:mm:ss a z\", \"h:mm:ss a zzzz\"], [\"{1}, {0}\", u, \"{1} 'at' {0}\", u], [\".\", \",\", \";\", \"%\", \"+\", \"-\", \"E\", \"×\", \"‰\", \"∞\", \"NaN\", \":\"], [\"#,##0.###\", \"#,##0%\", \"¤#,##0.00\", \"#E0\"], \"USD\", \"$\", \"US Dollar\", {}, \"ltr\", plural];\n\n/**\n * This const is used to store the locale data registered with `registerLocaleData`\n */\nlet LOCALE_DATA = {};\n/**\n * Register locale data to be used internally by Angular. See the\n * [\"I18n guide\"](guide/i18n-common-format-data-locale) to know how to import additional locale\n * data.\n *\n * The signature `registerLocaleData(data: any, extraData?: any)` is deprecated since v5.1\n */\nfunction registerLocaleData(data, localeId, extraData) {\n    if (typeof localeId !== 'string') {\n        extraData = localeId;\n        localeId = data[LocaleDataIndex.LocaleId];\n    }\n    localeId = localeId.toLowerCase().replace(/_/g, '-');\n    LOCALE_DATA[localeId] = data;\n    if (extraData) {\n        LOCALE_DATA[localeId][LocaleDataIndex.ExtraData] = extraData;\n    }\n}\n/**\n * Finds the locale data for a given locale.\n *\n * @param locale The locale code.\n * @returns The locale data.\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n-overview)\n */\nfunction findLocaleData(locale) {\n    const normalizedLocale = normalizeLocale(locale);\n    let match = getLocaleData(normalizedLocale);\n    if (match) {\n        return match;\n    }\n    // let's try to find a parent locale\n    const parentLocale = normalizedLocale.split('-')[0];\n    match = getLocaleData(parentLocale);\n    if (match) {\n        return match;\n    }\n    if (parentLocale === 'en') {\n        return localeEn;\n    }\n    throw new RuntimeError(701 /* RuntimeErrorCode.MISSING_LOCALE_DATA */, ngDevMode && `Missing locale data for the locale \"${locale}\".`);\n}\n/**\n * Retrieves the default currency code for the given locale.\n *\n * The default is defined as the first currency which is still in use.\n *\n * @param locale The code of the locale whose currency code we want.\n * @returns The code of the default currency for the given locale.\n *\n */\nfunction getLocaleCurrencyCode(locale) {\n    const data = findLocaleData(locale);\n    return data[LocaleDataIndex.CurrencyCode] || null;\n}\n/**\n * Retrieves the plural function used by ICU expressions to determine the plural case to use\n * for a given locale.\n * @param locale A locale code for the locale format rules to use.\n * @returns The plural function for the locale.\n * @see {@link NgPlural}\n * @see [Internationalization (i18n) Guide](/guide/i18n-overview)\n */\nfunction getLocalePluralCase(locale) {\n    const data = findLocaleData(locale);\n    return data[LocaleDataIndex.PluralCase];\n}\n/**\n * Helper function to get the given `normalizedLocale` from `LOCALE_DATA`\n * or from the global `ng.common.locale`.\n */\nfunction getLocaleData(normalizedLocale) {\n    if (!(normalizedLocale in LOCALE_DATA)) {\n        LOCALE_DATA[normalizedLocale] = _global.ng && _global.ng.common && _global.ng.common.locales &&\n            _global.ng.common.locales[normalizedLocale];\n    }\n    return LOCALE_DATA[normalizedLocale];\n}\n/**\n * Helper function to remove all the locale data from `LOCALE_DATA`.\n */\nfunction unregisterAllLocaleData() {\n    LOCALE_DATA = {};\n}\n/**\n * Index of each type of locale data from the locale data array\n */\nvar LocaleDataIndex;\n(function (LocaleDataIndex) {\n    LocaleDataIndex[LocaleDataIndex[\"LocaleId\"] = 0] = \"LocaleId\";\n    LocaleDataIndex[LocaleDataIndex[\"DayPeriodsFormat\"] = 1] = \"DayPeriodsFormat\";\n    LocaleDataIndex[LocaleDataIndex[\"DayPeriodsStandalone\"] = 2] = \"DayPeriodsStandalone\";\n    LocaleDataIndex[LocaleDataIndex[\"DaysFormat\"] = 3] = \"DaysFormat\";\n    LocaleDataIndex[LocaleDataIndex[\"DaysStandalone\"] = 4] = \"DaysStandalone\";\n    LocaleDataIndex[LocaleDataIndex[\"MonthsFormat\"] = 5] = \"MonthsFormat\";\n    LocaleDataIndex[LocaleDataIndex[\"MonthsStandalone\"] = 6] = \"MonthsStandalone\";\n    LocaleDataIndex[LocaleDataIndex[\"Eras\"] = 7] = \"Eras\";\n    LocaleDataIndex[LocaleDataIndex[\"FirstDayOfWeek\"] = 8] = \"FirstDayOfWeek\";\n    LocaleDataIndex[LocaleDataIndex[\"WeekendRange\"] = 9] = \"WeekendRange\";\n    LocaleDataIndex[LocaleDataIndex[\"DateFormat\"] = 10] = \"DateFormat\";\n    LocaleDataIndex[LocaleDataIndex[\"TimeFormat\"] = 11] = \"TimeFormat\";\n    LocaleDataIndex[LocaleDataIndex[\"DateTimeFormat\"] = 12] = \"DateTimeFormat\";\n    LocaleDataIndex[LocaleDataIndex[\"NumberSymbols\"] = 13] = \"NumberSymbols\";\n    LocaleDataIndex[LocaleDataIndex[\"NumberFormats\"] = 14] = \"NumberFormats\";\n    LocaleDataIndex[LocaleDataIndex[\"CurrencyCode\"] = 15] = \"CurrencyCode\";\n    LocaleDataIndex[LocaleDataIndex[\"CurrencySymbol\"] = 16] = \"CurrencySymbol\";\n    LocaleDataIndex[LocaleDataIndex[\"CurrencyName\"] = 17] = \"CurrencyName\";\n    LocaleDataIndex[LocaleDataIndex[\"Currencies\"] = 18] = \"Currencies\";\n    LocaleDataIndex[LocaleDataIndex[\"Directionality\"] = 19] = \"Directionality\";\n    LocaleDataIndex[LocaleDataIndex[\"PluralCase\"] = 20] = \"PluralCase\";\n    LocaleDataIndex[LocaleDataIndex[\"ExtraData\"] = 21] = \"ExtraData\";\n})(LocaleDataIndex || (LocaleDataIndex = {}));\n/**\n * Returns the canonical form of a locale name - lowercase with `_` replaced with `-`.\n */\nfunction normalizeLocale(locale) {\n    return locale.toLowerCase().replace(/_/g, '-');\n}\n\nconst pluralMapping = ['zero', 'one', 'two', 'few', 'many'];\n/**\n * Returns the plural case based on the locale\n */\nfunction getPluralCase(value, locale) {\n    const plural = getLocalePluralCase(locale)(parseInt(value, 10));\n    const result = pluralMapping[plural];\n    return (result !== undefined) ? result : 'other';\n}\n/**\n * The locale id that the application is using by default (for translations and ICU expressions).\n */\nconst DEFAULT_LOCALE_ID = 'en-US';\n/**\n * USD currency code that the application uses by default for CurrencyPipe when no\n * DEFAULT_CURRENCY_CODE is provided.\n */\nconst USD_CURRENCY_CODE = 'USD';\n\n/**\n * Marks that the next string is an element name.\n *\n * See `I18nMutateOpCodes` documentation.\n */\nconst ELEMENT_MARKER = {\n    marker: 'element'\n};\n/**\n * Marks that the next string is comment text need for ICU.\n *\n * See `I18nMutateOpCodes` documentation.\n */\nconst ICU_MARKER = {\n    marker: 'ICU'\n};\n/**\n * See `I18nCreateOpCodes`\n */\nvar I18nCreateOpCode;\n(function (I18nCreateOpCode) {\n    /**\n     * Number of bits to shift index so that it can be combined with the `APPEND_EAGERLY` and\n     * `COMMENT`.\n     */\n    I18nCreateOpCode[I18nCreateOpCode[\"SHIFT\"] = 2] = \"SHIFT\";\n    /**\n     * Should the node be appended to parent immediately after creation.\n     */\n    I18nCreateOpCode[I18nCreateOpCode[\"APPEND_EAGERLY\"] = 1] = \"APPEND_EAGERLY\";\n    /**\n     * If set the node should be comment (rather than a text) node.\n     */\n    I18nCreateOpCode[I18nCreateOpCode[\"COMMENT\"] = 2] = \"COMMENT\";\n})(I18nCreateOpCode || (I18nCreateOpCode = {}));\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd = 1;\n\n/**\n * The locale id that the application is currently using (for translations and ICU expressions).\n * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine\n * but is now defined as a global value.\n */\nlet LOCALE_ID = DEFAULT_LOCALE_ID;\n/**\n * Sets the locale id that will be used for translations and ICU expressions.\n * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine\n * but is now defined as a global value.\n *\n * @param localeId\n */\nfunction setLocaleId(localeId) {\n    assertDefined(localeId, `Expected localeId to be defined`);\n    if (typeof localeId === 'string') {\n        LOCALE_ID = localeId.toLowerCase().replace(/_/g, '-');\n    }\n}\n/**\n * Gets the locale id that will be used for translations and ICU expressions.\n * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine\n * but is now defined as a global value.\n */\nfunction getLocaleId() {\n    return LOCALE_ID;\n}\n\n/**\n * Find a node in front of which `currentTNode` should be inserted (takes i18n into account).\n *\n * This method determines the `RNode` in front of which we should insert the `currentRNode`. This\n * takes `TNode.insertBeforeIndex` into account.\n *\n * @param parentTNode parent `TNode`\n * @param currentTNode current `TNode` (The node which we would like to insert into the DOM)\n * @param lView current `LView`\n */\nfunction getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView) {\n    const tNodeInsertBeforeIndex = currentTNode.insertBeforeIndex;\n    const insertBeforeIndex = Array.isArray(tNodeInsertBeforeIndex) ? tNodeInsertBeforeIndex[0] : tNodeInsertBeforeIndex;\n    if (insertBeforeIndex === null) {\n        return getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView);\n    }\n    else {\n        ngDevMode && assertIndexInRange(lView, insertBeforeIndex);\n        return unwrapRNode(lView[insertBeforeIndex]);\n    }\n}\n/**\n * Process `TNode.insertBeforeIndex` by adding i18n text nodes.\n *\n * See `TNode.insertBeforeIndex`\n */\nfunction processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRElement) {\n    const tNodeInsertBeforeIndex = childTNode.insertBeforeIndex;\n    if (Array.isArray(tNodeInsertBeforeIndex)) {\n        // An array indicates that there are i18n nodes that need to be added as children of this\n        // `childRNode`. These i18n nodes were created before this `childRNode` was available and so\n        // only now can be added. The first element of the array is the normal index where we should\n        // insert the `childRNode`. Additional elements are the extra nodes to be added as children of\n        // `childRNode`.\n        ngDevMode && assertDomNode(childRNode);\n        let i18nParent = childRNode;\n        let anchorRNode = null;\n        if (!(childTNode.type & 3 /* TNodeType.AnyRNode */)) {\n            anchorRNode = i18nParent;\n            i18nParent = parentRElement;\n        }\n        if (i18nParent !== null && childTNode.componentOffset === -1) {\n            for (let i = 1; i < tNodeInsertBeforeIndex.length; i++) {\n                // No need to `unwrapRNode` because all of the indexes point to i18n text nodes.\n                // see `assertDomNode` below.\n                const i18nChild = lView[tNodeInsertBeforeIndex[i]];\n                nativeInsertBefore(renderer, i18nParent, i18nChild, anchorRNode, false);\n            }\n        }\n    }\n}\n\n/**\n * Add `tNode` to `previousTNodes` list and update relevant `TNode`s in `previousTNodes` list\n * `tNode.insertBeforeIndex`.\n *\n * Things to keep in mind:\n * 1. All i18n text nodes are encoded as `TNodeType.Element` and are created eagerly by the\n *    `ɵɵi18nStart` instruction.\n * 2. All `TNodeType.Placeholder` `TNodes` are elements which will be created later by\n *    `ɵɵelementStart` instruction.\n * 3. `ɵɵelementStart` instruction will create `TNode`s in the ascending `TNode.index` order. (So a\n *    smaller index `TNode` is guaranteed to be created before a larger one)\n *\n * We use the above three invariants to determine `TNode.insertBeforeIndex`.\n *\n * In an ideal world `TNode.insertBeforeIndex` would always be `TNode.next.index`. However,\n * this will not work because `TNode.next.index` may be larger than `TNode.index` which means that\n * the next node is not yet created and therefore we can't insert in front of it.\n *\n * Rule1: `TNode.insertBeforeIndex = null` if `TNode.next === null` (Initial condition, as we don't\n *        know if there will be further `TNode`s inserted after.)\n * Rule2: If `previousTNode` is created after the `tNode` being inserted, then\n *        `previousTNode.insertBeforeNode = tNode.index` (So when a new `tNode` is added we check\n *        previous to see if we can update its `insertBeforeTNode`)\n *\n * See `TNode.insertBeforeIndex` for more context.\n *\n * @param previousTNodes A list of previous TNodes so that we can easily traverse `TNode`s in\n *     reverse order. (If `TNode` would have `previous` this would not be necessary.)\n * @param newTNode A TNode to add to the `previousTNodes` list.\n */\nfunction addTNodeAndUpdateInsertBeforeIndex(previousTNodes, newTNode) {\n    // Start with Rule1\n    ngDevMode &&\n        assertEqual(newTNode.insertBeforeIndex, null, 'We expect that insertBeforeIndex is not set');\n    previousTNodes.push(newTNode);\n    if (previousTNodes.length > 1) {\n        for (let i = previousTNodes.length - 2; i >= 0; i--) {\n            const existingTNode = previousTNodes[i];\n            // Text nodes are created eagerly and so they don't need their `indexBeforeIndex` updated.\n            // It is safe to ignore them.\n            if (!isI18nText(existingTNode)) {\n                if (isNewTNodeCreatedBefore(existingTNode, newTNode) &&\n                    getInsertBeforeIndex(existingTNode) === null) {\n                    // If it was created before us in time, (and it does not yet have `insertBeforeIndex`)\n                    // then add the `insertBeforeIndex`.\n                    setInsertBeforeIndex(existingTNode, newTNode.index);\n                }\n            }\n        }\n    }\n}\nfunction isI18nText(tNode) {\n    return !(tNode.type & 64 /* TNodeType.Placeholder */);\n}\nfunction isNewTNodeCreatedBefore(existingTNode, newTNode) {\n    return isI18nText(newTNode) || existingTNode.index > newTNode.index;\n}\nfunction getInsertBeforeIndex(tNode) {\n    const index = tNode.insertBeforeIndex;\n    return Array.isArray(index) ? index[0] : index;\n}\nfunction setInsertBeforeIndex(tNode, value) {\n    const index = tNode.insertBeforeIndex;\n    if (Array.isArray(index)) {\n        // Array is stored if we have to insert child nodes. See `TNode.insertBeforeIndex`\n        index[0] = value;\n    }\n    else {\n        setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);\n        tNode.insertBeforeIndex = value;\n    }\n}\n\n/**\n * Retrieve `TIcu` at a given `index`.\n *\n * The `TIcu` can be stored either directly (if it is nested ICU) OR\n * it is stored inside tho `TIcuContainer` if it is top level ICU.\n *\n * The reason for this is that the top level ICU need a `TNode` so that they are part of the render\n * tree, but nested ICU's have no TNode, because we don't know ahead of time if the nested ICU is\n * expressed (parent ICU may have selected a case which does not contain it.)\n *\n * @param tView Current `TView`.\n * @param index Index where the value should be read from.\n */\nfunction getTIcu(tView, index) {\n    const value = tView.data[index];\n    if (value === null || typeof value === 'string')\n        return null;\n    if (ngDevMode &&\n        !(value.hasOwnProperty('tView') || value.hasOwnProperty('currentCaseLViewIndex'))) {\n        throwError('We expect to get \\'null\\'|\\'TIcu\\'|\\'TIcuContainer\\', but got: ' + value);\n    }\n    // Here the `value.hasOwnProperty('currentCaseLViewIndex')` is a polymorphic read as it can be\n    // either TIcu or TIcuContainerNode. This is not ideal, but we still think it is OK because it\n    // will be just two cases which fits into the browser inline cache (inline cache can take up to\n    // 4)\n    const tIcu = value.hasOwnProperty('currentCaseLViewIndex') ? value :\n        value.value;\n    ngDevMode && assertTIcu(tIcu);\n    return tIcu;\n}\n/**\n * Store `TIcu` at a give `index`.\n *\n * The `TIcu` can be stored either directly (if it is nested ICU) OR\n * it is stored inside tho `TIcuContainer` if it is top level ICU.\n *\n * The reason for this is that the top level ICU need a `TNode` so that they are part of the render\n * tree, but nested ICU's have no TNode, because we don't know ahead of time if the nested ICU is\n * expressed (parent ICU may have selected a case which does not contain it.)\n *\n * @param tView Current `TView`.\n * @param index Index where the value should be stored at in `Tview.data`\n * @param tIcu The TIcu to store.\n */\nfunction setTIcu(tView, index, tIcu) {\n    const tNode = tView.data[index];\n    ngDevMode &&\n        assertEqual(tNode === null || tNode.hasOwnProperty('tView'), true, 'We expect to get \\'null\\'|\\'TIcuContainer\\'');\n    if (tNode === null) {\n        tView.data[index] = tIcu;\n    }\n    else {\n        ngDevMode && assertTNodeType(tNode, 32 /* TNodeType.Icu */);\n        tNode.value = tIcu;\n    }\n}\n/**\n * Set `TNode.insertBeforeIndex` taking the `Array` into account.\n *\n * See `TNode.insertBeforeIndex`\n */\nfunction setTNodeInsertBeforeIndex(tNode, index) {\n    ngDevMode && assertTNode(tNode);\n    let insertBeforeIndex = tNode.insertBeforeIndex;\n    if (insertBeforeIndex === null) {\n        setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);\n        insertBeforeIndex = tNode.insertBeforeIndex =\n            [null /* may be updated to number later */, index];\n    }\n    else {\n        assertEqual(Array.isArray(insertBeforeIndex), true, 'Expecting array here');\n        insertBeforeIndex.push(index);\n    }\n}\n/**\n * Create `TNode.type=TNodeType.Placeholder` node.\n *\n * See `TNodeType.Placeholder` for more information.\n */\nfunction createTNodePlaceholder(tView, previousTNodes, index) {\n    const tNode = createTNodeAtIndex(tView, index, 64 /* TNodeType.Placeholder */, null, null);\n    addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tNode);\n    return tNode;\n}\n/**\n * Returns current ICU case.\n *\n * ICU cases are stored as index into the `TIcu.cases`.\n * At times it is necessary to communicate that the ICU case just switched and that next ICU update\n * should update all bindings regardless of the mask. In such a case the we store negative numbers\n * for cases which have just been switched. This function removes the negative flag.\n */\nfunction getCurrentICUCaseIndex(tIcu, lView) {\n    const currentCase = lView[tIcu.currentCaseLViewIndex];\n    return currentCase === null ? currentCase : (currentCase < 0 ? ~currentCase : currentCase);\n}\nfunction getParentFromIcuCreateOpCode(mergedCode) {\n    return mergedCode >>> 17 /* IcuCreateOpCode.SHIFT_PARENT */;\n}\nfunction getRefFromIcuCreateOpCode(mergedCode) {\n    return (mergedCode & 131070 /* IcuCreateOpCode.MASK_REF */) >>> 1 /* IcuCreateOpCode.SHIFT_REF */;\n}\nfunction getInstructionFromIcuCreateOpCode(mergedCode) {\n    return mergedCode & 1 /* IcuCreateOpCode.MASK_INSTRUCTION */;\n}\nfunction icuCreateOpCode(opCode, parentIdx, refIdx) {\n    ngDevMode && assertGreaterThanOrEqual(parentIdx, 0, 'Missing parent index');\n    ngDevMode && assertGreaterThan(refIdx, 0, 'Missing ref index');\n    return opCode | parentIdx << 17 /* IcuCreateOpCode.SHIFT_PARENT */ | refIdx << 1 /* IcuCreateOpCode.SHIFT_REF */;\n}\n\n/**\n * Keep track of which input bindings in `ɵɵi18nExp` have changed.\n *\n * This is used to efficiently update expressions in i18n only when the corresponding input has\n * changed.\n *\n * 1) Each bit represents which of the `ɵɵi18nExp` has changed.\n * 2) There are 32 bits allowed in JS.\n * 3) Bit 32 is special as it is shared for all changes past 32. (In other words if you have more\n * than 32 `ɵɵi18nExp` then all changes past 32nd `ɵɵi18nExp` will be mapped to same bit. This means\n * that we may end up changing more than we need to. But i18n expressions with 32 bindings is rare\n * so in practice it should not be an issue.)\n */\nlet changeMask = 0b0;\n/**\n * Keeps track of which bit needs to be updated in `changeMask`\n *\n * This value gets incremented on every call to `ɵɵi18nExp`\n */\nlet changeMaskCounter = 0;\n/**\n * Keep track of which input bindings in `ɵɵi18nExp` have changed.\n *\n * `setMaskBit` gets invoked by each call to `ɵɵi18nExp`.\n *\n * @param hasChange did `ɵɵi18nExp` detect a change.\n */\nfunction setMaskBit(hasChange) {\n    if (hasChange) {\n        changeMask = changeMask | (1 << Math.min(changeMaskCounter, 31));\n    }\n    changeMaskCounter++;\n}\nfunction applyI18n(tView, lView, index) {\n    if (changeMaskCounter > 0) {\n        ngDevMode && assertDefined(tView, `tView should be defined`);\n        const tI18n = tView.data[index];\n        // When `index` points to an `ɵɵi18nAttributes` then we have an array otherwise `TI18n`\n        const updateOpCodes = Array.isArray(tI18n) ? tI18n : tI18n.update;\n        const bindingsStartIndex = getBindingIndex() - changeMaskCounter - 1;\n        applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask);\n    }\n    // Reset changeMask & maskBit to default for the next update cycle\n    changeMask = 0b0;\n    changeMaskCounter = 0;\n}\n/**\n * Apply `I18nCreateOpCodes` op-codes as stored in `TI18n.create`.\n *\n * Creates text (and comment) nodes which are internationalized.\n *\n * @param lView Current lView\n * @param createOpCodes Set of op-codes to apply\n * @param parentRNode Parent node (so that direct children can be added eagerly) or `null` if it is\n *     a root node.\n * @param insertInFrontOf DOM node that should be used as an anchor.\n */\nfunction applyCreateOpCodes(lView, createOpCodes, parentRNode, insertInFrontOf) {\n    const renderer = lView[RENDERER];\n    for (let i = 0; i < createOpCodes.length; i++) {\n        const opCode = createOpCodes[i++];\n        const text = createOpCodes[i];\n        const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;\n        const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;\n        const index = opCode >>> I18nCreateOpCode.SHIFT;\n        let rNode = lView[index];\n        if (rNode === null) {\n            // We only create new DOM nodes if they don't already exist: If ICU switches case back to a\n            // case which was already instantiated, no need to create new DOM nodes.\n            rNode = lView[index] =\n                isComment ? renderer.createComment(text) : createTextNode(renderer, text);\n        }\n        if (appendNow && parentRNode !== null) {\n            nativeInsertBefore(renderer, parentRNode, rNode, insertInFrontOf, false);\n        }\n    }\n}\n/**\n * Apply `I18nMutateOpCodes` OpCodes.\n *\n * @param tView Current `TView`\n * @param mutableOpCodes Mutable OpCodes to process\n * @param lView Current `LView`\n * @param anchorRNode place where the i18n node should be inserted.\n */\nfunction applyMutableOpCodes(tView, mutableOpCodes, lView, anchorRNode) {\n    ngDevMode && assertDomNode(anchorRNode);\n    const renderer = lView[RENDERER];\n    // `rootIdx` represents the node into which all inserts happen.\n    let rootIdx = null;\n    // `rootRNode` represents the real node into which we insert. This can be different from\n    // `lView[rootIdx]` if we have projection.\n    //  - null we don't have a parent (as can be the case in when we are inserting into a root of\n    //    LView which has no parent.)\n    //  - `RElement` The element representing the root after taking projection into account.\n    let rootRNode;\n    for (let i = 0; i < mutableOpCodes.length; i++) {\n        const opCode = mutableOpCodes[i];\n        if (typeof opCode == 'string') {\n            const textNodeIndex = mutableOpCodes[++i];\n            if (lView[textNodeIndex] === null) {\n                ngDevMode && ngDevMode.rendererCreateTextNode++;\n                ngDevMode && assertIndexInRange(lView, textNodeIndex);\n                lView[textNodeIndex] = createTextNode(renderer, opCode);\n            }\n        }\n        else if (typeof opCode == 'number') {\n            switch (opCode & 1 /* IcuCreateOpCode.MASK_INSTRUCTION */) {\n                case 0 /* IcuCreateOpCode.AppendChild */:\n                    const parentIdx = getParentFromIcuCreateOpCode(opCode);\n                    if (rootIdx === null) {\n                        // The first operation should save the `rootIdx` because the first operation\n                        // must insert into the root. (Only subsequent operations can insert into a dynamic\n                        // parent)\n                        rootIdx = parentIdx;\n                        rootRNode = nativeParentNode(renderer, anchorRNode);\n                    }\n                    let insertInFrontOf;\n                    let parentRNode;\n                    if (parentIdx === rootIdx) {\n                        insertInFrontOf = anchorRNode;\n                        parentRNode = rootRNode;\n                    }\n                    else {\n                        insertInFrontOf = null;\n                        parentRNode = unwrapRNode(lView[parentIdx]);\n                    }\n                    // FIXME(misko): Refactor with `processI18nText`\n                    if (parentRNode !== null) {\n                        // This can happen if the `LView` we are adding to is not attached to a parent `LView`.\n                        // In such a case there is no \"root\" we can attach to. This is fine, as we still need to\n                        // create the elements. When the `LView` gets later added to a parent these \"root\" nodes\n                        // get picked up and added.\n                        ngDevMode && assertDomNode(parentRNode);\n                        const refIdx = getRefFromIcuCreateOpCode(opCode);\n                        ngDevMode && assertGreaterThan(refIdx, HEADER_OFFSET, 'Missing ref');\n                        // `unwrapRNode` is not needed here as all of these point to RNodes as part of the i18n\n                        // which can't have components.\n                        const child = lView[refIdx];\n                        ngDevMode && assertDomNode(child);\n                        nativeInsertBefore(renderer, parentRNode, child, insertInFrontOf, false);\n                        const tIcu = getTIcu(tView, refIdx);\n                        if (tIcu !== null && typeof tIcu === 'object') {\n                            // If we just added a comment node which has ICU then that ICU may have already been\n                            // rendered and therefore we need to re-add it here.\n                            ngDevMode && assertTIcu(tIcu);\n                            const caseIndex = getCurrentICUCaseIndex(tIcu, lView);\n                            if (caseIndex !== null) {\n                                applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, lView[tIcu.anchorIdx]);\n                            }\n                        }\n                    }\n                    break;\n                case 1 /* IcuCreateOpCode.Attr */:\n                    const elementNodeIndex = opCode >>> 1 /* IcuCreateOpCode.SHIFT_REF */;\n                    const attrName = mutableOpCodes[++i];\n                    const attrValue = mutableOpCodes[++i];\n                    // This code is used for ICU expressions only, since we don't support\n                    // directives/components in ICUs, we don't need to worry about inputs here\n                    setElementAttribute(renderer, getNativeByIndex(elementNodeIndex, lView), null, null, attrName, attrValue, null);\n                    break;\n                default:\n                    if (ngDevMode) {\n                        throw new RuntimeError(700 /* RuntimeErrorCode.INVALID_I18N_STRUCTURE */, `Unable to determine the type of mutate operation for \"${opCode}\"`);\n                    }\n            }\n        }\n        else {\n            switch (opCode) {\n                case ICU_MARKER:\n                    const commentValue = mutableOpCodes[++i];\n                    const commentNodeIndex = mutableOpCodes[++i];\n                    if (lView[commentNodeIndex] === null) {\n                        ngDevMode &&\n                            assertEqual(typeof commentValue, 'string', `Expected \"${commentValue}\" to be a comment node value`);\n                        ngDevMode && ngDevMode.rendererCreateComment++;\n                        ngDevMode && assertIndexInExpandoRange(lView, commentNodeIndex);\n                        const commentRNode = lView[commentNodeIndex] =\n                            createCommentNode(renderer, commentValue);\n                        // FIXME(misko): Attaching patch data is only needed for the root (Also add tests)\n                        attachPatchData(commentRNode, lView);\n                    }\n                    break;\n                case ELEMENT_MARKER:\n                    const tagName = mutableOpCodes[++i];\n                    const elementNodeIndex = mutableOpCodes[++i];\n                    if (lView[elementNodeIndex] === null) {\n                        ngDevMode &&\n                            assertEqual(typeof tagName, 'string', `Expected \"${tagName}\" to be an element node tag name`);\n                        ngDevMode && ngDevMode.rendererCreateElement++;\n                        ngDevMode && assertIndexInExpandoRange(lView, elementNodeIndex);\n                        const elementRNode = lView[elementNodeIndex] =\n                            createElementNode(renderer, tagName, null);\n                        // FIXME(misko): Attaching patch data is only needed for the root (Also add tests)\n                        attachPatchData(elementRNode, lView);\n                    }\n                    break;\n                default:\n                    ngDevMode &&\n                        throwError(`Unable to determine the type of mutate operation for \"${opCode}\"`);\n            }\n        }\n    }\n}\n/**\n * Apply `I18nUpdateOpCodes` OpCodes\n *\n * @param tView Current `TView`\n * @param lView Current `LView`\n * @param updateOpCodes OpCodes to process\n * @param bindingsStartIndex Location of the first `ɵɵi18nApply`\n * @param changeMask Each bit corresponds to a `ɵɵi18nExp` (Counting backwards from\n *     `bindingsStartIndex`)\n */\nfunction applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask) {\n    for (let i = 0; i < updateOpCodes.length; i++) {\n        // bit code to check if we should apply the next update\n        const checkBit = updateOpCodes[i];\n        // Number of opCodes to skip until next set of update codes\n        const skipCodes = updateOpCodes[++i];\n        if (checkBit & changeMask) {\n            // The value has been updated since last checked\n            let value = '';\n            for (let j = i + 1; j <= (i + skipCodes); j++) {\n                const opCode = updateOpCodes[j];\n                if (typeof opCode == 'string') {\n                    value += opCode;\n                }\n                else if (typeof opCode == 'number') {\n                    if (opCode < 0) {\n                        // Negative opCode represent `i18nExp` values offset.\n                        value += renderStringify(lView[bindingsStartIndex - opCode]);\n                    }\n                    else {\n                        const nodeIndex = (opCode >>> 2 /* I18nUpdateOpCode.SHIFT_REF */);\n                        switch (opCode & 3 /* I18nUpdateOpCode.MASK_OPCODE */) {\n                            case 1 /* I18nUpdateOpCode.Attr */:\n                                const propName = updateOpCodes[++j];\n                                const sanitizeFn = updateOpCodes[++j];\n                                const tNodeOrTagName = tView.data[nodeIndex];\n                                ngDevMode && assertDefined(tNodeOrTagName, 'Experting TNode or string');\n                                if (typeof tNodeOrTagName === 'string') {\n                                    // IF we don't have a `TNode`, then we are an element in ICU (as ICU content does\n                                    // not have TNode), in which case we know that there are no directives, and hence\n                                    // we use attribute setting.\n                                    setElementAttribute(lView[RENDERER], lView[nodeIndex], null, tNodeOrTagName, propName, value, sanitizeFn);\n                                }\n                                else {\n                                    elementPropertyInternal(tView, tNodeOrTagName, lView, propName, value, lView[RENDERER], sanitizeFn, false);\n                                }\n                                break;\n                            case 0 /* I18nUpdateOpCode.Text */:\n                                const rText = lView[nodeIndex];\n                                rText !== null && updateTextNode(lView[RENDERER], rText, value);\n                                break;\n                            case 2 /* I18nUpdateOpCode.IcuSwitch */:\n                                applyIcuSwitchCase(tView, getTIcu(tView, nodeIndex), lView, value);\n                                break;\n                            case 3 /* I18nUpdateOpCode.IcuUpdate */:\n                                applyIcuUpdateCase(tView, getTIcu(tView, nodeIndex), bindingsStartIndex, lView);\n                                break;\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            const opCode = updateOpCodes[i + 1];\n            if (opCode > 0 && (opCode & 3 /* I18nUpdateOpCode.MASK_OPCODE */) === 3 /* I18nUpdateOpCode.IcuUpdate */) {\n                // Special case for the `icuUpdateCase`. It could be that the mask did not match, but\n                // we still need to execute `icuUpdateCase` because the case has changed recently due to\n                // previous `icuSwitchCase` instruction. (`icuSwitchCase` and `icuUpdateCase` always come in\n                // pairs.)\n                const nodeIndex = (opCode >>> 2 /* I18nUpdateOpCode.SHIFT_REF */);\n                const tIcu = getTIcu(tView, nodeIndex);\n                const currentIndex = lView[tIcu.currentCaseLViewIndex];\n                if (currentIndex < 0) {\n                    applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView);\n                }\n            }\n        }\n        i += skipCodes;\n    }\n}\n/**\n * Apply OpCodes associated with updating an existing ICU.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param bindingsStartIndex Location of the first `ɵɵi18nApply`\n * @param lView Current `LView`\n */\nfunction applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView) {\n    ngDevMode && assertIndexInRange(lView, tIcu.currentCaseLViewIndex);\n    let activeCaseIndex = lView[tIcu.currentCaseLViewIndex];\n    if (activeCaseIndex !== null) {\n        let mask = changeMask;\n        if (activeCaseIndex < 0) {\n            // Clear the flag.\n            // Negative number means that the ICU was freshly created and we need to force the update.\n            activeCaseIndex = lView[tIcu.currentCaseLViewIndex] = ~activeCaseIndex;\n            // -1 is same as all bits on, which simulates creation since it marks all bits dirty\n            mask = -1;\n        }\n        applyUpdateOpCodes(tView, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);\n    }\n}\n/**\n * Apply OpCodes associated with switching a case on ICU.\n *\n * This involves tearing down existing case and than building up a new case.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param lView Current `LView`\n * @param value Value of the case to update to.\n */\nfunction applyIcuSwitchCase(tView, tIcu, lView, value) {\n    // Rebuild a new case for this ICU\n    const caseIndex = getCaseIndex(tIcu, value);\n    let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);\n    if (activeCaseIndex !== caseIndex) {\n        applyIcuSwitchCaseRemove(tView, tIcu, lView);\n        lView[tIcu.currentCaseLViewIndex] = caseIndex === null ? null : ~caseIndex;\n        if (caseIndex !== null) {\n            // Add the nodes for the new case\n            const anchorRNode = lView[tIcu.anchorIdx];\n            if (anchorRNode) {\n                ngDevMode && assertDomNode(anchorRNode);\n                applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, anchorRNode);\n            }\n        }\n    }\n}\n/**\n * Apply OpCodes associated with tearing ICU case.\n *\n * This involves tearing down existing case and than building up a new case.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param lView Current `LView`\n */\nfunction applyIcuSwitchCaseRemove(tView, tIcu, lView) {\n    let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);\n    if (activeCaseIndex !== null) {\n        const removeCodes = tIcu.remove[activeCaseIndex];\n        for (let i = 0; i < removeCodes.length; i++) {\n            const nodeOrIcuIndex = removeCodes[i];\n            if (nodeOrIcuIndex > 0) {\n                // Positive numbers are `RNode`s.\n                const rNode = getNativeByIndex(nodeOrIcuIndex, lView);\n                rNode !== null && nativeRemoveNode(lView[RENDERER], rNode);\n            }\n            else {\n                // Negative numbers are ICUs\n                applyIcuSwitchCaseRemove(tView, getTIcu(tView, ~nodeOrIcuIndex), lView);\n            }\n        }\n    }\n}\n/**\n * Returns the index of the current case of an ICU expression depending on the main binding value\n *\n * @param icuExpression\n * @param bindingValue The value of the main binding used by this ICU expression\n */\nfunction getCaseIndex(icuExpression, bindingValue) {\n    let index = icuExpression.cases.indexOf(bindingValue);\n    if (index === -1) {\n        switch (icuExpression.type) {\n            case 1 /* IcuType.plural */: {\n                const resolvedCase = getPluralCase(bindingValue, getLocaleId());\n                index = icuExpression.cases.indexOf(resolvedCase);\n                if (index === -1 && resolvedCase !== 'other') {\n                    index = icuExpression.cases.indexOf('other');\n                }\n                break;\n            }\n            case 0 /* IcuType.select */: {\n                index = icuExpression.cases.indexOf('other');\n                break;\n            }\n        }\n    }\n    return index === -1 ? null : index;\n}\n\nfunction loadIcuContainerVisitor() {\n    const _stack = [];\n    let _index = -1;\n    let _lView;\n    let _removes;\n    /**\n     * Retrieves a set of root nodes from `TIcu.remove`. Used by `TNodeType.ICUContainer`\n     * to determine which root belong to the ICU.\n     *\n     * Example of usage.\n     * ```\n     * const nextRNode = icuContainerIteratorStart(tIcuContainerNode, lView);\n     * let rNode: RNode|null;\n     * while(rNode = nextRNode()) {\n     *   console.log(rNode);\n     * }\n     * ```\n     *\n     * @param tIcuContainerNode Current `TIcuContainerNode`\n     * @param lView `LView` where the `RNode`s should be looked up.\n     */\n    function icuContainerIteratorStart(tIcuContainerNode, lView) {\n        _lView = lView;\n        while (_stack.length)\n            _stack.pop();\n        ngDevMode && assertTNodeForLView(tIcuContainerNode, lView);\n        enterIcu(tIcuContainerNode.value, lView);\n        return icuContainerIteratorNext;\n    }\n    function enterIcu(tIcu, lView) {\n        _index = 0;\n        const currentCase = getCurrentICUCaseIndex(tIcu, lView);\n        if (currentCase !== null) {\n            ngDevMode && assertNumberInRange(currentCase, 0, tIcu.cases.length - 1);\n            _removes = tIcu.remove[currentCase];\n        }\n        else {\n            _removes = EMPTY_ARRAY;\n        }\n    }\n    function icuContainerIteratorNext() {\n        if (_index < _removes.length) {\n            const removeOpCode = _removes[_index++];\n            ngDevMode && assertNumber(removeOpCode, 'Expecting OpCode number');\n            if (removeOpCode > 0) {\n                const rNode = _lView[removeOpCode];\n                ngDevMode && assertDomNode(rNode);\n                return rNode;\n            }\n            else {\n                _stack.push(_index, _removes);\n                // ICUs are represented by negative indices\n                const tIcuIndex = ~removeOpCode;\n                const tIcu = _lView[TVIEW].data[tIcuIndex];\n                ngDevMode && assertTIcu(tIcu);\n                enterIcu(tIcu, _lView);\n                return icuContainerIteratorNext();\n            }\n        }\n        else {\n            if (_stack.length === 0) {\n                return null;\n            }\n            else {\n                _removes = _stack.pop();\n                _index = _stack.pop();\n                return icuContainerIteratorNext();\n            }\n        }\n    }\n    return icuContainerIteratorStart;\n}\n\n/**\n * Converts `I18nCreateOpCodes` array into a human readable format.\n *\n * This function is attached to the `I18nCreateOpCodes.debug` property if `ngDevMode` is enabled.\n * This function provides a human readable view of the opcodes. This is useful when debugging the\n * application as well as writing more readable tests.\n *\n * @param this `I18nCreateOpCodes` if attached as a method.\n * @param opcodes `I18nCreateOpCodes` if invoked as a function.\n */\nfunction i18nCreateOpCodesToString(opcodes) {\n    const createOpCodes = opcodes || (Array.isArray(this) ? this : []);\n    let lines = [];\n    for (let i = 0; i < createOpCodes.length; i++) {\n        const opCode = createOpCodes[i++];\n        const text = createOpCodes[i];\n        const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;\n        const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;\n        const index = opCode >>> I18nCreateOpCode.SHIFT;\n        lines.push(`lView[${index}] = document.${isComment ? 'createComment' : 'createText'}(${JSON.stringify(text)});`);\n        if (appendNow) {\n            lines.push(`parent.appendChild(lView[${index}]);`);\n        }\n    }\n    return lines;\n}\n/**\n * Converts `I18nUpdateOpCodes` array into a human readable format.\n *\n * This function is attached to the `I18nUpdateOpCodes.debug` property if `ngDevMode` is enabled.\n * This function provides a human readable view of the opcodes. This is useful when debugging the\n * application as well as writing more readable tests.\n *\n * @param this `I18nUpdateOpCodes` if attached as a method.\n * @param opcodes `I18nUpdateOpCodes` if invoked as a function.\n */\nfunction i18nUpdateOpCodesToString(opcodes) {\n    const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));\n    let lines = [];\n    function consumeOpCode(value) {\n        const ref = value >>> 2 /* I18nUpdateOpCode.SHIFT_REF */;\n        const opCode = value & 3 /* I18nUpdateOpCode.MASK_OPCODE */;\n        switch (opCode) {\n            case 0 /* I18nUpdateOpCode.Text */:\n                return `(lView[${ref}] as Text).textContent = $$$`;\n            case 1 /* I18nUpdateOpCode.Attr */:\n                const attrName = parser.consumeString();\n                const sanitizationFn = parser.consumeFunction();\n                const value = sanitizationFn ? `(${sanitizationFn})($$$)` : '$$$';\n                return `(lView[${ref}] as Element).setAttribute('${attrName}', ${value})`;\n            case 2 /* I18nUpdateOpCode.IcuSwitch */:\n                return `icuSwitchCase(${ref}, $$$)`;\n            case 3 /* I18nUpdateOpCode.IcuUpdate */:\n                return `icuUpdateCase(${ref})`;\n        }\n        throw new Error('unexpected OpCode');\n    }\n    while (parser.hasMore()) {\n        let mask = parser.consumeNumber();\n        let size = parser.consumeNumber();\n        const end = parser.i + size;\n        const statements = [];\n        let statement = '';\n        while (parser.i < end) {\n            let value = parser.consumeNumberOrString();\n            if (typeof value === 'string') {\n                statement += value;\n            }\n            else if (value < 0) {\n                // Negative numbers are ref indexes\n                // Here `i` refers to current binding index. It is to signify that the value is relative,\n                // rather than absolute.\n                statement += '${lView[i' + value + ']}';\n            }\n            else {\n                // Positive numbers are operations.\n                const opCodeText = consumeOpCode(value);\n                statements.push(opCodeText.replace('$$$', '`' + statement + '`') + ';');\n                statement = '';\n            }\n        }\n        lines.push(`if (mask & 0b${mask.toString(2)}) { ${statements.join(' ')} }`);\n    }\n    return lines;\n}\n/**\n * Converts `I18nCreateOpCodes` array into a human readable format.\n *\n * This function is attached to the `I18nCreateOpCodes.debug` if `ngDevMode` is enabled. This\n * function provides a human readable view of the opcodes. This is useful when debugging the\n * application as well as writing more readable tests.\n *\n * @param this `I18nCreateOpCodes` if attached as a method.\n * @param opcodes `I18nCreateOpCodes` if invoked as a function.\n */\nfunction icuCreateOpCodesToString(opcodes) {\n    const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));\n    let lines = [];\n    function consumeOpCode(opCode) {\n        const parent = getParentFromIcuCreateOpCode(opCode);\n        const ref = getRefFromIcuCreateOpCode(opCode);\n        switch (getInstructionFromIcuCreateOpCode(opCode)) {\n            case 0 /* IcuCreateOpCode.AppendChild */:\n                return `(lView[${parent}] as Element).appendChild(lView[${lastRef}])`;\n            case 1 /* IcuCreateOpCode.Attr */:\n                return `(lView[${ref}] as Element).setAttribute(\"${parser.consumeString()}\", \"${parser.consumeString()}\")`;\n        }\n        throw new Error('Unexpected OpCode: ' + getInstructionFromIcuCreateOpCode(opCode));\n    }\n    let lastRef = -1;\n    while (parser.hasMore()) {\n        let value = parser.consumeNumberStringOrMarker();\n        if (value === ICU_MARKER) {\n            const text = parser.consumeString();\n            lastRef = parser.consumeNumber();\n            lines.push(`lView[${lastRef}] = document.createComment(\"${text}\")`);\n        }\n        else if (value === ELEMENT_MARKER) {\n            const text = parser.consumeString();\n            lastRef = parser.consumeNumber();\n            lines.push(`lView[${lastRef}] = document.createElement(\"${text}\")`);\n        }\n        else if (typeof value === 'string') {\n            lastRef = parser.consumeNumber();\n            lines.push(`lView[${lastRef}] = document.createTextNode(\"${value}\")`);\n        }\n        else if (typeof value === 'number') {\n            const line = consumeOpCode(value);\n            line && lines.push(line);\n        }\n        else {\n            throw new Error('Unexpected value');\n        }\n    }\n    return lines;\n}\n/**\n * Converts `I18nRemoveOpCodes` array into a human readable format.\n *\n * This function is attached to the `I18nRemoveOpCodes.debug` if `ngDevMode` is enabled. This\n * function provides a human readable view of the opcodes. This is useful when debugging the\n * application as well as writing more readable tests.\n *\n * @param this `I18nRemoveOpCodes` if attached as a method.\n * @param opcodes `I18nRemoveOpCodes` if invoked as a function.\n */\nfunction i18nRemoveOpCodesToString(opcodes) {\n    const removeCodes = opcodes || (Array.isArray(this) ? this : []);\n    let lines = [];\n    for (let i = 0; i < removeCodes.length; i++) {\n        const nodeOrIcuIndex = removeCodes[i];\n        if (nodeOrIcuIndex > 0) {\n            // Positive numbers are `RNode`s.\n            lines.push(`remove(lView[${nodeOrIcuIndex}])`);\n        }\n        else {\n            // Negative numbers are ICUs\n            lines.push(`removeNestedICU(${~nodeOrIcuIndex})`);\n        }\n    }\n    return lines;\n}\nclass OpCodeParser {\n    constructor(codes) {\n        this.i = 0;\n        this.codes = codes;\n    }\n    hasMore() {\n        return this.i < this.codes.length;\n    }\n    consumeNumber() {\n        let value = this.codes[this.i++];\n        assertNumber(value, 'expecting number in OpCode');\n        return value;\n    }\n    consumeString() {\n        let value = this.codes[this.i++];\n        assertString(value, 'expecting string in OpCode');\n        return value;\n    }\n    consumeFunction() {\n        let value = this.codes[this.i++];\n        if (value === null || typeof value === 'function') {\n            return value;\n        }\n        throw new Error('expecting function in OpCode');\n    }\n    consumeNumberOrString() {\n        let value = this.codes[this.i++];\n        if (typeof value === 'string') {\n            return value;\n        }\n        assertNumber(value, 'expecting number or string in OpCode');\n        return value;\n    }\n    consumeNumberStringOrMarker() {\n        let value = this.codes[this.i++];\n        if (typeof value === 'string' || typeof value === 'number' || value == ICU_MARKER ||\n            value == ELEMENT_MARKER) {\n            return value;\n        }\n        assertNumber(value, 'expecting number, string, ICU_MARKER or ELEMENT_MARKER in OpCode');\n        return value;\n    }\n}\n\nconst BINDING_REGEXP = /�(\\d+):?\\d*�/gi;\nconst ICU_REGEXP = /({\\s*�\\d+:?\\d*�\\s*,\\s*\\S{6}\\s*,[\\s\\S]*})/gi;\nconst NESTED_ICU = /�(\\d+)�/;\nconst ICU_BLOCK_REGEXP = /^\\s*(�\\d+:?\\d*�)\\s*,\\s*(select|plural)\\s*,/;\nconst MARKER = `�`;\nconst SUBTEMPLATE_REGEXP = /�\\/?\\*(\\d+:\\d+)�/gi;\nconst PH_REGEXP = /�(\\/?[#*]\\d+):?\\d*�/gi;\n/**\n * Angular uses the special entity &ngsp; as a placeholder for non-removable space.\n * It's replaced by the 0xE500 PUA (Private Use Areas) unicode character and later on replaced by a\n * space.\n * We are re-implementing the same idea since translations might contain this special character.\n */\nconst NGSP_UNICODE_REGEXP = /\\uE500/g;\nfunction replaceNgsp(value) {\n    return value.replace(NGSP_UNICODE_REGEXP, ' ');\n}\n/**\n * Patch a `debug` property getter on top of the existing object.\n *\n * NOTE: always call this method with `ngDevMode && attachDebugObject(...)`\n *\n * @param obj Object to patch\n * @param debugGetter Getter returning a value to patch\n */\nfunction attachDebugGetter(obj, debugGetter) {\n    if (ngDevMode) {\n        Object.defineProperty(obj, 'debug', { get: debugGetter, enumerable: false });\n    }\n    else {\n        throw new Error('This method should be guarded with `ngDevMode` so that it can be tree shaken in production!');\n    }\n}\n/**\n * Create dynamic nodes from i18n translation block.\n *\n * - Text nodes are created synchronously\n * - TNodes are linked into tree lazily\n *\n * @param tView Current `TView`\n * @parentTNodeIndex index to the parent TNode of this i18n block\n * @param lView Current `LView`\n * @param index Index of `ɵɵi18nStart` instruction.\n * @param message Message to translate.\n * @param subTemplateIndex Index into the sub template of message translation. (ie in case of\n *     `ngIf`) (-1 otherwise)\n */\nfunction i18nStartFirstCreatePass(tView, parentTNodeIndex, lView, index, message, subTemplateIndex) {\n    const rootTNode = getCurrentParentTNode();\n    const createOpCodes = [];\n    const updateOpCodes = [];\n    const existingTNodeStack = [[]];\n    if (ngDevMode) {\n        attachDebugGetter(createOpCodes, i18nCreateOpCodesToString);\n        attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n    }\n    message = getTranslationForTemplate(message, subTemplateIndex);\n    const msgParts = replaceNgsp(message).split(PH_REGEXP);\n    for (let i = 0; i < msgParts.length; i++) {\n        let value = msgParts[i];\n        if ((i & 1) === 0) {\n            // Even indexes are text (including bindings & ICU expressions)\n            const parts = i18nParseTextIntoPartsAndICU(value);\n            for (let j = 0; j < parts.length; j++) {\n                let part = parts[j];\n                if ((j & 1) === 0) {\n                    // `j` is odd therefore `part` is string\n                    const text = part;\n                    ngDevMode && assertString(text, 'Parsed ICU part should be string');\n                    if (text !== '') {\n                        i18nStartFirstCreatePassProcessTextNode(tView, rootTNode, existingTNodeStack[0], createOpCodes, updateOpCodes, lView, text);\n                    }\n                }\n                else {\n                    // `j` is Even therefor `part` is an `ICUExpression`\n                    const icuExpression = part;\n                    // Verify that ICU expression has the right shape. Translations might contain invalid\n                    // constructions (while original messages were correct), so ICU parsing at runtime may\n                    // not succeed (thus `icuExpression` remains a string).\n                    // Note: we intentionally retain the error here by not using `ngDevMode`, because\n                    // the value can change based on the locale and users aren't guaranteed to hit\n                    // an invalid string while they're developing.\n                    if (typeof icuExpression !== 'object') {\n                        throw new Error(`Unable to parse ICU expression in \"${message}\" message.`);\n                    }\n                    const icuContainerTNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodeStack[0], lView, createOpCodes, ngDevMode ? `ICU ${index}:${icuExpression.mainBinding}` : '', true);\n                    const icuNodeIndex = icuContainerTNode.index;\n                    ngDevMode &&\n                        assertGreaterThanOrEqual(icuNodeIndex, HEADER_OFFSET, 'Index must be in absolute LView offset');\n                    icuStart(tView, lView, updateOpCodes, parentTNodeIndex, icuExpression, icuNodeIndex);\n                }\n            }\n        }\n        else {\n            // Odd indexes are placeholders (elements and sub-templates)\n            // At this point value is something like: '/#1:2' (originally coming from '�/#1:2�')\n            const isClosing = value.charCodeAt(0) === 47 /* CharCode.SLASH */;\n            const type = value.charCodeAt(isClosing ? 1 : 0);\n            ngDevMode && assertOneOf(type, 42 /* CharCode.STAR */, 35 /* CharCode.HASH */);\n            const index = HEADER_OFFSET + Number.parseInt(value.substring((isClosing ? 2 : 1)));\n            if (isClosing) {\n                existingTNodeStack.shift();\n                setCurrentTNode(getCurrentParentTNode(), false);\n            }\n            else {\n                const tNode = createTNodePlaceholder(tView, existingTNodeStack[0], index);\n                existingTNodeStack.unshift([]);\n                setCurrentTNode(tNode, true);\n            }\n        }\n    }\n    tView.data[index] = {\n        create: createOpCodes,\n        update: updateOpCodes,\n    };\n}\n/**\n * Allocate space in i18n Range add create OpCode instruction to create a text or comment node.\n *\n * @param tView Current `TView` needed to allocate space in i18n range.\n * @param rootTNode Root `TNode` of the i18n block. This node determines if the new TNode will be\n *     added as part of the `i18nStart` instruction or as part of the `TNode.insertBeforeIndex`.\n * @param existingTNodes internal state for `addTNodeAndUpdateInsertBeforeIndex`.\n * @param lView Current `LView` needed to allocate space in i18n range.\n * @param createOpCodes Array storing `I18nCreateOpCodes` where new opCodes will be added.\n * @param text Text to be added when the `Text` or `Comment` node will be created.\n * @param isICU true if a `Comment` node for ICU (instead of `Text`) node should be created.\n */\nfunction createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, text, isICU) {\n    const i18nNodeIdx = allocExpando(tView, lView, 1, null);\n    let opCode = i18nNodeIdx << I18nCreateOpCode.SHIFT;\n    let parentTNode = getCurrentParentTNode();\n    if (rootTNode === parentTNode) {\n        // FIXME(misko): A null `parentTNode` should represent when we fall of the `LView` boundary.\n        // (there is no parent), but in some circumstances (because we are inconsistent about how we set\n        // `previousOrParentTNode`) it could point to `rootTNode` So this is a work around.\n        parentTNode = null;\n    }\n    if (parentTNode === null) {\n        // If we don't have a parent that means that we can eagerly add nodes.\n        // If we have a parent than these nodes can't be added now (as the parent has not been created\n        // yet) and instead the `parentTNode` is responsible for adding it. See\n        // `TNode.insertBeforeIndex`\n        opCode |= I18nCreateOpCode.APPEND_EAGERLY;\n    }\n    if (isICU) {\n        opCode |= I18nCreateOpCode.COMMENT;\n        ensureIcuContainerVisitorLoaded(loadIcuContainerVisitor);\n    }\n    createOpCodes.push(opCode, text === null ? '' : text);\n    // We store `{{?}}` so that when looking at debug `TNodeType.template` we can see where the\n    // bindings are.\n    const tNode = createTNodeAtIndex(tView, i18nNodeIdx, isICU ? 32 /* TNodeType.Icu */ : 1 /* TNodeType.Text */, text === null ? (ngDevMode ? '{{?}}' : '') : text, null);\n    addTNodeAndUpdateInsertBeforeIndex(existingTNodes, tNode);\n    const tNodeIdx = tNode.index;\n    setCurrentTNode(tNode, false /* Text nodes are self closing */);\n    if (parentTNode !== null && rootTNode !== parentTNode) {\n        // We are a child of deeper node (rather than a direct child of `i18nStart` instruction.)\n        // We have to make sure to add ourselves to the parent.\n        setTNodeInsertBeforeIndex(parentTNode, tNodeIdx);\n    }\n    return tNode;\n}\n/**\n * Processes text node in i18n block.\n *\n * Text nodes can have:\n * - Create instruction in `createOpCodes` for creating the text node.\n * - Allocate spec for text node in i18n range of `LView`\n * - If contains binding:\n *    - bindings => allocate space in i18n range of `LView` to store the binding value.\n *    - populate `updateOpCodes` with update instructions.\n *\n * @param tView Current `TView`\n * @param rootTNode Root `TNode` of the i18n block. This node determines if the new TNode will\n *     be added as part of the `i18nStart` instruction or as part of the\n *     `TNode.insertBeforeIndex`.\n * @param existingTNodes internal state for `addTNodeAndUpdateInsertBeforeIndex`.\n * @param createOpCodes Location where the creation OpCodes will be stored.\n * @param lView Current `LView`\n * @param text The translated text (which may contain binding)\n */\nfunction i18nStartFirstCreatePassProcessTextNode(tView, rootTNode, existingTNodes, createOpCodes, updateOpCodes, lView, text) {\n    const hasBinding = text.match(BINDING_REGEXP);\n    const tNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, hasBinding ? null : text, false);\n    if (hasBinding) {\n        generateBindingUpdateOpCodes(updateOpCodes, text, tNode.index, null, 0, null);\n    }\n}\n/**\n * See `i18nAttributes` above.\n */\nfunction i18nAttributesFirstPass(tView, index, values) {\n    const previousElement = getCurrentTNode();\n    const previousElementIndex = previousElement.index;\n    const updateOpCodes = [];\n    if (ngDevMode) {\n        attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n    }\n    if (tView.firstCreatePass && tView.data[index] === null) {\n        for (let i = 0; i < values.length; i += 2) {\n            const attrName = values[i];\n            const message = values[i + 1];\n            if (message !== '') {\n                // Check if attribute value contains an ICU and throw an error if that's the case.\n                // ICUs in element attributes are not supported.\n                // Note: we intentionally retain the error here by not using `ngDevMode`, because\n                // the `value` can change based on the locale and users aren't guaranteed to hit\n                // an invalid string while they're developing.\n                if (ICU_REGEXP.test(message)) {\n                    throw new Error(`ICU expressions are not supported in attributes. Message: \"${message}\".`);\n                }\n                // i18n attributes that hit this code path are guaranteed to have bindings, because\n                // the compiler treats static i18n attributes as regular attribute bindings.\n                // Since this may not be the first i18n attribute on this element we need to pass in how\n                // many previous bindings there have already been.\n                generateBindingUpdateOpCodes(updateOpCodes, message, previousElementIndex, attrName, countBindings(updateOpCodes), null);\n            }\n        }\n        tView.data[index] = updateOpCodes;\n    }\n}\n/**\n * Generate the OpCodes to update the bindings of a string.\n *\n * @param updateOpCodes Place where the update opcodes will be stored.\n * @param str The string containing the bindings.\n * @param destinationNode Index of the destination node which will receive the binding.\n * @param attrName Name of the attribute, if the string belongs to an attribute.\n * @param sanitizeFn Sanitization function used to sanitize the string after update, if necessary.\n * @param bindingStart The lView index of the next expression that can be bound via an opCode.\n * @returns The mask value for these bindings\n */\nfunction generateBindingUpdateOpCodes(updateOpCodes, str, destinationNode, attrName, bindingStart, sanitizeFn) {\n    ngDevMode &&\n        assertGreaterThanOrEqual(destinationNode, HEADER_OFFSET, 'Index must be in absolute LView offset');\n    const maskIndex = updateOpCodes.length; // Location of mask\n    const sizeIndex = maskIndex + 1; // location of size for skipping\n    updateOpCodes.push(null, null); // Alloc space for mask and size\n    const startIndex = maskIndex + 2; // location of first allocation.\n    if (ngDevMode) {\n        attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n    }\n    const textParts = str.split(BINDING_REGEXP);\n    let mask = 0;\n    for (let j = 0; j < textParts.length; j++) {\n        const textValue = textParts[j];\n        if (j & 1) {\n            // Odd indexes are bindings\n            const bindingIndex = bindingStart + parseInt(textValue, 10);\n            updateOpCodes.push(-1 - bindingIndex);\n            mask = mask | toMaskBit(bindingIndex);\n        }\n        else if (textValue !== '') {\n            // Even indexes are text\n            updateOpCodes.push(textValue);\n        }\n    }\n    updateOpCodes.push(destinationNode << 2 /* I18nUpdateOpCode.SHIFT_REF */ |\n        (attrName ? 1 /* I18nUpdateOpCode.Attr */ : 0 /* I18nUpdateOpCode.Text */));\n    if (attrName) {\n        updateOpCodes.push(attrName, sanitizeFn);\n    }\n    updateOpCodes[maskIndex] = mask;\n    updateOpCodes[sizeIndex] = updateOpCodes.length - startIndex;\n    return mask;\n}\n/**\n * Count the number of bindings in the given `opCodes`.\n *\n * It could be possible to speed this up, by passing the number of bindings found back from\n * `generateBindingUpdateOpCodes()` to `i18nAttributesFirstPass()` but this would then require more\n * complexity in the code and/or transient objects to be created.\n *\n * Since this function is only called once when the template is instantiated, is trivial in the\n * first instance (since `opCodes` will be an empty array), and it is not common for elements to\n * contain multiple i18n bound attributes, it seems like this is a reasonable compromise.\n */\nfunction countBindings(opCodes) {\n    let count = 0;\n    for (let i = 0; i < opCodes.length; i++) {\n        const opCode = opCodes[i];\n        // Bindings are negative numbers.\n        if (typeof opCode === 'number' && opCode < 0) {\n            count++;\n        }\n    }\n    return count;\n}\n/**\n * Convert binding index to mask bit.\n *\n * Each index represents a single bit on the bit-mask. Because bit-mask only has 32 bits, we make\n * the 32nd bit share all masks for all bindings higher than 32. Since it is extremely rare to\n * have more than 32 bindings this will be hit very rarely. The downside of hitting this corner\n * case is that we will execute binding code more often than necessary. (penalty of performance)\n */\nfunction toMaskBit(bindingIndex) {\n    return 1 << Math.min(bindingIndex, 31);\n}\nfunction isRootTemplateMessage(subTemplateIndex) {\n    return subTemplateIndex === -1;\n}\n/**\n * Removes everything inside the sub-templates of a message.\n */\nfunction removeInnerTemplateTranslation(message) {\n    let match;\n    let res = '';\n    let index = 0;\n    let inTemplate = false;\n    let tagMatched;\n    while ((match = SUBTEMPLATE_REGEXP.exec(message)) !== null) {\n        if (!inTemplate) {\n            res += message.substring(index, match.index + match[0].length);\n            tagMatched = match[1];\n            inTemplate = true;\n        }\n        else {\n            if (match[0] === `${MARKER}/*${tagMatched}${MARKER}`) {\n                index = match.index;\n                inTemplate = false;\n            }\n        }\n    }\n    ngDevMode &&\n        assertEqual(inTemplate, false, `Tag mismatch: unable to find the end of the sub-template in the translation \"${message}\"`);\n    res += message.slice(index);\n    return res;\n}\n/**\n * Extracts a part of a message and removes the rest.\n *\n * This method is used for extracting a part of the message associated with a template. A\n * translated message can span multiple templates.\n *\n * Example:\n * ```\n * <div i18n>Translate <span *ngIf>me</span>!</div>\n * ```\n *\n * @param message The message to crop\n * @param subTemplateIndex Index of the sub-template to extract. If undefined it returns the\n * external template and removes all sub-templates.\n */\nfunction getTranslationForTemplate(message, subTemplateIndex) {\n    if (isRootTemplateMessage(subTemplateIndex)) {\n        // We want the root template message, ignore all sub-templates\n        return removeInnerTemplateTranslation(message);\n    }\n    else {\n        // We want a specific sub-template\n        const start = message.indexOf(`:${subTemplateIndex}${MARKER}`) + 2 + subTemplateIndex.toString().length;\n        const end = message.search(new RegExp(`${MARKER}\\\\/\\\\*\\\\d+:${subTemplateIndex}${MARKER}`));\n        return removeInnerTemplateTranslation(message.substring(start, end));\n    }\n}\n/**\n * Generate the OpCodes for ICU expressions.\n *\n * @param icuExpression\n * @param index Index where the anchor is stored and an optional `TIcuContainerNode`\n *   - `lView[anchorIdx]` points to a `Comment` node representing the anchor for the ICU.\n *   - `tView.data[anchorIdx]` points to the `TIcuContainerNode` if ICU is root (`null` otherwise)\n */\nfunction icuStart(tView, lView, updateOpCodes, parentIdx, icuExpression, anchorIdx) {\n    ngDevMode && assertDefined(icuExpression, 'ICU expression must be defined');\n    let bindingMask = 0;\n    const tIcu = {\n        type: icuExpression.type,\n        currentCaseLViewIndex: allocExpando(tView, lView, 1, null),\n        anchorIdx,\n        cases: [],\n        create: [],\n        remove: [],\n        update: []\n    };\n    addUpdateIcuSwitch(updateOpCodes, icuExpression, anchorIdx);\n    setTIcu(tView, anchorIdx, tIcu);\n    const values = icuExpression.values;\n    for (let i = 0; i < values.length; i++) {\n        // Each value is an array of strings & other ICU expressions\n        const valueArr = values[i];\n        const nestedIcus = [];\n        for (let j = 0; j < valueArr.length; j++) {\n            const value = valueArr[j];\n            if (typeof value !== 'string') {\n                // It is an nested ICU expression\n                const icuIndex = nestedIcus.push(value) - 1;\n                // Replace nested ICU expression by a comment node\n                valueArr[j] = `<!--�${icuIndex}�-->`;\n            }\n        }\n        bindingMask = parseIcuCase(tView, tIcu, lView, updateOpCodes, parentIdx, icuExpression.cases[i], valueArr.join(''), nestedIcus) |\n            bindingMask;\n    }\n    if (bindingMask) {\n        addUpdateIcuUpdate(updateOpCodes, bindingMask, anchorIdx);\n    }\n}\n/**\n * Parses text containing an ICU expression and produces a JSON object for it.\n * Original code from closure library, modified for Angular.\n *\n * @param pattern Text containing an ICU expression that needs to be parsed.\n *\n */\nfunction parseICUBlock(pattern) {\n    const cases = [];\n    const values = [];\n    let icuType = 1 /* IcuType.plural */;\n    let mainBinding = 0;\n    pattern = pattern.replace(ICU_BLOCK_REGEXP, function (str, binding, type) {\n        if (type === 'select') {\n            icuType = 0 /* IcuType.select */;\n        }\n        else {\n            icuType = 1 /* IcuType.plural */;\n        }\n        mainBinding = parseInt(binding.slice(1), 10);\n        return '';\n    });\n    const parts = i18nParseTextIntoPartsAndICU(pattern);\n    // Looking for (key block)+ sequence. One of the keys has to be \"other\".\n    for (let pos = 0; pos < parts.length;) {\n        let key = parts[pos++].trim();\n        if (icuType === 1 /* IcuType.plural */) {\n            // Key can be \"=x\", we just want \"x\"\n            key = key.replace(/\\s*(?:=)?(\\w+)\\s*/, '$1');\n        }\n        if (key.length) {\n            cases.push(key);\n        }\n        const blocks = i18nParseTextIntoPartsAndICU(parts[pos++]);\n        if (cases.length > values.length) {\n            values.push(blocks);\n        }\n    }\n    // TODO(ocombe): support ICU expressions in attributes, see #21615\n    return { type: icuType, mainBinding: mainBinding, cases, values };\n}\n/**\n * Breaks pattern into strings and top level {...} blocks.\n * Can be used to break a message into text and ICU expressions, or to break an ICU expression\n * into keys and cases. Original code from closure library, modified for Angular.\n *\n * @param pattern (sub)Pattern to be broken.\n * @returns An `Array<string|IcuExpression>` where:\n *   - odd positions: `string` => text between ICU expressions\n *   - even positions: `ICUExpression` => ICU expression parsed into `ICUExpression` record.\n */\nfunction i18nParseTextIntoPartsAndICU(pattern) {\n    if (!pattern) {\n        return [];\n    }\n    let prevPos = 0;\n    const braceStack = [];\n    const results = [];\n    const braces = /[{}]/g;\n    // lastIndex doesn't get set to 0 so we have to.\n    braces.lastIndex = 0;\n    let match;\n    while (match = braces.exec(pattern)) {\n        const pos = match.index;\n        if (match[0] == '}') {\n            braceStack.pop();\n            if (braceStack.length == 0) {\n                // End of the block.\n                const block = pattern.substring(prevPos, pos);\n                if (ICU_BLOCK_REGEXP.test(block)) {\n                    results.push(parseICUBlock(block));\n                }\n                else {\n                    results.push(block);\n                }\n                prevPos = pos + 1;\n            }\n        }\n        else {\n            if (braceStack.length == 0) {\n                const substring = pattern.substring(prevPos, pos);\n                results.push(substring);\n                prevPos = pos + 1;\n            }\n            braceStack.push('{');\n        }\n    }\n    const substring = pattern.substring(prevPos);\n    results.push(substring);\n    return results;\n}\n/**\n * Parses a node, its children and its siblings, and generates the mutate & update OpCodes.\n *\n */\nfunction parseIcuCase(tView, tIcu, lView, updateOpCodes, parentIdx, caseName, unsafeCaseHtml, nestedIcus) {\n    const create = [];\n    const remove = [];\n    const update = [];\n    if (ngDevMode) {\n        attachDebugGetter(create, icuCreateOpCodesToString);\n        attachDebugGetter(remove, i18nRemoveOpCodesToString);\n        attachDebugGetter(update, i18nUpdateOpCodesToString);\n    }\n    tIcu.cases.push(caseName);\n    tIcu.create.push(create);\n    tIcu.remove.push(remove);\n    tIcu.update.push(update);\n    const inertBodyHelper = getInertBodyHelper(getDocument());\n    const inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeCaseHtml);\n    ngDevMode && assertDefined(inertBodyElement, 'Unable to generate inert body element');\n    const inertRootNode = getTemplateContent(inertBodyElement) || inertBodyElement;\n    if (inertRootNode) {\n        return walkIcuTree(tView, tIcu, lView, updateOpCodes, create, remove, update, inertRootNode, parentIdx, nestedIcus, 0);\n    }\n    else {\n        return 0;\n    }\n}\nfunction walkIcuTree(tView, tIcu, lView, sharedUpdateOpCodes, create, remove, update, parentNode, parentIdx, nestedIcus, depth) {\n    let bindingMask = 0;\n    let currentNode = parentNode.firstChild;\n    while (currentNode) {\n        const newIndex = allocExpando(tView, lView, 1, null);\n        switch (currentNode.nodeType) {\n            case Node.ELEMENT_NODE:\n                const element = currentNode;\n                const tagName = element.tagName.toLowerCase();\n                if (VALID_ELEMENTS.hasOwnProperty(tagName)) {\n                    addCreateNodeAndAppend(create, ELEMENT_MARKER, tagName, parentIdx, newIndex);\n                    tView.data[newIndex] = tagName;\n                    const elAttrs = element.attributes;\n                    for (let i = 0; i < elAttrs.length; i++) {\n                        const attr = elAttrs.item(i);\n                        const lowerAttrName = attr.name.toLowerCase();\n                        const hasBinding = !!attr.value.match(BINDING_REGEXP);\n                        // we assume the input string is safe, unless it's using a binding\n                        if (hasBinding) {\n                            if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {\n                                if (URI_ATTRS[lowerAttrName]) {\n                                    generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, _sanitizeUrl);\n                                }\n                                else {\n                                    generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, null);\n                                }\n                            }\n                            else {\n                                ngDevMode &&\n                                    console.warn(`WARNING: ignoring unsafe attribute value ` +\n                                        `${lowerAttrName} on element ${tagName} ` +\n                                        `(see ${XSS_SECURITY_URL})`);\n                            }\n                        }\n                        else {\n                            addCreateAttribute(create, newIndex, attr);\n                        }\n                    }\n                    // Parse the children of this node (if any)\n                    bindingMask = walkIcuTree(tView, tIcu, lView, sharedUpdateOpCodes, create, remove, update, currentNode, newIndex, nestedIcus, depth + 1) |\n                        bindingMask;\n                    addRemoveNode(remove, newIndex, depth);\n                }\n                break;\n            case Node.TEXT_NODE:\n                const value = currentNode.textContent || '';\n                const hasBinding = value.match(BINDING_REGEXP);\n                addCreateNodeAndAppend(create, null, hasBinding ? '' : value, parentIdx, newIndex);\n                addRemoveNode(remove, newIndex, depth);\n                if (hasBinding) {\n                    bindingMask =\n                        generateBindingUpdateOpCodes(update, value, newIndex, null, 0, null) | bindingMask;\n                }\n                break;\n            case Node.COMMENT_NODE:\n                // Check if the comment node is a placeholder for a nested ICU\n                const isNestedIcu = NESTED_ICU.exec(currentNode.textContent || '');\n                if (isNestedIcu) {\n                    const nestedIcuIndex = parseInt(isNestedIcu[1], 10);\n                    const icuExpression = nestedIcus[nestedIcuIndex];\n                    // Create the comment node that will anchor the ICU expression\n                    addCreateNodeAndAppend(create, ICU_MARKER, ngDevMode ? `nested ICU ${nestedIcuIndex}` : '', parentIdx, newIndex);\n                    icuStart(tView, lView, sharedUpdateOpCodes, parentIdx, icuExpression, newIndex);\n                    addRemoveNestedIcu(remove, newIndex, depth);\n                }\n                break;\n        }\n        currentNode = currentNode.nextSibling;\n    }\n    return bindingMask;\n}\nfunction addRemoveNode(remove, index, depth) {\n    if (depth === 0) {\n        remove.push(index);\n    }\n}\nfunction addRemoveNestedIcu(remove, index, depth) {\n    if (depth === 0) {\n        remove.push(~index); // remove ICU at `index`\n        remove.push(index); // remove ICU comment at `index`\n    }\n}\nfunction addUpdateIcuSwitch(update, icuExpression, index) {\n    update.push(toMaskBit(icuExpression.mainBinding), 2, -1 - icuExpression.mainBinding, index << 2 /* I18nUpdateOpCode.SHIFT_REF */ | 2 /* I18nUpdateOpCode.IcuSwitch */);\n}\nfunction addUpdateIcuUpdate(update, bindingMask, index) {\n    update.push(bindingMask, 1, index << 2 /* I18nUpdateOpCode.SHIFT_REF */ | 3 /* I18nUpdateOpCode.IcuUpdate */);\n}\nfunction addCreateNodeAndAppend(create, marker, text, appendToParentIdx, createAtIdx) {\n    if (marker !== null) {\n        create.push(marker);\n    }\n    create.push(text, createAtIdx, icuCreateOpCode(0 /* IcuCreateOpCode.AppendChild */, appendToParentIdx, createAtIdx));\n}\nfunction addCreateAttribute(create, newIndex, attr) {\n    create.push(newIndex << 1 /* IcuCreateOpCode.SHIFT_REF */ | 1 /* IcuCreateOpCode.Attr */, attr.name, attr.value);\n}\n\n// i18nPostprocess consts\nconst ROOT_TEMPLATE_ID = 0;\nconst PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\\[(�.+?�?)\\]/;\nconst PP_PLACEHOLDERS_REGEXP = /\\[(�.+?�?)\\]|(�\\/?\\*\\d+:\\d+�)/g;\nconst PP_ICU_VARS_REGEXP = /({\\s*)(VAR_(PLURAL|SELECT)(_\\d+)?)(\\s*,)/g;\nconst PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;\nconst PP_ICUS_REGEXP = /�I18N_EXP_(ICU(_\\d+)?)�/g;\nconst PP_CLOSE_TEMPLATE_REGEXP = /\\/\\*/;\nconst PP_TEMPLATE_ID_REGEXP = /\\d+\\:(\\d+)/;\n/**\n * Handles message string post-processing for internationalization.\n *\n * Handles message string post-processing by transforming it from intermediate\n * format (that might contain some markers that we need to replace) to the final\n * form, consumable by i18nStart instruction. Post processing steps include:\n *\n * 1. Resolve all multi-value cases (like [�*1:1��#2:1�|�#4:1�|�5�])\n * 2. Replace all ICU vars (like \"VAR_PLURAL\")\n * 3. Replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n * 4. Replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�)\n *    in case multiple ICUs have the same placeholder name\n *\n * @param message Raw translation string for post processing\n * @param replacements Set of replacements that should be applied\n *\n * @returns Transformed string that can be consumed by i18nStart instruction\n *\n * @codeGenApi\n */\nfunction i18nPostprocess(message, replacements = {}) {\n    /**\n     * Step 1: resolve all multi-value placeholders like [�#5�|�*1:1��#2:1�|�#4:1�]\n     *\n     * Note: due to the way we process nested templates (BFS), multi-value placeholders are typically\n     * grouped by templates, for example: [�#5�|�#6�|�#1:1�|�#3:2�] where �#5� and �#6� belong to root\n     * template, �#1:1� belong to nested template with index 1 and �#1:2� - nested template with index\n     * 3. However in real templates the order might be different: i.e. �#1:1� and/or �#3:2� may go in\n     * front of �#6�. The post processing step restores the right order by keeping track of the\n     * template id stack and looks for placeholders that belong to the currently active template.\n     */\n    let result = message;\n    if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)) {\n        const matches = {};\n        const templateIdsStack = [ROOT_TEMPLATE_ID];\n        result = result.replace(PP_PLACEHOLDERS_REGEXP, (m, phs, tmpl) => {\n            const content = phs || tmpl;\n            const placeholders = matches[content] || [];\n            if (!placeholders.length) {\n                content.split('|').forEach((placeholder) => {\n                    const match = placeholder.match(PP_TEMPLATE_ID_REGEXP);\n                    const templateId = match ? parseInt(match[1], 10) : ROOT_TEMPLATE_ID;\n                    const isCloseTemplateTag = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder);\n                    placeholders.push([templateId, isCloseTemplateTag, placeholder]);\n                });\n                matches[content] = placeholders;\n            }\n            if (!placeholders.length) {\n                throw new Error(`i18n postprocess: unmatched placeholder - ${content}`);\n            }\n            const currentTemplateId = templateIdsStack[templateIdsStack.length - 1];\n            let idx = 0;\n            // find placeholder index that matches current template id\n            for (let i = 0; i < placeholders.length; i++) {\n                if (placeholders[i][0] === currentTemplateId) {\n                    idx = i;\n                    break;\n                }\n            }\n            // update template id stack based on the current tag extracted\n            const [templateId, isCloseTemplateTag, placeholder] = placeholders[idx];\n            if (isCloseTemplateTag) {\n                templateIdsStack.pop();\n            }\n            else if (currentTemplateId !== templateId) {\n                templateIdsStack.push(templateId);\n            }\n            // remove processed tag from the list\n            placeholders.splice(idx, 1);\n            return placeholder;\n        });\n    }\n    // return current result if no replacements specified\n    if (!Object.keys(replacements).length) {\n        return result;\n    }\n    /**\n     * Step 2: replace all ICU vars (like \"VAR_PLURAL\")\n     */\n    result = result.replace(PP_ICU_VARS_REGEXP, (match, start, key, _type, _idx, end) => {\n        return replacements.hasOwnProperty(key) ? `${start}${replacements[key]}${end}` : match;\n    });\n    /**\n     * Step 3: replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n     */\n    result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP, (match, key) => {\n        return replacements.hasOwnProperty(key) ? replacements[key] : match;\n    });\n    /**\n     * Step 4: replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�) in case\n     * multiple ICUs have the same placeholder name\n     */\n    result = result.replace(PP_ICUS_REGEXP, (match, key) => {\n        if (replacements.hasOwnProperty(key)) {\n            const list = replacements[key];\n            if (!list.length) {\n                throw new Error(`i18n postprocess: unmatched ICU - ${match} with key: ${key}`);\n            }\n            return list.shift();\n        }\n        return match;\n    });\n    return result;\n}\n\n/**\n * Marks a block of text as translatable.\n *\n * The instructions `i18nStart` and `i18nEnd` mark the translation block in the template.\n * The translation `message` is the value which is locale specific. The translation string may\n * contain placeholders which associate inner elements and sub-templates within the translation.\n *\n * The translation `message` placeholders are:\n * - `�{index}(:{block})�`: *Binding Placeholder*: Marks a location where an expression will be\n *   interpolated into. The placeholder `index` points to the expression binding index. An optional\n *   `block` that matches the sub-template in which it was declared.\n * - `�#{index}(:{block})�`/`�/#{index}(:{block})�`: *Element Placeholder*:  Marks the beginning\n *   and end of DOM element that were embedded in the original translation block. The placeholder\n *   `index` points to the element index in the template instructions set. An optional `block` that\n *   matches the sub-template in which it was declared.\n * - `�*{index}:{block}�`/`�/*{index}:{block}�`: *Sub-template Placeholder*: Sub-templates must be\n *   split up and translated separately in each angular template function. The `index` points to the\n *   `template` instruction index. A `block` that matches the sub-template in which it was declared.\n *\n * @param index A unique index of the translation in the static block.\n * @param messageIndex An index of the translation message from the `def.consts` array.\n * @param subTemplateIndex Optional sub-template index in the `message`.\n *\n * @codeGenApi\n */\nfunction ɵɵi18nStart(index, messageIndex, subTemplateIndex = -1) {\n    const tView = getTView();\n    const lView = getLView();\n    const adjustedIndex = HEADER_OFFSET + index;\n    ngDevMode && assertDefined(tView, `tView should be defined`);\n    const message = getConstant(tView.consts, messageIndex);\n    const parentTNode = getCurrentParentTNode();\n    if (tView.firstCreatePass) {\n        i18nStartFirstCreatePass(tView, parentTNode === null ? 0 : parentTNode.index, lView, adjustedIndex, message, subTemplateIndex);\n    }\n    // Set a flag that this LView has i18n blocks.\n    // The flag is later used to determine whether this component should\n    // be hydrated (currently hydration is not supported for i18n blocks).\n    if (tView.type === 2 /* TViewType.Embedded */) {\n        // Annotate host component's LView (not embedded view's LView),\n        // since hydration can be skipped on per-component basis only.\n        const componentLView = lView[DECLARATION_COMPONENT_VIEW];\n        componentLView[FLAGS] |= 32 /* LViewFlags.HasI18n */;\n    }\n    else {\n        lView[FLAGS] |= 32 /* LViewFlags.HasI18n */;\n    }\n    const tI18n = tView.data[adjustedIndex];\n    const sameViewParentTNode = parentTNode === lView[T_HOST] ? null : parentTNode;\n    const parentRNode = getClosestRElement(tView, sameViewParentTNode, lView);\n    // If `parentTNode` is an `ElementContainer` than it has `<!--ng-container--->`.\n    // When we do inserts we have to make sure to insert in front of `<!--ng-container--->`.\n    const insertInFrontOf = parentTNode && (parentTNode.type & 8 /* TNodeType.ElementContainer */) ?\n        lView[parentTNode.index] :\n        null;\n    applyCreateOpCodes(lView, tI18n.create, parentRNode, insertInFrontOf);\n    setInI18nBlock(true);\n}\n/**\n * Translates a translation block marked by `i18nStart` and `i18nEnd`. It inserts the text/ICU nodes\n * into the render tree, moves the placeholder nodes and removes the deleted nodes.\n *\n * @codeGenApi\n */\nfunction ɵɵi18nEnd() {\n    setInI18nBlock(false);\n}\n/**\n *\n * Use this instruction to create a translation block that doesn't contain any placeholder.\n * It calls both {@link i18nStart} and {@link i18nEnd} in one instruction.\n *\n * The translation `message` is the value which is locale specific. The translation string may\n * contain placeholders which associate inner elements and sub-templates within the translation.\n *\n * The translation `message` placeholders are:\n * - `�{index}(:{block})�`: *Binding Placeholder*: Marks a location where an expression will be\n *   interpolated into. The placeholder `index` points to the expression binding index. An optional\n *   `block` that matches the sub-template in which it was declared.\n * - `�#{index}(:{block})�`/`�/#{index}(:{block})�`: *Element Placeholder*:  Marks the beginning\n *   and end of DOM element that were embedded in the original translation block. The placeholder\n *   `index` points to the element index in the template instructions set. An optional `block` that\n *   matches the sub-template in which it was declared.\n * - `�*{index}:{block}�`/`�/*{index}:{block}�`: *Sub-template Placeholder*: Sub-templates must be\n *   split up and translated separately in each angular template function. The `index` points to the\n *   `template` instruction index. A `block` that matches the sub-template in which it was declared.\n *\n * @param index A unique index of the translation in the static block.\n * @param messageIndex An index of the translation message from the `def.consts` array.\n * @param subTemplateIndex Optional sub-template index in the `message`.\n *\n * @codeGenApi\n */\nfunction ɵɵi18n(index, messageIndex, subTemplateIndex) {\n    ɵɵi18nStart(index, messageIndex, subTemplateIndex);\n    ɵɵi18nEnd();\n}\n/**\n * Marks a list of attributes as translatable.\n *\n * @param index A unique index in the static block\n * @param values\n *\n * @codeGenApi\n */\nfunction ɵɵi18nAttributes(index, attrsIndex) {\n    const tView = getTView();\n    ngDevMode && assertDefined(tView, `tView should be defined`);\n    const attrs = getConstant(tView.consts, attrsIndex);\n    i18nAttributesFirstPass(tView, index + HEADER_OFFSET, attrs);\n}\n/**\n * Stores the values of the bindings during each update cycle in order to determine if we need to\n * update the translated nodes.\n *\n * @param value The binding's value\n * @returns This function returns itself so that it may be chained\n * (e.g. `i18nExp(ctx.name)(ctx.title)`)\n *\n * @codeGenApi\n */\nfunction ɵɵi18nExp(value) {\n    const lView = getLView();\n    setMaskBit(bindingUpdated(lView, nextBindingIndex(), value));\n    return ɵɵi18nExp;\n}\n/**\n * Updates a translation block or an i18n attribute when the bindings have changed.\n *\n * @param index Index of either {@link i18nStart} (translation block) or {@link i18nAttributes}\n * (i18n attribute) on which it should update the content.\n *\n * @codeGenApi\n */\nfunction ɵɵi18nApply(index) {\n    applyI18n(getTView(), getLView(), index + HEADER_OFFSET);\n}\n/**\n * Handles message string post-processing for internationalization.\n *\n * Handles message string post-processing by transforming it from intermediate\n * format (that might contain some markers that we need to replace) to the final\n * form, consumable by i18nStart instruction. Post processing steps include:\n *\n * 1. Resolve all multi-value cases (like [�*1:1��#2:1�|�#4:1�|�5�])\n * 2. Replace all ICU vars (like \"VAR_PLURAL\")\n * 3. Replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n * 4. Replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�)\n *    in case multiple ICUs have the same placeholder name\n *\n * @param message Raw translation string for post processing\n * @param replacements Set of replacements that should be applied\n *\n * @returns Transformed string that can be consumed by i18nStart instruction\n *\n * @codeGenApi\n */\nfunction ɵɵi18nPostprocess(message, replacements = {}) {\n    return i18nPostprocess(message, replacements);\n}\n\n/**\n * Creates runtime data structures for `{#defer}` blocks.\n *\n * @param index The index of the defer block in the data array\n * @param deferredDepsFn Function that contains dependencies for this defer block\n *\n * @codeGenApi\n */\nfunction ɵɵdefer(index, deferredDepsFn) {\n    // TODO: implement runtime logic.\n}\n\n/*\n * This file re-exports all symbols contained in this directory.\n *\n * Why is this file not `index.ts`?\n *\n * There seems to be an inconsistent path resolution of an `index.ts` file\n * when only the parent directory is referenced. This could be due to the\n * node module resolution configuration differing from rollup and/or typescript.\n *\n * With commit\n * https://github.com/angular/angular/commit/d5e3f2c64bd13ce83e7c70788b7fc514ca4a9918\n * the `instructions.ts` file was moved to `instructions/instructions.ts` and an\n * `index.ts` file was used to re-export everything. Having had file names that were\n * importing from `instructions' directly (not the from the sub file or the `index.ts`\n * file) caused strange CI issues. `index.ts` had to be renamed to `all.ts` for this\n * to work.\n *\n * Jira Issue = FW-1184\n */\n\n/**\n * Resolves the providers which are defined in the DirectiveDef.\n *\n * When inserting the tokens and the factories in their respective arrays, we can assume that\n * this method is called first for the component (if any), and then for other directives on the same\n * node.\n * As a consequence,the providers are always processed in that order:\n * 1) The view providers of the component\n * 2) The providers of the component\n * 3) The providers of the other directives\n * This matches the structure of the injectables arrays of a view (for each node).\n * So the tokens and the factories can be pushed at the end of the arrays, except\n * in one case for multi providers.\n *\n * @param def the directive definition\n * @param providers: Array of `providers`.\n * @param viewProviders: Array of `viewProviders`.\n */\nfunction providersResolver(def, providers, viewProviders) {\n    const tView = getTView();\n    if (tView.firstCreatePass) {\n        const isComponent = isComponentDef(def);\n        // The list of view providers is processed first, and the flags are updated\n        resolveProvider(viewProviders, tView.data, tView.blueprint, isComponent, true);\n        // Then, the list of providers is processed, and the flags are updated\n        resolveProvider(providers, tView.data, tView.blueprint, isComponent, false);\n    }\n}\n/**\n * Resolves a provider and publishes it to the DI system.\n */\nfunction resolveProvider(provider, tInjectables, lInjectablesBlueprint, isComponent, isViewProvider) {\n    provider = resolveForwardRef(provider);\n    if (Array.isArray(provider)) {\n        // Recursively call `resolveProvider`\n        // Recursion is OK in this case because this code will not be in hot-path once we implement\n        // cloning of the initial state.\n        for (let i = 0; i < provider.length; i++) {\n            resolveProvider(provider[i], tInjectables, lInjectablesBlueprint, isComponent, isViewProvider);\n        }\n    }\n    else {\n        const tView = getTView();\n        const lView = getLView();\n        const tNode = getCurrentTNode();\n        let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide);\n        const providerFactory = providerToFactory(provider);\n        if (ngDevMode) {\n            const injector = new NodeInjector(tNode, lView);\n            runInInjectorProfilerContext(injector, token, () => {\n                emitProviderConfiguredEvent(provider, isViewProvider);\n            });\n        }\n        const beginIndex = tNode.providerIndexes & 1048575 /* TNodeProviderIndexes.ProvidersStartIndexMask */;\n        const endIndex = tNode.directiveStart;\n        const cptViewProvidersCount = tNode.providerIndexes >> 20 /* TNodeProviderIndexes.CptViewProvidersCountShift */;\n        if (isTypeProvider(provider) || !provider.multi) {\n            // Single provider case: the factory is created and pushed immediately\n            const factory = new NodeInjectorFactory(providerFactory, isViewProvider, ɵɵdirectiveInject);\n            const existingFactoryIndex = indexOf(token, tInjectables, isViewProvider ? beginIndex : beginIndex + cptViewProvidersCount, endIndex);\n            if (existingFactoryIndex === -1) {\n                diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);\n                registerDestroyHooksIfSupported(tView, provider, tInjectables.length);\n                tInjectables.push(token);\n                tNode.directiveStart++;\n                tNode.directiveEnd++;\n                if (isViewProvider) {\n                    tNode.providerIndexes += 1048576 /* TNodeProviderIndexes.CptViewProvidersCountShifter */;\n                }\n                lInjectablesBlueprint.push(factory);\n                lView.push(factory);\n            }\n            else {\n                lInjectablesBlueprint[existingFactoryIndex] = factory;\n                lView[existingFactoryIndex] = factory;\n            }\n        }\n        else {\n            // Multi provider case:\n            // We create a multi factory which is going to aggregate all the values.\n            // Since the output of such a factory depends on content or view injection,\n            // we create two of them, which are linked together.\n            //\n            // The first one (for view providers) is always in the first block of the injectables array,\n            // and the second one (for providers) is always in the second block.\n            // This is important because view providers have higher priority. When a multi token\n            // is being looked up, the view providers should be found first.\n            // Note that it is not possible to have a multi factory in the third block (directive block).\n            //\n            // The algorithm to process multi providers is as follows:\n            // 1) If the multi provider comes from the `viewProviders` of the component:\n            //   a) If the special view providers factory doesn't exist, it is created and pushed.\n            //   b) Else, the multi provider is added to the existing multi factory.\n            // 2) If the multi provider comes from the `providers` of the component or of another\n            // directive:\n            //   a) If the multi factory doesn't exist, it is created and provider pushed into it.\n            //      It is also linked to the multi factory for view providers, if it exists.\n            //   b) Else, the multi provider is added to the existing multi factory.\n            const existingProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex + cptViewProvidersCount, endIndex);\n            const existingViewProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex, beginIndex + cptViewProvidersCount);\n            const doesProvidersFactoryExist = existingProvidersFactoryIndex >= 0 &&\n                lInjectablesBlueprint[existingProvidersFactoryIndex];\n            const doesViewProvidersFactoryExist = existingViewProvidersFactoryIndex >= 0 &&\n                lInjectablesBlueprint[existingViewProvidersFactoryIndex];\n            if (isViewProvider && !doesViewProvidersFactoryExist ||\n                !isViewProvider && !doesProvidersFactoryExist) {\n                // Cases 1.a and 2.a\n                diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);\n                const factory = multiFactory(isViewProvider ? multiViewProvidersFactoryResolver : multiProvidersFactoryResolver, lInjectablesBlueprint.length, isViewProvider, isComponent, providerFactory);\n                if (!isViewProvider && doesViewProvidersFactoryExist) {\n                    lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory = factory;\n                }\n                registerDestroyHooksIfSupported(tView, provider, tInjectables.length, 0);\n                tInjectables.push(token);\n                tNode.directiveStart++;\n                tNode.directiveEnd++;\n                if (isViewProvider) {\n                    tNode.providerIndexes += 1048576 /* TNodeProviderIndexes.CptViewProvidersCountShifter */;\n                }\n                lInjectablesBlueprint.push(factory);\n                lView.push(factory);\n            }\n            else {\n                // Cases 1.b and 2.b\n                const indexInFactory = multiFactoryAdd(lInjectablesBlueprint[isViewProvider ? existingViewProvidersFactoryIndex :\n                    existingProvidersFactoryIndex], providerFactory, !isViewProvider && isComponent);\n                registerDestroyHooksIfSupported(tView, provider, existingProvidersFactoryIndex > -1 ? existingProvidersFactoryIndex :\n                    existingViewProvidersFactoryIndex, indexInFactory);\n            }\n            if (!isViewProvider && isComponent && doesViewProvidersFactoryExist) {\n                lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders++;\n            }\n        }\n    }\n}\n/**\n * Registers the `ngOnDestroy` hook of a provider, if the provider supports destroy hooks.\n * @param tView `TView` in which to register the hook.\n * @param provider Provider whose hook should be registered.\n * @param contextIndex Index under which to find the context for the hook when it's being invoked.\n * @param indexInFactory Only required for `multi` providers. Index of the provider in the multi\n * provider factory.\n */\nfunction registerDestroyHooksIfSupported(tView, provider, contextIndex, indexInFactory) {\n    const providerIsTypeProvider = isTypeProvider(provider);\n    const providerIsClassProvider = isClassProvider(provider);\n    if (providerIsTypeProvider || providerIsClassProvider) {\n        // Resolve forward references as `useClass` can hold a forward reference.\n        const classToken = providerIsClassProvider ? resolveForwardRef(provider.useClass) : provider;\n        const prototype = classToken.prototype;\n        const ngOnDestroy = prototype.ngOnDestroy;\n        if (ngOnDestroy) {\n            const hooks = tView.destroyHooks || (tView.destroyHooks = []);\n            if (!providerIsTypeProvider && provider.multi) {\n                ngDevMode &&\n                    assertDefined(indexInFactory, 'indexInFactory when registering multi factory destroy hook');\n                const existingCallbacksIndex = hooks.indexOf(contextIndex);\n                if (existingCallbacksIndex === -1) {\n                    hooks.push(contextIndex, [indexInFactory, ngOnDestroy]);\n                }\n                else {\n                    hooks[existingCallbacksIndex + 1].push(indexInFactory, ngOnDestroy);\n                }\n            }\n            else {\n                hooks.push(contextIndex, ngOnDestroy);\n            }\n        }\n    }\n}\n/**\n * Add a factory in a multi factory.\n * @returns Index at which the factory was inserted.\n */\nfunction multiFactoryAdd(multiFactory, factory, isComponentProvider) {\n    if (isComponentProvider) {\n        multiFactory.componentProviders++;\n    }\n    return multiFactory.multi.push(factory) - 1;\n}\n/**\n * Returns the index of item in the array, but only in the begin to end range.\n */\nfunction indexOf(item, arr, begin, end) {\n    for (let i = begin; i < end; i++) {\n        if (arr[i] === item)\n            return i;\n    }\n    return -1;\n}\n/**\n * Use this with `multi` `providers`.\n */\nfunction multiProvidersFactoryResolver(_, tData, lData, tNode) {\n    return multiResolve(this.multi, []);\n}\n/**\n * Use this with `multi` `viewProviders`.\n *\n * This factory knows how to concatenate itself with the existing `multi` `providers`.\n */\nfunction multiViewProvidersFactoryResolver(_, tData, lView, tNode) {\n    const factories = this.multi;\n    let result;\n    if (this.providerFactory) {\n        const componentCount = this.providerFactory.componentProviders;\n        const multiProviders = getNodeInjectable(lView, lView[TVIEW], this.providerFactory.index, tNode);\n        // Copy the section of the array which contains `multi` `providers` from the component\n        result = multiProviders.slice(0, componentCount);\n        // Insert the `viewProvider` instances.\n        multiResolve(factories, result);\n        // Copy the section of the array which contains `multi` `providers` from other directives\n        for (let i = componentCount; i < multiProviders.length; i++) {\n            result.push(multiProviders[i]);\n        }\n    }\n    else {\n        result = [];\n        // Insert the `viewProvider` instances.\n        multiResolve(factories, result);\n    }\n    return result;\n}\n/**\n * Maps an array of factories into an array of values.\n */\nfunction multiResolve(factories, result) {\n    for (let i = 0; i < factories.length; i++) {\n        const factory = factories[i];\n        result.push(factory());\n    }\n    return result;\n}\n/**\n * Creates a multi factory.\n */\nfunction multiFactory(factoryFn, index, isViewProvider, isComponent, f) {\n    const factory = new NodeInjectorFactory(factoryFn, isViewProvider, ɵɵdirectiveInject);\n    factory.multi = [];\n    factory.index = index;\n    factory.componentProviders = 0;\n    multiFactoryAdd(factory, f, isComponent && !isViewProvider);\n    return factory;\n}\n\n/**\n * This feature resolves the providers of a directive (or component),\n * and publish them into the DI system, making it visible to others for injection.\n *\n * For example:\n * ```ts\n * class ComponentWithProviders {\n *   constructor(private greeter: GreeterDE) {}\n *\n *   static ɵcmp = defineComponent({\n *     type: ComponentWithProviders,\n *     selectors: [['component-with-providers']],\n *    factory: () => new ComponentWithProviders(directiveInject(GreeterDE as any)),\n *    decls: 1,\n *    vars: 1,\n *    template: function(fs: RenderFlags, ctx: ComponentWithProviders) {\n *      if (fs & RenderFlags.Create) {\n *        ɵɵtext(0);\n *      }\n *      if (fs & RenderFlags.Update) {\n *        ɵɵtextInterpolate(ctx.greeter.greet());\n *      }\n *    },\n *    features: [ɵɵProvidersFeature([GreeterDE])]\n *  });\n * }\n * ```\n *\n * @param definition\n *\n * @codeGenApi\n */\nfunction ɵɵProvidersFeature(providers, viewProviders = []) {\n    return (definition) => {\n        definition.providersResolver =\n            (def, processProvidersFn) => {\n                return providersResolver(def, //\n                processProvidersFn ? processProvidersFn(providers) : providers, //\n                viewProviders);\n            };\n    };\n}\n\n/**\n * Represents an instance of an `NgModule` created by an `NgModuleFactory`.\n * Provides access to the `NgModule` instance and related objects.\n *\n * @publicApi\n */\nclass NgModuleRef$1 {\n}\n/**\n * @publicApi\n *\n * @deprecated\n * This class was mostly used as a part of ViewEngine-based JIT API and is no longer needed in Ivy\n * JIT mode. See [JIT API changes due to ViewEngine deprecation](guide/deprecations#jit-api-changes)\n * for additional context. Angular provides APIs that accept NgModule classes directly (such as\n * [PlatformRef.bootstrapModule](api/core/PlatformRef#bootstrapModule) and\n * [createNgModule](api/core/createNgModule)), consider switching to those APIs instead of\n * using factory-based ones.\n */\nclass NgModuleFactory$1 {\n}\n\n/**\n * Returns a new NgModuleRef instance based on the NgModule class and parent injector provided.\n *\n * @param ngModule NgModule class.\n * @param parentInjector Optional injector instance to use as a parent for the module injector. If\n *     not provided, `NullInjector` will be used instead.\n * @returns NgModuleRef that represents an NgModule instance.\n *\n * @publicApi\n */\nfunction createNgModule(ngModule, parentInjector) {\n    return new NgModuleRef(ngModule, parentInjector ?? null, []);\n}\n/**\n * The `createNgModule` function alias for backwards-compatibility.\n * Please avoid using it directly and use `createNgModule` instead.\n *\n * @deprecated Use `createNgModule` instead.\n */\nconst createNgModuleRef = createNgModule;\nclass NgModuleRef extends NgModuleRef$1 {\n    constructor(ngModuleType, _parent, additionalProviders) {\n        super();\n        this._parent = _parent;\n        // tslint:disable-next-line:require-internal-with-underscore\n        this._bootstrapComponents = [];\n        this.destroyCbs = [];\n        // When bootstrapping a module we have a dependency graph that looks like this:\n        // ApplicationRef -> ComponentFactoryResolver -> NgModuleRef. The problem is that if the\n        // module being resolved tries to inject the ComponentFactoryResolver, it'll create a\n        // circular dependency which will result in a runtime error, because the injector doesn't\n        // exist yet. We work around the issue by creating the ComponentFactoryResolver ourselves\n        // and providing it, rather than letting the injector resolve it.\n        this.componentFactoryResolver = new ComponentFactoryResolver(this);\n        const ngModuleDef = getNgModuleDef(ngModuleType);\n        ngDevMode &&\n            assertDefined(ngModuleDef, `NgModule '${stringify(ngModuleType)}' is not a subtype of 'NgModuleType'.`);\n        this._bootstrapComponents = maybeUnwrapFn$1(ngModuleDef.bootstrap);\n        this._r3Injector = createInjectorWithoutInjectorInstances(ngModuleType, _parent, [\n            { provide: NgModuleRef$1, useValue: this }, {\n                provide: ComponentFactoryResolver$1,\n                useValue: this.componentFactoryResolver\n            },\n            ...additionalProviders\n        ], stringify(ngModuleType), new Set(['environment']));\n        // We need to resolve the injector types separately from the injector creation, because\n        // the module might be trying to use this ref in its constructor for DI which will cause a\n        // circular error that will eventually error out, because the injector isn't created yet.\n        this._r3Injector.resolveInjectorInitializers();\n        this.instance = this._r3Injector.get(ngModuleType);\n    }\n    get injector() {\n        return this._r3Injector;\n    }\n    destroy() {\n        ngDevMode && assertDefined(this.destroyCbs, 'NgModule already destroyed');\n        const injector = this._r3Injector;\n        !injector.destroyed && injector.destroy();\n        this.destroyCbs.forEach(fn => fn());\n        this.destroyCbs = null;\n    }\n    onDestroy(callback) {\n        ngDevMode && assertDefined(this.destroyCbs, 'NgModule already destroyed');\n        this.destroyCbs.push(callback);\n    }\n}\nclass NgModuleFactory extends NgModuleFactory$1 {\n    constructor(moduleType) {\n        super();\n        this.moduleType = moduleType;\n    }\n    create(parentInjector) {\n        return new NgModuleRef(this.moduleType, parentInjector, []);\n    }\n}\nfunction createNgModuleRefWithProviders(moduleType, parentInjector, additionalProviders) {\n    return new NgModuleRef(moduleType, parentInjector, additionalProviders);\n}\nclass EnvironmentNgModuleRefAdapter extends NgModuleRef$1 {\n    constructor(config) {\n        super();\n        this.componentFactoryResolver = new ComponentFactoryResolver(this);\n        this.instance = null;\n        const injector = new R3Injector([\n            ...config.providers,\n            { provide: NgModuleRef$1, useValue: this },\n            { provide: ComponentFactoryResolver$1, useValue: this.componentFactoryResolver },\n        ], config.parent || getNullInjector(), config.debugName, new Set(['environment']));\n        this.injector = injector;\n        if (config.runEnvironmentInitializers) {\n            injector.resolveInjectorInitializers();\n        }\n    }\n    destroy() {\n        this.injector.destroy();\n    }\n    onDestroy(callback) {\n        this.injector.onDestroy(callback);\n    }\n}\n/**\n * Create a new environment injector.\n *\n * Learn more about environment injectors in\n * [this guide](guide/standalone-components#environment-injectors).\n *\n * @param providers An array of providers.\n * @param parent A parent environment injector.\n * @param debugName An optional name for this injector instance, which will be used in error\n *     messages.\n *\n * @publicApi\n */\nfunction createEnvironmentInjector(providers, parent, debugName = null) {\n    const adapter = new EnvironmentNgModuleRefAdapter({ providers, parent, debugName, runEnvironmentInitializers: true });\n    return adapter.injector;\n}\n\n/**\n * A service used by the framework to create instances of standalone injectors. Those injectors are\n * created on demand in case of dynamic component instantiation and contain ambient providers\n * collected from the imports graph rooted at a given standalone component.\n */\nclass StandaloneService {\n    constructor(_injector) {\n        this._injector = _injector;\n        this.cachedInjectors = new Map();\n    }\n    getOrCreateStandaloneInjector(componentDef) {\n        if (!componentDef.standalone) {\n            return null;\n        }\n        if (!this.cachedInjectors.has(componentDef)) {\n            const providers = internalImportProvidersFrom(false, componentDef.type);\n            const standaloneInjector = providers.length > 0 ?\n                createEnvironmentInjector([providers], this._injector, `Standalone[${componentDef.type.name}]`) :\n                null;\n            this.cachedInjectors.set(componentDef, standaloneInjector);\n        }\n        return this.cachedInjectors.get(componentDef);\n    }\n    ngOnDestroy() {\n        try {\n            for (const injector of this.cachedInjectors.values()) {\n                if (injector !== null) {\n                    injector.destroy();\n                }\n            }\n        }\n        finally {\n            this.cachedInjectors.clear();\n        }\n    }\n    /** @nocollapse */\n    static { this.ɵprov = ɵɵdefineInjectable({\n        token: StandaloneService,\n        providedIn: 'environment',\n        factory: () => new StandaloneService(ɵɵinject(EnvironmentInjector)),\n    }); }\n}\n/**\n * A feature that acts as a setup code for the {@link StandaloneService}.\n *\n * The most important responsibility of this feature is to expose the \"getStandaloneInjector\"\n * function (an entry points to a standalone injector creation) on a component definition object. We\n * go through the features infrastructure to make sure that the standalone injector creation logic\n * is tree-shakable and not included in applications that don't use standalone components.\n *\n * @codeGenApi\n */\nfunction ɵɵStandaloneFeature(definition) {\n    definition.getStandaloneInjector = (parentInjector) => {\n        return parentInjector.get(StandaloneService).getOrCreateStandaloneInjector(definition);\n    };\n}\n\n/**\n * Retrieves the component instance associated with a given DOM element.\n *\n * @usageNotes\n * Given the following DOM structure:\n *\n * ```html\n * <app-root>\n *   <div>\n *     <child-comp></child-comp>\n *   </div>\n * </app-root>\n * ```\n *\n * Calling `getComponent` on `<child-comp>` will return the instance of `ChildComponent`\n * associated with this DOM element.\n *\n * Calling the function on `<app-root>` will return the `MyApp` instance.\n *\n *\n * @param element DOM element from which the component should be retrieved.\n * @returns Component instance associated with the element or `null` if there\n *    is no component associated with it.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getComponent(element) {\n    ngDevMode && assertDomElement(element);\n    const context = getLContext(element);\n    if (context === null)\n        return null;\n    if (context.component === undefined) {\n        const lView = context.lView;\n        if (lView === null) {\n            return null;\n        }\n        context.component = getComponentAtNodeIndex(context.nodeIndex, lView);\n    }\n    return context.component;\n}\n/**\n * If inside an embedded view (e.g. `*ngIf` or `*ngFor`), retrieves the context of the embedded\n * view that the element is part of. Otherwise retrieves the instance of the component whose view\n * owns the element (in this case, the result is the same as calling `getOwningComponent`).\n *\n * @param element Element for which to get the surrounding component instance.\n * @returns Instance of the component that is around the element or null if the element isn't\n *    inside any component.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getContext(element) {\n    assertDomElement(element);\n    const context = getLContext(element);\n    const lView = context ? context.lView : null;\n    return lView === null ? null : lView[CONTEXT];\n}\n/**\n * Retrieves the component instance whose view contains the DOM element.\n *\n * For example, if `<child-comp>` is used in the template of `<app-comp>`\n * (i.e. a `ViewChild` of `<app-comp>`), calling `getOwningComponent` on `<child-comp>`\n * would return `<app-comp>`.\n *\n * @param elementOrDir DOM element, component or directive instance\n *    for which to retrieve the root components.\n * @returns Component instance whose view owns the DOM element or null if the element is not\n *    part of a component view.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getOwningComponent(elementOrDir) {\n    const context = getLContext(elementOrDir);\n    let lView = context ? context.lView : null;\n    if (lView === null)\n        return null;\n    let parent;\n    while (lView[TVIEW].type === 2 /* TViewType.Embedded */ && (parent = getLViewParent(lView))) {\n        lView = parent;\n    }\n    return lView[FLAGS] & 512 /* LViewFlags.IsRoot */ ? null : lView[CONTEXT];\n}\n/**\n * Retrieves all root components associated with a DOM element, directive or component instance.\n * Root components are those which have been bootstrapped by Angular.\n *\n * @param elementOrDir DOM element, component or directive instance\n *    for which to retrieve the root components.\n * @returns Root components associated with the target object.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getRootComponents(elementOrDir) {\n    const lView = readPatchedLView(elementOrDir);\n    return lView !== null ? [getRootContext(lView)] : [];\n}\n/**\n * Retrieves an `Injector` associated with an element, component or directive instance.\n *\n * @param elementOrDir DOM element, component or directive instance for which to\n *    retrieve the injector.\n * @returns Injector associated with the element, component or directive instance.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getInjector(elementOrDir) {\n    const context = getLContext(elementOrDir);\n    const lView = context ? context.lView : null;\n    if (lView === null)\n        return Injector.NULL;\n    const tNode = lView[TVIEW].data[context.nodeIndex];\n    return new NodeInjector(tNode, lView);\n}\n/**\n * Retrieve a set of injection tokens at a given DOM node.\n *\n * @param element Element for which the injection tokens should be retrieved.\n */\nfunction getInjectionTokens(element) {\n    const context = getLContext(element);\n    const lView = context ? context.lView : null;\n    if (lView === null)\n        return [];\n    const tView = lView[TVIEW];\n    const tNode = tView.data[context.nodeIndex];\n    const providerTokens = [];\n    const startIndex = tNode.providerIndexes & 1048575 /* TNodeProviderIndexes.ProvidersStartIndexMask */;\n    const endIndex = tNode.directiveEnd;\n    for (let i = startIndex; i < endIndex; i++) {\n        let value = tView.data[i];\n        if (isDirectiveDefHack(value)) {\n            // The fact that we sometimes store Type and sometimes DirectiveDef in this location is a\n            // design flaw.  We should always store same type so that we can be monomorphic. The issue\n            // is that for Components/Directives we store the def instead the type. The correct behavior\n            // is that we should always be storing injectable type in this location.\n            value = value.type;\n        }\n        providerTokens.push(value);\n    }\n    return providerTokens;\n}\n/**\n * Retrieves directive instances associated with a given DOM node. Does not include\n * component instances.\n *\n * @usageNotes\n * Given the following DOM structure:\n *\n * ```html\n * <app-root>\n *   <button my-button></button>\n *   <my-comp></my-comp>\n * </app-root>\n * ```\n *\n * Calling `getDirectives` on `<button>` will return an array with an instance of the `MyButton`\n * directive that is associated with the DOM node.\n *\n * Calling `getDirectives` on `<my-comp>` will return an empty array.\n *\n * @param node DOM node for which to get the directives.\n * @returns Array of directives associated with the node.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getDirectives(node) {\n    // Skip text nodes because we can't have directives associated with them.\n    if (node instanceof Text) {\n        return [];\n    }\n    const context = getLContext(node);\n    const lView = context ? context.lView : null;\n    if (lView === null) {\n        return [];\n    }\n    const tView = lView[TVIEW];\n    const nodeIndex = context.nodeIndex;\n    if (!tView?.data[nodeIndex]) {\n        return [];\n    }\n    if (context.directives === undefined) {\n        context.directives = getDirectivesAtNodeIndex(nodeIndex, lView);\n    }\n    // The `directives` in this case are a named array called `LComponentView`. Clone the\n    // result so we don't expose an internal data structure in the user's console.\n    return context.directives === null ? [] : [...context.directives];\n}\n/**\n * Returns the debug (partial) metadata for a particular directive or component instance.\n * The function accepts an instance of a directive or component and returns the corresponding\n * metadata.\n *\n * @param directiveOrComponentInstance Instance of a directive or component\n * @returns metadata of the passed directive or component\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getDirectiveMetadata(directiveOrComponentInstance) {\n    const { constructor } = directiveOrComponentInstance;\n    if (!constructor) {\n        throw new Error('Unable to find the instance constructor');\n    }\n    // In case a component inherits from a directive, we may have component and directive metadata\n    // To ensure we don't get the metadata of the directive, we want to call `getComponentDef` first.\n    const componentDef = getComponentDef$1(constructor);\n    if (componentDef) {\n        return {\n            inputs: componentDef.inputs,\n            outputs: componentDef.outputs,\n            encapsulation: componentDef.encapsulation,\n            changeDetection: componentDef.onPush ? ChangeDetectionStrategy.OnPush :\n                ChangeDetectionStrategy.Default\n        };\n    }\n    const directiveDef = getDirectiveDef(constructor);\n    if (directiveDef) {\n        return { inputs: directiveDef.inputs, outputs: directiveDef.outputs };\n    }\n    return null;\n}\n/**\n * Retrieve map of local references.\n *\n * The references are retrieved as a map of local reference name to element or directive instance.\n *\n * @param target DOM element, component or directive instance for which to retrieve\n *    the local references.\n */\nfunction getLocalRefs(target) {\n    const context = getLContext(target);\n    if (context === null)\n        return {};\n    if (context.localRefs === undefined) {\n        const lView = context.lView;\n        if (lView === null) {\n            return {};\n        }\n        context.localRefs = discoverLocalRefs(lView, context.nodeIndex);\n    }\n    return context.localRefs || {};\n}\n/**\n * Retrieves the host element of a component or directive instance.\n * The host element is the DOM element that matched the selector of the directive.\n *\n * @param componentOrDirective Component or directive instance for which the host\n *     element should be retrieved.\n * @returns Host element of the target.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getHostElement(componentOrDirective) {\n    return getLContext(componentOrDirective).native;\n}\n/**\n * Retrieves the rendered text for a given component.\n *\n * This function retrieves the host element of a component and\n * and then returns the `textContent` for that element. This implies\n * that the text returned will include re-projected content of\n * the component as well.\n *\n * @param component The component to return the content text for.\n */\nfunction getRenderedText(component) {\n    const hostElement = getHostElement(component);\n    return hostElement.textContent || '';\n}\n/**\n * Retrieves a list of event listeners associated with a DOM element. The list does include host\n * listeners, but it does not include event listeners defined outside of the Angular context\n * (e.g. through `addEventListener`).\n *\n * @usageNotes\n * Given the following DOM structure:\n *\n * ```html\n * <app-root>\n *   <div (click)=\"doSomething()\"></div>\n * </app-root>\n * ```\n *\n * Calling `getListeners` on `<div>` will return an object that looks as follows:\n *\n * ```ts\n * {\n *   name: 'click',\n *   element: <div>,\n *   callback: () => doSomething(),\n *   useCapture: false\n * }\n * ```\n *\n * @param element Element for which the DOM listeners should be retrieved.\n * @returns Array of event listeners on the DOM element.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getListeners(element) {\n    ngDevMode && assertDomElement(element);\n    const lContext = getLContext(element);\n    const lView = lContext === null ? null : lContext.lView;\n    if (lView === null)\n        return [];\n    const tView = lView[TVIEW];\n    const lCleanup = lView[CLEANUP];\n    const tCleanup = tView.cleanup;\n    const listeners = [];\n    if (tCleanup && lCleanup) {\n        for (let i = 0; i < tCleanup.length;) {\n            const firstParam = tCleanup[i++];\n            const secondParam = tCleanup[i++];\n            if (typeof firstParam === 'string') {\n                const name = firstParam;\n                const listenerElement = unwrapRNode(lView[secondParam]);\n                const callback = lCleanup[tCleanup[i++]];\n                const useCaptureOrIndx = tCleanup[i++];\n                // if useCaptureOrIndx is boolean then report it as is.\n                // if useCaptureOrIndx is positive number then it in unsubscribe method\n                // if useCaptureOrIndx is negative number then it is a Subscription\n                const type = (typeof useCaptureOrIndx === 'boolean' || useCaptureOrIndx >= 0) ? 'dom' : 'output';\n                const useCapture = typeof useCaptureOrIndx === 'boolean' ? useCaptureOrIndx : false;\n                if (element == listenerElement) {\n                    listeners.push({ element, name, callback, useCapture, type });\n                }\n            }\n        }\n    }\n    listeners.sort(sortListeners);\n    return listeners;\n}\nfunction sortListeners(a, b) {\n    if (a.name == b.name)\n        return 0;\n    return a.name < b.name ? -1 : 1;\n}\n/**\n * This function should not exist because it is megamorphic and only mostly correct.\n *\n * See call site for more info.\n */\nfunction isDirectiveDefHack(obj) {\n    return obj.type !== undefined && obj.declaredInputs !== undefined &&\n        obj.findHostDirectiveDefs !== undefined;\n}\n/**\n * Retrieve the component `LView` from component/element.\n *\n * NOTE: `LView` is a private and should not be leaked outside.\n *       Don't export this method to `ng.*` on window.\n *\n * @param target DOM element or component instance for which to retrieve the LView.\n */\nfunction getComponentLView(target) {\n    const lContext = getLContext(target);\n    const nodeIndx = lContext.nodeIndex;\n    const lView = lContext.lView;\n    ngDevMode && assertLView(lView);\n    const componentLView = lView[nodeIndx];\n    ngDevMode && assertLView(componentLView);\n    return componentLView;\n}\n/** Asserts that a value is a DOM Element. */\nfunction assertDomElement(value) {\n    if (typeof Element !== 'undefined' && !(value instanceof Element)) {\n        throw new Error('Expecting instance of DOM Element');\n    }\n}\n\n/**\n * Adds decorator, constructor, and property metadata to a given type via static metadata fields\n * on the type.\n *\n * These metadata fields can later be read with Angular's `ReflectionCapabilities` API.\n *\n * Calls to `setClassMetadata` can be guarded by ngDevMode, resulting in the metadata assignments\n * being tree-shaken away during production builds.\n */\nfunction setClassMetadata(type, decorators, ctorParameters, propDecorators) {\n    return noSideEffects(() => {\n        const clazz = type;\n        if (decorators !== null) {\n            if (clazz.hasOwnProperty('decorators') && clazz.decorators !== undefined) {\n                clazz.decorators.push(...decorators);\n            }\n            else {\n                clazz.decorators = decorators;\n            }\n        }\n        if (ctorParameters !== null) {\n            // Rather than merging, clobber the existing parameters. If other projects exist which\n            // use tsickle-style annotations and reflect over them in the same way, this could\n            // cause issues, but that is vanishingly unlikely.\n            clazz.ctorParameters = ctorParameters;\n        }\n        if (propDecorators !== null) {\n            // The property decorator objects are merged as it is possible different fields have\n            // different decorator types. Decorators on individual fields are not merged, as it's\n            // also incredibly unlikely that a field will be decorated both with an Angular\n            // decorator and a non-Angular decorator that's also been downleveled.\n            if (clazz.hasOwnProperty('propDecorators') && clazz.propDecorators !== undefined) {\n                clazz.propDecorators = { ...clazz.propDecorators, ...propDecorators };\n            }\n            else {\n                clazz.propDecorators = propDecorators;\n            }\n        }\n    });\n}\n\n/**\n * Bindings for pure functions are stored after regular bindings.\n *\n * |-------decls------|---------vars---------|                 |----- hostVars (dir1) ------|\n * ------------------------------------------------------------------------------------------\n * | nodes/refs/pipes | bindings | fn slots  | injector | dir1 | host bindings | host slots |\n * ------------------------------------------------------------------------------------------\n *                    ^                      ^\n *      TView.bindingStartIndex      TView.expandoStartIndex\n *\n * Pure function instructions are given an offset from the binding root. Adding the offset to the\n * binding root gives the first index where the bindings are stored. In component views, the binding\n * root is the bindingStartIndex. In host bindings, the binding root is the expandoStartIndex +\n * any directive instances + any hostVars in directives evaluated before it.\n *\n * See VIEW_DATA.md for more information about host binding resolution.\n */\n/**\n * If the value hasn't been saved, calls the pure function to store and return the\n * value. If it has been saved, returns the saved value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn Function that returns a value\n * @param thisArg Optional calling context of pureFn\n * @returns value\n *\n * @codeGenApi\n */\nfunction ɵɵpureFunction0(slotOffset, pureFn, thisArg) {\n    const bindingIndex = getBindingRoot() + slotOffset;\n    const lView = getLView();\n    return lView[bindingIndex] === NO_CHANGE ?\n        updateBinding(lView, bindingIndex, thisArg ? pureFn.call(thisArg) : pureFn()) :\n        getBinding(lView, bindingIndex);\n}\n/**\n * If the value of the provided exp has changed, calls the pure function to return\n * an updated value. Or if the value has not changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn Function that returns an updated value\n * @param exp Updated expression value\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction ɵɵpureFunction1(slotOffset, pureFn, exp, thisArg) {\n    return pureFunction1Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp, thisArg);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction ɵɵpureFunction2(slotOffset, pureFn, exp1, exp2, thisArg) {\n    return pureFunction2Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, thisArg);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction ɵɵpureFunction3(slotOffset, pureFn, exp1, exp2, exp3, thisArg) {\n    return pureFunction3Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, thisArg);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction ɵɵpureFunction4(slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {\n    return pureFunction4Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction ɵɵpureFunction5(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, thisArg) {\n    const bindingIndex = getBindingRoot() + slotOffset;\n    const lView = getLView();\n    const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n    return bindingUpdated(lView, bindingIndex + 4, exp5) || different ?\n        updateBinding(lView, bindingIndex + 5, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5) :\n            pureFn(exp1, exp2, exp3, exp4, exp5)) :\n        getBinding(lView, bindingIndex + 5);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param exp6\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction ɵɵpureFunction6(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, thisArg) {\n    const bindingIndex = getBindingRoot() + slotOffset;\n    const lView = getLView();\n    const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n    return bindingUpdated2(lView, bindingIndex + 4, exp5, exp6) || different ?\n        updateBinding(lView, bindingIndex + 6, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6) :\n            pureFn(exp1, exp2, exp3, exp4, exp5, exp6)) :\n        getBinding(lView, bindingIndex + 6);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param exp6\n * @param exp7\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction ɵɵpureFunction7(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, thisArg) {\n    const bindingIndex = getBindingRoot() + slotOffset;\n    const lView = getLView();\n    let different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n    return bindingUpdated3(lView, bindingIndex + 4, exp5, exp6, exp7) || different ?\n        updateBinding(lView, bindingIndex + 7, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7) :\n            pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7)) :\n        getBinding(lView, bindingIndex + 7);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param exp6\n * @param exp7\n * @param exp8\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction ɵɵpureFunction8(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8, thisArg) {\n    const bindingIndex = getBindingRoot() + slotOffset;\n    const lView = getLView();\n    const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n    return bindingUpdated4(lView, bindingIndex + 4, exp5, exp6, exp7, exp8) || different ?\n        updateBinding(lView, bindingIndex + 8, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8) :\n            pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8)) :\n        getBinding(lView, bindingIndex + 8);\n}\n/**\n * pureFunction instruction that can support any number of bindings.\n *\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn A pure function that takes binding values and builds an object or array\n * containing those values.\n * @param exps An array of binding values\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction ɵɵpureFunctionV(slotOffset, pureFn, exps, thisArg) {\n    return pureFunctionVInternal(getLView(), getBindingRoot(), slotOffset, pureFn, exps, thisArg);\n}\n/**\n * Results of a pure function invocation are stored in LView in a dedicated slot that is initialized\n * to NO_CHANGE. In rare situations a pure pipe might throw an exception on the very first\n * invocation and not produce any valid results. In this case LView would keep holding the NO_CHANGE\n * value. The NO_CHANGE is not something that we can use in expressions / bindings thus we convert\n * it to `undefined`.\n */\nfunction getPureFunctionReturnValue(lView, returnValueIndex) {\n    ngDevMode && assertIndexInRange(lView, returnValueIndex);\n    const lastReturnValue = lView[returnValueIndex];\n    return lastReturnValue === NO_CHANGE ? undefined : lastReturnValue;\n}\n/**\n * If the value of the provided exp has changed, calls the pure function to return\n * an updated value. Or if the value has not changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn Function that returns an updated value\n * @param exp Updated expression value\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nfunction pureFunction1Internal(lView, bindingRoot, slotOffset, pureFn, exp, thisArg) {\n    const bindingIndex = bindingRoot + slotOffset;\n    return bindingUpdated(lView, bindingIndex, exp) ?\n        updateBinding(lView, bindingIndex + 1, thisArg ? pureFn.call(thisArg, exp) : pureFn(exp)) :\n        getPureFunctionReturnValue(lView, bindingIndex + 1);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nfunction pureFunction2Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, thisArg) {\n    const bindingIndex = bindingRoot + slotOffset;\n    return bindingUpdated2(lView, bindingIndex, exp1, exp2) ?\n        updateBinding(lView, bindingIndex + 2, thisArg ? pureFn.call(thisArg, exp1, exp2) : pureFn(exp1, exp2)) :\n        getPureFunctionReturnValue(lView, bindingIndex + 2);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nfunction pureFunction3Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, thisArg) {\n    const bindingIndex = bindingRoot + slotOffset;\n    return bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) ?\n        updateBinding(lView, bindingIndex + 3, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3) : pureFn(exp1, exp2, exp3)) :\n        getPureFunctionReturnValue(lView, bindingIndex + 3);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n */\nfunction pureFunction4Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {\n    const bindingIndex = bindingRoot + slotOffset;\n    return bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) ?\n        updateBinding(lView, bindingIndex + 4, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4) : pureFn(exp1, exp2, exp3, exp4)) :\n        getPureFunctionReturnValue(lView, bindingIndex + 4);\n}\n/**\n * pureFunction instruction that can support any number of bindings.\n *\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn A pure function that takes binding values and builds an object or array\n * containing those values.\n * @param exps An array of binding values\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nfunction pureFunctionVInternal(lView, bindingRoot, slotOffset, pureFn, exps, thisArg) {\n    let bindingIndex = bindingRoot + slotOffset;\n    let different = false;\n    for (let i = 0; i < exps.length; i++) {\n        bindingUpdated(lView, bindingIndex++, exps[i]) && (different = true);\n    }\n    return different ? updateBinding(lView, bindingIndex, pureFn.apply(thisArg, exps)) :\n        getPureFunctionReturnValue(lView, bindingIndex);\n}\n\n/**\n * Create a pipe.\n *\n * @param index Pipe index where the pipe will be stored.\n * @param pipeName The name of the pipe\n * @returns T the instance of the pipe.\n *\n * @codeGenApi\n */\nfunction ɵɵpipe(index, pipeName) {\n    const tView = getTView();\n    let pipeDef;\n    const adjustedIndex = index + HEADER_OFFSET;\n    if (tView.firstCreatePass) {\n        // The `getPipeDef` throws if a pipe with a given name is not found\n        // (so we use non-null assertion below).\n        pipeDef = getPipeDef(pipeName, tView.pipeRegistry);\n        tView.data[adjustedIndex] = pipeDef;\n        if (pipeDef.onDestroy) {\n            (tView.destroyHooks ??= []).push(adjustedIndex, pipeDef.onDestroy);\n        }\n    }\n    else {\n        pipeDef = tView.data[adjustedIndex];\n    }\n    const pipeFactory = pipeDef.factory || (pipeDef.factory = getFactoryDef(pipeDef.type, true));\n    let previousInjectorProfilerContext;\n    if (ngDevMode) {\n        previousInjectorProfilerContext = setInjectorProfilerContext({\n            injector: new NodeInjector(getCurrentTNode(), getLView()),\n            token: pipeDef.type\n        });\n    }\n    const previousInjectImplementation = setInjectImplementation(ɵɵdirectiveInject);\n    try {\n        // DI for pipes is supposed to behave like directives when placed on a component\n        // host node, which means that we have to disable access to `viewProviders`.\n        const previousIncludeViewProviders = setIncludeViewProviders(false);\n        const pipeInstance = pipeFactory();\n        setIncludeViewProviders(previousIncludeViewProviders);\n        store(tView, getLView(), adjustedIndex, pipeInstance);\n        return pipeInstance;\n    }\n    finally {\n        // we have to restore the injector implementation in finally, just in case the creation of the\n        // pipe throws an error.\n        setInjectImplementation(previousInjectImplementation);\n        ngDevMode && setInjectorProfilerContext(previousInjectorProfilerContext);\n    }\n}\n/**\n * Searches the pipe registry for a pipe with the given name. If one is found,\n * returns the pipe. Otherwise, an error is thrown because the pipe cannot be resolved.\n *\n * @param name Name of pipe to resolve\n * @param registry Full list of available pipes\n * @returns Matching PipeDef\n */\nfunction getPipeDef(name, registry) {\n    if (registry) {\n        if (ngDevMode) {\n            const pipes = registry.filter(pipe => pipe.name === name);\n            // TODO: Throw an error in the next major\n            if (pipes.length > 1) {\n                console.warn(formatRuntimeError(313 /* RuntimeErrorCode.MULTIPLE_MATCHING_PIPES */, getMultipleMatchingPipesMessage(name)));\n            }\n        }\n        for (let i = registry.length - 1; i >= 0; i--) {\n            const pipeDef = registry[i];\n            if (name === pipeDef.name) {\n                return pipeDef;\n            }\n        }\n    }\n    if (ngDevMode) {\n        throw new RuntimeError(-302 /* RuntimeErrorCode.PIPE_NOT_FOUND */, getPipeNotFoundErrorMessage(name));\n    }\n}\n/**\n * Generates a helpful error message for the user when multiple pipes match the name.\n *\n * @param name Name of the pipe\n * @returns The error message\n */\nfunction getMultipleMatchingPipesMessage(name) {\n    const lView = getLView();\n    const declarationLView = lView[DECLARATION_COMPONENT_VIEW];\n    const context = declarationLView[CONTEXT];\n    const hostIsStandalone = isHostComponentStandalone(lView);\n    const componentInfoMessage = context ? ` in the '${context.constructor.name}' component` : '';\n    const verifyMessage = `check ${hostIsStandalone ? '\\'@Component.imports\\' of this component' :\n        'the imports of this module'}`;\n    const errorMessage = `Multiple pipes match the name \\`${name}\\`${componentInfoMessage}. ${verifyMessage}`;\n    return errorMessage;\n}\n/**\n * Generates a helpful error message for the user when a pipe is not found.\n *\n * @param name Name of the missing pipe\n * @returns The error message\n */\nfunction getPipeNotFoundErrorMessage(name) {\n    const lView = getLView();\n    const declarationLView = lView[DECLARATION_COMPONENT_VIEW];\n    const context = declarationLView[CONTEXT];\n    const hostIsStandalone = isHostComponentStandalone(lView);\n    const componentInfoMessage = context ? ` in the '${context.constructor.name}' component` : '';\n    const verifyMessage = `Verify that it is ${hostIsStandalone ? 'included in the \\'@Component.imports\\' of this component' :\n        'declared or imported in this module'}`;\n    const errorMessage = `The pipe '${name}' could not be found${componentInfoMessage}. ${verifyMessage}`;\n    return errorMessage;\n}\n/**\n * Invokes a pipe with 1 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\nfunction ɵɵpipeBind1(index, slotOffset, v1) {\n    const adjustedIndex = index + HEADER_OFFSET;\n    const lView = getLView();\n    const pipeInstance = load(lView, adjustedIndex);\n    return isPure(lView, adjustedIndex) ?\n        pureFunction1Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, pipeInstance) :\n        pipeInstance.transform(v1);\n}\n/**\n * Invokes a pipe with 2 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\nfunction ɵɵpipeBind2(index, slotOffset, v1, v2) {\n    const adjustedIndex = index + HEADER_OFFSET;\n    const lView = getLView();\n    const pipeInstance = load(lView, adjustedIndex);\n    return isPure(lView, adjustedIndex) ?\n        pureFunction2Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, pipeInstance) :\n        pipeInstance.transform(v1, v2);\n}\n/**\n * Invokes a pipe with 3 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n * @param v3 4rd argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\nfunction ɵɵpipeBind3(index, slotOffset, v1, v2, v3) {\n    const adjustedIndex = index + HEADER_OFFSET;\n    const lView = getLView();\n    const pipeInstance = load(lView, adjustedIndex);\n    return isPure(lView, adjustedIndex) ?\n        pureFunction3Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, pipeInstance) :\n        pipeInstance.transform(v1, v2, v3);\n}\n/**\n * Invokes a pipe with 4 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n * @param v3 3rd argument to {@link PipeTransform#transform}.\n * @param v4 4th argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\nfunction ɵɵpipeBind4(index, slotOffset, v1, v2, v3, v4) {\n    const adjustedIndex = index + HEADER_OFFSET;\n    const lView = getLView();\n    const pipeInstance = load(lView, adjustedIndex);\n    return isPure(lView, adjustedIndex) ? pureFunction4Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, v4, pipeInstance) :\n        pipeInstance.transform(v1, v2, v3, v4);\n}\n/**\n * Invokes a pipe with variable number of arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param values Array of arguments to pass to {@link PipeTransform#transform} method.\n *\n * @codeGenApi\n */\nfunction ɵɵpipeBindV(index, slotOffset, values) {\n    const adjustedIndex = index + HEADER_OFFSET;\n    const lView = getLView();\n    const pipeInstance = load(lView, adjustedIndex);\n    return isPure(lView, adjustedIndex) ?\n        pureFunctionVInternal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, values, pipeInstance) :\n        pipeInstance.transform.apply(pipeInstance, values);\n}\nfunction isPure(lView, index) {\n    return lView[TVIEW].data[index].pure;\n}\n\nfunction symbolIterator() {\n    // @ts-expect-error accessing a private member\n    return this._results[Symbol.iterator]();\n}\n/**\n * An unmodifiable list of items that Angular keeps up to date when the state\n * of the application changes.\n *\n * The type of object that {@link ViewChildren}, {@link ContentChildren}, and {@link QueryList}\n * provide.\n *\n * Implements an iterable interface, therefore it can be used in both ES6\n * javascript `for (var i of items)` loops as well as in Angular templates with\n * `*ngFor=\"let i of myList\"`.\n *\n * Changes can be observed by subscribing to the changes `Observable`.\n *\n * NOTE: In the future this class will implement an `Observable` interface.\n *\n * @usageNotes\n * ### Example\n * ```typescript\n * @Component({...})\n * class Container {\n *   @ViewChildren(Item) items:QueryList<Item>;\n * }\n * ```\n *\n * @publicApi\n */\nclass QueryList {\n    static { Symbol.iterator; }\n    /**\n     * Returns `Observable` of `QueryList` notifying the subscriber of changes.\n     */\n    get changes() {\n        return this._changes || (this._changes = new EventEmitter());\n    }\n    /**\n     * @param emitDistinctChangesOnly Whether `QueryList.changes` should fire only when actual change\n     *     has occurred. Or if it should fire when query is recomputed. (recomputing could resolve in\n     *     the same result)\n     */\n    constructor(_emitDistinctChangesOnly = false) {\n        this._emitDistinctChangesOnly = _emitDistinctChangesOnly;\n        this.dirty = true;\n        this._results = [];\n        this._changesDetected = false;\n        this._changes = null;\n        this.length = 0;\n        this.first = undefined;\n        this.last = undefined;\n        // This function should be declared on the prototype, but doing so there will cause the class\n        // declaration to have side-effects and become not tree-shakable. For this reason we do it in\n        // the constructor.\n        // [Symbol.iterator](): Iterator<T> { ... }\n        const proto = QueryList.prototype;\n        if (!proto[Symbol.iterator])\n            proto[Symbol.iterator] = symbolIterator;\n    }\n    /**\n     * Returns the QueryList entry at `index`.\n     */\n    get(index) {\n        return this._results[index];\n    }\n    /**\n     * See\n     * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\n     */\n    map(fn) {\n        return this._results.map(fn);\n    }\n    filter(fn) {\n        return this._results.filter(fn);\n    }\n    /**\n     * See\n     * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)\n     */\n    find(fn) {\n        return this._results.find(fn);\n    }\n    /**\n     * See\n     * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)\n     */\n    reduce(fn, init) {\n        return this._results.reduce(fn, init);\n    }\n    /**\n     * See\n     * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)\n     */\n    forEach(fn) {\n        this._results.forEach(fn);\n    }\n    /**\n     * See\n     * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)\n     */\n    some(fn) {\n        return this._results.some(fn);\n    }\n    /**\n     * Returns a copy of the internal results list as an Array.\n     */\n    toArray() {\n        return this._results.slice();\n    }\n    toString() {\n        return this._results.toString();\n    }\n    /**\n     * Updates the stored data of the query list, and resets the `dirty` flag to `false`, so that\n     * on change detection, it will not notify of changes to the queries, unless a new change\n     * occurs.\n     *\n     * @param resultsTree The query results to store\n     * @param identityAccessor Optional function for extracting stable object identity from a value\n     *    in the array. This function is executed for each element of the query result list while\n     *    comparing current query list with the new one (provided as a first argument of the `reset`\n     *    function) to detect if the lists are different. If the function is not provided, elements\n     *    are compared as is (without any pre-processing).\n     */\n    reset(resultsTree, identityAccessor) {\n        // Cast to `QueryListInternal` so that we can mutate fields which are readonly for the usage of\n        // QueryList (but not for QueryList itself.)\n        const self = this;\n        self.dirty = false;\n        const newResultFlat = flatten$1(resultsTree);\n        if (this._changesDetected = !arrayEquals(self._results, newResultFlat, identityAccessor)) {\n            self._results = newResultFlat;\n            self.length = newResultFlat.length;\n            self.last = newResultFlat[this.length - 1];\n            self.first = newResultFlat[0];\n        }\n    }\n    /**\n     * Triggers a change event by emitting on the `changes` {@link EventEmitter}.\n     */\n    notifyOnChanges() {\n        if (this._changes && (this._changesDetected || !this._emitDistinctChangesOnly))\n            this._changes.emit(this);\n    }\n    /** internal */\n    setDirty() {\n        this.dirty = true;\n    }\n    /** internal */\n    destroy() {\n        this.changes.complete();\n        this.changes.unsubscribe();\n    }\n}\n\nfunction createAndRenderEmbeddedLView(declarationLView, templateTNode, context, options) {\n    const embeddedTView = templateTNode.tView;\n    ngDevMode && assertDefined(embeddedTView, 'TView must be defined for a template node.');\n    ngDevMode && assertTNodeForLView(templateTNode, declarationLView);\n    // Embedded views follow the change detection strategy of the view they're declared in.\n    const isSignalView = declarationLView[FLAGS] & 4096 /* LViewFlags.SignalView */;\n    const viewFlags = isSignalView ? 4096 /* LViewFlags.SignalView */ : 16 /* LViewFlags.CheckAlways */;\n    const embeddedLView = createLView(declarationLView, embeddedTView, context, viewFlags, null, templateTNode, null, null, null, options?.injector ?? null, options?.hydrationInfo ?? null);\n    const declarationLContainer = declarationLView[templateTNode.index];\n    ngDevMode && assertLContainer(declarationLContainer);\n    embeddedLView[DECLARATION_LCONTAINER] = declarationLContainer;\n    const declarationViewLQueries = declarationLView[QUERIES];\n    if (declarationViewLQueries !== null) {\n        embeddedLView[QUERIES] = declarationViewLQueries.createEmbeddedView(embeddedTView);\n    }\n    // execute creation mode of a view\n    renderView(embeddedTView, embeddedLView, context);\n    return embeddedLView;\n}\nfunction getLViewFromLContainer(lContainer, index) {\n    const adjustedIndex = CONTAINER_HEADER_OFFSET + index;\n    // avoid reading past the array boundaries\n    if (adjustedIndex < lContainer.length) {\n        const lView = lContainer[adjustedIndex];\n        ngDevMode && assertLView(lView);\n        return lView;\n    }\n    return undefined;\n}\nfunction addLViewToLContainer(lContainer, lView, index, addToDOM = true) {\n    const tView = lView[TVIEW];\n    // insert to the view tree so the new view can be change-detected\n    insertView(tView, lView, lContainer, index);\n    // insert to the view to the DOM tree\n    if (addToDOM) {\n        const beforeNode = getBeforeNodeForView(index, lContainer);\n        const renderer = lView[RENDERER];\n        const parentRNode = nativeParentNode(renderer, lContainer[NATIVE]);\n        if (parentRNode !== null) {\n            addViewToDOM(tView, lContainer[T_HOST], renderer, lView, parentRNode, beforeNode);\n        }\n    }\n}\nfunction removeLViewFromLContainer(lContainer, index) {\n    const lView = detachView(lContainer, index);\n    if (lView !== undefined) {\n        destroyLView(lView[TVIEW], lView);\n    }\n    return lView;\n}\n\n/**\n * Represents an embedded template that can be used to instantiate embedded views.\n * To instantiate embedded views based on a template, use the `ViewContainerRef`\n * method `createEmbeddedView()`.\n *\n * Access a `TemplateRef` instance by placing a directive on an `<ng-template>`\n * element (or directive prefixed with `*`). The `TemplateRef` for the embedded view\n * is injected into the constructor of the directive,\n * using the `TemplateRef` token.\n *\n * You can also use a `Query` to find a `TemplateRef` associated with\n * a component or a directive.\n *\n * @see {@link ViewContainerRef}\n * @see [Navigate the Component Tree with DI](guide/dependency-injection-navtree)\n *\n * @publicApi\n */\nclass TemplateRef {\n    /**\n     * @internal\n     * @nocollapse\n     */\n    static { this.__NG_ELEMENT_ID__ = injectTemplateRef; }\n}\nconst ViewEngineTemplateRef = TemplateRef;\n// TODO(alxhub): combine interface and implementation. Currently this is challenging since something\n// in g3 depends on them being separate.\nconst R3TemplateRef = class TemplateRef extends ViewEngineTemplateRef {\n    constructor(_declarationLView, _declarationTContainer, elementRef) {\n        super();\n        this._declarationLView = _declarationLView;\n        this._declarationTContainer = _declarationTContainer;\n        this.elementRef = elementRef;\n    }\n    /**\n     * Returns an `ssrId` associated with a TView, which was used to\n     * create this instance of the `TemplateRef`.\n     *\n     * @internal\n     */\n    get ssrId() {\n        return this._declarationTContainer.tView?.ssrId || null;\n    }\n    createEmbeddedView(context, injector) {\n        return this.createEmbeddedViewImpl(context, injector);\n    }\n    /**\n     * @internal\n     */\n    createEmbeddedViewImpl(context, injector, hydrationInfo) {\n        const embeddedLView = createAndRenderEmbeddedLView(this._declarationLView, this._declarationTContainer, context, { injector, hydrationInfo });\n        return new ViewRef(embeddedLView);\n    }\n};\n/**\n * Creates a TemplateRef given a node.\n *\n * @returns The TemplateRef instance to use\n */\nfunction injectTemplateRef() {\n    return createTemplateRef(getCurrentTNode(), getLView());\n}\n/**\n * Creates a TemplateRef and stores it on the injector.\n *\n * @param hostTNode The node on which a TemplateRef is requested\n * @param hostLView The `LView` to which the node belongs\n * @returns The TemplateRef instance or null if we can't create a TemplateRef on a given node type\n */\nfunction createTemplateRef(hostTNode, hostLView) {\n    if (hostTNode.type & 4 /* TNodeType.Container */) {\n        ngDevMode && assertDefined(hostTNode.tView, 'TView must be allocated');\n        return new R3TemplateRef(hostLView, hostTNode, createElementRef(hostTNode, hostLView));\n    }\n    return null;\n}\n\n/**\n * Removes all dehydrated views from a given LContainer:\n * both in internal data structure, as well as removing\n * corresponding DOM nodes that belong to that dehydrated view.\n */\nfunction removeDehydratedViews(lContainer) {\n    const views = lContainer[DEHYDRATED_VIEWS] ?? [];\n    const parentLView = lContainer[PARENT];\n    const renderer = parentLView[RENDERER];\n    for (const view of views) {\n        removeDehydratedView(view, renderer);\n        ngDevMode && ngDevMode.dehydratedViewsRemoved++;\n    }\n    // Reset the value to an empty array to indicate that no\n    // further processing of dehydrated views is needed for\n    // this view container (i.e. do not trigger the lookup process\n    // once again in case a `ViewContainerRef` is created later).\n    lContainer[DEHYDRATED_VIEWS] = EMPTY_ARRAY;\n}\n/**\n * Helper function to remove all nodes from a dehydrated view.\n */\nfunction removeDehydratedView(dehydratedView, renderer) {\n    let nodesRemoved = 0;\n    let currentRNode = dehydratedView.firstChild;\n    if (currentRNode) {\n        const numNodes = dehydratedView.data[NUM_ROOT_NODES];\n        while (nodesRemoved < numNodes) {\n            ngDevMode && validateSiblingNodeExists(currentRNode);\n            const nextSibling = currentRNode.nextSibling;\n            nativeRemoveNode(renderer, currentRNode, false);\n            currentRNode = nextSibling;\n            nodesRemoved++;\n        }\n    }\n}\n/**\n * Walks over all views within this LContainer invokes dehydrated views\n * cleanup function for each one.\n */\nfunction cleanupLContainer(lContainer) {\n    removeDehydratedViews(lContainer);\n    for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n        cleanupLView(lContainer[i]);\n    }\n}\n/**\n * Walks over `LContainer`s and components registered within\n * this LView and invokes dehydrated views cleanup function for each one.\n */\nfunction cleanupLView(lView) {\n    const tView = lView[TVIEW];\n    for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {\n        if (isLContainer(lView[i])) {\n            const lContainer = lView[i];\n            cleanupLContainer(lContainer);\n        }\n        else if (Array.isArray(lView[i])) {\n            // This is a component, enter the `cleanupLView` recursively.\n            cleanupLView(lView[i]);\n        }\n    }\n}\n/**\n * Walks over all views registered within the ApplicationRef and removes\n * all dehydrated views from all `LContainer`s along the way.\n */\nfunction cleanupDehydratedViews(appRef) {\n    const viewRefs = appRef._views;\n    for (const viewRef of viewRefs) {\n        const lNode = getLNodeForHydration(viewRef);\n        // An `lView` might be `null` if a `ViewRef` represents\n        // an embedded view (not a component view).\n        if (lNode !== null && lNode[HOST] !== null) {\n            if (isLView(lNode)) {\n                cleanupLView(lNode);\n            }\n            else {\n                // Cleanup in the root component view\n                const componentLView = lNode[HOST];\n                cleanupLView(componentLView);\n                // Cleanup in all views within this view container\n                cleanupLContainer(lNode);\n            }\n            ngDevMode && ngDevMode.dehydratedViewsCleanupRuns++;\n        }\n    }\n}\n\n/**\n * Given a current DOM node and a serialized information about the views\n * in a container, walks over the DOM structure, collecting the list of\n * dehydrated views.\n */\nfunction locateDehydratedViewsInContainer(currentRNode, serializedViews) {\n    const dehydratedViews = [];\n    for (const serializedView of serializedViews) {\n        // Repeats a view multiple times as needed, based on the serialized information\n        // (for example, for *ngFor-produced views).\n        for (let i = 0; i < (serializedView[MULTIPLIER] ?? 1); i++) {\n            const view = {\n                data: serializedView,\n                firstChild: null,\n            };\n            if (serializedView[NUM_ROOT_NODES] > 0) {\n                // Keep reference to the first node in this view,\n                // so it can be accessed while invoking template instructions.\n                view.firstChild = currentRNode;\n                // Move over to the next node after this view, which can\n                // either be a first node of the next view or an anchor comment\n                // node after the last view in a container.\n                currentRNode = siblingAfter(serializedView[NUM_ROOT_NODES], currentRNode);\n            }\n            dehydratedViews.push(view);\n        }\n    }\n    return [currentRNode, dehydratedViews];\n}\n/**\n * Reference to a function that searches for a matching dehydrated views\n * stored on a given lContainer.\n * Returns `null` by default, when hydration is not enabled.\n */\nlet _findMatchingDehydratedViewImpl = (lContainer, template) => null;\n/**\n * Retrieves the next dehydrated view from the LContainer and verifies that\n * it matches a given template id (from the TView that was used to create this\n * instance of a view). If the id doesn't match, that means that we are in an\n * unexpected state and can not complete the reconciliation process. Thus,\n * all dehydrated views from this LContainer are removed (including corresponding\n * DOM nodes) and the rendering is performed as if there were no dehydrated views\n * in this container.\n */\nfunction findMatchingDehydratedViewImpl(lContainer, template) {\n    const views = lContainer[DEHYDRATED_VIEWS] ?? [];\n    if (!template || views.length === 0) {\n        return null;\n    }\n    const view = views[0];\n    // Verify whether the first dehydrated view in the container matches\n    // the template id passed to this function (that originated from a TView\n    // that was used to create an instance of an embedded or component views.\n    if (view.data[TEMPLATE_ID] === template) {\n        // If the template id matches - extract the first view and return it.\n        return views.shift();\n    }\n    else {\n        // Otherwise, we are at the state when reconciliation can not be completed,\n        // thus we remove all dehydrated views within this container (remove them\n        // from internal data structures as well as delete associated elements from\n        // the DOM tree).\n        removeDehydratedViews(lContainer);\n        return null;\n    }\n}\nfunction enableFindMatchingDehydratedViewImpl() {\n    _findMatchingDehydratedViewImpl = findMatchingDehydratedViewImpl;\n}\nfunction findMatchingDehydratedView(lContainer, template) {\n    return _findMatchingDehydratedViewImpl(lContainer, template);\n}\n\n/**\n * Represents a container where one or more views can be attached to a component.\n *\n * Can contain *host views* (created by instantiating a\n * component with the `createComponent()` method), and *embedded views*\n * (created by instantiating a `TemplateRef` with the `createEmbeddedView()` method).\n *\n * A view container instance can contain other view containers,\n * creating a [view hierarchy](guide/glossary#view-hierarchy).\n *\n * @usageNotes\n *\n * The example below demonstrates how the `createComponent` function can be used\n * to create an instance of a ComponentRef dynamically and attach it to an ApplicationRef,\n * so that it gets included into change detection cycles.\n *\n * Note: the example uses standalone components, but the function can also be used for\n * non-standalone components (declared in an NgModule) as well.\n *\n * ```typescript\n * @Component({\n *   standalone: true,\n *   selector: 'dynamic',\n *   template: `<span>This is a content of a dynamic component.</span>`,\n * })\n * class DynamicComponent {\n *   vcr = inject(ViewContainerRef);\n * }\n *\n * @Component({\n *   standalone: true,\n *   selector: 'app',\n *   template: `<main>Hi! This is the main content.</main>`,\n * })\n * class AppComponent {\n *   vcr = inject(ViewContainerRef);\n *\n *   ngAfterViewInit() {\n *     const compRef = this.vcr.createComponent(DynamicComponent);\n *     compRef.changeDetectorRef.detectChanges();\n *   }\n * }\n * ```\n *\n * @see {@link ComponentRef}\n * @see {@link EmbeddedViewRef}\n *\n * @publicApi\n */\nclass ViewContainerRef {\n    /**\n     * @internal\n     * @nocollapse\n     */\n    static { this.__NG_ELEMENT_ID__ = injectViewContainerRef; }\n}\n/**\n * Creates a ViewContainerRef and stores it on the injector. Or, if the ViewContainerRef\n * already exists, retrieves the existing ViewContainerRef.\n *\n * @returns The ViewContainerRef instance to use\n */\nfunction injectViewContainerRef() {\n    const previousTNode = getCurrentTNode();\n    return createContainerRef(previousTNode, getLView());\n}\nconst VE_ViewContainerRef = ViewContainerRef;\n// TODO(alxhub): cleaning up this indirection triggers a subtle bug in Closure in g3. Once the fix\n// for that lands, this can be cleaned up.\nconst R3ViewContainerRef = class ViewContainerRef extends VE_ViewContainerRef {\n    constructor(_lContainer, _hostTNode, _hostLView) {\n        super();\n        this._lContainer = _lContainer;\n        this._hostTNode = _hostTNode;\n        this._hostLView = _hostLView;\n    }\n    get element() {\n        return createElementRef(this._hostTNode, this._hostLView);\n    }\n    get injector() {\n        return new NodeInjector(this._hostTNode, this._hostLView);\n    }\n    /** @deprecated No replacement */\n    get parentInjector() {\n        const parentLocation = getParentInjectorLocation(this._hostTNode, this._hostLView);\n        if (hasParentInjector(parentLocation)) {\n            const parentView = getParentInjectorView(parentLocation, this._hostLView);\n            const injectorIndex = getParentInjectorIndex(parentLocation);\n            ngDevMode && assertNodeInjector(parentView, injectorIndex);\n            const parentTNode = parentView[TVIEW].data[injectorIndex + 8 /* NodeInjectorOffset.TNODE */];\n            return new NodeInjector(parentTNode, parentView);\n        }\n        else {\n            return new NodeInjector(null, this._hostLView);\n        }\n    }\n    clear() {\n        while (this.length > 0) {\n            this.remove(this.length - 1);\n        }\n    }\n    get(index) {\n        const viewRefs = getViewRefs(this._lContainer);\n        return viewRefs !== null && viewRefs[index] || null;\n    }\n    get length() {\n        return this._lContainer.length - CONTAINER_HEADER_OFFSET;\n    }\n    createEmbeddedView(templateRef, context, indexOrOptions) {\n        let index;\n        let injector;\n        if (typeof indexOrOptions === 'number') {\n            index = indexOrOptions;\n        }\n        else if (indexOrOptions != null) {\n            index = indexOrOptions.index;\n            injector = indexOrOptions.injector;\n        }\n        const hydrationInfo = findMatchingDehydratedView(this._lContainer, templateRef.ssrId);\n        const viewRef = templateRef.createEmbeddedViewImpl(context || {}, injector, hydrationInfo);\n        // If there is a matching dehydrated view, but the host TNode is located in the skip\n        // hydration block, this means that the content was detached (as a part of the skip\n        // hydration logic) and it needs to be appended into the DOM.\n        const skipDomInsertion = !!hydrationInfo && !hasInSkipHydrationBlockFlag(this._hostTNode);\n        this.insertImpl(viewRef, index, skipDomInsertion);\n        return viewRef;\n    }\n    createComponent(componentFactoryOrType, indexOrOptions, injector, projectableNodes, environmentInjector) {\n        const isComponentFactory = componentFactoryOrType && !isType(componentFactoryOrType);\n        let index;\n        // This function supports 2 signatures and we need to handle options correctly for both:\n        //   1. When first argument is a Component type. This signature also requires extra\n        //      options to be provided as object (more ergonomic option).\n        //   2. First argument is a Component factory. In this case extra options are represented as\n        //      positional arguments. This signature is less ergonomic and will be deprecated.\n        if (isComponentFactory) {\n            if (ngDevMode) {\n                assertEqual(typeof indexOrOptions !== 'object', true, 'It looks like Component factory was provided as the first argument ' +\n                    'and an options object as the second argument. This combination of arguments ' +\n                    'is incompatible. You can either change the first argument to provide Component ' +\n                    'type or change the second argument to be a number (representing an index at ' +\n                    'which to insert the new component\\'s host view into this container)');\n            }\n            index = indexOrOptions;\n        }\n        else {\n            if (ngDevMode) {\n                assertDefined(getComponentDef$1(componentFactoryOrType), `Provided Component class doesn't contain Component definition. ` +\n                    `Please check whether provided class has @Component decorator.`);\n                assertEqual(typeof indexOrOptions !== 'number', true, 'It looks like Component type was provided as the first argument ' +\n                    'and a number (representing an index at which to insert the new component\\'s ' +\n                    'host view into this container as the second argument. This combination of arguments ' +\n                    'is incompatible. Please use an object as the second argument instead.');\n            }\n            const options = (indexOrOptions || {});\n            if (ngDevMode && options.environmentInjector && options.ngModuleRef) {\n                throwError(`Cannot pass both environmentInjector and ngModuleRef options to createComponent().`);\n            }\n            index = options.index;\n            injector = options.injector;\n            projectableNodes = options.projectableNodes;\n            environmentInjector = options.environmentInjector || options.ngModuleRef;\n        }\n        const componentFactory = isComponentFactory ?\n            componentFactoryOrType :\n            new ComponentFactory(getComponentDef$1(componentFactoryOrType));\n        const contextInjector = injector || this.parentInjector;\n        // If an `NgModuleRef` is not provided explicitly, try retrieving it from the DI tree.\n        if (!environmentInjector && componentFactory.ngModule == null) {\n            // For the `ComponentFactory` case, entering this logic is very unlikely, since we expect that\n            // an instance of a `ComponentFactory`, resolved via `ComponentFactoryResolver` would have an\n            // `ngModule` field. This is possible in some test scenarios and potentially in some JIT-based\n            // use-cases. For the `ComponentFactory` case we preserve backwards-compatibility and try\n            // using a provided injector first, then fall back to the parent injector of this\n            // `ViewContainerRef` instance.\n            //\n            // For the factory-less case, it's critical to establish a connection with the module\n            // injector tree (by retrieving an instance of an `NgModuleRef` and accessing its injector),\n            // so that a component can use DI tokens provided in MgModules. For this reason, we can not\n            // rely on the provided injector, since it might be detached from the DI tree (for example, if\n            // it was created via `Injector.create` without specifying a parent injector, or if an\n            // injector is retrieved from an `NgModuleRef` created via `createNgModule` using an\n            // NgModule outside of a module tree). Instead, we always use `ViewContainerRef`'s parent\n            // injector, which is normally connected to the DI tree, which includes module injector\n            // subtree.\n            const _injector = isComponentFactory ? contextInjector : this.parentInjector;\n            // DO NOT REFACTOR. The code here used to have a `injector.get(NgModuleRef, null) ||\n            // undefined` expression which seems to cause internal google apps to fail. This is documented\n            // in the following internal bug issue: go/b/142967802\n            const result = _injector.get(EnvironmentInjector, null);\n            if (result) {\n                environmentInjector = result;\n            }\n        }\n        const componentDef = getComponentDef$1(componentFactory.componentType ?? {});\n        const dehydratedView = findMatchingDehydratedView(this._lContainer, componentDef?.id ?? null);\n        const rNode = dehydratedView?.firstChild ?? null;\n        const componentRef = componentFactory.create(contextInjector, projectableNodes, rNode, environmentInjector);\n        // If there is a matching dehydrated view, but the host TNode is located in the skip\n        // hydration block, this means that the content was detached (as a part of the skip\n        // hydration logic) and it needs to be appended into the DOM.\n        const skipDomInsertion = !!dehydratedView && !hasInSkipHydrationBlockFlag(this._hostTNode);\n        this.insertImpl(componentRef.hostView, index, skipDomInsertion);\n        return componentRef;\n    }\n    insert(viewRef, index) {\n        return this.insertImpl(viewRef, index, false);\n    }\n    insertImpl(viewRef, index, skipDomInsertion) {\n        const lView = viewRef._lView;\n        const tView = lView[TVIEW];\n        if (ngDevMode && viewRef.destroyed) {\n            throw new Error('Cannot insert a destroyed View in a ViewContainer!');\n        }\n        if (viewAttachedToContainer(lView)) {\n            // If view is already attached, detach it first so we clean up references appropriately.\n            const prevIdx = this.indexOf(viewRef);\n            // A view might be attached either to this or a different container. The `prevIdx` for\n            // those cases will be:\n            // equal to -1 for views attached to this ViewContainerRef\n            // >= 0 for views attached to a different ViewContainerRef\n            if (prevIdx !== -1) {\n                this.detach(prevIdx);\n            }\n            else {\n                const prevLContainer = lView[PARENT];\n                ngDevMode &&\n                    assertEqual(isLContainer(prevLContainer), true, 'An attached view should have its PARENT point to a container.');\n                // We need to re-create a R3ViewContainerRef instance since those are not stored on\n                // LView (nor anywhere else).\n                const prevVCRef = new R3ViewContainerRef(prevLContainer, prevLContainer[T_HOST], prevLContainer[PARENT]);\n                prevVCRef.detach(prevVCRef.indexOf(viewRef));\n            }\n        }\n        // Logical operation of adding `LView` to `LContainer`\n        const adjustedIdx = this._adjustIndex(index);\n        const lContainer = this._lContainer;\n        addLViewToLContainer(lContainer, lView, adjustedIdx, !skipDomInsertion);\n        viewRef.attachToViewContainerRef();\n        addToArray(getOrCreateViewRefs(lContainer), adjustedIdx, viewRef);\n        return viewRef;\n    }\n    move(viewRef, newIndex) {\n        if (ngDevMode && viewRef.destroyed) {\n            throw new Error('Cannot move a destroyed View in a ViewContainer!');\n        }\n        return this.insert(viewRef, newIndex);\n    }\n    indexOf(viewRef) {\n        const viewRefsArr = getViewRefs(this._lContainer);\n        return viewRefsArr !== null ? viewRefsArr.indexOf(viewRef) : -1;\n    }\n    remove(index) {\n        const adjustedIdx = this._adjustIndex(index, -1);\n        const detachedView = detachView(this._lContainer, adjustedIdx);\n        if (detachedView) {\n            // Before destroying the view, remove it from the container's array of `ViewRef`s.\n            // This ensures the view container length is updated before calling\n            // `destroyLView`, which could recursively call view container methods that\n            // rely on an accurate container length.\n            // (e.g. a method on this view container being called by a child directive's OnDestroy\n            // lifecycle hook)\n            removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx);\n            destroyLView(detachedView[TVIEW], detachedView);\n        }\n    }\n    detach(index) {\n        const adjustedIdx = this._adjustIndex(index, -1);\n        const view = detachView(this._lContainer, adjustedIdx);\n        const wasDetached = view && removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx) != null;\n        return wasDetached ? new ViewRef(view) : null;\n    }\n    _adjustIndex(index, shift = 0) {\n        if (index == null) {\n            return this.length + shift;\n        }\n        if (ngDevMode) {\n            assertGreaterThan(index, -1, `ViewRef index must be positive, got ${index}`);\n            // +1 because it's legal to insert at the end.\n            assertLessThan(index, this.length + 1 + shift, 'index');\n        }\n        return index;\n    }\n};\nfunction getViewRefs(lContainer) {\n    return lContainer[VIEW_REFS];\n}\nfunction getOrCreateViewRefs(lContainer) {\n    return (lContainer[VIEW_REFS] || (lContainer[VIEW_REFS] = []));\n}\n/**\n * Creates a ViewContainerRef and stores it on the injector.\n *\n * @param hostTNode The node that is requesting a ViewContainerRef\n * @param hostLView The view to which the node belongs\n * @returns The ViewContainerRef instance to use\n */\nfunction createContainerRef(hostTNode, hostLView) {\n    ngDevMode && assertTNodeType(hostTNode, 12 /* TNodeType.AnyContainer */ | 3 /* TNodeType.AnyRNode */);\n    let lContainer;\n    const slotValue = hostLView[hostTNode.index];\n    if (isLContainer(slotValue)) {\n        // If the host is a container, we don't need to create a new LContainer\n        lContainer = slotValue;\n    }\n    else {\n        // An LContainer anchor can not be `null`, but we set it here temporarily\n        // and update to the actual value later in this function (see\n        // `_locateOrCreateAnchorNode`).\n        lContainer = createLContainer(slotValue, hostLView, null, hostTNode);\n        hostLView[hostTNode.index] = lContainer;\n        addToViewTree(hostLView, lContainer);\n    }\n    _locateOrCreateAnchorNode(lContainer, hostLView, hostTNode, slotValue);\n    return new R3ViewContainerRef(lContainer, hostTNode, hostLView);\n}\n/**\n * Creates and inserts a comment node that acts as an anchor for a view container.\n *\n * If the host is a regular element, we have to insert a comment node manually which will\n * be used as an anchor when inserting elements. In this specific case we use low-level DOM\n * manipulation to insert it.\n */\nfunction insertAnchorNode(hostLView, hostTNode) {\n    const renderer = hostLView[RENDERER];\n    ngDevMode && ngDevMode.rendererCreateComment++;\n    const commentNode = renderer.createComment(ngDevMode ? 'container' : '');\n    const hostNative = getNativeByTNode(hostTNode, hostLView);\n    const parentOfHostNative = nativeParentNode(renderer, hostNative);\n    nativeInsertBefore(renderer, parentOfHostNative, commentNode, nativeNextSibling(renderer, hostNative), false);\n    return commentNode;\n}\nlet _locateOrCreateAnchorNode = createAnchorNode;\n/**\n * Regular creation mode: an anchor is created and\n * assigned to the `lContainer[NATIVE]` slot.\n */\nfunction createAnchorNode(lContainer, hostLView, hostTNode, slotValue) {\n    // We already have a native element (anchor) set, return.\n    if (lContainer[NATIVE])\n        return;\n    let commentNode;\n    // If the host is an element container, the native host element is guaranteed to be a\n    // comment and we can reuse that comment as anchor element for the new LContainer.\n    // The comment node in question is already part of the DOM structure so we don't need to append\n    // it again.\n    if (hostTNode.type & 8 /* TNodeType.ElementContainer */) {\n        commentNode = unwrapRNode(slotValue);\n    }\n    else {\n        commentNode = insertAnchorNode(hostLView, hostTNode);\n    }\n    lContainer[NATIVE] = commentNode;\n}\n/**\n * Hydration logic that looks up:\n *  - an anchor node in the DOM and stores the node in `lContainer[NATIVE]`\n *  - all dehydrated views in this container and puts them into `lContainer[DEHYDRATED_VIEWS]`\n */\nfunction locateOrCreateAnchorNode(lContainer, hostLView, hostTNode, slotValue) {\n    // We already have a native element (anchor) set and the process\n    // of finding dehydrated views happened (so the `lContainer[DEHYDRATED_VIEWS]`\n    // is not null), exit early.\n    if (lContainer[NATIVE] && lContainer[DEHYDRATED_VIEWS])\n        return;\n    const hydrationInfo = hostLView[HYDRATION];\n    const noOffsetIndex = hostTNode.index - HEADER_OFFSET;\n    // TODO(akushnir): this should really be a single condition, refactor the code\n    // to use `hasInSkipHydrationBlockFlag` logic inside `isInSkipHydrationBlock`.\n    const skipHydration = isInSkipHydrationBlock(hostTNode) || hasInSkipHydrationBlockFlag(hostTNode);\n    const isNodeCreationMode = !hydrationInfo || skipHydration || isDisconnectedNode(hydrationInfo, noOffsetIndex);\n    // Regular creation mode.\n    if (isNodeCreationMode) {\n        return createAnchorNode(lContainer, hostLView, hostTNode, slotValue);\n    }\n    // Hydration mode, looking up an anchor node and dehydrated views in DOM.\n    const currentRNode = getSegmentHead(hydrationInfo, noOffsetIndex);\n    const serializedViews = hydrationInfo.data[CONTAINERS]?.[noOffsetIndex];\n    ngDevMode &&\n        assertDefined(serializedViews, 'Unexpected state: no hydration info available for a given TNode, ' +\n            'which represents a view container.');\n    const [commentNode, dehydratedViews] = locateDehydratedViewsInContainer(currentRNode, serializedViews);\n    if (ngDevMode) {\n        validateMatchingNode(commentNode, Node.COMMENT_NODE, null, hostLView, hostTNode, true);\n        // Do not throw in case this node is already claimed (thus `false` as a second\n        // argument). If this container is created based on an `<ng-template>`, the comment\n        // node would be already claimed from the `template` instruction. If an element acts\n        // as an anchor (e.g. <div #vcRef>), a separate comment node would be created/located,\n        // so we need to claim it here.\n        markRNodeAsClaimedByHydration(commentNode, false);\n    }\n    lContainer[NATIVE] = commentNode;\n    lContainer[DEHYDRATED_VIEWS] = dehydratedViews;\n}\nfunction enableLocateOrCreateContainerRefImpl() {\n    _locateOrCreateAnchorNode = locateOrCreateAnchorNode;\n}\n\nclass LQuery_ {\n    constructor(queryList) {\n        this.queryList = queryList;\n        this.matches = null;\n    }\n    clone() {\n        return new LQuery_(this.queryList);\n    }\n    setDirty() {\n        this.queryList.setDirty();\n    }\n}\nclass LQueries_ {\n    constructor(queries = []) {\n        this.queries = queries;\n    }\n    createEmbeddedView(tView) {\n        const tQueries = tView.queries;\n        if (tQueries !== null) {\n            const noOfInheritedQueries = tView.contentQueries !== null ? tView.contentQueries[0] : tQueries.length;\n            const viewLQueries = [];\n            // An embedded view has queries propagated from a declaration view at the beginning of the\n            // TQueries collection and up until a first content query declared in the embedded view. Only\n            // propagated LQueries are created at this point (LQuery corresponding to declared content\n            // queries will be instantiated from the content query instructions for each directive).\n            for (let i = 0; i < noOfInheritedQueries; i++) {\n                const tQuery = tQueries.getByIndex(i);\n                const parentLQuery = this.queries[tQuery.indexInDeclarationView];\n                viewLQueries.push(parentLQuery.clone());\n            }\n            return new LQueries_(viewLQueries);\n        }\n        return null;\n    }\n    insertView(tView) {\n        this.dirtyQueriesWithMatches(tView);\n    }\n    detachView(tView) {\n        this.dirtyQueriesWithMatches(tView);\n    }\n    dirtyQueriesWithMatches(tView) {\n        for (let i = 0; i < this.queries.length; i++) {\n            if (getTQuery(tView, i).matches !== null) {\n                this.queries[i].setDirty();\n            }\n        }\n    }\n}\nclass TQueryMetadata_ {\n    constructor(predicate, flags, read = null) {\n        this.predicate = predicate;\n        this.flags = flags;\n        this.read = read;\n    }\n}\nclass TQueries_ {\n    constructor(queries = []) {\n        this.queries = queries;\n    }\n    elementStart(tView, tNode) {\n        ngDevMode &&\n            assertFirstCreatePass(tView, 'Queries should collect results on the first template pass only');\n        for (let i = 0; i < this.queries.length; i++) {\n            this.queries[i].elementStart(tView, tNode);\n        }\n    }\n    elementEnd(tNode) {\n        for (let i = 0; i < this.queries.length; i++) {\n            this.queries[i].elementEnd(tNode);\n        }\n    }\n    embeddedTView(tNode) {\n        let queriesForTemplateRef = null;\n        for (let i = 0; i < this.length; i++) {\n            const childQueryIndex = queriesForTemplateRef !== null ? queriesForTemplateRef.length : 0;\n            const tqueryClone = this.getByIndex(i).embeddedTView(tNode, childQueryIndex);\n            if (tqueryClone) {\n                tqueryClone.indexInDeclarationView = i;\n                if (queriesForTemplateRef !== null) {\n                    queriesForTemplateRef.push(tqueryClone);\n                }\n                else {\n                    queriesForTemplateRef = [tqueryClone];\n                }\n            }\n        }\n        return queriesForTemplateRef !== null ? new TQueries_(queriesForTemplateRef) : null;\n    }\n    template(tView, tNode) {\n        ngDevMode &&\n            assertFirstCreatePass(tView, 'Queries should collect results on the first template pass only');\n        for (let i = 0; i < this.queries.length; i++) {\n            this.queries[i].template(tView, tNode);\n        }\n    }\n    getByIndex(index) {\n        ngDevMode && assertIndexInRange(this.queries, index);\n        return this.queries[index];\n    }\n    get length() {\n        return this.queries.length;\n    }\n    track(tquery) {\n        this.queries.push(tquery);\n    }\n}\nclass TQuery_ {\n    constructor(metadata, nodeIndex = -1) {\n        this.metadata = metadata;\n        this.matches = null;\n        this.indexInDeclarationView = -1;\n        this.crossesNgTemplate = false;\n        /**\n         * A flag indicating if a given query still applies to nodes it is crossing. We use this flag\n         * (alongside with _declarationNodeIndex) to know when to stop applying content queries to\n         * elements in a template.\n         */\n        this._appliesToNextNode = true;\n        this._declarationNodeIndex = nodeIndex;\n    }\n    elementStart(tView, tNode) {\n        if (this.isApplyingToNode(tNode)) {\n            this.matchTNode(tView, tNode);\n        }\n    }\n    elementEnd(tNode) {\n        if (this._declarationNodeIndex === tNode.index) {\n            this._appliesToNextNode = false;\n        }\n    }\n    template(tView, tNode) {\n        this.elementStart(tView, tNode);\n    }\n    embeddedTView(tNode, childQueryIndex) {\n        if (this.isApplyingToNode(tNode)) {\n            this.crossesNgTemplate = true;\n            // A marker indicating a `<ng-template>` element (a placeholder for query results from\n            // embedded views created based on this `<ng-template>`).\n            this.addMatch(-tNode.index, childQueryIndex);\n            return new TQuery_(this.metadata);\n        }\n        return null;\n    }\n    isApplyingToNode(tNode) {\n        if (this._appliesToNextNode &&\n            (this.metadata.flags & 1 /* QueryFlags.descendants */) !== 1 /* QueryFlags.descendants */) {\n            const declarationNodeIdx = this._declarationNodeIndex;\n            let parent = tNode.parent;\n            // Determine if a given TNode is a \"direct\" child of a node on which a content query was\n            // declared (only direct children of query's host node can match with the descendants: false\n            // option). There are 3 main use-case / conditions to consider here:\n            // - <needs-target><i #target></i></needs-target>: here <i #target> parent node is a query\n            // host node;\n            // - <needs-target><ng-template [ngIf]=\"true\"><i #target></i></ng-template></needs-target>:\n            // here <i #target> parent node is null;\n            // - <needs-target><ng-container><i #target></i></ng-container></needs-target>: here we need\n            // to go past `<ng-container>` to determine <i #target> parent node (but we shouldn't traverse\n            // up past the query's host node!).\n            while (parent !== null && (parent.type & 8 /* TNodeType.ElementContainer */) &&\n                parent.index !== declarationNodeIdx) {\n                parent = parent.parent;\n            }\n            return declarationNodeIdx === (parent !== null ? parent.index : -1);\n        }\n        return this._appliesToNextNode;\n    }\n    matchTNode(tView, tNode) {\n        const predicate = this.metadata.predicate;\n        if (Array.isArray(predicate)) {\n            for (let i = 0; i < predicate.length; i++) {\n                const name = predicate[i];\n                this.matchTNodeWithReadOption(tView, tNode, getIdxOfMatchingSelector(tNode, name));\n                // Also try matching the name to a provider since strings can be used as DI tokens too.\n                this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, name, false, false));\n            }\n        }\n        else {\n            if (predicate === TemplateRef) {\n                if (tNode.type & 4 /* TNodeType.Container */) {\n                    this.matchTNodeWithReadOption(tView, tNode, -1);\n                }\n            }\n            else {\n                this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, predicate, false, false));\n            }\n        }\n    }\n    matchTNodeWithReadOption(tView, tNode, nodeMatchIdx) {\n        if (nodeMatchIdx !== null) {\n            const read = this.metadata.read;\n            if (read !== null) {\n                if (read === ElementRef || read === ViewContainerRef ||\n                    read === TemplateRef && (tNode.type & 4 /* TNodeType.Container */)) {\n                    this.addMatch(tNode.index, -2);\n                }\n                else {\n                    const directiveOrProviderIdx = locateDirectiveOrProvider(tNode, tView, read, false, false);\n                    if (directiveOrProviderIdx !== null) {\n                        this.addMatch(tNode.index, directiveOrProviderIdx);\n                    }\n                }\n            }\n            else {\n                this.addMatch(tNode.index, nodeMatchIdx);\n            }\n        }\n    }\n    addMatch(tNodeIdx, matchIdx) {\n        if (this.matches === null) {\n            this.matches = [tNodeIdx, matchIdx];\n        }\n        else {\n            this.matches.push(tNodeIdx, matchIdx);\n        }\n    }\n}\n/**\n * Iterates over local names for a given node and returns directive index\n * (or -1 if a local name points to an element).\n *\n * @param tNode static data of a node to check\n * @param selector selector to match\n * @returns directive index, -1 or null if a selector didn't match any of the local names\n */\nfunction getIdxOfMatchingSelector(tNode, selector) {\n    const localNames = tNode.localNames;\n    if (localNames !== null) {\n        for (let i = 0; i < localNames.length; i += 2) {\n            if (localNames[i] === selector) {\n                return localNames[i + 1];\n            }\n        }\n    }\n    return null;\n}\nfunction createResultByTNodeType(tNode, currentView) {\n    if (tNode.type & (3 /* TNodeType.AnyRNode */ | 8 /* TNodeType.ElementContainer */)) {\n        return createElementRef(tNode, currentView);\n    }\n    else if (tNode.type & 4 /* TNodeType.Container */) {\n        return createTemplateRef(tNode, currentView);\n    }\n    return null;\n}\nfunction createResultForNode(lView, tNode, matchingIdx, read) {\n    if (matchingIdx === -1) {\n        // if read token and / or strategy is not specified, detect it using appropriate tNode type\n        return createResultByTNodeType(tNode, lView);\n    }\n    else if (matchingIdx === -2) {\n        // read a special token from a node injector\n        return createSpecialToken(lView, tNode, read);\n    }\n    else {\n        // read a token\n        return getNodeInjectable(lView, lView[TVIEW], matchingIdx, tNode);\n    }\n}\nfunction createSpecialToken(lView, tNode, read) {\n    if (read === ElementRef) {\n        return createElementRef(tNode, lView);\n    }\n    else if (read === TemplateRef) {\n        return createTemplateRef(tNode, lView);\n    }\n    else if (read === ViewContainerRef) {\n        ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 12 /* TNodeType.AnyContainer */);\n        return createContainerRef(tNode, lView);\n    }\n    else {\n        ngDevMode &&\n            throwError(`Special token to read should be one of ElementRef, TemplateRef or ViewContainerRef but got ${stringify(read)}.`);\n    }\n}\n/**\n * A helper function that creates query results for a given view. This function is meant to do the\n * processing once and only once for a given view instance (a set of results for a given view\n * doesn't change).\n */\nfunction materializeViewResults(tView, lView, tQuery, queryIndex) {\n    const lQuery = lView[QUERIES].queries[queryIndex];\n    if (lQuery.matches === null) {\n        const tViewData = tView.data;\n        const tQueryMatches = tQuery.matches;\n        const result = [];\n        for (let i = 0; i < tQueryMatches.length; i += 2) {\n            const matchedNodeIdx = tQueryMatches[i];\n            if (matchedNodeIdx < 0) {\n                // we at the <ng-template> marker which might have results in views created based on this\n                // <ng-template> - those results will be in separate views though, so here we just leave\n                // null as a placeholder\n                result.push(null);\n            }\n            else {\n                ngDevMode && assertIndexInRange(tViewData, matchedNodeIdx);\n                const tNode = tViewData[matchedNodeIdx];\n                result.push(createResultForNode(lView, tNode, tQueryMatches[i + 1], tQuery.metadata.read));\n            }\n        }\n        lQuery.matches = result;\n    }\n    return lQuery.matches;\n}\n/**\n * A helper function that collects (already materialized) query results from a tree of views,\n * starting with a provided LView.\n */\nfunction collectQueryResults(tView, lView, queryIndex, result) {\n    const tQuery = tView.queries.getByIndex(queryIndex);\n    const tQueryMatches = tQuery.matches;\n    if (tQueryMatches !== null) {\n        const lViewResults = materializeViewResults(tView, lView, tQuery, queryIndex);\n        for (let i = 0; i < tQueryMatches.length; i += 2) {\n            const tNodeIdx = tQueryMatches[i];\n            if (tNodeIdx > 0) {\n                result.push(lViewResults[i / 2]);\n            }\n            else {\n                const childQueryIndex = tQueryMatches[i + 1];\n                const declarationLContainer = lView[-tNodeIdx];\n                ngDevMode && assertLContainer(declarationLContainer);\n                // collect matches for views inserted in this container\n                for (let i = CONTAINER_HEADER_OFFSET; i < declarationLContainer.length; i++) {\n                    const embeddedLView = declarationLContainer[i];\n                    if (embeddedLView[DECLARATION_LCONTAINER] === embeddedLView[PARENT]) {\n                        collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);\n                    }\n                }\n                // collect matches for views created from this declaration container and inserted into\n                // different containers\n                if (declarationLContainer[MOVED_VIEWS] !== null) {\n                    const embeddedLViews = declarationLContainer[MOVED_VIEWS];\n                    for (let i = 0; i < embeddedLViews.length; i++) {\n                        const embeddedLView = embeddedLViews[i];\n                        collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);\n                    }\n                }\n            }\n        }\n    }\n    return result;\n}\n/**\n * Refreshes a query by combining matches from all active views and removing matches from deleted\n * views.\n *\n * @returns `true` if a query got dirty during change detection or if this is a static query\n * resolving in creation mode, `false` otherwise.\n *\n * @codeGenApi\n */\nfunction ɵɵqueryRefresh(queryList) {\n    const lView = getLView();\n    const tView = getTView();\n    const queryIndex = getCurrentQueryIndex();\n    setCurrentQueryIndex(queryIndex + 1);\n    const tQuery = getTQuery(tView, queryIndex);\n    if (queryList.dirty &&\n        (isCreationMode(lView) ===\n            ((tQuery.metadata.flags & 2 /* QueryFlags.isStatic */) === 2 /* QueryFlags.isStatic */))) {\n        if (tQuery.matches === null) {\n            queryList.reset([]);\n        }\n        else {\n            const result = tQuery.crossesNgTemplate ?\n                collectQueryResults(tView, lView, queryIndex, []) :\n                materializeViewResults(tView, lView, tQuery, queryIndex);\n            queryList.reset(result, unwrapElementRef);\n            queryList.notifyOnChanges();\n        }\n        return true;\n    }\n    return false;\n}\n/**\n * Creates new QueryList, stores the reference in LView and returns QueryList.\n *\n * @param predicate The type for which the query will search\n * @param flags Flags associated with the query\n * @param read What to save in the query\n *\n * @codeGenApi\n */\nfunction ɵɵviewQuery(predicate, flags, read) {\n    ngDevMode && assertNumber(flags, 'Expecting flags');\n    const tView = getTView();\n    if (tView.firstCreatePass) {\n        createTQuery(tView, new TQueryMetadata_(predicate, flags, read), -1);\n        if ((flags & 2 /* QueryFlags.isStatic */) === 2 /* QueryFlags.isStatic */) {\n            tView.staticViewQueries = true;\n        }\n    }\n    createLQuery(tView, getLView(), flags);\n}\n/**\n * Registers a QueryList, associated with a content query, for later refresh (part of a view\n * refresh).\n *\n * @param directiveIndex Current directive index\n * @param predicate The type for which the query will search\n * @param flags Flags associated with the query\n * @param read What to save in the query\n * @returns QueryList<T>\n *\n * @codeGenApi\n */\nfunction ɵɵcontentQuery(directiveIndex, predicate, flags, read) {\n    ngDevMode && assertNumber(flags, 'Expecting flags');\n    const tView = getTView();\n    if (tView.firstCreatePass) {\n        const tNode = getCurrentTNode();\n        createTQuery(tView, new TQueryMetadata_(predicate, flags, read), tNode.index);\n        saveContentQueryAndDirectiveIndex(tView, directiveIndex);\n        if ((flags & 2 /* QueryFlags.isStatic */) === 2 /* QueryFlags.isStatic */) {\n            tView.staticContentQueries = true;\n        }\n    }\n    createLQuery(tView, getLView(), flags);\n}\n/**\n * Loads a QueryList corresponding to the current view or content query.\n *\n * @codeGenApi\n */\nfunction ɵɵloadQuery() {\n    return loadQueryInternal(getLView(), getCurrentQueryIndex());\n}\nfunction loadQueryInternal(lView, queryIndex) {\n    ngDevMode &&\n        assertDefined(lView[QUERIES], 'LQueries should be defined when trying to load a query');\n    ngDevMode && assertIndexInRange(lView[QUERIES].queries, queryIndex);\n    return lView[QUERIES].queries[queryIndex].queryList;\n}\nfunction createLQuery(tView, lView, flags) {\n    const queryList = new QueryList((flags & 4 /* QueryFlags.emitDistinctChangesOnly */) === 4 /* QueryFlags.emitDistinctChangesOnly */);\n    storeCleanupWithContext(tView, lView, queryList, queryList.destroy);\n    if (lView[QUERIES] === null)\n        lView[QUERIES] = new LQueries_();\n    lView[QUERIES].queries.push(new LQuery_(queryList));\n}\nfunction createTQuery(tView, metadata, nodeIndex) {\n    if (tView.queries === null)\n        tView.queries = new TQueries_();\n    tView.queries.track(new TQuery_(metadata, nodeIndex));\n}\nfunction saveContentQueryAndDirectiveIndex(tView, directiveIndex) {\n    const tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);\n    const lastSavedDirectiveIndex = tViewContentQueries.length ? tViewContentQueries[tViewContentQueries.length - 1] : -1;\n    if (directiveIndex !== lastSavedDirectiveIndex) {\n        tViewContentQueries.push(tView.queries.length - 1, directiveIndex);\n    }\n}\nfunction getTQuery(tView, index) {\n    ngDevMode && assertDefined(tView.queries, 'TQueries must be defined to retrieve a TQuery');\n    return tView.queries.getByIndex(index);\n}\n\n/**\n * Retrieves `TemplateRef` instance from `Injector` when a local reference is placed on the\n * `<ng-template>` element.\n *\n * @codeGenApi\n */\nfunction ɵɵtemplateRefExtractor(tNode, lView) {\n    return createTemplateRef(tNode, lView);\n}\n\n/**\n * A mapping of the @angular/core API surface used in generated expressions to the actual symbols.\n *\n * This should be kept up to date with the public exports of @angular/core.\n */\nconst angularCoreEnv = (() => ({\n    'ɵɵattribute': ɵɵattribute,\n    'ɵɵattributeInterpolate1': ɵɵattributeInterpolate1,\n    'ɵɵattributeInterpolate2': ɵɵattributeInterpolate2,\n    'ɵɵattributeInterpolate3': ɵɵattributeInterpolate3,\n    'ɵɵattributeInterpolate4': ɵɵattributeInterpolate4,\n    'ɵɵattributeInterpolate5': ɵɵattributeInterpolate5,\n    'ɵɵattributeInterpolate6': ɵɵattributeInterpolate6,\n    'ɵɵattributeInterpolate7': ɵɵattributeInterpolate7,\n    'ɵɵattributeInterpolate8': ɵɵattributeInterpolate8,\n    'ɵɵattributeInterpolateV': ɵɵattributeInterpolateV,\n    'ɵɵdefineComponent': ɵɵdefineComponent,\n    'ɵɵdefineDirective': ɵɵdefineDirective,\n    'ɵɵdefineInjectable': ɵɵdefineInjectable,\n    'ɵɵdefineInjector': ɵɵdefineInjector,\n    'ɵɵdefineNgModule': ɵɵdefineNgModule,\n    'ɵɵdefinePipe': ɵɵdefinePipe,\n    'ɵɵdirectiveInject': ɵɵdirectiveInject,\n    'ɵɵgetInheritedFactory': ɵɵgetInheritedFactory,\n    'ɵɵinject': ɵɵinject,\n    'ɵɵinjectAttribute': ɵɵinjectAttribute,\n    'ɵɵinvalidFactory': ɵɵinvalidFactory,\n    'ɵɵinvalidFactoryDep': ɵɵinvalidFactoryDep,\n    'ɵɵtemplateRefExtractor': ɵɵtemplateRefExtractor,\n    'ɵɵresetView': ɵɵresetView,\n    'ɵɵHostDirectivesFeature': ɵɵHostDirectivesFeature,\n    'ɵɵNgOnChangesFeature': ɵɵNgOnChangesFeature,\n    'ɵɵProvidersFeature': ɵɵProvidersFeature,\n    'ɵɵCopyDefinitionFeature': ɵɵCopyDefinitionFeature,\n    'ɵɵInheritDefinitionFeature': ɵɵInheritDefinitionFeature,\n    'ɵɵInputTransformsFeature': ɵɵInputTransformsFeature,\n    'ɵɵStandaloneFeature': ɵɵStandaloneFeature,\n    'ɵɵnextContext': ɵɵnextContext,\n    'ɵɵnamespaceHTML': ɵɵnamespaceHTML,\n    'ɵɵnamespaceMathML': ɵɵnamespaceMathML,\n    'ɵɵnamespaceSVG': ɵɵnamespaceSVG,\n    'ɵɵenableBindings': ɵɵenableBindings,\n    'ɵɵdisableBindings': ɵɵdisableBindings,\n    'ɵɵelementStart': ɵɵelementStart,\n    'ɵɵelementEnd': ɵɵelementEnd,\n    'ɵɵelement': ɵɵelement,\n    'ɵɵelementContainerStart': ɵɵelementContainerStart,\n    'ɵɵelementContainerEnd': ɵɵelementContainerEnd,\n    'ɵɵelementContainer': ɵɵelementContainer,\n    'ɵɵpureFunction0': ɵɵpureFunction0,\n    'ɵɵpureFunction1': ɵɵpureFunction1,\n    'ɵɵpureFunction2': ɵɵpureFunction2,\n    'ɵɵpureFunction3': ɵɵpureFunction3,\n    'ɵɵpureFunction4': ɵɵpureFunction4,\n    'ɵɵpureFunction5': ɵɵpureFunction5,\n    'ɵɵpureFunction6': ɵɵpureFunction6,\n    'ɵɵpureFunction7': ɵɵpureFunction7,\n    'ɵɵpureFunction8': ɵɵpureFunction8,\n    'ɵɵpureFunctionV': ɵɵpureFunctionV,\n    'ɵɵgetCurrentView': ɵɵgetCurrentView,\n    'ɵɵrestoreView': ɵɵrestoreView,\n    'ɵɵlistener': ɵɵlistener,\n    'ɵɵprojection': ɵɵprojection,\n    'ɵɵsyntheticHostProperty': ɵɵsyntheticHostProperty,\n    'ɵɵsyntheticHostListener': ɵɵsyntheticHostListener,\n    'ɵɵpipeBind1': ɵɵpipeBind1,\n    'ɵɵpipeBind2': ɵɵpipeBind2,\n    'ɵɵpipeBind3': ɵɵpipeBind3,\n    'ɵɵpipeBind4': ɵɵpipeBind4,\n    'ɵɵpipeBindV': ɵɵpipeBindV,\n    'ɵɵprojectionDef': ɵɵprojectionDef,\n    'ɵɵhostProperty': ɵɵhostProperty,\n    'ɵɵproperty': ɵɵproperty,\n    'ɵɵpropertyInterpolate': ɵɵpropertyInterpolate,\n    'ɵɵpropertyInterpolate1': ɵɵpropertyInterpolate1,\n    'ɵɵpropertyInterpolate2': ɵɵpropertyInterpolate2,\n    'ɵɵpropertyInterpolate3': ɵɵpropertyInterpolate3,\n    'ɵɵpropertyInterpolate4': ɵɵpropertyInterpolate4,\n    'ɵɵpropertyInterpolate5': ɵɵpropertyInterpolate5,\n    'ɵɵpropertyInterpolate6': ɵɵpropertyInterpolate6,\n    'ɵɵpropertyInterpolate7': ɵɵpropertyInterpolate7,\n    'ɵɵpropertyInterpolate8': ɵɵpropertyInterpolate8,\n    'ɵɵpropertyInterpolateV': ɵɵpropertyInterpolateV,\n    'ɵɵpipe': ɵɵpipe,\n    'ɵɵqueryRefresh': ɵɵqueryRefresh,\n    'ɵɵviewQuery': ɵɵviewQuery,\n    'ɵɵloadQuery': ɵɵloadQuery,\n    'ɵɵcontentQuery': ɵɵcontentQuery,\n    'ɵɵreference': ɵɵreference,\n    'ɵɵclassMap': ɵɵclassMap,\n    'ɵɵclassMapInterpolate1': ɵɵclassMapInterpolate1,\n    'ɵɵclassMapInterpolate2': ɵɵclassMapInterpolate2,\n    'ɵɵclassMapInterpolate3': ɵɵclassMapInterpolate3,\n    'ɵɵclassMapInterpolate4': ɵɵclassMapInterpolate4,\n    'ɵɵclassMapInterpolate5': ɵɵclassMapInterpolate5,\n    'ɵɵclassMapInterpolate6': ɵɵclassMapInterpolate6,\n    'ɵɵclassMapInterpolate7': ɵɵclassMapInterpolate7,\n    'ɵɵclassMapInterpolate8': ɵɵclassMapInterpolate8,\n    'ɵɵclassMapInterpolateV': ɵɵclassMapInterpolateV,\n    'ɵɵstyleMap': ɵɵstyleMap,\n    'ɵɵstyleMapInterpolate1': ɵɵstyleMapInterpolate1,\n    'ɵɵstyleMapInterpolate2': ɵɵstyleMapInterpolate2,\n    'ɵɵstyleMapInterpolate3': ɵɵstyleMapInterpolate3,\n    'ɵɵstyleMapInterpolate4': ɵɵstyleMapInterpolate4,\n    'ɵɵstyleMapInterpolate5': ɵɵstyleMapInterpolate5,\n    'ɵɵstyleMapInterpolate6': ɵɵstyleMapInterpolate6,\n    'ɵɵstyleMapInterpolate7': ɵɵstyleMapInterpolate7,\n    'ɵɵstyleMapInterpolate8': ɵɵstyleMapInterpolate8,\n    'ɵɵstyleMapInterpolateV': ɵɵstyleMapInterpolateV,\n    'ɵɵstyleProp': ɵɵstyleProp,\n    'ɵɵstylePropInterpolate1': ɵɵstylePropInterpolate1,\n    'ɵɵstylePropInterpolate2': ɵɵstylePropInterpolate2,\n    'ɵɵstylePropInterpolate3': ɵɵstylePropInterpolate3,\n    'ɵɵstylePropInterpolate4': ɵɵstylePropInterpolate4,\n    'ɵɵstylePropInterpolate5': ɵɵstylePropInterpolate5,\n    'ɵɵstylePropInterpolate6': ɵɵstylePropInterpolate6,\n    'ɵɵstylePropInterpolate7': ɵɵstylePropInterpolate7,\n    'ɵɵstylePropInterpolate8': ɵɵstylePropInterpolate8,\n    'ɵɵstylePropInterpolateV': ɵɵstylePropInterpolateV,\n    'ɵɵclassProp': ɵɵclassProp,\n    'ɵɵadvance': ɵɵadvance,\n    'ɵɵtemplate': ɵɵtemplate,\n    'ɵɵdefer': ɵɵdefer,\n    'ɵɵtext': ɵɵtext,\n    'ɵɵtextInterpolate': ɵɵtextInterpolate,\n    'ɵɵtextInterpolate1': ɵɵtextInterpolate1,\n    'ɵɵtextInterpolate2': ɵɵtextInterpolate2,\n    'ɵɵtextInterpolate3': ɵɵtextInterpolate3,\n    'ɵɵtextInterpolate4': ɵɵtextInterpolate4,\n    'ɵɵtextInterpolate5': ɵɵtextInterpolate5,\n    'ɵɵtextInterpolate6': ɵɵtextInterpolate6,\n    'ɵɵtextInterpolate7': ɵɵtextInterpolate7,\n    'ɵɵtextInterpolate8': ɵɵtextInterpolate8,\n    'ɵɵtextInterpolateV': ɵɵtextInterpolateV,\n    'ɵɵi18n': ɵɵi18n,\n    'ɵɵi18nAttributes': ɵɵi18nAttributes,\n    'ɵɵi18nExp': ɵɵi18nExp,\n    'ɵɵi18nStart': ɵɵi18nStart,\n    'ɵɵi18nEnd': ɵɵi18nEnd,\n    'ɵɵi18nApply': ɵɵi18nApply,\n    'ɵɵi18nPostprocess': ɵɵi18nPostprocess,\n    'ɵɵresolveWindow': ɵɵresolveWindow,\n    'ɵɵresolveDocument': ɵɵresolveDocument,\n    'ɵɵresolveBody': ɵɵresolveBody,\n    'ɵɵsetComponentScope': ɵɵsetComponentScope,\n    'ɵɵsetNgModuleScope': ɵɵsetNgModuleScope,\n    'ɵɵregisterNgModuleType': registerNgModuleType,\n    'ɵɵsanitizeHtml': ɵɵsanitizeHtml,\n    'ɵɵsanitizeStyle': ɵɵsanitizeStyle,\n    'ɵɵsanitizeResourceUrl': ɵɵsanitizeResourceUrl,\n    'ɵɵsanitizeScript': ɵɵsanitizeScript,\n    'ɵɵsanitizeUrl': ɵɵsanitizeUrl,\n    'ɵɵsanitizeUrlOrResourceUrl': ɵɵsanitizeUrlOrResourceUrl,\n    'ɵɵtrustConstantHtml': ɵɵtrustConstantHtml,\n    'ɵɵtrustConstantResourceUrl': ɵɵtrustConstantResourceUrl,\n    'ɵɵvalidateIframeAttribute': ɵɵvalidateIframeAttribute,\n    'forwardRef': forwardRef,\n    'resolveForwardRef': resolveForwardRef,\n}))();\n\nfunction patchModuleCompilation() {\n    // Does nothing, but exists as a target for patching.\n}\n\nfunction isModuleWithProviders$1(value) {\n    return value.ngModule !== undefined;\n}\nfunction isNgModule$1(value) {\n    return !!getNgModuleDef(value);\n}\nfunction isPipe(value) {\n    return !!getPipeDef$1(value);\n}\nfunction isDirective(value) {\n    return !!getDirectiveDef(value);\n}\nfunction isComponent(value) {\n    return !!getComponentDef$1(value);\n}\n\nconst moduleQueue = [];\n/**\n * Enqueues moduleDef to be checked later to see if scope can be set on its\n * component declarations.\n */\nfunction enqueueModuleForDelayedScoping(moduleType, ngModule) {\n    moduleQueue.push({ moduleType, ngModule });\n}\nlet flushingModuleQueue = false;\n/**\n * Loops over queued module definitions, if a given module definition has all of its\n * declarations resolved, it dequeues that module definition and sets the scope on\n * its declarations.\n */\nfunction flushModuleScopingQueueAsMuchAsPossible() {\n    if (!flushingModuleQueue) {\n        flushingModuleQueue = true;\n        try {\n            for (let i = moduleQueue.length - 1; i >= 0; i--) {\n                const { moduleType, ngModule } = moduleQueue[i];\n                if (ngModule.declarations && ngModule.declarations.every(isResolvedDeclaration)) {\n                    // dequeue\n                    moduleQueue.splice(i, 1);\n                    setScopeOnDeclaredComponents(moduleType, ngModule);\n                }\n            }\n        }\n        finally {\n            flushingModuleQueue = false;\n        }\n    }\n}\n/**\n * Returns truthy if a declaration has resolved. If the declaration happens to be\n * an array of declarations, it will recurse to check each declaration in that array\n * (which may also be arrays).\n */\nfunction isResolvedDeclaration(declaration) {\n    if (Array.isArray(declaration)) {\n        return declaration.every(isResolvedDeclaration);\n    }\n    return !!resolveForwardRef(declaration);\n}\n/**\n * Compiles a module in JIT mode.\n *\n * This function automatically gets called when a class has a `@NgModule` decorator.\n */\nfunction compileNgModule(moduleType, ngModule = {}) {\n    patchModuleCompilation();\n    compileNgModuleDefs(moduleType, ngModule);\n    if (ngModule.id !== undefined) {\n        registerNgModuleType(moduleType, ngModule.id);\n    }\n    // Because we don't know if all declarations have resolved yet at the moment the\n    // NgModule decorator is executing, we're enqueueing the setting of module scope\n    // on its declarations to be run at a later time when all declarations for the module,\n    // including forward refs, have resolved.\n    enqueueModuleForDelayedScoping(moduleType, ngModule);\n}\n/**\n * Compiles and adds the `ɵmod`, `ɵfac` and `ɵinj` properties to the module class.\n *\n * It's possible to compile a module via this API which will allow duplicate declarations in its\n * root.\n */\nfunction compileNgModuleDefs(moduleType, ngModule, allowDuplicateDeclarationsInRoot = false) {\n    ngDevMode && assertDefined(moduleType, 'Required value moduleType');\n    ngDevMode && assertDefined(ngModule, 'Required value ngModule');\n    const declarations = flatten$1(ngModule.declarations || EMPTY_ARRAY);\n    let ngModuleDef = null;\n    Object.defineProperty(moduleType, NG_MOD_DEF, {\n        configurable: true,\n        get: () => {\n            if (ngModuleDef === null) {\n                if (ngDevMode && ngModule.imports && ngModule.imports.indexOf(moduleType) > -1) {\n                    // We need to assert this immediately, because allowing it to continue will cause it to\n                    // go into an infinite loop before we've reached the point where we throw all the errors.\n                    throw new Error(`'${stringifyForError(moduleType)}' module can't import itself`);\n                }\n                const compiler = getCompilerFacade({ usage: 0 /* JitCompilerUsage.Decorator */, kind: 'NgModule', type: moduleType });\n                ngModuleDef = compiler.compileNgModule(angularCoreEnv, `ng:///${moduleType.name}/ɵmod.js`, {\n                    type: moduleType,\n                    bootstrap: flatten$1(ngModule.bootstrap || EMPTY_ARRAY).map(resolveForwardRef),\n                    declarations: declarations.map(resolveForwardRef),\n                    imports: flatten$1(ngModule.imports || EMPTY_ARRAY)\n                        .map(resolveForwardRef)\n                        .map(expandModuleWithProviders),\n                    exports: flatten$1(ngModule.exports || EMPTY_ARRAY)\n                        .map(resolveForwardRef)\n                        .map(expandModuleWithProviders),\n                    schemas: ngModule.schemas ? flatten$1(ngModule.schemas) : null,\n                    id: ngModule.id || null,\n                });\n                // Set `schemas` on ngModuleDef to an empty array in JIT mode to indicate that runtime\n                // should verify that there are no unknown elements in a template. In AOT mode, that check\n                // happens at compile time and `schemas` information is not present on Component and Module\n                // defs after compilation (so the check doesn't happen the second time at runtime).\n                if (!ngModuleDef.schemas) {\n                    ngModuleDef.schemas = [];\n                }\n            }\n            return ngModuleDef;\n        }\n    });\n    let ngFactoryDef = null;\n    Object.defineProperty(moduleType, NG_FACTORY_DEF, {\n        get: () => {\n            if (ngFactoryDef === null) {\n                const compiler = getCompilerFacade({ usage: 0 /* JitCompilerUsage.Decorator */, kind: 'NgModule', type: moduleType });\n                ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${moduleType.name}/ɵfac.js`, {\n                    name: moduleType.name,\n                    type: moduleType,\n                    deps: reflectDependencies(moduleType),\n                    target: compiler.FactoryTarget.NgModule,\n                    typeArgumentCount: 0,\n                });\n            }\n            return ngFactoryDef;\n        },\n        // Make the property configurable in dev mode to allow overriding in tests\n        configurable: !!ngDevMode,\n    });\n    let ngInjectorDef = null;\n    Object.defineProperty(moduleType, NG_INJ_DEF, {\n        get: () => {\n            if (ngInjectorDef === null) {\n                ngDevMode && verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot);\n                const meta = {\n                    name: moduleType.name,\n                    type: moduleType,\n                    providers: ngModule.providers || EMPTY_ARRAY,\n                    imports: [\n                        (ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef),\n                        (ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef),\n                    ],\n                };\n                const compiler = getCompilerFacade({ usage: 0 /* JitCompilerUsage.Decorator */, kind: 'NgModule', type: moduleType });\n                ngInjectorDef =\n                    compiler.compileInjector(angularCoreEnv, `ng:///${moduleType.name}/ɵinj.js`, meta);\n            }\n            return ngInjectorDef;\n        },\n        // Make the property configurable in dev mode to allow overriding in tests\n        configurable: !!ngDevMode,\n    });\n}\nfunction generateStandaloneInDeclarationsError(type, location) {\n    const prefix = `Unexpected \"${stringifyForError(type)}\" found in the \"declarations\" array of the`;\n    const suffix = `\"${stringifyForError(type)}\" is marked as standalone and can't be declared ` +\n        'in any NgModule - did you intend to import it instead (by adding it to the \"imports\" array)?';\n    return `${prefix} ${location}, ${suffix}`;\n}\nfunction verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot, importingModule) {\n    if (verifiedNgModule.get(moduleType))\n        return;\n    // skip verifications of standalone components, directives, and pipes\n    if (isStandalone(moduleType))\n        return;\n    verifiedNgModule.set(moduleType, true);\n    moduleType = resolveForwardRef(moduleType);\n    let ngModuleDef;\n    if (importingModule) {\n        ngModuleDef = getNgModuleDef(moduleType);\n        if (!ngModuleDef) {\n            throw new Error(`Unexpected value '${moduleType.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);\n        }\n    }\n    else {\n        ngModuleDef = getNgModuleDef(moduleType, true);\n    }\n    const errors = [];\n    const declarations = maybeUnwrapFn$1(ngModuleDef.declarations);\n    const imports = maybeUnwrapFn$1(ngModuleDef.imports);\n    flatten$1(imports).map(unwrapModuleWithProvidersImports).forEach(modOrStandaloneCmpt => {\n        verifySemanticsOfNgModuleImport(modOrStandaloneCmpt, moduleType);\n        verifySemanticsOfNgModuleDef(modOrStandaloneCmpt, false, moduleType);\n    });\n    const exports = maybeUnwrapFn$1(ngModuleDef.exports);\n    declarations.forEach(verifyDeclarationsHaveDefinitions);\n    declarations.forEach(verifyDirectivesHaveSelector);\n    declarations.forEach((declarationType) => verifyNotStandalone(declarationType, moduleType));\n    const combinedDeclarations = [\n        ...declarations.map(resolveForwardRef),\n        ...flatten$1(imports.map(computeCombinedExports)).map(resolveForwardRef),\n    ];\n    exports.forEach(verifyExportsAreDeclaredOrReExported);\n    declarations.forEach(decl => verifyDeclarationIsUnique(decl, allowDuplicateDeclarationsInRoot));\n    const ngModule = getAnnotation(moduleType, 'NgModule');\n    if (ngModule) {\n        ngModule.imports &&\n            flatten$1(ngModule.imports).map(unwrapModuleWithProvidersImports).forEach(mod => {\n                verifySemanticsOfNgModuleImport(mod, moduleType);\n                verifySemanticsOfNgModuleDef(mod, false, moduleType);\n            });\n        ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyCorrectBootstrapType);\n        ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyComponentIsPartOfNgModule);\n    }\n    // Throw Error if any errors were detected.\n    if (errors.length) {\n        throw new Error(errors.join('\\n'));\n    }\n    ////////////////////////////////////////////////////////////////////////////////////////////////\n    function verifyDeclarationsHaveDefinitions(type) {\n        type = resolveForwardRef(type);\n        const def = getComponentDef$1(type) || getDirectiveDef(type) || getPipeDef$1(type);\n        if (!def) {\n            errors.push(`Unexpected value '${stringifyForError(type)}' declared by the module '${stringifyForError(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`);\n        }\n    }\n    function verifyDirectivesHaveSelector(type) {\n        type = resolveForwardRef(type);\n        const def = getDirectiveDef(type);\n        if (!getComponentDef$1(type) && def && def.selectors.length == 0) {\n            errors.push(`Directive ${stringifyForError(type)} has no selector, please add it!`);\n        }\n    }\n    function verifyNotStandalone(type, moduleType) {\n        type = resolveForwardRef(type);\n        const def = getComponentDef$1(type) || getDirectiveDef(type) || getPipeDef$1(type);\n        if (def?.standalone) {\n            const location = `\"${stringifyForError(moduleType)}\" NgModule`;\n            errors.push(generateStandaloneInDeclarationsError(type, location));\n        }\n    }\n    function verifyExportsAreDeclaredOrReExported(type) {\n        type = resolveForwardRef(type);\n        const kind = getComponentDef$1(type) && 'component' || getDirectiveDef(type) && 'directive' ||\n            getPipeDef$1(type) && 'pipe';\n        if (kind) {\n            // only checked if we are declared as Component, Directive, or Pipe\n            // Modules don't need to be declared or imported.\n            if (combinedDeclarations.lastIndexOf(type) === -1) {\n                // We are exporting something which we don't explicitly declare or import.\n                errors.push(`Can't export ${kind} ${stringifyForError(type)} from ${stringifyForError(moduleType)} as it was neither declared nor imported!`);\n            }\n        }\n    }\n    function verifyDeclarationIsUnique(type, suppressErrors) {\n        type = resolveForwardRef(type);\n        const existingModule = ownerNgModule.get(type);\n        if (existingModule && existingModule !== moduleType) {\n            if (!suppressErrors) {\n                const modules = [existingModule, moduleType].map(stringifyForError).sort();\n                errors.push(`Type ${stringifyForError(type)} is part of the declarations of 2 modules: ${modules[0]} and ${modules[1]}! ` +\n                    `Please consider moving ${stringifyForError(type)} to a higher module that imports ${modules[0]} and ${modules[1]}. ` +\n                    `You can also create a new NgModule that exports and includes ${stringifyForError(type)} then import that NgModule in ${modules[0]} and ${modules[1]}.`);\n            }\n        }\n        else {\n            // Mark type as having owner.\n            ownerNgModule.set(type, moduleType);\n        }\n    }\n    function verifyComponentIsPartOfNgModule(type) {\n        type = resolveForwardRef(type);\n        const existingModule = ownerNgModule.get(type);\n        if (!existingModule && !isStandalone(type)) {\n            errors.push(`Component ${stringifyForError(type)} is not part of any NgModule or the module has not been imported into your module.`);\n        }\n    }\n    function verifyCorrectBootstrapType(type) {\n        type = resolveForwardRef(type);\n        if (!getComponentDef$1(type)) {\n            errors.push(`${stringifyForError(type)} cannot be used as an entry component.`);\n        }\n        if (isStandalone(type)) {\n            // Note: this error should be the same as the\n            // `NGMODULE_BOOTSTRAP_IS_STANDALONE` one in AOT compiler.\n            errors.push(`The \\`${stringifyForError(type)}\\` class is a standalone component, which can ` +\n                `not be used in the \\`@NgModule.bootstrap\\` array. Use the \\`bootstrapApplication\\` ` +\n                `function for bootstrap instead.`);\n        }\n    }\n    function verifySemanticsOfNgModuleImport(type, importingModule) {\n        type = resolveForwardRef(type);\n        const directiveDef = getComponentDef$1(type) || getDirectiveDef(type);\n        if (directiveDef !== null && !directiveDef.standalone) {\n            throw new Error(`Unexpected directive '${type.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);\n        }\n        const pipeDef = getPipeDef$1(type);\n        if (pipeDef !== null && !pipeDef.standalone) {\n            throw new Error(`Unexpected pipe '${type.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);\n        }\n    }\n}\nfunction unwrapModuleWithProvidersImports(typeOrWithProviders) {\n    typeOrWithProviders = resolveForwardRef(typeOrWithProviders);\n    return typeOrWithProviders.ngModule || typeOrWithProviders;\n}\nfunction getAnnotation(type, name) {\n    let annotation = null;\n    collect(type.__annotations__);\n    collect(type.decorators);\n    return annotation;\n    function collect(annotations) {\n        if (annotations) {\n            annotations.forEach(readAnnotation);\n        }\n    }\n    function readAnnotation(decorator) {\n        if (!annotation) {\n            const proto = Object.getPrototypeOf(decorator);\n            if (proto.ngMetadataName == name) {\n                annotation = decorator;\n            }\n            else if (decorator.type) {\n                const proto = Object.getPrototypeOf(decorator.type);\n                if (proto.ngMetadataName == name) {\n                    annotation = decorator.args[0];\n                }\n            }\n        }\n    }\n}\n/**\n * Keep track of compiled components. This is needed because in tests we often want to compile the\n * same component with more than one NgModule. This would cause an error unless we reset which\n * NgModule the component belongs to. We keep the list of compiled components here so that the\n * TestBed can reset it later.\n */\nlet ownerNgModule = new WeakMap();\nlet verifiedNgModule = new WeakMap();\nfunction resetCompiledComponents() {\n    ownerNgModule = new WeakMap();\n    verifiedNgModule = new WeakMap();\n    moduleQueue.length = 0;\n    GENERATED_COMP_IDS.clear();\n}\n/**\n * Computes the combined declarations of explicit declarations, as well as declarations inherited by\n * traversing the exports of imported modules.\n * @param type\n */\nfunction computeCombinedExports(type) {\n    type = resolveForwardRef(type);\n    const ngModuleDef = getNgModuleDef(type);\n    // a standalone component, directive or pipe\n    if (ngModuleDef === null) {\n        return [type];\n    }\n    return flatten$1(maybeUnwrapFn$1(ngModuleDef.exports).map((type) => {\n        const ngModuleDef = getNgModuleDef(type);\n        if (ngModuleDef) {\n            verifySemanticsOfNgModuleDef(type, false);\n            return computeCombinedExports(type);\n        }\n        else {\n            return type;\n        }\n    }));\n}\n/**\n * Some declared components may be compiled asynchronously, and thus may not have their\n * ɵcmp set yet. If this is the case, then a reference to the module is written into\n * the `ngSelectorScope` property of the declared type.\n */\nfunction setScopeOnDeclaredComponents(moduleType, ngModule) {\n    const declarations = flatten$1(ngModule.declarations || EMPTY_ARRAY);\n    const transitiveScopes = transitiveScopesFor(moduleType);\n    declarations.forEach(declaration => {\n        declaration = resolveForwardRef(declaration);\n        if (declaration.hasOwnProperty(NG_COMP_DEF)) {\n            // A `ɵcmp` field exists - go ahead and patch the component directly.\n            const component = declaration;\n            const componentDef = getComponentDef$1(component);\n            patchComponentDefWithScope(componentDef, transitiveScopes);\n        }\n        else if (!declaration.hasOwnProperty(NG_DIR_DEF) && !declaration.hasOwnProperty(NG_PIPE_DEF)) {\n            // Set `ngSelectorScope` for future reference when the component compilation finishes.\n            declaration.ngSelectorScope = moduleType;\n        }\n    });\n}\n/**\n * Patch the definition of a component with directives and pipes from the compilation scope of\n * a given module.\n */\nfunction patchComponentDefWithScope(componentDef, transitiveScopes) {\n    componentDef.directiveDefs = () => Array.from(transitiveScopes.compilation.directives)\n        .map(dir => dir.hasOwnProperty(NG_COMP_DEF) ? getComponentDef$1(dir) : getDirectiveDef(dir))\n        .filter(def => !!def);\n    componentDef.pipeDefs = () => Array.from(transitiveScopes.compilation.pipes).map(pipe => getPipeDef$1(pipe));\n    componentDef.schemas = transitiveScopes.schemas;\n    // Since we avoid Components/Directives/Pipes recompiling in case there are no overrides, we\n    // may face a problem where previously compiled defs available to a given Component/Directive\n    // are cached in TView and may become stale (in case any of these defs gets recompiled). In\n    // order to avoid this problem, we force fresh TView to be created.\n    componentDef.tView = null;\n}\n/**\n * Compute the pair of transitive scopes (compilation scope and exported scope) for a given type\n * (either a NgModule or a standalone component / directive / pipe).\n */\nfunction transitiveScopesFor(type) {\n    if (isNgModule$1(type)) {\n        return transitiveScopesForNgModule(type);\n    }\n    else if (isStandalone(type)) {\n        const directiveDef = getComponentDef$1(type) || getDirectiveDef(type);\n        if (directiveDef !== null) {\n            return {\n                schemas: null,\n                compilation: {\n                    directives: new Set(),\n                    pipes: new Set(),\n                },\n                exported: {\n                    directives: new Set([type]),\n                    pipes: new Set(),\n                },\n            };\n        }\n        const pipeDef = getPipeDef$1(type);\n        if (pipeDef !== null) {\n            return {\n                schemas: null,\n                compilation: {\n                    directives: new Set(),\n                    pipes: new Set(),\n                },\n                exported: {\n                    directives: new Set(),\n                    pipes: new Set([type]),\n                },\n            };\n        }\n    }\n    // TODO: change the error message to be more user-facing and take standalone into account\n    throw new Error(`${type.name} does not have a module def (ɵmod property)`);\n}\n/**\n * Compute the pair of transitive scopes (compilation scope and exported scope) for a given module.\n *\n * This operation is memoized and the result is cached on the module's definition. This function can\n * be called on modules with components that have not fully compiled yet, but the result should not\n * be used until they have.\n *\n * @param moduleType module that transitive scope should be calculated for.\n */\nfunction transitiveScopesForNgModule(moduleType) {\n    const def = getNgModuleDef(moduleType, true);\n    if (def.transitiveCompileScopes !== null) {\n        return def.transitiveCompileScopes;\n    }\n    const scopes = {\n        schemas: def.schemas || null,\n        compilation: {\n            directives: new Set(),\n            pipes: new Set(),\n        },\n        exported: {\n            directives: new Set(),\n            pipes: new Set(),\n        },\n    };\n    maybeUnwrapFn$1(def.imports).forEach((imported) => {\n        // When this module imports another, the imported module's exported directives and pipes are\n        // added to the compilation scope of this module.\n        const importedScope = transitiveScopesFor(imported);\n        importedScope.exported.directives.forEach(entry => scopes.compilation.directives.add(entry));\n        importedScope.exported.pipes.forEach(entry => scopes.compilation.pipes.add(entry));\n    });\n    maybeUnwrapFn$1(def.declarations).forEach(declared => {\n        const declaredWithDefs = declared;\n        if (getPipeDef$1(declaredWithDefs)) {\n            scopes.compilation.pipes.add(declared);\n        }\n        else {\n            // Either declared has a ɵcmp or ɵdir, or it's a component which hasn't\n            // had its template compiled yet. In either case, it gets added to the compilation's\n            // directives.\n            scopes.compilation.directives.add(declared);\n        }\n    });\n    maybeUnwrapFn$1(def.exports).forEach((exported) => {\n        const exportedType = exported;\n        // Either the type is a module, a pipe, or a component/directive (which may not have a\n        // ɵcmp as it might be compiled asynchronously).\n        if (isNgModule$1(exportedType)) {\n            // When this module exports another, the exported module's exported directives and pipes are\n            // added to both the compilation and exported scopes of this module.\n            const exportedScope = transitiveScopesFor(exportedType);\n            exportedScope.exported.directives.forEach(entry => {\n                scopes.compilation.directives.add(entry);\n                scopes.exported.directives.add(entry);\n            });\n            exportedScope.exported.pipes.forEach(entry => {\n                scopes.compilation.pipes.add(entry);\n                scopes.exported.pipes.add(entry);\n            });\n        }\n        else if (getPipeDef$1(exportedType)) {\n            scopes.exported.pipes.add(exportedType);\n        }\n        else {\n            scopes.exported.directives.add(exportedType);\n        }\n    });\n    def.transitiveCompileScopes = scopes;\n    return scopes;\n}\nfunction expandModuleWithProviders(value) {\n    if (isModuleWithProviders$1(value)) {\n        return value.ngModule;\n    }\n    return value;\n}\n\nlet _nextReferenceId = 0;\nclass MetadataOverrider {\n    constructor() {\n        this._references = new Map();\n    }\n    /**\n     * Creates a new instance for the given metadata class\n     * based on an old instance and overrides.\n     */\n    overrideMetadata(metadataClass, oldMetadata, override) {\n        const props = {};\n        if (oldMetadata) {\n            _valueProps(oldMetadata).forEach((prop) => props[prop] = oldMetadata[prop]);\n        }\n        if (override.set) {\n            if (override.remove || override.add) {\n                throw new Error(`Cannot set and add/remove ${ɵstringify(metadataClass)} at the same time!`);\n            }\n            setMetadata(props, override.set);\n        }\n        if (override.remove) {\n            removeMetadata(props, override.remove, this._references);\n        }\n        if (override.add) {\n            addMetadata(props, override.add);\n        }\n        return new metadataClass(props);\n    }\n}\nfunction removeMetadata(metadata, remove, references) {\n    const removeObjects = new Set();\n    for (const prop in remove) {\n        const removeValue = remove[prop];\n        if (Array.isArray(removeValue)) {\n            removeValue.forEach((value) => {\n                removeObjects.add(_propHashKey(prop, value, references));\n            });\n        }\n        else {\n            removeObjects.add(_propHashKey(prop, removeValue, references));\n        }\n    }\n    for (const prop in metadata) {\n        const propValue = metadata[prop];\n        if (Array.isArray(propValue)) {\n            metadata[prop] = propValue.filter((value) => !removeObjects.has(_propHashKey(prop, value, references)));\n        }\n        else {\n            if (removeObjects.has(_propHashKey(prop, propValue, references))) {\n                metadata[prop] = undefined;\n            }\n        }\n    }\n}\nfunction addMetadata(metadata, add) {\n    for (const prop in add) {\n        const addValue = add[prop];\n        const propValue = metadata[prop];\n        if (propValue != null && Array.isArray(propValue)) {\n            metadata[prop] = propValue.concat(addValue);\n        }\n        else {\n            metadata[prop] = addValue;\n        }\n    }\n}\nfunction setMetadata(metadata, set) {\n    for (const prop in set) {\n        metadata[prop] = set[prop];\n    }\n}\nfunction _propHashKey(propName, propValue, references) {\n    let nextObjectId = 0;\n    const objectIds = new Map();\n    const replacer = (key, value) => {\n        if (value !== null && typeof value === 'object') {\n            if (objectIds.has(value)) {\n                return objectIds.get(value);\n            }\n            // Record an id for this object such that any later references use the object's id instead\n            // of the object itself, in order to break cyclic pointers in objects.\n            objectIds.set(value, `ɵobj#${nextObjectId++}`);\n            // The first time an object is seen the object itself is serialized.\n            return value;\n        }\n        else if (typeof value === 'function') {\n            value = _serializeReference(value, references);\n        }\n        return value;\n    };\n    return `${propName}:${JSON.stringify(propValue, replacer)}`;\n}\nfunction _serializeReference(ref, references) {\n    let id = references.get(ref);\n    if (!id) {\n        id = `${ɵstringify(ref)}${_nextReferenceId++}`;\n        references.set(ref, id);\n    }\n    return id;\n}\nfunction _valueProps(obj) {\n    const props = [];\n    // regular public props\n    Object.keys(obj).forEach((prop) => {\n        if (!prop.startsWith('_')) {\n            props.push(prop);\n        }\n    });\n    // getters\n    let proto = obj;\n    while (proto = Object.getPrototypeOf(proto)) {\n        Object.keys(proto).forEach((protoProp) => {\n            const desc = Object.getOwnPropertyDescriptor(proto, protoProp);\n            if (!protoProp.startsWith('_') && desc && 'get' in desc) {\n                props.push(protoProp);\n            }\n        });\n    }\n    return props;\n}\n\nconst reflection = new ɵReflectionCapabilities();\n/**\n * Allows to override ivy metadata for tests (via the `TestBed`).\n */\nclass OverrideResolver {\n    constructor() {\n        this.overrides = new Map();\n        this.resolved = new Map();\n    }\n    addOverride(type, override) {\n        const overrides = this.overrides.get(type) || [];\n        overrides.push(override);\n        this.overrides.set(type, overrides);\n        this.resolved.delete(type);\n    }\n    setOverrides(overrides) {\n        this.overrides.clear();\n        overrides.forEach(([type, override]) => {\n            this.addOverride(type, override);\n        });\n    }\n    getAnnotation(type) {\n        const annotations = reflection.annotations(type);\n        // Try to find the nearest known Type annotation and make sure that this annotation is an\n        // instance of the type we are looking for, so we can use it for resolution. Note: there might\n        // be multiple known annotations found due to the fact that Components can extend Directives (so\n        // both Directive and Component annotations would be present), so we always check if the known\n        // annotation has the right type.\n        for (let i = annotations.length - 1; i >= 0; i--) {\n            const annotation = annotations[i];\n            const isKnownType = annotation instanceof Directive || annotation instanceof Component ||\n                annotation instanceof Pipe || annotation instanceof NgModule;\n            if (isKnownType) {\n                return annotation instanceof this.type ? annotation : null;\n            }\n        }\n        return null;\n    }\n    resolve(type) {\n        let resolved = this.resolved.get(type) || null;\n        if (!resolved) {\n            resolved = this.getAnnotation(type);\n            if (resolved) {\n                const overrides = this.overrides.get(type);\n                if (overrides) {\n                    const overrider = new MetadataOverrider();\n                    overrides.forEach(override => {\n                        resolved = overrider.overrideMetadata(this.type, resolved, override);\n                    });\n                }\n            }\n            this.resolved.set(type, resolved);\n        }\n        return resolved;\n    }\n}\nclass DirectiveResolver extends OverrideResolver {\n    get type() {\n        return Directive;\n    }\n}\nclass ComponentResolver extends OverrideResolver {\n    get type() {\n        return Component;\n    }\n}\nclass PipeResolver extends OverrideResolver {\n    get type() {\n        return Pipe;\n    }\n}\nclass NgModuleResolver extends OverrideResolver {\n    get type() {\n        return NgModule;\n    }\n}\n\nvar TestingModuleOverride;\n(function (TestingModuleOverride) {\n    TestingModuleOverride[TestingModuleOverride[\"DECLARATION\"] = 0] = \"DECLARATION\";\n    TestingModuleOverride[TestingModuleOverride[\"OVERRIDE_TEMPLATE\"] = 1] = \"OVERRIDE_TEMPLATE\";\n})(TestingModuleOverride || (TestingModuleOverride = {}));\nfunction isTestingModuleOverride(value) {\n    return value === TestingModuleOverride.DECLARATION ||\n        value === TestingModuleOverride.OVERRIDE_TEMPLATE;\n}\nfunction assertNoStandaloneComponents(types, resolver, location) {\n    types.forEach(type => {\n        const component = resolver.resolve(type);\n        if (component && component.standalone) {\n            throw new Error(generateStandaloneInDeclarationsError(type, location));\n        }\n    });\n}\nclass TestBedCompiler {\n    constructor(platform, additionalModuleTypes) {\n        this.platform = platform;\n        this.additionalModuleTypes = additionalModuleTypes;\n        this.originalComponentResolutionQueue = null;\n        // Testing module configuration\n        this.declarations = [];\n        this.imports = [];\n        this.providers = [];\n        this.schemas = [];\n        // Queues of components/directives/pipes that should be recompiled.\n        this.pendingComponents = new Set();\n        this.pendingDirectives = new Set();\n        this.pendingPipes = new Set();\n        // Keep track of all components and directives, so we can patch Providers onto defs later.\n        this.seenComponents = new Set();\n        this.seenDirectives = new Set();\n        // Keep track of overridden modules, so that we can collect all affected ones in the module tree.\n        this.overriddenModules = new Set();\n        // Store resolved styles for Components that have template overrides present and `styleUrls`\n        // defined at the same time.\n        this.existingComponentStyles = new Map();\n        this.resolvers = initResolvers();\n        this.componentToModuleScope = new Map();\n        // Map that keeps initial version of component/directive/pipe defs in case\n        // we compile a Type again, thus overriding respective static fields. This is\n        // required to make sure we restore defs to their initial states between test runs.\n        // Note: one class may have multiple defs (for example: ɵmod and ɵinj in case of an\n        // NgModule), store all of them in a map.\n        this.initialNgDefs = new Map();\n        // Array that keeps cleanup operations for initial versions of component/directive/pipe/module\n        // defs in case TestBed makes changes to the originals.\n        this.defCleanupOps = [];\n        this._injector = null;\n        this.compilerProviders = null;\n        this.providerOverrides = [];\n        this.rootProviderOverrides = [];\n        // Overrides for injectables with `{providedIn: SomeModule}` need to be tracked and added to that\n        // module's provider list.\n        this.providerOverridesByModule = new Map();\n        this.providerOverridesByToken = new Map();\n        this.scopesWithOverriddenProviders = new Set();\n        this.testModuleRef = null;\n        class DynamicTestModule {\n        }\n        this.testModuleType = DynamicTestModule;\n    }\n    setCompilerProviders(providers) {\n        this.compilerProviders = providers;\n        this._injector = null;\n    }\n    configureTestingModule(moduleDef) {\n        // Enqueue any compilation tasks for the directly declared component.\n        if (moduleDef.declarations !== undefined) {\n            // Verify that there are no standalone components\n            assertNoStandaloneComponents(moduleDef.declarations, this.resolvers.component, '\"TestBed.configureTestingModule\" call');\n            this.queueTypeArray(moduleDef.declarations, TestingModuleOverride.DECLARATION);\n            this.declarations.push(...moduleDef.declarations);\n        }\n        // Enqueue any compilation tasks for imported modules.\n        if (moduleDef.imports !== undefined) {\n            this.queueTypesFromModulesArray(moduleDef.imports);\n            this.imports.push(...moduleDef.imports);\n        }\n        if (moduleDef.providers !== undefined) {\n            this.providers.push(...moduleDef.providers);\n        }\n        if (moduleDef.schemas !== undefined) {\n            this.schemas.push(...moduleDef.schemas);\n        }\n    }\n    overrideModule(ngModule, override) {\n        this.overriddenModules.add(ngModule);\n        // Compile the module right away.\n        this.resolvers.module.addOverride(ngModule, override);\n        const metadata = this.resolvers.module.resolve(ngModule);\n        if (metadata === null) {\n            throw invalidTypeError(ngModule.name, 'NgModule');\n        }\n        this.recompileNgModule(ngModule, metadata);\n        // At this point, the module has a valid module def (ɵmod), but the override may have introduced\n        // new declarations or imported modules. Ingest any possible new types and add them to the\n        // current queue.\n        this.queueTypesFromModulesArray([ngModule]);\n    }\n    overrideComponent(component, override) {\n        this.verifyNoStandaloneFlagOverrides(component, override);\n        this.resolvers.component.addOverride(component, override);\n        this.pendingComponents.add(component);\n    }\n    overrideDirective(directive, override) {\n        this.verifyNoStandaloneFlagOverrides(directive, override);\n        this.resolvers.directive.addOverride(directive, override);\n        this.pendingDirectives.add(directive);\n    }\n    overridePipe(pipe, override) {\n        this.verifyNoStandaloneFlagOverrides(pipe, override);\n        this.resolvers.pipe.addOverride(pipe, override);\n        this.pendingPipes.add(pipe);\n    }\n    verifyNoStandaloneFlagOverrides(type, override) {\n        if (override.add?.hasOwnProperty('standalone') || override.set?.hasOwnProperty('standalone') ||\n            override.remove?.hasOwnProperty('standalone')) {\n            throw new Error(`An override for the ${type.name} class has the \\`standalone\\` flag. ` +\n                `Changing the \\`standalone\\` flag via TestBed overrides is not supported.`);\n        }\n    }\n    overrideProvider(token, provider) {\n        let providerDef;\n        if (provider.useFactory !== undefined) {\n            providerDef = {\n                provide: token,\n                useFactory: provider.useFactory,\n                deps: provider.deps || [],\n                multi: provider.multi\n            };\n        }\n        else if (provider.useValue !== undefined) {\n            providerDef = { provide: token, useValue: provider.useValue, multi: provider.multi };\n        }\n        else {\n            providerDef = { provide: token };\n        }\n        const injectableDef = typeof token !== 'string' ? ɵgetInjectableDef(token) : null;\n        const providedIn = injectableDef === null ? null : resolveForwardRef$1(injectableDef.providedIn);\n        const overridesBucket = providedIn === 'root' ? this.rootProviderOverrides : this.providerOverrides;\n        overridesBucket.push(providerDef);\n        // Keep overrides grouped by token as well for fast lookups using token\n        this.providerOverridesByToken.set(token, providerDef);\n        if (injectableDef !== null && providedIn !== null && typeof providedIn !== 'string') {\n            const existingOverrides = this.providerOverridesByModule.get(providedIn);\n            if (existingOverrides !== undefined) {\n                existingOverrides.push(providerDef);\n            }\n            else {\n                this.providerOverridesByModule.set(providedIn, [providerDef]);\n            }\n        }\n    }\n    overrideTemplateUsingTestingModule(type, template) {\n        const def = type[ɵNG_COMP_DEF];\n        const hasStyleUrls = () => {\n            const metadata = this.resolvers.component.resolve(type);\n            return !!metadata.styleUrls && metadata.styleUrls.length > 0;\n        };\n        const overrideStyleUrls = !!def && !isComponentDefPendingResolution(type) && hasStyleUrls();\n        // In Ivy, compiling a component does not require knowing the module providing the\n        // component's scope, so overrideTemplateUsingTestingModule can be implemented purely via\n        // overrideComponent. Important: overriding template requires full Component re-compilation,\n        // which may fail in case styleUrls are also present (thus Component is considered as required\n        // resolution). In order to avoid this, we preemptively set styleUrls to an empty array,\n        // preserve current styles available on Component def and restore styles back once compilation\n        // is complete.\n        const override = overrideStyleUrls ? { template, styles: [], styleUrls: [] } : { template };\n        this.overrideComponent(type, { set: override });\n        if (overrideStyleUrls && def.styles && def.styles.length > 0) {\n            this.existingComponentStyles.set(type, def.styles);\n        }\n        // Set the component's scope to be the testing module.\n        this.componentToModuleScope.set(type, TestingModuleOverride.OVERRIDE_TEMPLATE);\n    }\n    async compileComponents() {\n        this.clearComponentResolutionQueue();\n        // Run compilers for all queued types.\n        let needsAsyncResources = this.compileTypesSync();\n        // compileComponents() should not be async unless it needs to be.\n        if (needsAsyncResources) {\n            let resourceLoader;\n            let resolver = (url) => {\n                if (!resourceLoader) {\n                    resourceLoader = this.injector.get(ResourceLoader);\n                }\n                return Promise.resolve(resourceLoader.get(url));\n            };\n            await resolveComponentResources(resolver);\n        }\n    }\n    finalize() {\n        // One last compile\n        this.compileTypesSync();\n        // Create the testing module itself.\n        this.compileTestModule();\n        this.applyTransitiveScopes();\n        this.applyProviderOverrides();\n        // Patch previously stored `styles` Component values (taken from ɵcmp), in case these\n        // Components have `styleUrls` fields defined and template override was requested.\n        this.patchComponentsWithExistingStyles();\n        // Clear the componentToModuleScope map, so that future compilations don't reset the scope of\n        // every component.\n        this.componentToModuleScope.clear();\n        const parentInjector = this.platform.injector;\n        this.testModuleRef = new ɵRender3NgModuleRef(this.testModuleType, parentInjector, []);\n        // ApplicationInitStatus.runInitializers() is marked @internal to core.\n        // Cast it to any before accessing it.\n        this.testModuleRef.injector.get(ApplicationInitStatus).runInitializers();\n        // Set locale ID after running app initializers, since locale information might be updated while\n        // running initializers. This is also consistent with the execution order while bootstrapping an\n        // app (see `packages/core/src/application_ref.ts` file).\n        const localeId = this.testModuleRef.injector.get(LOCALE_ID$1, ɵDEFAULT_LOCALE_ID);\n        ɵsetLocaleId(localeId);\n        return this.testModuleRef;\n    }\n    /**\n     * @internal\n     */\n    _compileNgModuleSync(moduleType) {\n        this.queueTypesFromModulesArray([moduleType]);\n        this.compileTypesSync();\n        this.applyProviderOverrides();\n        this.applyProviderOverridesInScope(moduleType);\n        this.applyTransitiveScopes();\n    }\n    /**\n     * @internal\n     */\n    async _compileNgModuleAsync(moduleType) {\n        this.queueTypesFromModulesArray([moduleType]);\n        await this.compileComponents();\n        this.applyProviderOverrides();\n        this.applyProviderOverridesInScope(moduleType);\n        this.applyTransitiveScopes();\n    }\n    /**\n     * @internal\n     */\n    _getModuleResolver() {\n        return this.resolvers.module;\n    }\n    /**\n     * @internal\n     */\n    _getComponentFactories(moduleType) {\n        return maybeUnwrapFn(moduleType.ɵmod.declarations).reduce((factories, declaration) => {\n            const componentDef = declaration.ɵcmp;\n            componentDef && factories.push(new ɵRender3ComponentFactory(componentDef, this.testModuleRef));\n            return factories;\n        }, []);\n    }\n    compileTypesSync() {\n        // Compile all queued components, directives, pipes.\n        let needsAsyncResources = false;\n        this.pendingComponents.forEach(declaration => {\n            needsAsyncResources = needsAsyncResources || isComponentDefPendingResolution(declaration);\n            const metadata = this.resolvers.component.resolve(declaration);\n            if (metadata === null) {\n                throw invalidTypeError(declaration.name, 'Component');\n            }\n            this.maybeStoreNgDef(ɵNG_COMP_DEF, declaration);\n            ɵcompileComponent(declaration, metadata);\n        });\n        this.pendingComponents.clear();\n        this.pendingDirectives.forEach(declaration => {\n            const metadata = this.resolvers.directive.resolve(declaration);\n            if (metadata === null) {\n                throw invalidTypeError(declaration.name, 'Directive');\n            }\n            this.maybeStoreNgDef(ɵNG_DIR_DEF, declaration);\n            ɵcompileDirective(declaration, metadata);\n        });\n        this.pendingDirectives.clear();\n        this.pendingPipes.forEach(declaration => {\n            const metadata = this.resolvers.pipe.resolve(declaration);\n            if (metadata === null) {\n                throw invalidTypeError(declaration.name, 'Pipe');\n            }\n            this.maybeStoreNgDef(ɵNG_PIPE_DEF, declaration);\n            ɵcompilePipe(declaration, metadata);\n        });\n        this.pendingPipes.clear();\n        return needsAsyncResources;\n    }\n    applyTransitiveScopes() {\n        if (this.overriddenModules.size > 0) {\n            // Module overrides (via `TestBed.overrideModule`) might affect scopes that were previously\n            // calculated and stored in `transitiveCompileScopes`. If module overrides are present,\n            // collect all affected modules and reset scopes to force their re-calculation.\n            const testingModuleDef = this.testModuleType[ɵNG_MOD_DEF];\n            const affectedModules = this.collectModulesAffectedByOverrides(testingModuleDef.imports);\n            if (affectedModules.size > 0) {\n                affectedModules.forEach(moduleType => {\n                    this.storeFieldOfDefOnType(moduleType, ɵNG_MOD_DEF, 'transitiveCompileScopes');\n                    moduleType[ɵNG_MOD_DEF].transitiveCompileScopes = null;\n                });\n            }\n        }\n        const moduleToScope = new Map();\n        const getScopeOfModule = (moduleType) => {\n            if (!moduleToScope.has(moduleType)) {\n                const isTestingModule = isTestingModuleOverride(moduleType);\n                const realType = isTestingModule ? this.testModuleType : moduleType;\n                moduleToScope.set(moduleType, ɵtransitiveScopesFor(realType));\n            }\n            return moduleToScope.get(moduleType);\n        };\n        this.componentToModuleScope.forEach((moduleType, componentType) => {\n            const moduleScope = getScopeOfModule(moduleType);\n            this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'directiveDefs');\n            this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'pipeDefs');\n            // `tView` that is stored on component def contains information about directives and pipes\n            // that are in the scope of this component. Patching component scope will cause `tView` to be\n            // changed. Store original `tView` before patching scope, so the `tView` (including scope\n            // information) is restored back to its previous/original state before running next test.\n            this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'tView');\n            ɵpatchComponentDefWithScope(componentType.ɵcmp, moduleScope);\n        });\n        this.componentToModuleScope.clear();\n    }\n    applyProviderOverrides() {\n        const maybeApplyOverrides = (field) => (type) => {\n            const resolver = field === ɵNG_COMP_DEF ? this.resolvers.component : this.resolvers.directive;\n            const metadata = resolver.resolve(type);\n            if (this.hasProviderOverrides(metadata.providers)) {\n                this.patchDefWithProviderOverrides(type, field);\n            }\n        };\n        this.seenComponents.forEach(maybeApplyOverrides(ɵNG_COMP_DEF));\n        this.seenDirectives.forEach(maybeApplyOverrides(ɵNG_DIR_DEF));\n        this.seenComponents.clear();\n        this.seenDirectives.clear();\n    }\n    /**\n     * Applies provider overrides to a given type (either an NgModule or a standalone component)\n     * and all imported NgModules and standalone components recursively.\n     */\n    applyProviderOverridesInScope(type) {\n        const hasScope = isStandaloneComponent(type) || isNgModule(type);\n        // The function can be re-entered recursively while inspecting dependencies\n        // of an NgModule or a standalone component. Exit early if we come across a\n        // type that can not have a scope (directive or pipe) or the type is already\n        // processed earlier.\n        if (!hasScope || this.scopesWithOverriddenProviders.has(type)) {\n            return;\n        }\n        this.scopesWithOverriddenProviders.add(type);\n        // NOTE: the line below triggers JIT compilation of the module injector,\n        // which also invokes verification of the NgModule semantics, which produces\n        // detailed error messages. The fact that the code relies on this line being\n        // present here is suspicious and should be refactored in a way that the line\n        // below can be moved (for ex. after an early exit check below).\n        const injectorDef = type[ɵNG_INJ_DEF];\n        // No provider overrides, exit early.\n        if (this.providerOverridesByToken.size === 0)\n            return;\n        if (isStandaloneComponent(type)) {\n            // Visit all component dependencies and override providers there.\n            const def = getComponentDef(type);\n            const dependencies = maybeUnwrapFn(def.dependencies ?? []);\n            for (const dependency of dependencies) {\n                this.applyProviderOverridesInScope(dependency);\n            }\n        }\n        else {\n            const providers = [\n                ...injectorDef.providers,\n                ...(this.providerOverridesByModule.get(type) || [])\n            ];\n            if (this.hasProviderOverrides(providers)) {\n                this.maybeStoreNgDef(ɵNG_INJ_DEF, type);\n                this.storeFieldOfDefOnType(type, ɵNG_INJ_DEF, 'providers');\n                injectorDef.providers = this.getOverriddenProviders(providers);\n            }\n            // Apply provider overrides to imported modules recursively\n            const moduleDef = type[ɵNG_MOD_DEF];\n            const imports = maybeUnwrapFn(moduleDef.imports);\n            for (const importedModule of imports) {\n                this.applyProviderOverridesInScope(importedModule);\n            }\n            // Also override the providers on any ModuleWithProviders imports since those don't appear in\n            // the moduleDef.\n            for (const importedModule of flatten(injectorDef.imports)) {\n                if (isModuleWithProviders(importedModule)) {\n                    this.defCleanupOps.push({\n                        object: importedModule,\n                        fieldName: 'providers',\n                        originalValue: importedModule.providers\n                    });\n                    importedModule.providers = this.getOverriddenProviders(importedModule.providers);\n                }\n            }\n        }\n    }\n    patchComponentsWithExistingStyles() {\n        this.existingComponentStyles.forEach((styles, type) => type[ɵNG_COMP_DEF].styles = styles);\n        this.existingComponentStyles.clear();\n    }\n    queueTypeArray(arr, moduleType) {\n        for (const value of arr) {\n            if (Array.isArray(value)) {\n                this.queueTypeArray(value, moduleType);\n            }\n            else {\n                this.queueType(value, moduleType);\n            }\n        }\n    }\n    recompileNgModule(ngModule, metadata) {\n        // Cache the initial ngModuleDef as it will be overwritten.\n        this.maybeStoreNgDef(ɵNG_MOD_DEF, ngModule);\n        this.maybeStoreNgDef(ɵNG_INJ_DEF, ngModule);\n        ɵcompileNgModuleDefs(ngModule, metadata);\n    }\n    queueType(type, moduleType) {\n        const component = this.resolvers.component.resolve(type);\n        if (component) {\n            // Check whether a give Type has respective NG def (ɵcmp) and compile if def is\n            // missing. That might happen in case a class without any Angular decorators extends another\n            // class where Component/Directive/Pipe decorator is defined.\n            if (isComponentDefPendingResolution(type) || !type.hasOwnProperty(ɵNG_COMP_DEF)) {\n                this.pendingComponents.add(type);\n            }\n            this.seenComponents.add(type);\n            // Keep track of the module which declares this component, so later the component's scope\n            // can be set correctly. If the component has already been recorded here, then one of several\n            // cases is true:\n            // * the module containing the component was imported multiple times (common).\n            // * the component is declared in multiple modules (which is an error).\n            // * the component was in 'declarations' of the testing module, and also in an imported module\n            //   in which case the module scope will be TestingModuleOverride.DECLARATION.\n            // * overrideTemplateUsingTestingModule was called for the component in which case the module\n            //   scope will be TestingModuleOverride.OVERRIDE_TEMPLATE.\n            //\n            // If the component was previously in the testing module's 'declarations' (meaning the\n            // current value is TestingModuleOverride.DECLARATION), then `moduleType` is the component's\n            // real module, which was imported. This pattern is understood to mean that the component\n            // should use its original scope, but that the testing module should also contain the\n            // component in its scope.\n            //\n            // Note: standalone components have no associated NgModule, so the `moduleType` can be `null`.\n            if (moduleType !== null &&\n                (!this.componentToModuleScope.has(type) ||\n                    this.componentToModuleScope.get(type) === TestingModuleOverride.DECLARATION)) {\n                this.componentToModuleScope.set(type, moduleType);\n            }\n            return;\n        }\n        const directive = this.resolvers.directive.resolve(type);\n        if (directive) {\n            if (!type.hasOwnProperty(ɵNG_DIR_DEF)) {\n                this.pendingDirectives.add(type);\n            }\n            this.seenDirectives.add(type);\n            return;\n        }\n        const pipe = this.resolvers.pipe.resolve(type);\n        if (pipe && !type.hasOwnProperty(ɵNG_PIPE_DEF)) {\n            this.pendingPipes.add(type);\n            return;\n        }\n    }\n    queueTypesFromModulesArray(arr) {\n        // Because we may encounter the same NgModule or a standalone Component while processing\n        // the dependencies of an NgModule or a standalone Component, we cache them in this set so we\n        // can skip ones that have already been seen encountered. In some test setups, this caching\n        // resulted in 10X runtime improvement.\n        const processedDefs = new Set();\n        const queueTypesFromModulesArrayRecur = (arr) => {\n            for (const value of arr) {\n                if (Array.isArray(value)) {\n                    queueTypesFromModulesArrayRecur(value);\n                }\n                else if (hasNgModuleDef(value)) {\n                    const def = value.ɵmod;\n                    if (processedDefs.has(def)) {\n                        continue;\n                    }\n                    processedDefs.add(def);\n                    // Look through declarations, imports, and exports, and queue\n                    // everything found there.\n                    this.queueTypeArray(maybeUnwrapFn(def.declarations), value);\n                    queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.imports));\n                    queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.exports));\n                }\n                else if (isModuleWithProviders(value)) {\n                    queueTypesFromModulesArrayRecur([value.ngModule]);\n                }\n                else if (isStandaloneComponent(value)) {\n                    this.queueType(value, null);\n                    const def = getComponentDef(value);\n                    if (processedDefs.has(def)) {\n                        continue;\n                    }\n                    processedDefs.add(def);\n                    const dependencies = maybeUnwrapFn(def.dependencies ?? []);\n                    dependencies.forEach((dependency) => {\n                        // Note: in AOT, the `dependencies` might also contain regular\n                        // (NgModule-based) Component, Directive and Pipes, so we handle\n                        // them separately and proceed with recursive process for standalone\n                        // Components and NgModules only.\n                        if (isStandaloneComponent(dependency) || hasNgModuleDef(dependency)) {\n                            queueTypesFromModulesArrayRecur([dependency]);\n                        }\n                        else {\n                            this.queueType(dependency, null);\n                        }\n                    });\n                }\n            }\n        };\n        queueTypesFromModulesArrayRecur(arr);\n    }\n    // When module overrides (via `TestBed.overrideModule`) are present, it might affect all modules\n    // that import (even transitively) an overridden one. For all affected modules we need to\n    // recalculate their scopes for a given test run and restore original scopes at the end. The goal\n    // of this function is to collect all affected modules in a set for further processing. Example:\n    // if we have the following module hierarchy: A -> B -> C (where `->` means `imports`) and module\n    // `C` is overridden, we consider `A` and `B` as affected, since their scopes might become\n    // invalidated with the override.\n    collectModulesAffectedByOverrides(arr) {\n        const seenModules = new Set();\n        const affectedModules = new Set();\n        const calcAffectedModulesRecur = (arr, path) => {\n            for (const value of arr) {\n                if (Array.isArray(value)) {\n                    // If the value is an array, just flatten it (by invoking this function recursively),\n                    // keeping \"path\" the same.\n                    calcAffectedModulesRecur(value, path);\n                }\n                else if (hasNgModuleDef(value)) {\n                    if (seenModules.has(value)) {\n                        // If we've seen this module before and it's included into \"affected modules\" list, mark\n                        // the whole path that leads to that module as affected, but do not descend into its\n                        // imports, since we already examined them before.\n                        if (affectedModules.has(value)) {\n                            path.forEach(item => affectedModules.add(item));\n                        }\n                        continue;\n                    }\n                    seenModules.add(value);\n                    if (this.overriddenModules.has(value)) {\n                        path.forEach(item => affectedModules.add(item));\n                    }\n                    // Examine module imports recursively to look for overridden modules.\n                    const moduleDef = value[ɵNG_MOD_DEF];\n                    calcAffectedModulesRecur(maybeUnwrapFn(moduleDef.imports), path.concat(value));\n                }\n            }\n        };\n        calcAffectedModulesRecur(arr, []);\n        return affectedModules;\n    }\n    /**\n     * Preserve an original def (such as ɵmod, ɵinj, etc) before applying an override.\n     * Note: one class may have multiple defs (for example: ɵmod and ɵinj in case of\n     * an NgModule). If there is a def in a set already, don't override it, since\n     * an original one should be restored at the end of a test.\n     */\n    maybeStoreNgDef(prop, type) {\n        if (!this.initialNgDefs.has(type)) {\n            this.initialNgDefs.set(type, new Map());\n        }\n        const currentDefs = this.initialNgDefs.get(type);\n        if (!currentDefs.has(prop)) {\n            const currentDef = Object.getOwnPropertyDescriptor(type, prop);\n            currentDefs.set(prop, currentDef);\n        }\n    }\n    storeFieldOfDefOnType(type, defField, fieldName) {\n        const def = type[defField];\n        const originalValue = def[fieldName];\n        this.defCleanupOps.push({ object: def, fieldName, originalValue });\n    }\n    /**\n     * Clears current components resolution queue, but stores the state of the queue, so we can\n     * restore it later. Clearing the queue is required before we try to compile components (via\n     * `TestBed.compileComponents`), so that component defs are in sync with the resolution queue.\n     */\n    clearComponentResolutionQueue() {\n        if (this.originalComponentResolutionQueue === null) {\n            this.originalComponentResolutionQueue = new Map();\n        }\n        clearResolutionOfComponentResourcesQueue().forEach((value, key) => this.originalComponentResolutionQueue.set(key, value));\n    }\n    /*\n     * Restores component resolution queue to the previously saved state. This operation is performed\n     * as a part of restoring the state after completion of the current set of tests (that might\n     * potentially mutate the state).\n     */\n    restoreComponentResolutionQueue() {\n        if (this.originalComponentResolutionQueue !== null) {\n            restoreComponentResolutionQueue(this.originalComponentResolutionQueue);\n            this.originalComponentResolutionQueue = null;\n        }\n    }\n    restoreOriginalState() {\n        // Process cleanup ops in reverse order so the field's original value is restored correctly (in\n        // case there were multiple overrides for the same field).\n        forEachRight(this.defCleanupOps, (op) => {\n            op.object[op.fieldName] = op.originalValue;\n        });\n        // Restore initial component/directive/pipe defs\n        this.initialNgDefs.forEach((defs, type) => {\n            defs.forEach((descriptor, prop) => {\n                if (!descriptor) {\n                    // Delete operations are generally undesirable since they have performance\n                    // implications on objects they were applied to. In this particular case, situations\n                    // where this code is invoked should be quite rare to cause any noticeable impact,\n                    // since it's applied only to some test cases (for example when class with no\n                    // annotations extends some @Component) when we need to clear 'ɵcmp' field on a given\n                    // class to restore its original state (before applying overrides and running tests).\n                    delete type[prop];\n                }\n                else {\n                    Object.defineProperty(type, prop, descriptor);\n                }\n            });\n        });\n        this.initialNgDefs.clear();\n        this.scopesWithOverriddenProviders.clear();\n        this.restoreComponentResolutionQueue();\n        // Restore the locale ID to the default value, this shouldn't be necessary but we never know\n        ɵsetLocaleId(ɵDEFAULT_LOCALE_ID);\n    }\n    compileTestModule() {\n        class RootScopeModule {\n        }\n        ɵcompileNgModuleDefs(RootScopeModule, {\n            providers: [...this.rootProviderOverrides],\n        });\n        const providers = [\n            provideZoneChangeDetection(),\n            { provide: Compiler, useFactory: () => new R3TestCompiler(this) },\n            ...this.providers,\n            ...this.providerOverrides,\n        ];\n        const imports = [RootScopeModule, this.additionalModuleTypes, this.imports || []];\n        // clang-format off\n        ɵcompileNgModuleDefs(this.testModuleType, {\n            declarations: this.declarations,\n            imports,\n            schemas: this.schemas,\n            providers,\n        }, /* allowDuplicateDeclarationsInRoot */ true);\n        // clang-format on\n        this.applyProviderOverridesInScope(this.testModuleType);\n    }\n    get injector() {\n        if (this._injector !== null) {\n            return this._injector;\n        }\n        const providers = [];\n        const compilerOptions = this.platform.injector.get(COMPILER_OPTIONS);\n        compilerOptions.forEach(opts => {\n            if (opts.providers) {\n                providers.push(opts.providers);\n            }\n        });\n        if (this.compilerProviders !== null) {\n            providers.push(...this.compilerProviders);\n        }\n        this._injector = Injector$1.create({ providers, parent: this.platform.injector });\n        return this._injector;\n    }\n    // get overrides for a specific provider (if any)\n    getSingleProviderOverrides(provider) {\n        const token = getProviderToken(provider);\n        return this.providerOverridesByToken.get(token) || null;\n    }\n    getProviderOverrides(providers) {\n        if (!providers || !providers.length || this.providerOverridesByToken.size === 0)\n            return [];\n        // There are two flattening operations here. The inner flattenProviders() operates on the\n        // metadata's providers and applies a mapping function which retrieves overrides for each\n        // incoming provider. The outer flatten() then flattens the produced overrides array. If this is\n        // not done, the array can contain other empty arrays (e.g. `[[], []]`) which leak into the\n        // providers array and contaminate any error messages that might be generated.\n        return flatten(flattenProviders(providers, (provider) => this.getSingleProviderOverrides(provider) || []));\n    }\n    getOverriddenProviders(providers) {\n        if (!providers || !providers.length || this.providerOverridesByToken.size === 0)\n            return [];\n        const flattenedProviders = flattenProviders(providers);\n        const overrides = this.getProviderOverrides(flattenedProviders);\n        const overriddenProviders = [...flattenedProviders, ...overrides];\n        const final = [];\n        const seenOverriddenProviders = new Set();\n        // We iterate through the list of providers in reverse order to make sure provider overrides\n        // take precedence over the values defined in provider list. We also filter out all providers\n        // that have overrides, keeping overridden values only. This is needed, since presence of a\n        // provider with `ngOnDestroy` hook will cause this hook to be registered and invoked later.\n        forEachRight(overriddenProviders, (provider) => {\n            const token = getProviderToken(provider);\n            if (this.providerOverridesByToken.has(token)) {\n                if (!seenOverriddenProviders.has(token)) {\n                    seenOverriddenProviders.add(token);\n                    // Treat all overridden providers as `{multi: false}` (even if it's a multi-provider) to\n                    // make sure that provided override takes highest precedence and is not combined with\n                    // other instances of the same multi provider.\n                    final.unshift({ ...provider, multi: false });\n                }\n            }\n            else {\n                final.unshift(provider);\n            }\n        });\n        return final;\n    }\n    hasProviderOverrides(providers) {\n        return this.getProviderOverrides(providers).length > 0;\n    }\n    patchDefWithProviderOverrides(declaration, field) {\n        const def = declaration[field];\n        if (def && def.providersResolver) {\n            this.maybeStoreNgDef(field, declaration);\n            const resolver = def.providersResolver;\n            const processProvidersFn = (providers) => this.getOverriddenProviders(providers);\n            this.storeFieldOfDefOnType(declaration, field, 'providersResolver');\n            def.providersResolver = (ngDef) => resolver(ngDef, processProvidersFn);\n        }\n    }\n}\nfunction initResolvers() {\n    return {\n        module: new NgModuleResolver(),\n        component: new ComponentResolver(),\n        directive: new DirectiveResolver(),\n        pipe: new PipeResolver()\n    };\n}\nfunction isStandaloneComponent(value) {\n    const def = getComponentDef(value);\n    return !!def?.standalone;\n}\nfunction getComponentDef(value) {\n    return value.ɵcmp ?? null;\n}\nfunction hasNgModuleDef(value) {\n    return value.hasOwnProperty('ɵmod');\n}\nfunction isNgModule(value) {\n    return hasNgModuleDef(value);\n}\nfunction maybeUnwrapFn(maybeFn) {\n    return maybeFn instanceof Function ? maybeFn() : maybeFn;\n}\nfunction flatten(values) {\n    const out = [];\n    values.forEach(value => {\n        if (Array.isArray(value)) {\n            out.push(...flatten(value));\n        }\n        else {\n            out.push(value);\n        }\n    });\n    return out;\n}\nfunction identityFn(value) {\n    return value;\n}\nfunction flattenProviders(providers, mapFn = identityFn) {\n    const out = [];\n    for (let provider of providers) {\n        if (ɵisEnvironmentProviders(provider)) {\n            provider = provider.ɵproviders;\n        }\n        if (Array.isArray(provider)) {\n            out.push(...flattenProviders(provider, mapFn));\n        }\n        else {\n            out.push(mapFn(provider));\n        }\n    }\n    return out;\n}\nfunction getProviderField(provider, field) {\n    return provider && typeof provider === 'object' && provider[field];\n}\nfunction getProviderToken(provider) {\n    return getProviderField(provider, 'provide') || provider;\n}\nfunction isModuleWithProviders(value) {\n    return value.hasOwnProperty('ngModule');\n}\nfunction forEachRight(values, fn) {\n    for (let idx = values.length - 1; idx >= 0; idx--) {\n        fn(values[idx], idx);\n    }\n}\nfunction invalidTypeError(name, expectedType) {\n    return new Error(`${name} class doesn't have @${expectedType} decorator or is missing metadata.`);\n}\nclass R3TestCompiler {\n    constructor(testBed) {\n        this.testBed = testBed;\n    }\n    compileModuleSync(moduleType) {\n        this.testBed._compileNgModuleSync(moduleType);\n        return new ɵNgModuleFactory(moduleType);\n    }\n    async compileModuleAsync(moduleType) {\n        await this.testBed._compileNgModuleAsync(moduleType);\n        return new ɵNgModuleFactory(moduleType);\n    }\n    compileModuleAndAllComponentsSync(moduleType) {\n        const ngModuleFactory = this.compileModuleSync(moduleType);\n        const componentFactories = this.testBed._getComponentFactories(moduleType);\n        return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n    }\n    async compileModuleAndAllComponentsAsync(moduleType) {\n        const ngModuleFactory = await this.compileModuleAsync(moduleType);\n        const componentFactories = this.testBed._getComponentFactories(moduleType);\n        return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n    }\n    clearCache() { }\n    clearCacheFor(type) { }\n    getModuleId(moduleType) {\n        const meta = this.testBed._getModuleResolver().resolve(moduleType);\n        return meta && meta.id || undefined;\n    }\n}\n\n// The formatter and CI disagree on how this import statement should be formatted. Both try to keep\nlet _nextRootElementId = 0;\n/**\n * Returns a singleton of the `TestBed` class.\n *\n * @publicApi\n */\nfunction getTestBed() {\n    return TestBedImpl.INSTANCE;\n}\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * TestBed is the primary api for writing unit tests for Angular applications and libraries.\n */\nclass TestBedImpl {\n    constructor() {\n        // Properties\n        this.platform = null;\n        this.ngModule = null;\n        this._compiler = null;\n        this._testModuleRef = null;\n        this._activeFixtures = [];\n        /**\n         * Internal-only flag to indicate whether a module\n         * scoping queue has been checked and flushed already.\n         * @nodoc\n         */\n        this.globalCompilationChecked = false;\n    }\n    static { this._INSTANCE = null; }\n    static get INSTANCE() {\n        return TestBedImpl._INSTANCE = TestBedImpl._INSTANCE || new TestBedImpl();\n    }\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @publicApi\n     */\n    static initTestEnvironment(ngModule, platform, options) {\n        const testBed = TestBedImpl.INSTANCE;\n        testBed.initTestEnvironment(ngModule, platform, options);\n        return testBed;\n    }\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @publicApi\n     */\n    static resetTestEnvironment() {\n        TestBedImpl.INSTANCE.resetTestEnvironment();\n    }\n    static configureCompiler(config) {\n        return TestBedImpl.INSTANCE.configureCompiler(config);\n    }\n    /**\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\n     * which are defined in test_injector.js\n     */\n    static configureTestingModule(moduleDef) {\n        return TestBedImpl.INSTANCE.configureTestingModule(moduleDef);\n    }\n    /**\n     * Compile components with a `templateUrl` for the test's NgModule.\n     * It is necessary to call this function\n     * as fetching urls is asynchronous.\n     */\n    static compileComponents() {\n        return TestBedImpl.INSTANCE.compileComponents();\n    }\n    static overrideModule(ngModule, override) {\n        return TestBedImpl.INSTANCE.overrideModule(ngModule, override);\n    }\n    static overrideComponent(component, override) {\n        return TestBedImpl.INSTANCE.overrideComponent(component, override);\n    }\n    static overrideDirective(directive, override) {\n        return TestBedImpl.INSTANCE.overrideDirective(directive, override);\n    }\n    static overridePipe(pipe, override) {\n        return TestBedImpl.INSTANCE.overridePipe(pipe, override);\n    }\n    static overrideTemplate(component, template) {\n        return TestBedImpl.INSTANCE.overrideTemplate(component, template);\n    }\n    /**\n     * Overrides the template of the given component, compiling the template\n     * in the context of the TestingModule.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     */\n    static overrideTemplateUsingTestingModule(component, template) {\n        return TestBedImpl.INSTANCE.overrideTemplateUsingTestingModule(component, template);\n    }\n    static overrideProvider(token, provider) {\n        return TestBedImpl.INSTANCE.overrideProvider(token, provider);\n    }\n    static inject(token, notFoundValue, flags) {\n        return TestBedImpl.INSTANCE.inject(token, notFoundValue, ɵconvertToBitFlags(flags));\n    }\n    /** @deprecated from v9.0.0 use TestBed.inject */\n    static get(token, notFoundValue = Injector$1.THROW_IF_NOT_FOUND, flags = InjectFlags$1.Default) {\n        return TestBedImpl.INSTANCE.inject(token, notFoundValue, flags);\n    }\n    /**\n     * Runs the given function in the `EnvironmentInjector` context of `TestBed`.\n     *\n     * @see {@link EnvironmentInjector#runInContext}\n     */\n    static runInInjectionContext(fn) {\n        return TestBedImpl.INSTANCE.runInInjectionContext(fn);\n    }\n    static createComponent(component) {\n        return TestBedImpl.INSTANCE.createComponent(component);\n    }\n    static resetTestingModule() {\n        return TestBedImpl.INSTANCE.resetTestingModule();\n    }\n    static execute(tokens, fn, context) {\n        return TestBedImpl.INSTANCE.execute(tokens, fn, context);\n    }\n    static get platform() {\n        return TestBedImpl.INSTANCE.platform;\n    }\n    static get ngModule() {\n        return TestBedImpl.INSTANCE.ngModule;\n    }\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @publicApi\n     */\n    initTestEnvironment(ngModule, platform, options) {\n        if (this.platform || this.ngModule) {\n            throw new Error('Cannot set base providers because it has already been called');\n        }\n        TestBedImpl._environmentTeardownOptions = options?.teardown;\n        TestBedImpl._environmentErrorOnUnknownElementsOption = options?.errorOnUnknownElements;\n        TestBedImpl._environmentErrorOnUnknownPropertiesOption = options?.errorOnUnknownProperties;\n        this.platform = platform;\n        this.ngModule = ngModule;\n        this._compiler = new TestBedCompiler(this.platform, this.ngModule);\n        // TestBed does not have an API which can reliably detect the start of a test, and thus could be\n        // used to track the state of the NgModule registry and reset it correctly. Instead, when we\n        // know we're in a testing scenario, we disable the check for duplicate NgModule registration\n        // completely.\n        ɵsetAllowDuplicateNgModuleIdsForTest(true);\n    }\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @publicApi\n     */\n    resetTestEnvironment() {\n        this.resetTestingModule();\n        this._compiler = null;\n        this.platform = null;\n        this.ngModule = null;\n        TestBedImpl._environmentTeardownOptions = undefined;\n        ɵsetAllowDuplicateNgModuleIdsForTest(false);\n    }\n    resetTestingModule() {\n        this.checkGlobalCompilationFinished();\n        ɵresetCompiledComponents();\n        if (this._compiler !== null) {\n            this.compiler.restoreOriginalState();\n        }\n        this._compiler = new TestBedCompiler(this.platform, this.ngModule);\n        // Restore the previous value of the \"error on unknown elements\" option\n        ɵsetUnknownElementStrictMode$1(this._previousErrorOnUnknownElementsOption ?? THROW_ON_UNKNOWN_ELEMENTS_DEFAULT);\n        // Restore the previous value of the \"error on unknown properties\" option\n        ɵsetUnknownPropertyStrictMode$1(this._previousErrorOnUnknownPropertiesOption ?? THROW_ON_UNKNOWN_PROPERTIES_DEFAULT);\n        // We have to chain a couple of try/finally blocks, because each step can\n        // throw errors and we don't want it to interrupt the next step and we also\n        // want an error to be thrown at the end.\n        try {\n            this.destroyActiveFixtures();\n        }\n        finally {\n            try {\n                if (this.shouldTearDownTestingModule()) {\n                    this.tearDownTestingModule();\n                }\n            }\n            finally {\n                this._testModuleRef = null;\n                this._instanceTeardownOptions = undefined;\n                this._instanceErrorOnUnknownElementsOption = undefined;\n                this._instanceErrorOnUnknownPropertiesOption = undefined;\n            }\n        }\n        return this;\n    }\n    configureCompiler(config) {\n        if (config.useJit != null) {\n            throw new Error('JIT compiler is not configurable via TestBed APIs.');\n        }\n        if (config.providers !== undefined) {\n            this.compiler.setCompilerProviders(config.providers);\n        }\n        return this;\n    }\n    configureTestingModule(moduleDef) {\n        this.assertNotInstantiated('TestBed.configureTestingModule', 'configure the test module');\n        // Trigger module scoping queue flush before executing other TestBed operations in a test.\n        // This is needed for the first test invocation to ensure that globally declared modules have\n        // their components scoped properly. See the `checkGlobalCompilationFinished` function\n        // description for additional info.\n        this.checkGlobalCompilationFinished();\n        // Always re-assign the options, even if they're undefined.\n        // This ensures that we don't carry them between tests.\n        this._instanceTeardownOptions = moduleDef.teardown;\n        this._instanceErrorOnUnknownElementsOption = moduleDef.errorOnUnknownElements;\n        this._instanceErrorOnUnknownPropertiesOption = moduleDef.errorOnUnknownProperties;\n        // Store the current value of the strict mode option,\n        // so we can restore it later\n        this._previousErrorOnUnknownElementsOption = ɵgetUnknownElementStrictMode$1();\n        ɵsetUnknownElementStrictMode$1(this.shouldThrowErrorOnUnknownElements());\n        this._previousErrorOnUnknownPropertiesOption = ɵgetUnknownPropertyStrictMode$1();\n        ɵsetUnknownPropertyStrictMode$1(this.shouldThrowErrorOnUnknownProperties());\n        this.compiler.configureTestingModule(moduleDef);\n        return this;\n    }\n    compileComponents() {\n        return this.compiler.compileComponents();\n    }\n    inject(token, notFoundValue, flags) {\n        if (token === TestBed) {\n            return this;\n        }\n        const UNDEFINED = {};\n        const result = this.testModuleRef.injector.get(token, UNDEFINED, ɵconvertToBitFlags(flags));\n        return result === UNDEFINED ? this.compiler.injector.get(token, notFoundValue, flags) :\n            result;\n    }\n    /** @deprecated from v9.0.0 use TestBed.inject */\n    get(token, notFoundValue = Injector$1.THROW_IF_NOT_FOUND, flags = InjectFlags$1.Default) {\n        return this.inject(token, notFoundValue, flags);\n    }\n    runInInjectionContext(fn) {\n        return this.inject(EnvironmentInjector$1).runInContext(fn);\n    }\n    execute(tokens, fn, context) {\n        const params = tokens.map(t => this.inject(t));\n        return fn.apply(context, params);\n    }\n    overrideModule(ngModule, override) {\n        this.assertNotInstantiated('overrideModule', 'override module metadata');\n        this.compiler.overrideModule(ngModule, override);\n        return this;\n    }\n    overrideComponent(component, override) {\n        this.assertNotInstantiated('overrideComponent', 'override component metadata');\n        this.compiler.overrideComponent(component, override);\n        return this;\n    }\n    overrideTemplateUsingTestingModule(component, template) {\n        this.assertNotInstantiated('TestBed.overrideTemplateUsingTestingModule', 'Cannot override template when the test module has already been instantiated');\n        this.compiler.overrideTemplateUsingTestingModule(component, template);\n        return this;\n    }\n    overrideDirective(directive, override) {\n        this.assertNotInstantiated('overrideDirective', 'override directive metadata');\n        this.compiler.overrideDirective(directive, override);\n        return this;\n    }\n    overridePipe(pipe, override) {\n        this.assertNotInstantiated('overridePipe', 'override pipe metadata');\n        this.compiler.overridePipe(pipe, override);\n        return this;\n    }\n    /**\n     * Overwrites all providers for the given token with the given provider definition.\n     */\n    overrideProvider(token, provider) {\n        this.assertNotInstantiated('overrideProvider', 'override provider');\n        this.compiler.overrideProvider(token, provider);\n        return this;\n    }\n    overrideTemplate(component, template) {\n        return this.overrideComponent(component, { set: { template, templateUrl: null } });\n    }\n    createComponent(type) {\n        const testComponentRenderer = this.inject(TestComponentRenderer);\n        const rootElId = `root${_nextRootElementId++}`;\n        testComponentRenderer.insertRootElement(rootElId);\n        const componentDef = type.ɵcmp;\n        if (!componentDef) {\n            throw new Error(`It looks like '${ɵstringify(type)}' has not been compiled.`);\n        }\n        const noNgZone = this.inject(ComponentFixtureNoNgZone, false);\n        const autoDetect = this.inject(ComponentFixtureAutoDetect, false);\n        const ngZone = noNgZone ? null : this.inject(NgZone$1, null);\n        const componentFactory = new ɵRender3ComponentFactory(componentDef);\n        const initComponent = () => {\n            const componentRef = componentFactory.create(Injector$1.NULL, [], `#${rootElId}`, this.testModuleRef);\n            return new ComponentFixture(componentRef, ngZone, autoDetect);\n        };\n        const fixture = ngZone ? ngZone.run(initComponent) : initComponent();\n        this._activeFixtures.push(fixture);\n        return fixture;\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n    get compiler() {\n        if (this._compiler === null) {\n            throw new Error(`Need to call TestBed.initTestEnvironment() first`);\n        }\n        return this._compiler;\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n    get testModuleRef() {\n        if (this._testModuleRef === null) {\n            this._testModuleRef = this.compiler.finalize();\n        }\n        return this._testModuleRef;\n    }\n    assertNotInstantiated(methodName, methodDescription) {\n        if (this._testModuleRef !== null) {\n            throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. ` +\n                `Make sure you are not using \\`inject\\` before \\`${methodName}\\`.`);\n        }\n    }\n    /**\n     * Check whether the module scoping queue should be flushed, and flush it if needed.\n     *\n     * When the TestBed is reset, it clears the JIT module compilation queue, cancelling any\n     * in-progress module compilation. This creates a potential hazard - the very first time the\n     * TestBed is initialized (or if it's reset without being initialized), there may be pending\n     * compilations of modules declared in global scope. These compilations should be finished.\n     *\n     * To ensure that globally declared modules have their components scoped properly, this function\n     * is called whenever TestBed is initialized or reset. The _first_ time that this happens, prior\n     * to any other operations, the scoping queue is flushed.\n     */\n    checkGlobalCompilationFinished() {\n        // Checking _testNgModuleRef is null should not be necessary, but is left in as an additional\n        // guard that compilations queued in tests (after instantiation) are never flushed accidentally.\n        if (!this.globalCompilationChecked && this._testModuleRef === null) {\n            ɵflushModuleScopingQueueAsMuchAsPossible();\n        }\n        this.globalCompilationChecked = true;\n    }\n    destroyActiveFixtures() {\n        let errorCount = 0;\n        this._activeFixtures.forEach((fixture) => {\n            try {\n                fixture.destroy();\n            }\n            catch (e) {\n                errorCount++;\n                console.error('Error during cleanup of component', {\n                    component: fixture.componentInstance,\n                    stacktrace: e,\n                });\n            }\n        });\n        this._activeFixtures = [];\n        if (errorCount > 0 && this.shouldRethrowTeardownErrors()) {\n            throw Error(`${errorCount} ${(errorCount === 1 ? 'component' : 'components')} ` +\n                `threw errors during cleanup`);\n        }\n    }\n    shouldRethrowTeardownErrors() {\n        const instanceOptions = this._instanceTeardownOptions;\n        const environmentOptions = TestBedImpl._environmentTeardownOptions;\n        // If the new teardown behavior hasn't been configured, preserve the old behavior.\n        if (!instanceOptions && !environmentOptions) {\n            return TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n        }\n        // Otherwise use the configured behavior or default to rethrowing.\n        return instanceOptions?.rethrowErrors ?? environmentOptions?.rethrowErrors ??\n            this.shouldTearDownTestingModule();\n    }\n    shouldThrowErrorOnUnknownElements() {\n        // Check if a configuration has been provided to throw when an unknown element is found\n        return this._instanceErrorOnUnknownElementsOption ??\n            TestBedImpl._environmentErrorOnUnknownElementsOption ?? THROW_ON_UNKNOWN_ELEMENTS_DEFAULT;\n    }\n    shouldThrowErrorOnUnknownProperties() {\n        // Check if a configuration has been provided to throw when an unknown property is found\n        return this._instanceErrorOnUnknownPropertiesOption ??\n            TestBedImpl._environmentErrorOnUnknownPropertiesOption ??\n            THROW_ON_UNKNOWN_PROPERTIES_DEFAULT;\n    }\n    shouldTearDownTestingModule() {\n        return this._instanceTeardownOptions?.destroyAfterEach ??\n            TestBedImpl._environmentTeardownOptions?.destroyAfterEach ??\n            TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n    }\n    tearDownTestingModule() {\n        // If the module ref has already been destroyed, we won't be able to get a test renderer.\n        if (this._testModuleRef === null) {\n            return;\n        }\n        // Resolve the renderer ahead of time, because we want to remove the root elements as the very\n        // last step, but the injector will be destroyed as a part of the module ref destruction.\n        const testRenderer = this.inject(TestComponentRenderer);\n        try {\n            this._testModuleRef.destroy();\n        }\n        catch (e) {\n            if (this.shouldRethrowTeardownErrors()) {\n                throw e;\n            }\n            else {\n                console.error('Error during cleanup of a testing module', {\n                    component: this._testModuleRef.instance,\n                    stacktrace: e,\n                });\n            }\n        }\n        finally {\n            testRenderer.removeAllRootElements?.();\n        }\n    }\n}\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * @publicApi\n */\nconst TestBed = TestBedImpl;\n/**\n * Allows injecting dependencies in `beforeEach()` and `it()`. Note: this function\n * (imported from the `@angular/core/testing` package) can **only** be used to inject dependencies\n * in tests. To inject dependencies in your application code, use the [`inject`](api/core/inject)\n * function from the `@angular/core` package instead.\n *\n * Example:\n *\n * ```\n * beforeEach(inject([Dependency, AClass], (dep, object) => {\n *   // some code that uses `dep` and `object`\n *   // ...\n * }));\n *\n * it('...', inject([AClass], (object) => {\n *   object.doSomething();\n *   expect(...);\n * })\n * ```\n *\n * @publicApi\n */\nfunction inject(tokens, fn) {\n    const testBed = TestBedImpl.INSTANCE;\n    // Not using an arrow function to preserve context passed from call site\n    return function () {\n        return testBed.execute(tokens, fn, this);\n    };\n}\n/**\n * @publicApi\n */\nclass InjectSetupWrapper {\n    constructor(_moduleDef) {\n        this._moduleDef = _moduleDef;\n    }\n    _addModule() {\n        const moduleDef = this._moduleDef();\n        if (moduleDef) {\n            TestBedImpl.configureTestingModule(moduleDef);\n        }\n    }\n    inject(tokens, fn) {\n        const self = this;\n        // Not using an arrow function to preserve context passed from call site\n        return function () {\n            self._addModule();\n            return inject(tokens, fn).call(this);\n        };\n    }\n}\nfunction withModule(moduleDef, fn) {\n    if (fn) {\n        // Not using an arrow function to preserve context passed from call site\n        return function () {\n            const testBed = TestBedImpl.INSTANCE;\n            if (moduleDef) {\n                testBed.configureTestingModule(moduleDef);\n            }\n            return fn.apply(this);\n        };\n    }\n    return new InjectSetupWrapper(() => moduleDef);\n}\n\n/**\n * Public Test Library for unit testing Angular applications. Assumes that you are running\n * with Jasmine, Mocha, or a similar framework which exports a beforeEach function and\n * allows tests to be asynchronous by either returning a promise or using a 'done' parameter.\n */\n// Reset the test providers and the fake async zone before each test.\n// We keep a guard because somehow this file can make it into a bundle and be executed\n// beforeEach is only defined when executing the tests\nglobalThis.beforeEach?.(getCleanupHook(false));\n// We provide both a `beforeEach` and `afterEach`, because the updated behavior for\n// tearing down the module is supposed to run after the test so that we can associate\n// teardown errors with the correct test.\n// We keep a guard because somehow this file can make it into a bundle and be executed\n// afterEach is only defined when executing the tests\nglobalThis.afterEach?.(getCleanupHook(true));\nfunction getCleanupHook(expectedTeardownValue) {\n    return () => {\n        const testBed = TestBedImpl.INSTANCE;\n        if (testBed.shouldTearDownTestingModule() === expectedTeardownValue) {\n            testBed.resetTestingModule();\n            resetFakeAsyncZone();\n        }\n    };\n}\n/**\n * This API should be removed. But doing so seems to break `google3` and so it requires a bit of\n * investigation.\n *\n * A work around is to mark it as `@codeGenApi` for now and investigate later.\n *\n * @codeGenApi\n */\n// TODO(iminar): Remove this code in a safe way.\nconst __core_private_testing_placeholder__ = '';\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of the core/testing package.\n */\n\n/// <reference types=\"jasmine\" />\n// This file only reexports content of the `src` folder. Keep it that way.\n\n// This file is not used to build this module. It is only used during editing\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ComponentFixture, ComponentFixtureAutoDetect, ComponentFixtureNoNgZone, InjectSetupWrapper, TestBed, TestComponentRenderer, __core_private_testing_placeholder__, async, discardPeriodicTasks, fakeAsync, flush, flushMicrotasks, getTestBed, inject, resetFakeAsyncZone, tick, waitForAsync, withModule, MetadataOverrider as ɵMetadataOverrider };\n"],"mappings":"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AwC,CAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,SAASA,CAAC7D,EAAE,EAAE;EACnB,IAAI0D,mBAAmB,EAAE;IACrB,OAAOA,mBAAmB,CAACG,SAAS,CAAC7D,EAAE,CAAC;EAC5C;EACA,MAAM,IAAI4C,KAAK,CAACe,wCAAwC,CAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASG,IAAIA,CAACC,MAAM,GAAG,CAAC,EAAEC,WAAW,GAAG;EACpCC,iCAAiC,EAAE;AACvC,CAAC,EAAE;EACC,IAAIP,mBAAmB,EAAE;IACrB,OAAOA,mBAAmB,CAACI,IAAI,CAACC,MAAM,EAAEC,WAAW,CAAC;EACxD;EACA,MAAM,IAAIpB,KAAK,CAACe,wCAAwC,CAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASO,KAAKA,CAACC,QAAQ,EAAE;EACrB,IAAIT,mBAAmB,EAAE;IACrB,OAAOA,mBAAmB,CAACQ,KAAK,CAACC,QAAQ,CAAC;EAC9C;EACA,MAAM,IAAIvB,KAAK,CAACe,wCAAwC,CAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,SAASS,oBAAoBA,CAAA,EAAG;EAC5B,IAAIV,mBAAmB,EAAE;IACrB,OAAOA,mBAAmB,CAACU,oBAAoB,CAAC,CAAC;EACrD;EACA,MAAM,IAAIxB,KAAK,CAACe,wCAAwC,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C,MAAM,CAACO,iBAAiB,EAAE;AAC/C;AACA,SAASE,yBAAyBA,CAAA,EAAG;EACjCV,gBAAgB,CAACC,MAAM,CAACO,iBAAiB,EAAE;AAC/C;AACA,SAASG,kBAAkBA,CAAA,EAAG;EAC1B,OAAOX,gBAAgB,CAACG,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA,SAASS,wBAAwBA,CAAA,EAAG;EAChC,OAAOZ,gBAAgB,CAACI,sBAAsB,KAAK,IAAI;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,SAASS,wBAAwBA,CAACnhB,KAAK,EAAE;EACrC,OAAOsgB,gBAAgB,CAACI,sBAAsB,KAAK1gB,KAAK;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASohB,gBAAgBA,CAAA,EAAG;EACxBd,gBAAgB,CAACG,eAAe,GAAG,IAAI;AAC3C;AACA;AACA;AACA;AACA;AACA,SAASY,uBAAuBA,CAACrhB,KAAK,EAAE;EACpCsgB,gBAAgB,CAACI,sBAAsB,GAAG1gB,KAAK;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASshB,iBAAiBA,CAAA,EAAG;EACzBhB,gBAAgB,CAACG,eAAe,GAAG,KAAK;AAC5C;AACA;AACA;AACA;AACA,SAASc,uBAAuBA,CAAA,EAAG;EAC/BjB,gBAAgB,CAACI,sBAAsB,GAAG,IAAI;AAClD;AACA;AACA;AACA;AACA,SAASc,QAAQA,CAAA,EAAG;EAChB,OAAOlB,gBAAgB,CAACC,MAAM,CAAClL,KAAK;AACxC;AACA;AACA;AACA;AACA,SAASoM,QAAQA,CAAA,EAAG;EAChB,OAAOnB,gBAAgB,CAACC,MAAM,CAACtgB,KAAK;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASyhB,aAAaA,CAACC,aAAa,EAAE;EAClCrB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EAAE;EAC9C,MAAMyvB,UAAU,GAAGlwB,GAAG,CAACS,CAAC,CAAC,GAAG,CAAC;EAC7B,MAAMwvB,IAAI,GAAGjwB,GAAG,CAACS,CAAC,GAAG,CAAC,CAAC;EACvB,MAAMytB,cAAc,GAAGgC,UAAU,GAAG,CAAClwB,GAAG,CAACS,CAAC,CAAC,GAAGT,GAAG,CAACS,CAAC,CAAC;EACpD,MAAM4vB,SAAS,GAAGhD,WAAW,CAACa,cAAc,CAAC;EAC7C,IAAIgC,UAAU,EAAE;IACZ,MAAMI,qBAAqB,GAAGjD,WAAW,CAACvS,KAAK,CAAC,IAAI,EAAE,CAAC;IACvD;IACA,IAAIwV,qBAAqB,GACpBjD,WAAW,CAACxR,mBAAmB,CAAC,IAAI,EAAE,CAAC,oDAAqD,IAC7F,CAACwR,WAAW,CAACvS,KAAK,CAAC,GAAG,CAAC,CAAC,yCAAyC4U,SAAS,EAAE;MAC5ErC,WAAW,CAACvS,KAAK,CAAC,IAAI,IAAI,CAAC;MAC3BsV,gBAAgB,CAACC,SAAS,EAAEJ,IAAI,CAAC;IACrC;EACJ,CAAC,MACI;IACDG,gBAAgB,CAACC,SAAS,EAAEJ,IAAI,CAAC;EACrC;AACJ;AAEA,MAAMM,kBAAkB,GAAG,CAAC,CAAC;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,mBAAmB,CAAC;EACtB5+B,WAAWA;EACX;A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Cob,MAAM,CAAC;EACjD;EACAxd,SAASA,CAACtN,QAAQ,EAAE;IAChBmd,mBAAmB,CAAC,IAAI,CAAC2N,MAAM,EAAE9qB,QAAQ,CAAC;EAC9C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIgpD,YAAYA,CAAA,EAAG;IACXnP,aAAa,CAAC,IAAI,CAAC+O,mBAAmB,IAAI,IAAI,CAAC99B,MAAM,CAAC;EAC1D;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIm+B,MAAMA,CAAA,EAAG;IACL,IAAI,CAACn+B,MAAM,CAACnb,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC;EAC/B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIu5C,QAAQA,CAAA,EAAG;IACP,IAAI,CAACp+B,MAAM,CAACnb,KAAK,CAAC,IAAI,GAAG,CAAC;EAC9B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI1nB,aAAaA,C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C;EAC3D,MAAMr2E,IAAI,GAAGy2E,oBAAoB,CAACJ,aAAa,CAAC;EAChD,OAAOr2E,IAAI,KAAK,CAAC,GAAGo2E,oBAAoB,CAACC,aAAa,CAAC,GAAGr2E,IAAI;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI82E,mEAAmE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,qBAAqBA,CAACpsD,KAAK,EAAEzV,KAAK,EAAE8hE,qBAAqB,EAAEvyE,KAAK,EAAEwyE,aAAa,EAAEC,cAAc,EAAE;EACtGpwE,SAAS,IAAI4kB,qBAAqB,CAACiL,QAAQ,CAAC,CAAC,CAAC;EAC9C,IAAIwgD,SAAS,GAAGD,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"},"metadata":{},"sourceType":"module","externalDependencies":[]}