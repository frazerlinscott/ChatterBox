{"ast":null,"code":"import { TestBed } from '@angular/core/testing';\nimport { GroupsComponent } from './groups.component';\nimport { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';\nimport { FormsModule } from '@angular/forms';\nimport { Router } from '@angular/router';\nimport { of } from 'rxjs';\ndescribe('GroupsComponent', () => {\n  let component;\n  let fixture;\n  let httpMock;\n  let router;\n  class MockRouter {\n    navigateByUrl(url) {\n      return url;\n    }\n  }\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      declarations: [GroupsComponent],\n      imports: [HttpClientTestingModule, FormsModule],\n      providers: [{\n        provide: Router,\n        useClass: MockRouter\n      }]\n    });\n    fixture = TestBed.createComponent(GroupsComponent);\n    component = fixture.componentInstance;\n    httpMock = TestBed.inject(HttpTestingController);\n    router = TestBed.inject(Router);\n    fixture.detectChanges();\n  });\n  it('should create', () => {\n    expect(component).toBeTruthy();\n  });\n  it('should leave group', () => {\n    // Mock the HTTP response\n    spyOn(component.http, 'post').and.returnValue(of({}));\n    const group = {\n      members: ['user1', 'user2', 'user3'],\n      channels: {\n        channel1: ['user1', 'user2'],\n        channel2: ['user1', 'user3']\n      }\n    };\n    // Trigger the leaveGroup function\n    component.leaveGroup(group);\n    // Expect the http.post method to have been called with the correct arguments\n    expect(component.http.post).toHaveBeenCalledWith('http://localhost:3000/update-groups', group);\n    // Check if the necessary modifications have been made to the group object\n    expect(group.members).toEqual(['user1', 'user2']); // User removed\n    expect(group.channels.channel1).toEqual(['user1', 'user2']); // User removed\n    expect(group.channels.channel2).toEqual(['user1']); // User removed\n    // Verify that the getGroups method has been called\n    spyOn(component, 'getGroups');\n    expect(component.getGroups).toHaveBeenCalled();\n  });\n});\n// import { TestBed, ComponentFixture, async } from '@angular/core/testing';\n// import { GroupsComponent } from './groups.component';\n// import { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';\n// import { RouterTestingModule } from '@angular/router/testing';\n// import { FormsModule } from '@angular/forms';\n// import * as $ from 'jquery';\n// const BACKEND_URL = \"http://localhost:3000\";\n// describe('GroupsComponent', () => {\n//     let component: GroupsComponent;\n//     let fixture: ComponentFixture<GroupsComponent>;\n//     let httpMock: HttpTestingController;\n//     beforeEach(async(() => {\n//         // Mock the current user in session storage\n//         const mockUser = {\n//             username: 'user1',\n//             role: 3 \n//         };\n//         sessionStorage.setItem('current.user', JSON.stringify(mockUser));\n//         TestBed.configureTestingModule({\n//             imports: [\n//                 HttpClientTestingModule,\n//                 RouterTestingModule,\n//                 FormsModule \n//             ],\n//             declarations: [GroupsComponent]\n//         }).compileComponents();\n//         fixture = TestBed.createComponent(GroupsComponent);\n//         component = fixture.componentInstance;\n//         httpMock = TestBed.inject(HttpTestingController);\n//         fixture.detectChanges();\n//     }));\n//     afterEach(() => {\n//         httpMock.verify(); // Ensure that no requests are outstanding\n//     });\n//     it('should make an HTTP POST request when the requestButton is clicked', () => {\n//         const mockGroup = {\n//             groupID: 1, // Replace with an appropriate group ID\n//             userRequests: [] as string[] \n//             // Other properties of the mock group as needed\n//         };\n//         component.loggedInUser = { username: 'user1' };\n//         component.requestButton(mockGroup);\n//         const req = httpMock.expectOne(`${BACKEND_URL}/update-groups`); // Assuming BACKEND_URL is imported\n//         expect(req.request.method).toBe('POST');\n//         expect(req.request.body).toEqual(mockGroup); // Ensure that the request body matches the group object\n//         req.flush({}); // Mock a successful response\n//         // Check that the user request was updated\n//         expect(mockGroup.userRequests).toContain('user1');\n//         // Verify that the button is disabled after the request\n//         expect(component.buttonDisabledStates[mockGroup.groupID]).toBe(true);\n//     });\n// });","map":{"version":3,"names":["TestBed","GroupsComponent","HttpClientTestingModule","HttpTestingController","FormsModule","Router","of","describe","component","fixture","httpMock","router","MockRouter","navigateByUrl","url","beforeEach","configureTestingModule","declarations","imports","providers","provide","useClass","createComponent","componentInstance","inject","detectChanges","it","expect","toBeTruthy","spyOn","http","and","returnValue","group","members","channels","channel1","channel2","leaveGroup","post","toHaveBeenCalledWith","toEqual","getGroups","toHaveBeenCalled"],"sources":["/Users/frazerlinscott/Desktop/Software Frameworks/Assignments/Assignment1_SoftwareFrames_s2930588/src/app/groups/groups.component.spec.ts"],"sourcesContent":["import { ComponentFixture, TestBed } from '@angular/core/testing';\nimport { GroupsComponent } from './groups.component';\nimport { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';\nimport { FormsModule } from '@angular/forms';\nimport { Router } from '@angular/router';\nimport { of } from 'rxjs';\nimport { HttpClientModule } from '@angular/common/http';\n\ndescribe('GroupsComponent', () => {\n  let component: GroupsComponent;\n  let fixture: ComponentFixture<GroupsComponent>;\n  let httpMock: HttpTestingController;\n  let router: Router;\n\n  class MockRouter {\n    navigateByUrl(url: string) { return url; }\n  }\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      declarations: [GroupsComponent],\n      imports: [HttpClientTestingModule, FormsModule,],\n      providers: [\n        { provide: Router, useClass: MockRouter }\n      ]\n    });\n    fixture = TestBed.createComponent(GroupsComponent);\n    component = fixture.componentInstance;\n    httpMock = TestBed.inject(HttpTestingController);\n    router = TestBed.inject(Router);\n    fixture.detectChanges();\n  });\n\n  it('should create', () => {\n    expect(component).toBeTruthy();\n  });\n\n  it('should leave group', () => {\n    // Mock the HTTP response\n    spyOn(component.http, 'post').and.returnValue(of({}));\n\n    const group = {\n      members: ['user1', 'user2', 'user3'],\n      channels: {\n        channel1: ['user1', 'user2'],\n        channel2: ['user1', 'user3'],\n      },\n    };\n\n    // Trigger the leaveGroup function\n    component.leaveGroup(group);\n\n    // Expect the http.post method to have been called with the correct arguments\n    expect(component.http.post).toHaveBeenCalledWith(\n      'http://localhost:3000/update-groups',\n      group\n    );\n\n    // Check if the necessary modifications have been made to the group object\n    expect(group.members).toEqual(['user1', 'user2']); // User removed\n    expect(group.channels.channel1).toEqual(['user1', 'user2']); // User removed\n    expect(group.channels.channel2).toEqual(['user1']); // User removed\n\n    // Verify that the getGroups method has been called\n    spyOn(component, 'getGroups');\n    expect(component.getGroups).toHaveBeenCalled();\n  });\n});\n\n\n\n// import { TestBed, ComponentFixture, async } from '@angular/core/testing';\n// import { GroupsComponent } from './groups.component';\n// import { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';\n// import { RouterTestingModule } from '@angular/router/testing';\n// import { FormsModule } from '@angular/forms';\n// import * as $ from 'jquery';\n\n// const BACKEND_URL = \"http://localhost:3000\";\n\n// describe('GroupsComponent', () => {\n//     let component: GroupsComponent;\n//     let fixture: ComponentFixture<GroupsComponent>;\n//     let httpMock: HttpTestingController;\n\n//     beforeEach(async(() => {\n//         // Mock the current user in session storage\n//         const mockUser = {\n//             username: 'user1',\n//             role: 3 \n//         };\n\n//         sessionStorage.setItem('current.user', JSON.stringify(mockUser));\n\n//         TestBed.configureTestingModule({\n//             imports: [\n//                 HttpClientTestingModule,\n//                 RouterTestingModule,\n//                 FormsModule \n//             ],\n//             declarations: [GroupsComponent]\n//         }).compileComponents();\n\n//         fixture = TestBed.createComponent(GroupsComponent);\n//         component = fixture.componentInstance;\n//         httpMock = TestBed.inject(HttpTestingController);\n//         fixture.detectChanges();\n//     }));\n\n//     afterEach(() => {\n//         httpMock.verify(); // Ensure that no requests are outstanding\n//     });\n\n//     it('should make an HTTP POST request when the requestButton is clicked', () => {\n//         const mockGroup = {\n//             groupID: 1, // Replace with an appropriate group ID\n//             userRequests: [] as string[] \n//             // Other properties of the mock group as needed\n//         };\n  \n//         component.loggedInUser = { username: 'user1' };\n  \n//         component.requestButton(mockGroup);\n  \n//         const req = httpMock.expectOne(`${BACKEND_URL}/update-groups`); // Assuming BACKEND_URL is imported\n//         expect(req.request.method).toBe('POST');\n//         expect(req.request.body).toEqual(mockGroup); // Ensure that the request body matches the group object\n  \n//         req.flush({}); // Mock a successful response\n  \n//         // Check that the user request was updated\n//         expect(mockGroup.userRequests).toContain('user1');\n  \n//         // Verify that the button is disabled after the request\n//         expect(component.buttonDisabledStates[mockGroup.groupID]).toBe(true);\n//     });\n// });\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}